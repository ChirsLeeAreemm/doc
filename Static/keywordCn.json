[{"id":1,"title":"项目介绍","content":"  ______                          _____                              _        \n |  ____|                        / ____|                            | |       \n | |__      __ _   ___   _   _  | (___   __      __   ___     ___   | |   ___ \n |  __|    / _` | / __| | | | |  \\___ \\  \\ \\ /\\ / /  / _ \\   / _ \\  | |  / _ \\\n | |____  | (_| | \\__ \\ | |_| |  ____) |  \\ V  V /  | (_) | | (_) | | | |  __/\n |______|  \\__,_| |___/  \\__, | |_____/    \\_/\\_/    \\___/   \\___/  |_|  \\___|\n                          __/ |                                                \n                         |___/                                                \nEasySwoole\n\n\n\n\n\nEasySwoole 是一款基于 Swoole Server 开发的常驻内存型的分布式 PHP 框架，专为 API 而生，摆脱传统 PHP 运行模式在进程唤起和文件加载上带来的性能损失。\nEasySwoole 高度封装了 Swoole Server 而依旧维持 Swoole Server 原有特性，支持同时混合监听 HTTP、自定义 TCP、UDP 协议，让开发者以最低的学习成本和精力编写出多进程、可异步、高可用的应用服务。在开发上，我们为您准备了以下常用组件：\n\nHTTP 服务服务器\n协程 ORM (类似Tp ORM)\n图片验证码\nValidate 验证器\n协程模板渲染引擎\nJWT 组件\n协程 TCP、UDP、WEB_SOCKET 服务端\n协程 Redis 连接池\n协程 MySQL 连接池\n协程 Memcached 客户端\n协程通用连接池\n协程 Kafka 客户端\nNSQ 协程客户端\n分布式跨平台 RPC 组件\n协程 Consul 客户端\n协程 Apollo 配置中心\n协程 Actor 组件\n协程 SMTP 客户端\n协程版微信公众号与小程序 SDK\n协程版微信、支付宝支付 SDK\n协程 ElasticSearch 客户端\n协程 HTTP 客户端组件\n协程上下文管理\nIOC、协程上下文管理器\nSnowflake Id生成器\nCrontab 秒级任务\n自定义进程\n自定义消息队列\nTracker 链路跟踪\nAtomic 限流器\nFast-Cache 组件\nPolicy 权限组件\n注解及API文档自动生成组件\nCasbin 验证权限组件\n自动生成代码组件\nOAuth 组件\n协程 OSS 客户端\nPrinter 易联云打印机SDK\n数据库迁移工具\n协程 ETCD 客户端\n\n以上组件为常用组件，更多组件请看组件库文档\n生产可用\nEasySwoole 从最早的前身 EasyPHP-Swoole，到更名为 EasySwoole，再到现如今的 EasySwoole 3.x 版本，多年时间在众多社区小伙伴的共同努力下，EasySwoole 的稳定与可靠已经经历了非常多的大企业检验。\n例如：\n\n腾讯公司的 IEG 部门\nWEGAME 部门\n网宿科技（国内 CDN 厂家）\n360 金融\n360 小游戏（Actor）\n9377 小游戏\n厦门美图网\n蝉大师\n宝宝巴士\n瑞祥科技集团\n\n等公司都在使用 EasySwoole。\n特性\n\n强大的 TCP/UDP Server 框架，多线程，EventLoop，事件驱动，异步，Worker 进程组，Task 异步任务，毫秒定时器，SSL/TLS 隧道加密\nEventLoop API，让用户可以直接操作底层的事件循环，将 Socket、Stream、管道等 Linux 文件加入到事件循环中\n定时器、协程对象池、HTTP/SOCKET 控制器、分布式微服务、RPC 支持\n\n优势\n\n简单易用开发效率高\n并发百万 TCP 连接\nTCP/UDP/UnixSocket\n支持异步/同步/协程\n支持多进程/多线程\nCPU 亲和性/守护进程\n\n维护团队\n\n作者\n\n如果的如果 admin@fosuss.com   \n\n\n团队成员\n\n阿正 1589789807@qq.com\n会长 2788828128@qq.com\n北溟有鱼 1769360227@qq.com\n机器人 694050314@qq.com\nSiam(宣言) 59419979@qq.com\n仙士可 1067197739@qq.com\n史迪仔 975975398@qq.com\nXueSi 1592328848@qq.com\n\n\n\n以上排名不分先后        \n其他\n\n\nGitHub  喜欢记得点个star\n\n\nGitHub for Doc\n\n\nDEMO 暂且没有完全适配新版本，具体看文档。\n\n\nQQ 交流群\n\nVIP 群 579434607 （本群需要付费599元）\nEasySwoole 官方一群 633921431(已满)\nEasySwoole 官方二群 709134628(已满)\nEasySwoole 官方三群 932625047(已满)\nEasySwoole 官方四群 779897753(已满)\nEasySwoole 官方五群 853946743\n\n\n\n商业支持：\n\nQQ 291323003\nEMAIL admin@fosuss.com   \n\n\n\n作者微信\n    \n\n\n捐赠\n您的捐赠是对 EasySwoole 项目开发组最大的鼓励和支持。我们会坚持开发维护下去。 您的捐赠将被用于:\n\n持续和深入地开发\n文档和社区的建设和维护\n\n\n\n\n\n\nif (/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent)) {\n\n}else{\n        if(localStorage.getItem('isNew2') != 1){\n            $.ajax({\n                url: '/Preface/contact.html',\n                method: 'POST',\n                success: function (res) {\n                    var newHtml = $(res);\n                    var newBody = newHtml.find('.markdown-body').eq(0).html();\n                    localStorage.setItem('isNew2',1);\n                    layer.open({\n                      type: 1,\n                      title: '欢迎来到 EasySwoole，欢迎加入 QQ 交流群',\n                      shadeClose: true,\n                      shade: false,\n                      maxmin: true, \n                      area: ['893px', '600px'],\n                      content: \"\"+newBody+\"\"\n                    });                     \n                }\n            });        \n\n        }\n}   \n","link":"/Preface/intro.html"},{"id":2,"title":"交流群","content":"QQ 交流群\n\nVIP群 579434607 （本群需要付费599元）\nEasySwoole 官方一群 633921431(已满)\nEasySwoole 官方二群 709134628(已满)\nEasySwoole 官方三群 932625047(已满)\nEasySwoole 官方四群 779897753(已满)\nEasySwoole 官方五群 853946743 \n\n联系作者\n\n微信\n\n\n\n\nQQ \n\n291323003    \n\n\n","link":"/Preface/contact.html"},{"id":3,"title":"捐赠","content":"捐赠\n您的捐赠是对EasySwoole项目开发组最大的鼓励和支持。我们会坚持开发维护下去。 您的捐赠将被用于：\n\n持续和深入地开发\n文档和社区的建设和维护\n\n支付宝\n\n支付宝二维码支持花呗、信用卡分期付款\n微信\n\n通过微信捐赠的用户，请捐赠时留言您的名字，否则不知道您的大名\n捐赠者列表\n\n*章进\n*晓博\n*振宇\n*高明\n*东东\n*佳明\n*亮亮\n*凯峰\n*进国\n*海旋\n*志军\n*成龙\n*玲杰\n*东杰\n*鹏\n*力\n*宾\n*海伟\n*勇辉\n*思杰\n*龙翔\n*洋\n*伟平\n*坤平\n*勇城\n*锐\n*昆标\n*浩斌\n*博文\n*苏维\n*海涛\n*志成\n*磊\n*凯\n*建军\n*浩\n*永健\n*志强\n*少峰\n*坤磊\n*国锴\n*祖兴\n*宇翔\n*慧锋\n*萍萍\n*经国\n*超\n*达庆\n*瑾\n*强\n*民\n*振生\n*张虎\n*西湖\n*洪鐾\n*金发\n*洋\n*成永\n*俊德\n*涛\n*志银\n*科志\n*诚\n*杰\n*洪福\n*星\n*海弟\n*成龙\n*干\n*昌盛\n*坤磊\n*奇峰\n*远东\n*宾干\n*伟东\n*明磊\n*国恒\n*泉\n*进国\n*子华\n*刚\n*鹏亮\n*礼森\n*兵帅\n*旭\n*志超\n*以达\n*鹏鸿\n*航\n*亮\n*向荣\n*胜\n*艺轩\n*诸亮\n*志林\n*少峰\n*伟良\n*恒\n*钢筋\n*银\n*永欢\n*雏清\n*俊\n*凯\n*浩伟\n*亮亮\n*鹏辉\n*强\n*兵\n*金蓉\n*兴龙\n*龙辉\n*武益\n*艺\n*卫东\n\n以上名单为按照时间排序，与捐赠金额无关(多次捐赠者未避免重复也只写一次)，如果您不希望出现在该列表，或者是被遗漏了，请与 291323003@qq.com 联系。","link":"/Preface/donate.html"},{"id":4,"title":"新手必看","content":"新手入门\n本文适用于那些对Swoole/EasySwoole毫无了解,只用过传统fpm框架的开发者,看完这个教程,你将可以入门Swoole/EasySwoole  \n学习要求\n在观看本教程时,请先确认你的技术基础是否满足:  \n\nphp语法基础(菜鸟教程/慕课网可学)\nphp面对对象基础(菜鸟教程/慕课网可学)\nphp设计模式(http://www.imooc.com/learn/236)\nphp异常,错误处理(http://www.imooc.com/learn/380)\n使用过fpm框架开发或对mvc框架有了解\n能安装linux系统,以及基础使用\n开发经验半年以上\n有着 百度/谷歌 搜索答案的经历\n\n注意事项\n为了您能学会该教程,请注意一下事项:  \n\n教程每个章节都有看完\n不懂的技术语句有去搜索了解\n请不要跳章节学习,每个章节都有存在的必要\n","link":"/NoobCourse/introduction.html"},{"id":5,"title":"运行模式","content":"运行模式\nphp有着5种运行模式,常见的有4种:  \ncgi 协议模式\ncgi模式 通用网关接口（Common Gateway Interface）,它允许web服务器通过特定的协议与应用程序通信,\n调用原理大概为:\n用户请求-&gt;Web服务器接收请求-&gt;fork子进程 调用程序/执行程序-&gt;程序返回内容/程序调用结束-&gt;web服务器接收内容-&gt;返回给用户\n由于每次用户请求,都得fork创建进程调用一次程序,然后销毁进程,所以性能较低\nfast-cgi 协议模式\nfast-cgi是cgi模式的升级版,它像是一个常驻型的cgi,只要开启后,就可一直处理请求,不再需要结束进程,\n调用原理大概为:\nweb服务器fast-cgi进程管理器初始化-&gt;预先fork n个进程\n用户请求-&gt;web服务器接收请求-&gt;交给fast-cgi进程管理器-&gt;fast-cgi进程管理区接收,给其中一个空闲fast-cgi进程处理-&gt;处理完成,fast-cgi进程变为空闲状态,等待下次请求-&gt;web服务器接收内容-&gt;返回给用户\n\n注意,fast-cgi和cgi都是一种协议,开启的进程是单独实现该协议的进程  \n\n模块模式\napache+php运行时,默认使用的是模块模式,它把php作为apache的模块随apache启动而启动,接收到用户请求时则直接通过调用mod_php模块进行处理,详细内容可自行百度\nphp-cli模式\nphp-cli模式属于命令行模式,对于很多刚开始学php就开始wamp,wnmp的开发者来说是最陌生的一种运行模式\n该模式不需要借助其他程序,直接输入php xx.php 就能执行php代码\n命令行模式和常规web模式明显不一样的是:  \n\n没有超时时间\n默认关闭buffer缓冲\nSTDIN和STDOUT标准输入/输出/错误 的使用\necho var_dump,phpinfo等输出直接输出到控制台\n可使用的类/函数 不同\nphp.ini配置的不同\n\n\n想要了解详细内容可查看http://php.net/manual/zh/features.commandline.php \n\n其他\n\n本文将以上除了php-cli的模式,都定义为常规web访问模式  \n","link":"/NoobCourse/RunMode/introduction.html"},{"id":6,"title":"php-fpm","content":"php-fpm\nPHP-FPM（FastCGI 进程管理器）用于替换 PHP FastCGI 的大部分附加功能，对于高负载网站是非常有用的。\n它的功能包括:\n\n支持平滑停止/启动的高级进程管理功能;\n可以工作于不同的 uid/gid/chroot 环境下，并监听不同的端口和使用不同的 php.ini 配置文件（可取代 safe_mode 的设置）;\nstdout 和 stderr 日志记录;\n在发生意外情况的时候能够重新启动并缓存被破坏的 opcode;\n文件上传优化支持;\n&quot;慢日志&quot; - 记录脚本（不仅记录文件名，还记录 PHP backtrace 信息，可以使用 ptrace或者类似工具读取和分析远程进程的运行数据）运行所导致的异常缓慢;\nfastcgi_finish_request() - 特殊功能：用于在请求完成和刷新数据后，继续在后台执行耗时的工作（录入视频转换、统计处理等）;\n动态／静态子进程产生;\n基本 SAPI 运行状态信息（类似Apache的 mod_status）;\n基于 php.ini 的配置文件。\n\n工作原理:\n它的工作原理大概为:\nphp-fpm启动-&gt;生成n个fast-cgi协议处理进程-&gt;监听一个端口等待任务\n用户请求-&gt;web服务器接收请求-&gt;请求转发给php-fpm-&gt;php-fpm交给一个空闲进程处理\n-&gt;进程处理完成-&gt;php-fpm返回给web服务器-&gt;web服务器接收数据-&gt;返回给用户\n\nnginx+php-fpm 就是用的以上的方法\n","link":"/NoobCourse/RunMode/php-fpm.html"},{"id":7,"title":"基础介绍","content":"php-cli\n在前面的简单介绍中,我们已经了解了有php-cli这个模式,现在我们继续详细了解下php-cli和传统web模式不一样的地方吧  \n超时时间\n在php-cli中,默认超时时间为永久不超时,但是可以通过set_time_limit设置超时时间.\n&lt;?php\nset_time_limit(1);\nwhile (1){\n}\nbuffer缓冲\n在常规web模式中,echo,var_dump,phpinfo等输出语句/函数,默认情况是先进入php缓冲区,等缓冲区到达一定数量,才开始传输给web服务器的,但是在php-cli模式中,默认关闭buffer,直接输出,例如以下代码:  \n&lt;?php\nob_start();//开启buffer缓冲区  php-cli下默认关闭buffer,由于web访问测试较麻烦,该段代码只为了查看以及测试缓冲区的作用,在web模式下,默认开启,无需手动开启,可自行配置\nfor($i=0;$i&lt;1000;$i++){\n    echo $i;\n    sleep(1);\n    if($i%10==0){\n        //当i为10的倍数时,将直接结束并输出缓冲区的数据,然后再次开启缓冲区\n        ob_end_flush();\n        ob_start();\n    }\n}\n\n也可通过ob_get_contents函数获取缓冲区内容,ob缓冲系列函数可自行搜索了解  \n\nbuffer缓冲详细内容可查看:http://www.php20.cn/article/sw/buffer/104 \n标准输入/输出/错误\n执行一个命令行都存在3个标准文件(linux一切皆文件): \n\n标准输入 (stdin,通常对应终端的键盘,进程可通过该文件获取键盘输入的数据)\n标准输出 (stdout,对应终端的屏幕,进程通过写入数据到该文件,将数据显示到屏幕)\n标准错误 (stderr,对应终端的屏幕,进程通过写入数据到该文件,将错误信息显示到屏幕)\n在php-cli命令行下,可通过以上3个文件句柄进行一系列的逻辑操作,比如:\n启动php文件,监听标准输入,获取到输入的网址,php再进行网址的数据请求/接收 等等操作\n而在常规web模式下,标准输出会被拦截 \n\necho var_dump等输出函数其实就是stdout,但是在常规web访问下被重定向到了web服务器,然后由web服务器输出\n\n\n\n了解详细内容可查看http://www.php20.cn/article/156\nphp-cli 专属扩展\nphp有些扩展在常规web下运行时没用/没有意义的 例如: \n\nswoole扩展\nsocket扩展\n等\n","link":"/NoobCourse/RunMode/php-cli/introduction.html"},{"id":8,"title":"网络协议","content":"网络协议\n网络协议为计算机网络中进行数据交换而建立的规则,标准或约定的集合,所有的计算机/手机等网络设备通信都得遵循网络协议.\n网络协议根据通信的步骤,层级划分为7个层级,从上往下为:  \n\n应用层\n表示层\n会话层\n传输层\n网络层\n数据链路层\n物理层\n\n\n作为php应用程序开发者,我们只需要了解网络层以上的协议即可","link":"/NoobCourse/NetworkrPotocol/introduction.html"},{"id":9,"title":"ip","content":"ip协议(网络层)\nip协议是互联网的基础协议,它是目前最流行的一种网络协议\n范围\nIP的责任就是把数据从源传送到目的地。它不负责保证传送可靠性，流控制，包顺序和其它对于主机到主机协议来说很普通的服务。\n接口\n这个协议由主机到主机协议调用，而此协议负责调用本地网络协议将数据包传送以下一个网关或目的主机。例如TCP可以调用IP协议，在调用时传送目的地址和源地址作为参数，IP形成数据包并调用本地网络（协议）接口传送数据包。\n操作\nIP实现两个基本功能：寻址和分段。IP可以根据数据包包头中包括的目的地址将数据包传送到目的地址，在此过程中IP负责选择传送的道路，这种选择道路称为路由功能。如果有些网络内只能传送小数据包，IP可以将数据包重新组装并在报头域内注明。IP模块中包括这些基本功能，这些模块存在于网络中的每台主机和网关上，而且这些模块（特别在网关上）有路由选择和其它服务功能。对IP来说，数据包之间没有什么联系，对IP不好说什么连接或逻辑链路。  \nIP使用四个关键技术提供服务：服务类型，生存时间，选项和报头校验码。服务类型指希望得到的服务质量。服务类型是一个参数集，这些参数是Internet能够提供服务的代表。这种服务类型由网关使用，用于在特定的网络，或是用于下下一个要经过的网络，或是下一个要对这个数据包进行路由的网关上选择实际的传送参数。生存时间是数据包可以生存的时间上限。它由发送者设置，由经过路由的地方处理。如果未到达时生存时间为零，抛弃此数据包。对于控制函数来说选项是重要的，但对于通常的通信来说它没有存在的必要。选项包括时间戳，安全和特殊路由。报头校验码保证数据的正确传输。如果校验出错，抛弃整个数据包。\nip地址\n把数据从源传送到目的地时,需要有ip地址才能传输,现在ip地址分为ipv4和ipv6 两种地址,现在最常见的就是ipv4地址,例如127.0.0.1(本机地址)  119.75.217.109(百度ip)  \nip传输必须要有明确的ip地址,才能进行数据发送\n\n详细内容可自行了解\n","link":"/NoobCourse/NetworkrPotocol/ip.html"},{"id":10,"title":"tcp","content":"tcp(传输层)\nTCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能，用户数据报协议（UDP）是同一层内  另一个重要的传输协议。在因特网协议族（Internet protocol suite）中，TCP层是位于IP层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。  \n应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分区成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元（ MTU）的限制）。之后TCP把结果包传给IP层，由它来通过网络将包传送给接收端实体 的TCP层。TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。\n三次握手\nTCP是因特网中的传输层协议，使用三次握手协议建立连接。当主动方发出SYN连接请求后，等待对方回答SYN+ACK ，并最终对对方的 SYN 执行 ACK 确认。这种建立连接的方法可以防止产生错误的连接，TCP使用的流量控制协议是可变大小的滑动窗口协议。\nTCP三次握手的过程如下：\n\n客户端发送SYN（SEQ=x）报文给服务器端，进入SYN_SEND状态。\n服务器端收到SYN报文，回应一个SYN （SEQ=y）ACK(ACK=x+1）报文，进入SYN_RECV状态。\n客户端收到服务器端的SYN报文，回应一个ACK(ACK=y+1）报文，进入Established状态。\n\n连接成功\n连接成功之后双方即可互相传输字节流,并随时可关闭连接,传输的数据有以下特性  \n\n\n传输的数据被tcp分割成了最适合发送的数据块 传递给ip协议,这个发送数据称为 报文段 或 段 \n\n\ntcp作为可靠性连接,每次发送数据段,会启动一个定时器,每次接收数据段,会发送一次确认,如果定时器没有及时收到确认,则会重发数据\n\n\nTCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段（希望发端超时并重发）。\n\n\n两个应用程序通过TCP连接交换8bit字节构成的字节流。TCP不在字节流中插入记录标识符。我们将这称为字节流服务（bytestreamservice）。如果一方的应用程序先传10字节，又传20字节，再传50字节，连接的另一方将无法了解发方每次发送了多少字节。只要自己的接收缓存没有塞满，TCP 接收方将有多少就收多少。一端将字节流放到TCP连接上，同样的字节流将出现在TCP连接的另一端。\n\n\n四次挥手\n建立一个连接需要三次握手，而终止一个连接要经过四次挥手，这是由TCP的半关闭（half-close）造成的。具体过程如下所示。\n\n某个应用进程首先调用close，称该端执行“主动关闭”（active close）。该端的TCP于是发送一个FIN分节，表示数据发送完毕。\n接收到这个FIN的对端执行 “被动关闭”（passive close），这个FIN由TCP确认。\n注意：FIN的接收也作为一个文件结束符（end-of-file）传递给接收端应用进程，放在已排队等候该应用进程接收的任何其他数据之后，因为，FIN的接收意味着接收端应用进程在相应连接上再无额外数据可接收。\n一段时间后，接收到这个文件结束符的应用进程将调用close关闭它的套接字。这导致它的TCP也发送一个FIN。\n接收这个最终FIN的原发送端TCP（即执行主动关闭的那一端）确认这个FIN。\n既然每个方向都需要一个FIN和一个ACK，因此通常需要4个分节。\n\n\n“通常”是指，某些情况下，步骤1的FIN随数据一起发送，另外，步骤2和步骤3发送的分节都出自执行被动关闭那一端，有可能被合并成一个分节。\n在步骤2与步骤3之间，从执行被动关闭一端到执行主动关闭一端流动数据是可能的，这称为“半关闭”（half-close）。\n当一个Unix进程无论自愿地（调用exit或从main函数返回）还是非自愿地（收到一个终止本进程的信号）终止时，所有打开的描述符都被关闭，这也导致仍然打开的任何TCP连接上也发出一个FIN。\n无论是客户还是服务器，任何一端都可以执行主动关闭。通常情况是，客户执行主动关闭，但是某些协议，例如，HTTP/1.0却由服务器执行主动关闭。\n\nphp中的tcp\nphp可通过socket函数,swoole扩展,stream流函数进行创建tcp协议的socket,绑定网卡端口,进行tcp服务端/客户端操作\n在php中,我们并不需要了解tcp的握手/挥手,我们只需要知道ip:port能连接/创建 一个tcp服务端/客户端就行了\n使用php的socket,我们可以直接发送字符串,接收的也是字符串,其他一切都是语言,操作系统所需要做的事,\n我们只需要处理好字符串的完整性,例如我们使用php做tcp服务端  \n\n客户端连接成功后,发送了一个&quot;easyswoole是一个非常好的swoole框架&quot;的字符串 \n而服务端每次只接收9个字节,那第一次获取只会接收到&quot;easyswool&quot;的残缺字符串,需要继续获取数据\n\n其他\n\n可自行搜索详细理解\n","link":"/NoobCourse/NetworkrPotocol/Tcp/tcp.html"},{"id":11,"title":"http","content":"http协议\n超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。1960年美国人Ted Nelson构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了HTTP超文本传输协议标准架构的发展根基。Ted Nelson组织协调万维网协会（World Wide Web Consortium）和互联网工程工作小组（Internet Engineering Task Force ）共同合作研究，最终发布了一系列的RFC，其中著名的RFC 2616定义了HTTP 1.1。 \n技术架构\nHTTP是一个客户端和服务器端请求和应答的标准（TCP）。客户端是终端用户，服务器端是网站。通过使用Web浏览器、网络爬虫或者其它的工具，客户端发起一个到服务器上指定端口（默认端口为80）的HTTP请求。（我们称这个客户端）叫用户代理（user agent）。应答的服务器上存储着（一些）资源，比如HTML文件和图像。（我们称）这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在  \n多个中间层，比如代理，网关，或者隧道（tunnels）。尽管TCP/IP协议是互联网上最流行的应用，HTTP协议并没有规定必须使用它和（基于）它支持的层。 事实上，HTTP可以在任何其他互联网协议上，或者在其他网络上实现。HTTP只假定（其下层协议提供）可靠的传输，任何能够提供这种保证的协议都可以被其使用。  \n通常，由HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端发送过来的请求。一旦收到请求，服务器（向客户端）发回一个状态行，比如&quot;HTTP/1.1 200 OK&quot;，和（响应的）消息，消息的消息体可能是请求的文件、错误消息、或者其它一些信息。  \nHTTP使用TCP而不是UDP的原因在于（打开）一个网页必须传送很多数据，而TCP协议提供传输控制，按顺序组织数据，和错误纠正。  \n通过HTTP或者HTTPS协议请求的资源由统一资源标示符（Uniform Resource Identifiers）（或者，更准确一些，URLs）来标识。  \n\n过程解析\nhttp一次请求的过程大概如下:\n\n用户在浏览器输入www.easyswoole.com\ndns服务器解析/或者本机hosts,路由器hosts对比 获得ip\n浏览器访问默认端口80,则访问的tcp地址为  ip:80\ntcp协议3次握手,建立连接\n发送一个http request请求头\n服务器获得http request请求头,表明该次访问为http访问,解析http请求头,获得请求类型,请求格式,以及请求数据(cookie,get,post数据)\n服务器发送response响应数据,主动断开\n浏览器接收response响应数据,解析响应文本类型,解析数据,断开连接\n\nhttps协议中,在请求以及响应时多了一层tls,ssl加密解密协议,默认端口从80变为了443 \n\n\n\nphper中的http\n由于php大部分时候都是用于web服务器,所以php开发者接触最多的协议也就是基于tcp/ip协议的http协议了\n在php初级程序员中,其实没有详细的了解过http协议,但是可以通过浏览器的f12-&gt;network去查看http协议具体的请求头,以及服务端发送的响应头","link":"/NoobCourse/NetworkrPotocol/Tcp/http.html"},{"id":12,"title":"websocket","content":"WebSocket协议\nWebSocket协议是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。\n产生背景\n在没有WebSocket协议之前,在网页中,实现一个聊天室只能使用ajax 不断轮询,请求服务器是否有数据产生,而这样的实现方法会出现一系列的问题:  \n\n如果轮询时间间隔太短,会导致客户端和服务端在一个时间段内不断的进行http tcp的握手/挥手动作和http 请求头,响应头的传输,大量消耗服务器资源,如果用户量大的情况,会造成服务器的繁忙以至于宕机\n客户端每次只能通过发送http 请求获得服务器是否有数据返回,且数据的及时性无法保证\n\n正因为在这种情况下,所以WebSocket出现了,它只需要一次http握手,就可以保持一个长连接,使得服务器可以主动发送消息给客户端,大大减少了轮询机制的消耗 \n实现原理\n在实现websocket连线过程中，需要通过浏览器发出websocket连线请求，然后服务器发出回应，这个过程通常称为“握手” 。在 WebSocket API，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。在此WebSocket 协议中，为我们实现即时服务带来了两大好处：\n\nHeader: 互相沟通的Header是很小的-大概只有 2 Bytes\nServer Push: 服务器的推送，服务器不再被动的接收到浏览器的请求之后才返回数据，而是在有新数据时就主动推送给浏览器。\n\n握手协议\n  \n首先,浏览器发起一个http协议的websocket握手请求:  \nGET /websocket/HTTP/1.1\n\nHost: localhost\nUpgrade: websocket          #表示希望将http协议升级到Websocket协议。\nConnection: Upgrade         #表示希望将http协议升级到Websocket协议。\nSec-WebSocket-Key: xqBt3ImNzJbYqRINxEFlkg==   #浏览器随机生成的base64 encode的值，用来询问服务器是否是支持WebSocket。\nOrigin: http://服务器地址\nSec-WebSocket-Version: 13\nwebsocket服务器响应:  \nHTTP/1.1 101 Switching Protocols\nUpgrade: websocket                #告诉浏览器已经升级到websocket\nConnection: Upgrade               #告诉浏览器已经升级到websocket\nSec-WebSocket-Accept: K7DJLdLooIwIG/MOpvWFB3y3FE8=   #将请求包“Sec-WebSocket-Key”的值，与” 258EAFA5-E914-47DA-95CA-C5AB0DC85B11 ″这个字符串进行拼接，然后对拼接后的字符串进行sha-1运算，再进行base64编码得到的。用来说明自己是WebSocket助理服务器。\n这样就已经是握手成功了,浏览器和服务端已经建立了一个websocket通道,发送数据不再需要tcp握手,也不需要发送http请求头,服务端也可自动下发数据到浏览器\nHTML5 Web Socket API\n在HTML5中内置有一些API，用于响应应用程序发起的请求。基本API语句如下：\nvar ws = new WebSocket(url,name);//创建对象\nws.send(msg);//发送文本消息\nws.onmessage = (function(evt/*服务器发送数据的对象*/){})();//接收消息回调事件\nws.onerror = (function(evt/*错误对象*/){})();//错误处理\nws.close();//关闭连接\n其他\n可自行搜索了解详细内容","link":"/NoobCourse/NetworkrPotocol/Tcp/websocket.html"},{"id":13,"title":"udp","content":"udp(传输层)\nUDP 是User Datagram Protocol的简称， 中文名是用户数据报协议，是OSI（Open System Interconnection，开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，IETF RFC 768是UDP的正式规范。UDP在IP报文的协议号是17。  \nUDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。UDP用来支持那些需要在计算机之间传输数据的网络应用。包括网络视频会议系统在内的众多的客户/服务器模式的网络应用都需要使用UDP协议。UDP协议从问世至今已经被使用了很多年，虽然其最初的光彩已经被一些类似协议所掩盖，但是即使是在今天UDP仍然不失为一项非常实用和可行的网络传输层协议。   \n与所熟知的TCP（传输控制协议）协议一样，UDP协议直接位于IP（网际协议）协议的顶层。根据OSI（开放系统互连）参考模型，UDP和TCP都属于传输层协议。UDP协议的主要作用是将网络数据流量压缩成数据包的形式。一个典型的数据包就是一个二进制数据的传输单位。每一个数据包的前8个字节用来包含报头信息，剩余字节则用来包含具体的传输数据。\nudp与tcp\nudp和tcp都属于传输层的协议,都位于ip协议的顶层,他们不同之处有:  \n\nudp是无连接协议,不需要进行tcp的握手\nudp每次发送最大长度是65535,而tcp在握手后可以源源不断的发送\nudp协议使用报头中的校验值来保证数据的安全。校验值首先在数据发送方通过特殊的算法计算得出，在传递到接收方之后，还需要再重新计算。如果某个数据报在传输过程中被第三方篡改或者由于线路噪音等原因受到损坏，发送和接收方的校验计算值将不会相符，由此UDP协议可以检测是否出错。这与TCP协议是不同的，后者要求必须具有校验值。  \nudp报文没有可靠性保证、顺序保证和流量控制字段等，可靠性较差。但是正因为udp协议的控制选项较少，在数据传输过程中延迟小、数据传输效率高，适合对可靠性要求不高的应用程序，或者可以保障可靠性的应用程序，如DNS、TFTP、SNMP等。\n在网络质量令人十分不满意的环境下，UDP协议数据包丢失会比较严重。而tcp会进行确认验证,确保对方接收成功\nudp可实现对网关内的所有主机进行广播\n\nphper的udp\n在php初级开发者中,是很少接触到udp协议的,常见的有DNS协议,\n在我们输入一个域名时,会先请求到一个dns服务器,由dns服务器匹配出一个ip地址,然后通过ip地址去传输数据,\n在这个步骤中,请求dns服务器使用的就是udp协议\n其他\n具体详细内容可自行搜索了解","link":"/NoobCourse/NetworkrPotocol/udp.html"},{"id":14,"title":"port端口","content":"端口\n在网络技术中，端口（Port）包括逻辑端口和物理端口两种类型。物理端口指的是物理存在的端口，如ADSL Modem、集线器、交换机、路由器上用 于连接其他网络设备的接口，如RJ-45端口、SC端口等等。逻辑端口是指逻辑意义上用于区分服务的端口，如TCP/IP协议中的服务端口，端口号的范围从0到65535，比如用于浏览网页服务的80端口，用于FTP服务的21端口等。由于物理端口和逻辑端口数量较多，为了对端口进行区分，将每个端口进行了编号，这就是端口号。本文主要讲逻辑端口.\n逻辑端口\n端口有什么用呢？我们知道，一台拥有IP地址的主机可以提供许多服务，比如Web服务、FTP服务、SMTP服务等，这些服务完全可以通过1个IP地址来实现。那么，主机是怎样区分不同的网络服务呢？显然不能只靠IP地址，因为IP 地址与网络服务的关系是一对多的关系。实际上是通过“IP地址+端口号”来区 分不同的服务的。\n服务器一般都是通过知名端口号来识别的。例如，对于每个TCP/IP实现来说，FTP服务器的TCP端口号都是21，每个Telnet服务器的TCP端口号都是23，每个TFTP(简单文件传送协议)服务器的UDP端口号都是69。任何TCP/IP实现所提供的服务都用知名的1～1023之间的端口号。这些知名端口号由Internet  号分配机构（InternetAssignedNumbersAuthority,IANA）来管理。\n到1992年为止，知名端口号介于1～255之间。256～1023之间的端口号通常都是由Unix系统占用，以提供一些特定的Unix服务—也就是说，提供一些只有Unix系统才有的、而其他操作系统可能不提供的服务，IANA管理1～1023之间所有的端口号。\nInternet扩展服务与Unix特定服务之间的一个差别就是Telnet和Rlogin。它们二者都允许通过计算机网络登录到其他主机上。Telnet是采用端口号为23的TCP/IP标准且几乎可以在所有操作系统上进行实现。Rlogin只是为Unix系统设计的（尽管许多非Unix系统也提供该服务），它的有名端口号为513。\n客户端通常对它所使用的端口号并不关心，只需保证该端口号在本机上是唯一的就可以了。客户端口号又称作临时端口号（即存在时间很短暂）。这是因为它通常只是在用户运行该客户程序时才存在，而服务器则只要主机开着的，其服务就运行。\n大多数TCP/IP实现给临时端口分配1024～5000之间的端口号。大于5000的端口号是为其他服务器预留的（Internet上并不常用的服务)。我们可以在后面看见许多这样的给临时端口分配端口号的例子。\nSolaris2.2是一个很有名的例外。通常TCP和UDP的缺省临时端口号从32768开始。  \nphper中的端口\n在php开发者中,最常见的就是80 http默认端口了,在通常情况下,我们访问  www.easyswoole.com  ,其实是请求的  www.easyswoole.com:80  ,在没有指定端口的情况下,访问网站都是默认为80端口,如果你web服务器监听的是8080端口,访问时就必须  www.easyswoole.com:8080  带上端口才能访问  ","link":"/NoobCourse/NetworkrPotocol/port.html"},{"id":15,"title":"会话管理","content":"会话管理\n在http协议中,我们了解到了,http每次请求都是握手/挥手,第二次和第一次请求时没有任何关联的,属于无状态协议,那么问题来了,既然http是无状态协议,那服务器是怎么区分不同的用户的呢?,这就是会话了  \n基础讲解\n服务器能区分用户的原理主要就是在于会话,每次发起http请求时,都附加上一条身份识别数据,例如下面这个http请求头:   \nGET / HTTP/1.1\nHost: www.easyswoole.com\nConnection: keep-alive\nPragma: no-cache\nCache-Control: no-cache\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 UBrowser/6.2.4094.1 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 \nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.8\nCookie: Hm_lvt_4c8d895ff3b25bddb6fa4185c8651cc3=1541986142,1542074627,1542158990,1542252497; Hm_lpvt_4c8d895ff3b25bddb6fa4185c8651cc3=1542252498\n抛开http本身需要的数据,我们讲解下:\nUser-Agent: 用户端信息,浏览器的各种信息\nCookie: cookie会话\n服务端可以通过User-Agent获得用户的浏览器信息,可以通过cookie获取自定义的信息\n所以我们可以:  \n\n用户A第一次进入,没有附带cookie\n服务端记录这个用户,响应头增加一个set_cookie:id=1的cookie\n浏览器获得响应头,解析到set_cookie动作,把id=1存进cookie\n第二次请求服务端,带上id=1的cookie,服务端就可以知道:这次请求时用户A请求的\n同理,用户B第一次进入,服务端响应set_cookie:id=2\n...\n\n可以看出,只要用户端每次请求,跟服务端约定好一个参数作为用户标识,服务端就可以通过这个标识区分不同的用户了","link":"/NoobCourse/Conversation/introduction.html"},{"id":16,"title":"cookie","content":"Cookie\nCookie 是在 HTTP 协议下，服务器或脚本可以维护客户工作站上信息的一种方式。  \nCookie 是由 Web 服务器保存在用户浏览器（客户端）上的小文本文件，它可以包含有关用户的信息。无论何时用户链接到服务器，Web 站点都可以访问 Cookie 信息 。  \n目前有些 Cookie 是临时的，有些则是持续的。临时的 Cookie 只在浏览器上保存一段规定的时间，一旦超过规定的时间，该 Cookie 就会被系统清除 。  \n持续的 Cookie 则保存在用户的 Cookie 文件中，下一次用户返回时，仍然可以对它进行调用。在 Cookie 文件中保存 Cookie，有些用户担心 Cookie 中的用户信息被一些别有用心的人窃取，而造成一定的损害。其实，网站以外的用户无法跨过网站来获得 Cookie 信息。如果因为这种担心而屏蔽 Cookie，肯定会因此拒绝访问许多站点页面。因为，当今有许多 Web 站点开发人员使用 Cookie 技术，例如 Session 对象的使用就离不开 Cookie 的支持\n存储\ncookie存储在用户端(通常是浏览器端),可通过JavaScript脚本,服务端response头进行设置/修改/删除操作\n一个cookie,存在以下信息:  \nname   一个唯一确定的cookie名称,通常来讲cookie的名称是不区分大小写的。\n\nvalue  存储在cookie中的字符串值。\n\ndomain  cookie对于哪个域是有效的。所有向该域发送的请求中都会包含这个cookie信息。这个值可以包含子域(如：\nyq.aliyun.com)，也可以不包含它(如：.aliyun.com，则对于aliyun.com的所有子域都有效).\n\npath   表示这个cookie影响到的路径，浏览器跟会根据这项配置，像指定域中匹配的路径发送cookie。\n\nexpires  失效时间，表示cookie何时应该被删除的时间戳(也就是，何时应该停止向服务器发送这个cookie)。如果不设置这个时间戳，浏览器会在页面关闭时即将删除所有cookie；不过也可以自己设置删除时间。这个值是GMT时间格式，如果客户端和服务器端时间不一致，使用expires就会存在偏差。\n\nmax-age 与expires作用相同，用来告诉浏览器此cookie多久过期（单位是秒），而不是一个固定的时间点。正常情况下，max-age的优先级高于expires。\n\nHttpOnly  告知浏览器不允许通过脚本document.cookie去更改这个值，同样这个值在document.cookie中也不可见。但在http请求张仍然会携带这个cookie。注意这个值虽然在脚本中不可获取，但仍然在浏览器安装目录中以文件形式存在。这项设置通常在服务器端设置。\n\nsecure   安全标志，指定后，只有在使用SSL链接时候才能发送到服务器，如果是http链接则不会传递该信息。就算设置了secure 属性也并不代表他人不能看到你机器本地保存的 cookie 信息，所以不要把重要信息放cookie就对了服务器端设置\ncookie不仅仅只作为session会话,也可存储一些不重要的会员个性化设置,例如:  \n\n用户A通过设置cookie type:red \n用户A请求服务端,想获取一个页面\n服务端接收到请求,并解析到type:red,给用户A返回一个红色风格的首页 \n\n安全\n服务端安全\n首先,cookie是存储在用户端的,可以被用户修改,所以服务端不能直接通过一个cookie来确定用户身份,需要用一定的方式加密或者对等存储(cookie作为凭证,在服务端记录对应数据),服务端session就是使用这种方法存储的\n用户端安全\n在通常情况下,用户端的cookie安全的,网站以外的用户无法跨过网站来获取用户的cookie信息,但是有心之人可能会通过ajax方法,让用户访问A网站,却使用B网站的脚本进行敏感操作.(详细内容可自行搜索&quot;跨站点脚本攻击&quot;)\nphper中的cookie\n在php  web网站中,用户端cookie是必不可少的,没有cookie就无法启用session会话,无法识别用户身份,php中的session_start()函数就是向用户端设置一个cookie值用于session会话.","link":"/NoobCourse/Conversation/cookie.html"},{"id":17,"title":"session","content":"Session\n在计算机中，尤其是在网络应用中，称为“会话控制”。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。  \n当用户请求来自应用程序的 Web 页时，如果该用户还没有会话，则 Web 服务器将自动创建一个 Session 对象。当会话过期或被放弃后，服务器将终止该会话。  \n注意 会话状态仅在支持 cookie 的浏览器中保留。  \n会话实现原理\nsession会话的实现原理大概如下所示:\n\n用户A第一次进入,没有附带任何标识信息(通常是cookie)\n服务端接收请求,给与用户A一个会话标识(通常是set_cookie,cookie值将加密)\n服务端根据会话标识,在服务器本地存储用户信息\n用户A端获取到会话标识,存储到用户端本地\n用户A第二次请求,附带会话标识(通常是cookie)\n服务端通过会话标识,找到服务端相应的用户信息\n\nphp中的session\nphp已经内置封装好了一个功能完整的会话管理,基础用法为:\n&lt;?php\nsession_start();//启动新会话或者重用现有会话,发送set-cookie的响应头,告诉浏览器设置一个php_session的cookie 会话,会话id为php随机产生,并在服务器端临时目录产生一个对应的session文件\n$_SESSION['a'] = 1;//存储一个关于该会话id的值\nsession_destroy();//销毁会话数据\n//当在脚本结束时,会将超全局变量$_SESSION中的值存储进对应的session文件\n可自行搜索了解详细内容(如自定义session_id,自定义存储方式,自定义启用会话方式等)","link":"/NoobCourse/Conversation/session.html"},{"id":18,"title":"api/token","content":"api/token\ntoken其实和session原理差不多,服务端通过给用户发送一个token,用户通过该token进行请求服务端,这种会话验证方式一般用于跨平台开发,以及接口开发,大概步骤为:\n\n用户A第一次进入,通过验证机制(账号密码登陆)请求服务端token\n服务端验证成功,给用户发送一个token(针对用户)\n服务端根据token,在服务端存储对应的数据(文件,mysql,redis等)\n用户A端获取到token,存储到用户端本地\n用户A请求某接口,带上token\n服务端通过token,验证用户有效性,返回数据\n\n这种设计理念和session相差不大(无论如何变换,都是需要用户端存储相应的标识,用于给服务端解析) \n\n为了安全,服务端可设定token有效时间,以及加密token,每隔一段时间变动一次token等.\n","link":"/NoobCourse/Conversation/token.html"},{"id":19,"title":"linux基础","content":"Linux\nLinux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的UNIX工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。\nLinux的发行版\nLinux的发行版说简单点就是将Linux内核与应用软件做一个打包。\n目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等。\n\n可自行搜索安装方法,推荐使用虚拟机安装,或docker镜像等\n\n一切皆文件\nlinux 一切皆文件,在linux系统中,所有东西都是用文件来表示的,例如磁盘,内存,鼠标,显示器,socket,都是以文件来标识的,任何设备都是通过操作文件(写入,读取)的方式来操作  \nwindows连接linux\n连接linux终端需要使用ssh协议工具进行连接,linux必须开启ssh连接(默认开启)\nwindows ssh工具推荐:\n\nphpstorm自带ssh,以及sftp\nSecure CRT\nputty\n\n可自行搜索下载\n详细教程可自行搜索了解,建议菜鸟教程","link":"/NoobCourse/Linux/introduction.html"},{"id":20,"title":"lnmp安装","content":"LNMP\nLNMP代表的就是：Linux系统下Nginx+MySQL+PHP这种网站服务器架构。  \nLinux是一类Unix计算机操作系统的统称，是目前最流行的免费操作系统。代表版本有：debian、centos、ubuntu、fedora、gentoo等。  \nNginx是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP代理服务器。  \nMysql是一个小型关系型数据库管理系统。    \nPHP是一种在服务器端执行的嵌入HTML文档的脚本语言。  \n这四种软件均为免费开源软件，组合到一起，成为一个免费、高效、扩展性强的网站服务系统。  \n安装\nlnmp环境安装有以下几种方法:\n\nyum,apt-get 软件包安装\n编译安装\n集成一键安装\n\n由于软件包安装步骤较多,可自行搜索了解详细\n编译安装\n编译安装主要步骤为(需要有编译器):\n\n下载软件源码,cd 目录\n./configure 参数解析,配置安装位置参数,以及其他绑定参数\nmake 一般情况下，只需要直接用make即可，但是有时候，生成的Makefile文件中并没有指定C编译器或者C++编译器，那么就需要手动指定了，不然就有可能出现编译错误。\nmake install \n\n安装php时最为复杂,需要根据需要使用的扩展,预先安装一系列的软件支持,然后在./configure中配置软件目录,配置需要开启的扩展等\n\n\n\n可自行搜索了解详细\n集成一键安装\n集成一键安装是通过预先写好的shell脚本,里面包含了安装lnmp所有的命令(编译或软件包安装命令),以及包含了所需扩展的软件包.\n集成一键安装可使用以下几种:\n\nlnmp集成环境:https://lnmp.org/   \n宝塔:http://www.bt.cn/\n可自行搜索了解详细\n","link":"/NoobCourse/Linux/lnmp.html"},{"id":21,"title":"命令","content":"命令基础\nlinux命令存储以下位置:\n\n/bin(指向/usr/bin)目录,包含基本的用户命令,默认全体用户都可使用,例如curl,ls命令\n/sbin(指向/usr/sbin),/usr/local/sbin,存放需要root权限的命令以及工具,默认root用户使用,例如ip,halt命令\n/usr/local/bin 给用户放置自己的可执行程序的地方,不会被系统升级覆盖\n/usr/local/sbin 给管理员放置自己的可执行程序的地方,不会被系统升级覆盖\n\n如果在每个命令目录都存在某个命令时,通过系统的$PATH变量决定优先级\necho $PATH\n# 每台电脑输出不同,/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/usr/local/protobuf/bin/:/root/bin\n所以,当你输入 ls 命令,点击回车时,系统会以此从各个目录找到这个命令文件,然后执行该文件.\n执行当前目录文件\n如果你的程序命令没有放在以上文件夹,我们也可通过相对路径以及绝对路径启动该命令:\n./php -m #当你在php命令文件目录中时,\n/www/server/php/72/bin/php -m,宝塔php命令目录\n根据这个原理,我们可以安装多个php版本,并启动\n/www/server/php/72/bin/php -m\n/www/server/php/56/bin/php -m","link":"/NoobCourse/Linux/command.html"},{"id":22,"title":"进程管理","content":"进程管理\n我们可以使用ps 查看当前进程(相当于windows的任务管理器)\nps -ef |grep php\n输出:\nroot       8351   8346  0 09:07 ?        00:00:00 /usr/bin/php /www/wwwroot/es3_demo/test.php\nroot      10618   8970  0 14:26 pts/0    00:00:00 grep --color=auto php\n用于筛选出当前运行中,包含php关键字的进程信息\n通过kill -9 PID可杀死某一个进程:\nkill -9 10618\n使用killall 可杀死指定名字的进程:\nkillall -9 php\n杀死所有php进程\n\nkill 和killall其实是给进程发送一个进程信号的命令,-9是SIGKILL 信号,终止进程,可通过kill ,killall命令发送其他信号\n","link":"/NoobCourse/Linux/process.html"},{"id":23,"title":"扩展安装","content":"php扩展安装\n在windows中,只需要将dll文件移动到扩展目录,并在php.ini中引入即可\nlinux中类似,我们需要安装扩展的软件(例如mysql扩展,我们需要先安装mysql),再安装mysql操作扩展(mysqli,pdo)生成.so文件,在php.ini中引入.so文件即可\n编译安装\nswoole扩展,先下载swoole官方源码:https://github.com/swoole/swoole-src\n解压,进入目录\nphpize #当不存在./configure时\n./configure --with-php-config=/usr/local/php/bin/php-config\nmake \nmake install\n这时候.so文件会自动生成到php扩展目录(有些扩展需要自己移动进去),\n在php.ini最后面加上\n extension = swoole.so\n然后php -m查看扩展,就能看到swoole扩展安装好了","link":"/NoobCourse/Linux/extention.html"},{"id":24,"title":"端口监控","content":"端口监控\n在ip章节中,我们知道了,开启一个tcp/udp服务,都得占用一个端口,所有我们可以通过查看端口的方式去判断服务是否开启成功.\nnetstat命令\n使用netstat命令可查看端口占用情况\nnetstat命令各个参数说明如下:\n\n-t : 指明显示TCP端口\n-u : 指明显示UDP端口\n-l : 仅显示监听套接字(所谓套接字就是使应用程序能够读写与收发通讯协议(protocol)与资料的程序)\n-p : 显示进程标识符和程序名称，每一个套接字/端口都属于一个程序。\n-n : 不进行DNS轮询，显示IP(可以加速操作)\nnetstat -ntulp |grep 80 \n查看80端口占用情况\n输出:\ntcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      1036/nginx: master  \n\n\nlsof命令\nlsof命令需要自行安装\nsudo yum install lsof\n使用方法如下:\nlsof  -i tcp #列出所有tcp网络连接\nlsof  -i udp #列出所有udp网络连接信息\nlsof -i :8080 #列出使用8080端口信息","link":"/NoobCourse/Linux/port.html"},{"id":25,"title":"防火墙说明","content":"防火墙\n当你开启一个tcp服务,却发现访问不了,那么你得考虑下是否是防火墙拦截了,\n目前,最常见的拦截有以下几种情况:\n\n服务器本机防火墙拦截\n服务器供应商拦截(阿里云,腾讯云安全组)\n\n服务器本机拦截,可通过防火墙管理软件,开端口,或者直接关闭防火墙进行解决(不建议):\n例如centos 7下,防火墙管理软件为firewalld.\n基础命令为:\nsystemctl start firewalld;#启动\nsystemctl stop firewalld;#停止\nsystemctl status firewalld;#查看状态\nsystemctl disable firewalld;#开机禁用\nsystemctl enable firewalld;#开启启动\nfirewall-cmd --zone=public --add-port=80/tcp --permanent #开放80/tcp端口  （--permanent永久生效，没有此参数重启后失效）;\nfirewall-cmd --reload;#\nfirewall-cmd --zone= public --query-port=80/tcp;#查看80/tcp端口\nfirewall-cmd --zone= public --remove-port=80/tcp --permanent;#删除该端口开放","link":"/NoobCourse/Linux/firewall.html"},{"id":26,"title":"部分新特性","content":"PHP7与php5\nphp在2015年12月03日发布了7.0正式版,带来了许多新的特性，以下是不完全列表:\n\n\n性能提升：PHP7比PHP5.6性能提升了两倍。 Improved performance: PHP 7 is up to twice as fast as PHP 5.6\n\n\n全面一致的64位支持。 Consistent 64-bit support\n\n\n以前的许多致命错误，现在改成抛出异常。Many fatal errors are now Exceptions\n\n\n移除了一些老的不在支持的SAPI（服务器端应用编程端口）和扩展。Removal of old and unsupported SAPIs and extensions\n\n\n新增了空接合操作符。The null coalescing operator (??)\n\n\n新增加了结合比较运算符。Combined comparison Operator (&lt;=&gt;)\n\n\n新增加了函数的返回类型声明。Return Type Declarations\n\n\n新增加了标量类型声明。Scalar Type Declarations\n\n\n新增加匿名类。Anonymous Classes\n\n\n本教程主要讲解swoole将要用到或有相关性的特性\n致命错误将可用异常形式抛出\n在php7之后,大部分错误可通过异常形式抛出,并可使用catch拦截,例如:\ntry {\n   $a-&gt;test();//未定义该对象并没有该方法,抛出一个Throwable类\n    // Code that may throw an Exception or Error.\n} catch (Throwable $t) {\n    var_dump($t-&gt;getMessage());\n    // Executed only in PHP 7, will not match in PHP 5\n} catch (Exception $e) {\n}\n运行之后将打印一条报错语句:\nstring(40) \"Call to a member function test() on null\"\n??  null合并运算符\n由于日常使用中存在大量同时使用三元表达式和 isset()的情况， php7添加了null合并运算符 (??) 这个语法糖。如果变量存在且值不为NULL， 它就会返回自身的值，否则返回它的第二个操作数。例如:\n$a = $b??0;\n//如果当$b为null,则返回0.如果$b不为null,则返回$b;\n标量类型声明\n标量类型声明 有两种模式: 强制 (默认) 和 严格模式。 现在可以使用下列类型参数（无论用强制模式还是严格模式）： 字符串(string), 整数 (int), 浮点数 (float), 以及布尔值 (bool)。它们扩充了PHP5中引入的其他类型：类名，接口，数组和 回调类型。例如:\n&lt;?php\nfunction a(\n    ?int $a /*参数必须是int或者null*/,\n    string $b/*参数必须string*/,\n    Closure $function /*参数必须是匿名函数*/,\n    array $array/*参数必须是数组*/\n    ){}\n\n类名/接口限定都需要考虑命名空间\n\n返回值类型声明\nPHP 7 增加了对返回类型声明的支持。 类似于参数类型声明，返回类型声明指明了函数返回值的类型。可用的类型与参数声明中可用的类型相同。例如:\n&lt;?php\nfunction a():int{//必须返回int类型,否则报错\n    return 1;\n}\nfunction b():?int{//必须返回int类型或者null类型,否则报错\n    return 'das';\n}\n太空船操作符&lt;=&gt;（组合比较符）\n太空船操作符用于比较两个表达式。当$a小于、等于或大于$b时它分别返回-1、0或1。 比较的原则是沿用 PHP 的常规比较规则进行的。\n&lt;?php\n// Integers\necho 1 &lt;=&gt; 1; // 0\necho 1 &lt;=&gt; 2; // -1\necho 2 &lt;=&gt; 1; // 1\n// Floats\necho 1.5 &lt;=&gt; 1.5; // 0\necho 1.5 &lt;=&gt; 2.5; // -1\necho 2.5 &lt;=&gt; 1.5; // 1\n// Strings\necho \"a\" &lt;=&gt; \"a\"; // 0\necho \"a\" &lt;=&gt; \"b\"; // -1\necho \"b\" &lt;=&gt; \"a\"; // 1","link":"/NoobCourse/PHP/php7.html"},{"id":27,"title":"回调事件","content":"回调函数\n回调函数就是在主进程执行当中,突然跳转到预先设置好的函数中去执行的函数.\n以下是自知乎作者常溪玲的解说：\n你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。\n以下是一个非常简单的回调函数的例子:\n&lt;?php\n//登记回调函数\nfunction insert(int $i):bool {\n    echo \"插入数据{$i}\\n\";//模拟数据库插入//响应回调事件\n    return true;\n}\n$arr = range(0,1000);//模拟生成1001条数据\nfunction action(array $arr, callable $function)\n{\n    foreach ($arr as $value) {\n        if ($value % 10 == 0) {//当满足条件时,去执行回调函数处理//触发回调\n            call_user_func($function, $value);//调用回调事件\n        }\n    }\n}\naction($arr,'insert');\n\n在这个例子中,首先定义了一个插入数据的函数,定义了一个1001条数据的数组\n然后调用了action函数,当遍历数组满足条件时,则执行设定好的回调函数进行插入数据\n回调函数的几种写法\n函数字符串:\n&lt;?php\nfunction insert(int $i):bool {\n    echo \"插入数据{$i}\\n\";//模拟数据库插入\n    return true;\n}\n$arr = range(0,1000);//模拟生成1001条数据\nfunction action(array $arr, callable $function)\n{\n    foreach ($arr as $value) {\n        if ($value % 10 == 0) {//当满足条件时,去执行回调函数处理\n            call_user_func($function, $value);\n        }\n    }\n}\naction($arr,'insert');\n匿名函数\n&lt;?php\n$arr = range(0,1000);//模拟生成1001条数据\nfunction action(array $arr, callable $function)\n{\n    foreach ($arr as $value) {\n        if ($value % 10 == 0) {//当满足条件时,去执行回调函数处理\n            call_user_func($function, $value);\n        }\n    }\n}\naction($arr,function($i){\n    echo \"插入数据{$i}\\n\";//模拟数据库插入\n    return true;\n});\n类静态方法\n&lt;?php\n$arr = range(0, 1000);//模拟生成1001条数据\nfunction action(array $arr, callable $function)\n{\n    foreach ($arr as $value) {\n        if ($value % 10 == 0) {//当满足条件时,去执行回调函数处理\n            call_user_func($function, $value);\n        }\n    }\n}\nclass A{\n    static function insert(int $i):bool {\n        echo \"插入数据{$i}\\n\";//模拟数据库插入\n        return true;\n    }\n}\naction($arr,'A::insert');\naction($arr,array('A','insert'));\n\n类方法\n&lt;?php\n$arr = range(0, 1000);//模拟生成1001条数据\nfunction action(array $arr, callable $function)\n{\n    foreach ($arr as $value) {\n        if ($value % 10 == 0) {//当满足条件时,去执行回调函数处理\n            call_user_func($function, $value);\n        }\n    }\n}\nclass A{\n    public function insert(int $i):bool {\n        echo \"插入数据{$i}\\n\";//模拟数据库插入\n        return true;\n    }\n}\n$a = new A();\naction($arr,array($a,'insert'));\n","link":"/NoobCourse/PHP/callback.html"},{"id":28,"title":"闭包/匿名函数","content":"闭包函数\n闭包的概念\n闭包就是能够读取其他函数内部变量的函数。例如在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。\n在php中,闭包函数一般就是匿名函数.\n举例,有一个定时任务,每一秒执行一次,现在我们要开启一个服务,然后准备在30秒的时候关闭这个服务\n&lt;?php\nfunction tick($callback){\n    while (1) {//简单实现的定时器,每秒都去执行一次回调\n        call_user_func($callback);\n        sleep(1);\n    }\n}\nclass Server\n{\n    //模拟退出一个服务\n    public function exitServer()\n    {\n        return true;\n    }\n}\n$server = new Server();\n$time = time();\ntick(function ()use($server) {\n    $server-&gt;exitServer();\n});\n在这里面,使用匿名函数,use了函数外部的$server变量,才使得定时器能回调调用$server-&gt;exitServer();\n匿名函数\n匿名函数 通俗来讲,就是没有名字的函数,例如上面写的function(){},它通常作为闭包函数使用,使用方法如下:\n&lt;?php\n$fun = function($name){\n    printf(\"Hello %s\\r\\n\",$name);\n};\necho $fun('Tioncico');\nfunction a($callback){\n    return $callback();\n}\na(function (){\n    echo \"EasySwoole\\n\";\n    return 1;\n});\nuse\nPHP在默认情况下，匿名函数不能调用所在代码块的上下文变量，而需要通过使用use关键字。\n&lt;?php\nfunction a($callback){\n    return $callback();\n}\n$str1 = \"hello,\";\n$str2 = \"Tioncico,\";\na(function ()use($str1,$str2){\n    echo $str1,$str2,\"EasySwoole\\n\";\n    return 1;\n});\n","link":"/NoobCourse/PHP/closures.html"},{"id":29,"title":"php多进程","content":"php多进程\nphp多进程是在开发业务逻辑层面,并行处理多个任务的一种开发方式,例如,需要给10万给会员发送邮件,每个邮件需要处理1秒,如果是一个进程处理,就得10万*1秒才能处理完,但是,如果开启多个进程同时处理,例如:10个进程,那只需要10万*1/10秒就能处理完成,缩短了10倍的时间\n多进程的概念\n前面有讲到,多进程主要是在开发业务逻辑层面,并行处理多个任务的开发方式,什么叫做开发业务逻辑层面呢?\n在上面我们有讲到,php-fpm是fast-cgi的进程管理器,启动之后会启动多个fast-cgi进程,等待任务处理  \n在php-fpm软件层面,fast-cgi的多个进程就属于多进程处理,但是,当用户发起请求,由nginx交给php-fpm处理请求时,在这个层面,每个请求其实只占有一个php fast-cgi进程进行处理逻辑,对于运行业务逻辑的这个php进程,其实是单进程的.\n同理,当我们直接运行一个php文件时,默认是只开启了一个php进程进行运行php的代码\n多进程的开发场景\n在传统web模式下,php一向是单进程处理业务逻辑,只有在php-cli模式下,用于处理异步任务,作为网络服务器时,才可能用到多进程处理,所以,大部分phper都对php多进程的概念不熟悉\n伪多进程\n在上面讲到,在传统web下,一个请求就是一个进程,我们可以通过这个方法,实现理论上的多进程:\n\n在一个php文件中,写消费任务逻辑,比如给队列中的会员id发送邮件(注意超时,注意用户端关闭不终止脚本)\n用网页访问这个php文件,相当于开启了一个进程处理\n再开第二个网页访问这个文件,相当于又开启了一个进程\n如此重复,我们可以得到n个处理邮件的进程\n针对于消费任务逻辑层面,我们已经是开启了多进程在处理了\n","link":"/NoobCourse/PHP/Multiprocess/introduction.html"},{"id":30,"title":"多进程开启","content":"多进程使用\n怎么才能在一个php脚本中,开启多进程处理呢?这里我们可以使用2种方法(注意,本教程只适用于linux,php-cli环境)\npcntl扩展\npcntl是php官方的多进程扩展,只能在linux环境使用,例如:\n&lt;?php\n$num=1;\n$str=\"EasySwoole,Easy学swoole\\n\";\n$pid = pcntl_fork();//新开一个子进程,上面的变量内存将会复制一份到子进程中.这个函数,在主进程中返回子进程进程id,在子进程返回0,开启失败在主进程返回-1\necho $str;//这下面的代码,将会被主进程,子进程共同执行\n\nif($pid&gt;0){//主进程代码\n    echo \"我是主进程,子进程的pid是{$pid}\\n\";\n}elseif($pid==0){\n    echo \"我是子进程,我的pid是\".getmypid().\"\\n\";\n}else{\n    echo \"我是主进程,我现在慌得一批,开启子进程失败了\\n\";\n}\n详细内容可自行搜索了解\nswoole扩展\nswoole扩展是面向生产环境的 PHP 异步网络通信引擎,它也有着进程管理模块\n&lt;?php\n$num = 1;\n$str = \"EasySwoole,Easy学swoole\\n\";\n\n$process = new swoole_process(function () use ($str) {//实例化一个进程类,传入回调函数\n    echo $str;//变量内存照常复制一份,只不过swoole的开启子进程后使用的是回调方法运行\n    echo \"我是子进程,我的pid是\" . getmypid() . \"\\n\";\n});\n$pid = $process-&gt;start();//开启子进程,创建成功返回子进程的PID，创建失败返回false。\necho $str;\nif ($pid &gt; 0) {//主进程代码\n    echo \"我是主进程,子进程的pid是{$pid}\\n\";\n}else{\n    echo \"我是主进程,我现在不慌了,失败就失败吧\\n\";\n}\n详细内容可自行搜索了解","link":"/NoobCourse/PHP/Multiprocess/fork.html"},{"id":31,"title":"进程通信","content":"进程通信\n在各个进程中,内存空间都是不一致的,各个变量都是在不同的内存空间,举个简单的例子  \n\n用户A访问服务端,$_SESSION['user']=1;\n用户B同时访问服务端,读取$_SESSION['user']是读取不到的,因为进程之间内存不是相同的  \n\n同样,在php多进程中,pcntl_fork之后,虽然能读取到之前的变量,但这个变量是复制出来的一份,和原来那份存储位置根本不同,例如:\n&lt;?php\n$str = \"EasySwoole\\n\";\n$pid = pcntl_fork();\nif($pid&gt;0){\n    $str=\"Tioncico\\n\";//在主进程修改了$str,不会影响到子进程的$str变量\n    echo $str;\n}elseif ($pid==0){\n    echo $str;//$str是pcntl_fork复制出来的\n}else{\n\n}\n所以,多进程中根本无法直接通信,那么,该怎么样才能通信呢?可以使用以下几种方式进行通信\n\n管道通信,分为有名管道,无名管道等,可自行搜索了解详细\n消息队列通信,使用linux消息队列,通过sysvmsg扩展,可查看:http://www.php20.cn/article/137\n\n进程信号通信,可查看:http://www.php20.cn/article/134\n\n共享内存通信,映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。\n套接字通信\n第三方通信,使用文件操作,mysql,redis等方法也可实现通信\n\n可自行搜索了解详细内容 ","link":"/NoobCourse/PHP/Multiprocess/processCommunication.html"},{"id":32,"title":"进程信号","content":"进程信号\n信号（Signals ）是Unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原始机制。一个键盘中断或者一个错误条件（比如进程试图访问它的虚拟内存中不存在的位置等）都有可能产生一个信号。Shell也使用信号向它的子进程发送作业控制信号。  \n信号是在Unix System V中首先引入的，它实现了15种信号，但很不可靠。BSD4.2解决了其中的许多问题，而在BSD4.3中进一步加强和改善了信号机制。但两者的接口不完全兼容。在Posix 1003.1标准中做了一些强行规定，它定义了一个标准的信号接口，但没有规定接口的实现。目前几乎所有的Unix变种都提供了和Posix标准兼容的信号实现机制。\n阶段\n在一个信号的生命周期中有两个阶段：生成和传送。当一个事件发生时，需要通知一个进程，这时生成一个信号。当进程识别出信号的到来，就采取适当的动作来传送或处理信号。在信号到来和进程对信号进行处理之间，信号在进程上挂起（pending）。  \n内核为进程生产信号，来响应不同的事件，这些事件就是信号源。主要的信号源如下：  \n\n异常：进程运行过程中出现异常；  \n其它进程：一个进程可以向另一个或一组进程发送信号；\n终端中断：Ctrl-C，Ctrl-\\等；\n作业控制：前台、后台进程的管理；\n分配额：CPU超时或文件大小突破限制；\n通知：通知进程某事件发生，如I/O就绪等；\n报警：计时器到期。\n\n常见信号\n\n\nSIGHUP： 从终端上发出的结束信号；\n\n\nSIGINT： 来自键盘的中断信号（Ctrl-C）；\n\n\nSIGQUIT：来自键盘的退出信号（Ctrl-\\）；\n\n\nSIGFPE： 浮点异常信号（例如浮点运算溢出）；\n\n\nSIGKILL：该信号结束接收信号的进程；\n\n\nSIGALRM：进程的定时器到期时，发送该信号；\n\n\nSIGTERM：kill 命令发出的信号；\n\n\nSIGCHLD：标识子进程停止或结束的信号；\n每一个信号都有一个缺省动作，它是当进程没有给这个信号指定处理程序时，内核对信号的处理。有5种缺省的动作：\n\n\n异常终止（abort）：在进程的当前目录下，把进程的地址空间内容、寄存器内容保存到一个叫做core的文件中，而后终止进程。  \n\n\n退出（exit）：不产生core文件，直接终止进程。\n\n\n忽略（ignore）：忽略该信号。\n\n\n停止（stop）：挂起该进程。\n\n\n继续（continue）：如果进程被挂起，则恢复进程的运行。否则，忽略信号。\n\n\n进程可以对任何信号指定另一个动作或重载缺省动作，指定的新动作可以是忽略信号。进程也可以暂时地阻塞一个信号。因此进程可以选择对某种信号所采取的特定操作，这些操作包括：\n\n\n忽略信号：进程可忽略产生的信号，但 SIGKILL 和 SIGSTOP 信号不能被忽略,必须处理（由进程自己或由内核处理）。进程可以忽略掉系统产生的大多数信号。\n\n\n阻塞信号：进程可选择阻塞某些信号，即先将到来的某些信号记录下来，等到以后（解除阻塞后）再处理它。\n\n\n由进程处理该信号：进程本身可在系统中注册处理信号的处理程序地址，当发出该信号时，由注册的处理程序处理信号。\n\n\n由内核进行缺省处理：信号由内核的缺省处理程序处理，执行该信号的缺省动作。例如，进程接收到SIGFPE（浮点异常）的缺省动作是产生core并退出。大多数情况下，信号由内核处理。\n\n\n需要指出的是，对信号的任何处理，包括终止进程，都必须由接收到信号的进程来执行。而进程要执行信号处理程序，就必须等到它真正运行时。因此，对信号的处理可能需要延迟一段时间。  \n信号没有固有的优先级。如果为一个进程同时产生了两个信号，这两个信号会以任意顺序出现在进程中并会按任意顺序被处理。另外，也没有机制用于区分同一种类的多个信号。如果进程在处理某个信号之前，又有相同的信号发出，则进程只能接收到一个信号。进程无法知道它接收了1个还是42个SIGCONT信号。\n\n详细内容可查看:http://www.php20.cn/article/134\n","link":"/NoobCourse/PHP/Multiprocess/processSignal.html"},{"id":33,"title":"僵尸进程","content":"僵尸进程\n僵尸进程是当子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此时子进程将成为一个僵尸进程。\n在unix进程管理中,如果你新开的子进程运行结束,父进程将会收到一个SIGCHLD信号,子进程成为僵尸进程(保存了进程的状态等信息),等待父进程的处理,如果父进程一直不处理,该进程将会一直存在,占用系统进程表项,如果僵尸进程过多,导致系统没有可用的进程表项,于是再也无法运行其他的程序\n\n为了更容易理解,本文使用pcntl扩展进行进程管理  \n\n例如:\n&lt;?php\n$num = 1;\n$str = \"EasySwoole,Easy学swoole\\n\";\n$pid = pcntl_fork();\nif ($pid &gt; 0) {//主进程代码\n    echo \"我是主进程,id是\".getmypid().\",子进程的pid是{$pid}\\n\";\n    pcntl_async_signals(true);\n    pcntl_signal(SIGCHLD, function () {\n        echo '子进程退出了,请及时处理' . PHP_EOL;\n    });\n    while (1) {//主进程一直不退出\n        sleep(1);\n    }\n\n} elseif ($pid == 0) {\n    echo \"我是子进程,我的pid是\" . getmypid() . \"\\n\";\n} else {\n    echo \"我是主进程,我慌得一批,开启子进程失败了\\n\";\n}\n\n使用ps查看僵尸进程:\nps -A -ostat,ppid,pid,cmd |grep -e '^[Zz]'\n输出:\nZ+     7136   7137 [php] &lt;defunct&gt;\n\n当主进程退出之后,子进程将会被init接管并处理\n\n回收僵尸进程\n回收僵尸进程\n通过pcntl_wait和pcntl_waitpid等函数等待子进程结束\n&lt;?php\n$pid = pcntl_fork();\n\nif ($pid == -1) {\n    die('fork error');\n} else if ($pid &gt; 0) {\n//父进程阻塞着等待子进程的退出\n//    pcntl_wait($status);\n//    pcntl_waitpid($pid, $status);\n\n//非阻塞方式\n//    pcntl_wait($status, WNOHANG);\n\n//    pcntl_waitpid($pid, $status, WNOHANG);\n\n} else {\n    sleep(3);\n    echo \"child \\r\\n\";\n    exit;\n}\n通过signal函数为SIGCHLD安装handler，因为子进程结束后，父进程会收到该信号，可以在handler中调用pcntl_wait或pcntl_waitpid来回收.\n&lt;?php\npcntl_async_signals(true);\n\npcntl_signal(SIGCHLD, function () {\n    echo \"SIGCHLD \\r\\n\";\n    //阻塞方式\n    pcntl_wait($status);\n    //pcntl_waitpid(-1, $status);\n\n    //非阻塞\n    //pcntl_wait($status, WNOHANG);\n    //pcntl_waitpid(-1, $status, WNOHANG);\n});\n\n$pid = pcntl_fork();\n\nif ($pid == -1) {\n    die('fork error');\n} else if ($pid) {\n    sleep(10);\n} else {\n    sleep(3);\n    echo \"child \\r\\n\";\n    exit;\n}\n忽略掉子进程结束信号,交给init进程管理\n&lt;?php\npcntl_async_signals(true);\n\npcntl_signal(SIGCHLD, SIG_IGN);\n\n$pid = pcntl_fork();\nif ($pid == -1) {\n    die('fork error');\n} else if ($pid&gt;0) {\n    while(1){\n        sleep(1);\n    }\n} else {\n    sleep(3);\n    echo \"child \\r\\n\";\n    exit;\n}","link":"/NoobCourse/PHP/Multiprocess/zombieProcess.html"},{"id":34,"title":"孤儿进程","content":"孤儿进程\n孤儿进程指的是在其父进程执行完成或被终止后仍继续运行的一类进程。这些孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。\n孤儿进程没有任何危害,只是需要注意自己的代码逻辑即可.\n例如:\n&lt;?php\n$pid = pcntl_fork();\nif ($pid == -1) {\n    die('fork error');\n} else if ($pid&gt;0) {\n    echo \"爸爸先走了,儿子你好好干活\\n\";\n    exit(0);\n} else {\n    while(1){\n        echo \"1\";\n        sleep(1);\n    }\n}\n运行结果:\n\n孤儿进程和僵尸进程\n僵尸进程：一个子进程在其父进程还没有调用wait()或waitpid()的情况下退出。这个子进程就是僵尸进程。任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。这是每个 子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。  \n孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。因此孤儿进程并不会有什么危害  。","link":"/NoobCourse/PHP/Multiprocess/orphanProcess.html"},{"id":35,"title":"守护进程","content":"守护进程\n守护进程(daemon)是一类在后台运行的特殊进程，用于执行特定的系统任务。很多守护进程在系统引导的时候启动，并且一直运行直到系统关闭。另一些只在需要的时候才启动，完成任务后就自动结束。 \n用户使守护进程独立于所有终端是因为，在守护进程从一个终端启动的情况下，这同一个终端可能被其他的用户使用。例如，用户从一个终端启动守护进程后退出，然后另外一个人也登录到这个终端。用户不希望后者在使用该终端的过程中，接收到守护进程的任何错误信息。同样，由终端键人的任何信号(例如中断信号)也不应该影响先前在该终端启动的任何守护进程的运行。虽然让服务器后台运行很容易(只要shell命令行以&amp;结尾即可)，但用户还应该做些工作，让程序本身能够自动进入后台，且不依赖于任何终端。\n创建步骤\n\n调用fork(),创建新进程,它会是将来的守护进程.\n在父进程中调用exit,保证子进程不是父进程,成为孤儿进程\n调用setsid()创建新的会话区,让进程摆脱原会话的控制、让进程摆脱原进程组的控制和让进程摆脱原控制终端的控制。(如果不进行这步,孤儿进程将会在控制终端退出后退出)\n将当前目录改成根目录(如果把当前目录作为守护进程的目录,当前目录不能被卸载他作为守护进程的工作目录)\n将标准输入,标注输出,标准错误重定向到/dev/null.(否则会在控制终端中输出)\n重设文件创建掩码,文件创建掩码是指屏蔽掉文件创建时的对应位。由于使用fork函数新建的子进程继承了父进程的文件创建掩码，这就给该子进程使用文件带来了诸多的麻烦。因此，把文件创建掩码设置为0，可以大大增强该守护进程的灵活性。设置文件创建掩码的函数是umask，通常的使用方法为umask(0)。\n关闭文件描述符,用fork新建的子进程会从父进程那里继承一些已经打开了的文件。这些被打开的文件可能永远不会被守护进程读或写，但它们一样消耗系统资源，可能导致所在的文件系统无法卸载。\n\n特点\n首先，守护进程最重要的特性是后台运行。其次，守护进程必须与其运行前的环境隔离开来。这些环境包括未关闭的文件描述符、控制终端、会话和进程组、工作目录以及文件创建掩码等。这些环境通常是守护进程从执行它的父进程(特别是shell)继承下来的。最后，守护进程的启动方式有其特殊之处。它可以在Linux系统启动时从启动脚本/etc/rc．d中启动，也可以由作业控制进程crond启动，还可以由用户终端(通常是shell)执行。  \n除这些以外，守护进程与普通进程基本上没有什么区别。因此，编写守护进样实际上是把一个普通进程按照上述的守护进程的特性改造成为守护进程。\n分类\n按照服务类型分为如下几个。\n\n系统守护进程：syslogd、login、crond、at等。\n网络守护进程：sendmail、httpd、xinetd、等。\n独立启动的守护进程：httpd、named、xinetd等。\n被动守护进程（由xinetd启动）：telnet、finger、ktalk等。\n","link":"/NoobCourse/PHP/Multiprocess/deamon.html"},{"id":36,"title":"同步/异步","content":"同步\n同步代码主要是指调用某个逻辑时,会等待到该逻辑返回调用结果.\n例如:\n&lt;?php\n$num = 30;\n$result = M('test')-&gt;select();//伪代码,查询数据库\nsleep(3);//伪代码,当成执行了3秒才返回\necho json_encode($result);//返回数据\n只有当select查询到数据时,才会返回数据给$result,这个值一定是数据库操作完毕返回的值\n例如:\n&lt;?php\n$num = -30;\n$result = abs($num);\necho json_encode($result);//返回数据\n\nabs会返回数据给$result,这个值一定是abs正确操作的值\n例如:\n用户请求www.easyswoole.com,页面会一直等待easyswoole响应数据.\n例如:\n&lt;?php\n//模拟发送邮件中\n$status = send();\nsleep(30);//发送邮件花费30秒\n\necho \"发送邮件\".$status?'完成':'失败';\n等待发送邮件的成功/失败,就是同步\n异步\n异步代码主要是指调用某个逻辑时,不会等待该逻辑返回的结果,只会返回是否已经调用的最初结果(或不返回)\n例如:\n调用$.ajax(),默认情况下是异步ajax,它会继续往下执行代码,当有结果返回时通过回调事件进行处理.\n例如:\n&lt;?php\n$pid = pcntl_fork();\nif ($pid == 0) {\n    //子进程\n    //模拟发送邮件\n    sleep(30);//发送邮件花费30秒\n    exit(0);\n}\n\npcntl_waitpid($pid, $status, WNOHANG);\necho \"发送邮件中\";\n通过新开一个进程去处理发送邮件的任务,在当前进程中不关心发送邮件的结果,直接往下执行\n","link":"/NoobCourse/sync.html"},{"id":37,"title":"阻塞/非阻塞","content":"进程阻塞\n正在运行的进程由于提出系统服务请求（如I/O操作），但因为某种原因未得到操作系统的立即响应，或者需要从其他合作进程获得的数据尚未到达等原因，该进程只能调用阻塞原语把自己阻塞，等待相应的事件出现后才被唤醒。\n阻塞状态\n正在进行的进程由于发生某事件而暂时无法继续执行时，便放弃处理机而处于暂停状态，亦即进程的执行受到阻塞，我们把这种暂停状态叫阻塞进程阻塞，有时也成为等待状态或封锁状态。通常这种处于阻塞状态的进程也排成一个队列。有的系统则根据阻塞原因的不同而处于阻塞状态进程排成多个队列。  \n例如:\n用户访问服务端,请求用户的个人的订单信息,由于数据库数据量大,数据库繁忙,sql语句查询了3秒才返回,这个查询数据库的过程,就是可称为是&quot;阻塞的&quot;.(进程调用外部逻辑)   \n\n阻塞这个概念和时间关系不大,就算查了0.1秒,也可以说是阻塞了0.1秒,因为这个并不是进程本身执行所消耗的时间,而是因为查询数据库,等待数据库响应消耗的时间.\n但阻塞的危害性和时间有关,阻塞0.1秒对于用户是没有任何问题的,但是阻塞10秒将会使用户体验下降很多,所以我们需要重视阻塞\n用户访问服务端,由于某个地方调用了死循环或多重循环浪费了许多时间,无法继续往下执行,这个状态也可称为阻塞.(非进程阻塞,可自行避免)\n非进程阻塞 在进程阻塞层面中,并不算是被阻塞了,因为它依旧在执行进程中的代码,没有等待清空\n\n阻塞函数\n如上所说,调用数据库等外部逻辑,造成阻塞的函数,就叫做阻塞函数\nphp中的阻塞\n在php初级开发者中,或许没有听过这个概念,阻塞往往是和&quot;同步&quot;概念一起存在的,例如查询数据库,获取文件数据,请求其他网站,等等,只要需要消耗非进程本身执行时间并需要进程等待(同步)的,都可以说是阻塞.\n\n几乎所有的阻塞,都是与I/O有关.\n阻塞一定是同步代码调用阻塞函数才会阻塞,但同步代码不一定会阻塞(不调用阻塞函数的同步代码)\n&lt;?php\n$num = 30;\n$result = M('test')-&gt;select();//伪代码,sql阻塞\nsleep(3);//伪代码,当成执行了3秒才返回\necho json_encode($result);//返回数据\n\n可自行搜索了解更多\n非阻塞\n非阻塞,顾名思义,就是在进程在运行中,不存在阻塞情况,一直能往下执行.\n\n非阻塞一般是指调用I/O操作时,进程无需等待I/O操作,直接往下执行的情况\n非阻塞通常是和&quot;异步&quot;概念一起存在,只要是异步获取I/O,就一定是非阻塞\n异步调用I/O一定是非阻塞的,但非阻塞不一定需要异步调用才可实现(非阻塞模型)\n\n例如:\n当查询数据库时,马上返回状态(查询到了就返回数据,数据还没到就返回-1),程序可以立即往下执行逻辑.  \n\n这种马上返回结果,无需等待(并不一定有数据)的函数,就叫做非阻塞函数,也可称为是&quot;异步调用&quot;\n\n非阻塞模型\n可以通过非阻塞模型去实现非阻塞(主要针对于server服务端实现).\n详细了解可查看:http://www.php20.cn/article/157\nphp中的非阻塞\nphp初级开发者中,很少有非阻塞这个概念存在,但php是有非阻塞的,例如socket_set_nonblock()函数,将socket改为非阻塞状态\n通过flock($file,LOCK_EX|LOCK_NB),可将文件操作设置为非阻塞状态\n可自行搜索了解详细  \n非阻塞注意事项\n由于非阻塞的返回结果是不确定的,当我们需要关心返回结果的情况时,需要确保返回结果是正确的(例如while(1){}定时查询,当数据正确返回退出循环),或者直接使用阻塞函数\n阻塞和非阻塞的举例\n阻塞:\n小明去电脑店买Mac,问店员现在有没有MacBook Pro版本,有多少台,店员告诉小明,&quot;我得去查一查,你得等等&quot;,小明站在店门口等了2天,店员回来了,告诉小明,现在有10台,然后小明买了一台.\n\n在这个过程中,店员查询是否有mbp的动作,就属于I/O操作,叫小明等等这个操作,就是阻塞情况,小明等了2天,就说明查询mbp时间为2天,阻塞了2天,店员回来告诉小明有10台,就是阻塞函数出现了结果,并返回了数据,小明买了一台,就是继续往下执行了代码\n\n非阻塞:\n小明去电脑店买Mac,问店员现在有没有MacBook Pro版本,有多少台,店员告诉小明,&quot;我得去查一查,你先回去呗&quot;,小明回家,每隔10分钟打电话给店员,但是店员每次都告诉他还没查到,小明每次打完电话就去敲PHP代码,2天后,小明打完一把LOL,又打电话给店员问,店员告诉小明,现在有10台了,然后小明买了一台.\n\n在这个过程中,店员查询是否有mbp的动作,就属于I/O操作,叫小明回家这个操作,就是非阻塞情况,小明不断打电话,这个就是定时轮询查询,店员不断的回复,这个情况就是非阻塞函数没有返回数据,小明去敲PHP,说明非阻塞情况还能执行其他代码,2天后,店员回来告诉小明有10台,就是非阻塞函数通过轮询出现了结果,并返回了数据,小明买了一台,就是退出了循环继续往下执行了代码\n\n","link":"/NoobCourse/block.html"},{"id":38,"title":"协程","content":"协程\n协程不是进程或线程，其执行过程更类似于子例程，或者说不带返回值的函数调用。\n一个程序可以包含多个协程，可以对比与一个进程包含多个线程，因而下面我们来比较协程和线程。我们知道多个线程相对独立，有自己的上下文，切换受系统控制；而协程也相对独立，有自己的上下文，但是其切换由自己控制，由当前协程切换到其他协程由当前协程来控制。\n\n协程执行顺序\n首先,我们来看一个原生php代码:\n&lt;?php\nfunction task1(){\n    for ($i=0;$i&lt;=300;$i++){\n        //写入文件,大概要3000微秒\n        usleep(3000);\n        echo \"写入文件{$i}\\n\";\n    }\n}\nfunction task2(){\n    for ($i=0;$i&lt;=500;$i++){\n        //发送邮件给500名会员,大概3000微秒\n        usleep(3000);\n        echo \"发送邮件{$i}\\n\";\n    }\n}\nfunction task3(){\n    for ($i=0;$i&lt;=100;$i++){\n        //模拟插入100条数据,大概3000微秒\n        usleep(3000);\n        echo \"插入数据{$i}\\n\";\n    }\n}\ntask1();\ntask2();\ntask3();\n在这个代码中,我们主要做了3件事:写入文件,发送邮件,以及插入数据.\n再看下面这段代码:\n&lt;?php\nfunction task1($i)\n{\n    //使用$i标识 写入文件,大概要3000微秒\n    if ($i &gt; 300) {\n        return false;//超过300不用写了\n    }\n    echo \"写入文件{$i}\\n\";\n    usleep(3000);\n    return true;\n}\n\nfunction task2($i)\n{\n    //使用$i标识 发送邮件,大概要3000微秒\n    if ($i &gt; 500) {\n        return false;//超过500不用发送了\n    }\n    echo \"发送邮件{$i}\\n\";\n    usleep(3000);\n    return true;\n}\n\nfunction task3($i)\n{\n    //使用$i标识 插入数据,大概要3000微秒\n    if ($i &gt; 100) {\n        return false;//超过100不用插入\n    }\n    echo \"插入数据{$i}\\n\";\n    usleep(3000);\n    return true;\n}\n\n$i           = 0;\n$task1Result = true;\n$task2Result = true;\n$task3Result = true;\nwhile (true) {\n    $task1Result &amp;&amp; $task1Result = task1($i);\n    $task2Result &amp;&amp; $task2Result = task2($i);\n    $task3Result &amp;&amp; $task3Result = task3($i);\n    if($task1Result===false&amp;&amp;$task2Result===false&amp;&amp;$task3Result===false){\n        break;//全部任务完成,退出循环\n    }\n    $i++;\n}\n这段代码也是做了3件事,写入文件,发送邮件,以及插入数据,但是和上面的不同的是,这段代码将这3件事交叉执行,每个任务执行完一次之后,切换到另一个任务,如此循环.\n类似于这样的执行顺序,就是协程.\n\n协程是指一种用代码实现任务交叉执行的逻辑,协程可以使得代码1中的3个函数交叉运行,在实现了协程的框架中,我们不需要通过代码2的方法实现任务交叉执行.直接可让代码1中的while(1),执行一次后切换\n\n协程的实现\n在php中,实现协程主要使用2种方式: \n\nyield生成器实现 (详细原理可查看http://www.php20.cn/article/148)\nswoole扩展实现\n\nswoole实现协程代码:\n&lt;?php\nfunction task1(){\n    for ($i=0;$i&lt;=300;$i++){\n        //写入文件,大概要3000微秒\n        usleep(3000);\n        echo \"写入文件{$i}\\n\";\n        Co::sleep(0.001);//挂起当前协程,0.001秒后恢复//相当于切换协程\n    }\n}\nfunction task2(){\n    for ($i=0;$i&lt;=500;$i++){\n        //发送邮件给500名会员,大概3000微秒\n        usleep(3000);\n        echo \"发送邮件{$i}\\n\";\n        Co::sleep(0.001);//挂起当前协程,0.001秒后恢复//相当于切换协程\n    }\n}\nfunction task3(){\n    for ($i=0;$i&lt;=100;$i++){\n        //模拟插入100条数据,大概3000微秒\n        usleep(3000);\n        echo \"插入数据{$i}\\n\";\n        Co::sleep(0.001);//挂起当前协程,0.001秒后恢复//相当于切换协程\n    }\n}\n$pid1 = go('task1');//go函数是swoole的开启协程函数,用于开启一个协程\n$pid2 = go('task2');\n$pid3 = go('task3');\n以上代码,即可实现切换函数\n\n为什么要用sleep挂起协程实现切换呢?因为swoole的协程是自动的,当协程内遇上I/O操作(mysql,redis)等时,swoole的协程会自动切换,运行到下一个协程任务中(切换后,I/O继续执行),直到下一个协程任务完成或者被切换(遇上I/O),如此反复,直到所有协程任务完成,则任务完成\n\n协程与进程\n由上面的协程执行顺序中的代码2,我们很容易发现,协程其实只是运行在一个进程中的函数,只是这个函数会被切换到下一个执行,可以这么说:\n\n协程只是一串运行在进程中的任务代码,只是这些任务代码可以交叉运行\n注意,协程并不是多任务并行,属于多任务串行,每个进程在一个时间只执行了一个任务\n\n协程的作用域\n由于协程就是进程中一串任务代码,所以它的全局变量,静态变量等变量都是共享的,包括了php的全局缓冲区.\n所以,在开发之中,需要特别注意协程中的全局变量,静态变量,只要某一个协程内修改了,那将会影响全部的协程,在使用ob缓冲区函数拦截的时候,也得考虑是否会被其他协程的输出给污染.\n用协程执行顺序中的代码2解释,当task1给$_GET['name']赋值为1时,task2读取$_GET['name']也会是1,task2将$_GET['name']赋值为2时,task3读取$_GET['name']也会是2\n协程中的I/O连接\n在协程中,要特别注意不能共用一个I/O连接,否则会造成数据异常.\n用协程执行顺序中的代码2解释,当task1,task2函数共用mysql连接,并都进行查询时,由于协程是交叉运行的,可能会造成task1获取到task1+task2查询出来的数据,也可能会丢失部分数据,被task2获取.\n\n由于协程的交叉运行机制,各个协程的I/O连接都必须是独立的,所以我们需要在每个协程都创建一个连接,但由于mysql,redis的连接数有限,以及连接的开启关闭需要消耗大量资源,所以我们可以使用连接池方案实现共用连接(只要保证每个连接每次只有一个协程在使用即可)\n","link":"/NoobCourse/coroutine.html"},{"id":39,"title":"初识swoole","content":"初识 Swoole\n前言\n\n在之前的教程当中我们已经了解到了php的几种运行模式：\n\n\nCGI   通用网关接口(Common Gateway Interface)\n\nFast-CGI 是 cgi的升级版本，用 PHP-FPM(FastCGI Process Manager) 即 fast-cgi 进程管理器\n\nmod 以模块的形式集成进 Apache 中，接受 Apache 提供的.php文件，并进行解析。\n\nCLI 命令行模式，直接使用 PHP 去执行.php文件时便是此模式。\n\n尽管 CLI 模式可以完成更多有趣和强大的功能，但大多数php程序员很少使用 CLI 模式。\n起源\nSwoole是Rango在2010年底，因为公司业务需要自己实现一个Tcp Socket Server 实现SMT\nP协议接收数据，但是在当时PHP在这个领域几乎是一片空白，所以Rango自己学习，最终完成了需求；随后便开源了此套系统，希望能帮助其他PHPer解决在这个领域的问题，让PHP从单纯的Web开发扩展到更大的空间。\n以下内容来自于Swoole官方文档\n\n项目起源\nSwoole 项目最初的想法是来自于之前所做的一个企业软件项目。当时大概是2010年底，公司产品有一个需求是用户可以任意生成一个 email 地址，然后其他用户可以向这个email发邮件，后台能实时将邮件内容解析成数据，并主动通知用户。当时项目使用PHP开发的，在实现这个需求时遇到了难题，PHP只能依赖其他的STMP服务器，通过pop3协议定时查收新邮件来完成，这样就不是实时的。如果要实现的实时系统必须自己写一个TCP Socket Server实现SMTP协议接收数据。当时PHP在这个领域几乎是空白，没有一套成熟的网络通信框架。为了实现需求，我从socket学起到TCP/IP、IO复用、libevent、多进程，最后终于实现了这套程序。做完这个项目后我就想把这套程序开源出来，希望能帮助其他PHPer解决在这个领域的难题。如果能有这样一个框架，那么PHP就能从单纯地做一个Web网站延伸到更大的空间。\n还有一个重要的原因是PHP程序的性能问题，我最早是学Java出身的，工作后才转行成为一名PHP程序员。在使用PHP开发程序的过程中，我一直在思考的问题 PHP 和 Java 比最大的优势是什么？简单高效， PHP 在请求完成之后会释放所有资源和内存，无须担心内存泄漏。代码的质量无论高低一样运行的很流畅。但同时这也是 PHP 致命的缺点。一旦请求数量上升，并发很高的时候，快速创建资源，又马上释放，使得 PHP 程序运行效率急剧下降。另外一旦项目的功能的越来越复杂，代码增多后，对于 PHP 也会是灾难。这也是 PHP 的框架为什么没有被 PHP 程序员广泛接受，而 Java 不存在这个问题。再好的框架也会被这种低效的方式拖累，导致系统变慢。所以想到了使用 PHP 来开发 PHP 的应用服务器，让 PHP 的代码加载到内存后，拥有更长的生命周期，这样建立的数据库连接和其他大的对象，不被释放。每次请求只需要处理很少的代码，而这些代码只在第一次运行时，被 PHP 解析器编译，驻留内存。另外，之前 PHP 不能实现的，对象持久化、数据库连接池，缓存连接池都可以实现。系统的运行效率会大大提高。\n经过一段时间研究，目前已经初步得到实现。使用 PHP 本身编写出 HTTP 服务器，以独立服务器方式运行，单个程序页面 ( 有对象生成，数据库连接、 smarty 模板操作 ) 的执行时间由原来的 0.0x 秒，下降到 0.00x 秒。使用 Apache AB 并发 100 测试。比传统 LAMP 方式， Request per Second 高出至少 10 倍。在我的测试机上 (Ubuntu10.04 Inter Core E5300 + 2G 内存 ) ， Apache 只跑到 83RPS 。 Swoole Server 可以跑到 1150 多 RPS。\n这个项目就是Swoole的雏形。这个版本一直持续维护了2年多，在这个过程中逐步有了一些经验积累，对这套技术方案的存在问题有了更深入的理解，比如性能差、限制较多无法直接调用操作系统接口、内存管理效率低下。\n入职腾讯\n2011年底我入职腾讯，负责朋友网的PHP平台开发工作。惊奇地发现朋友网的同事不光这样想了，他们直接做到了。朋友网团队已经在生产环境中使用了这套方案。朋友网有三架马车，第一个是PWS，这是一个纯PHP编写的WebServer，朋友网线上有600多台服务器运行在PWS上，完全没有使用Apache、PHP-FPM之类的程序。第二个是SAPS，这是使用纯PHP开发的一个分布式队列，当时大概由150台服务器的集群在跑，很多图片裁剪、头像处理、消息同时、数据同步等逻辑全部使用了SAPS做逻辑异步化。第三个是PSF，这是一个PHP实现的Server框架，朋友网很多逻辑层的服务器都是基于PSF实现的。大概有300台左右的集群在运行PSF服务器程序。在朋友网的这段时间，我学到了很多Linux底层、网络通信的知识，积累了很多大型集群高并发环境的网络通信跟踪、调试经验，为开发Swoole打下了一个很好的基础。\n开发Swoole\n在这期间也学习了解到了Node.js、Golang这些优秀的技术方案，得到了更多灵感。在2012年的时候就有了新的想法，决定使用C语言重新实现一个性能更强、功能更强大的版本。这就是现在的Swoole扩展。\n现在Swoole已经被很多PHP技术团队用于实际项目的开发工作，国内国外都有。国内知名的有百度订单中心、百度地图、腾讯QQ公众号和企业QQ、战旗直播、360、当当网、穷游等。另外还有很多物联网、硬件、游戏项目也在使用Swoole 。另外基于Swoole的开源框架也越来越多，比如TSF、Blink、swPromise 等等，在Github上也能找到很多Swoole相关的项目和代码。\n名字由来\nSwoole这个名字不是一个英文单词，是由我创造的一个音近字。我最早想到的名字是叫做 sword-server，寓意是为广大PHPer创造一把锋利的剑，后来联想到 google 也是凭空创造出来的，所以我就给它命名为 swoole。\n\n现在\n\n随着Swoole进入4.0时代，原2.0时期协程的各种各样的坑，在4.0都得到了解决。\n如今的Swoole可以说是真正好用可靠的PHP异步网络引擎。\n2018年7月Rango辞去工作，组织了全职的研发团队来开发 Swoole 内核、组件和工具链。在文档、测试、社区运营方面也会投入更多资源。本段来源\nSwoole 能做什么\n\n以下内容来源于Swoole官方文档\nSwoole 是使用 C 和 C++ 语言编写的PHP扩展， 内置了异步非阻塞、多线程的网络IO服务器，PHP程序员仅需处理事件回调即可，无需关心底层。\n同时Swoole也提供了许多非常多的内置功能如：\n\nPHP语言的异步多线程服务器\n异步TCP/UDP网络客户端\n异步MySQL\n异步Redis\n数据库连接池\nAsyncTask\n消息队列\n毫秒定时器\n异步文件读写\n异步DNS查询\nHttp/WebSocket服务器端/客户端\nHttp2.0服务器端/客户端\n\n与大家熟知的 Workerman 框架不同，Swoole更像是一个基础库给了开发者一把无比锋利的宝剑，可以按照自己想要的方法去使用。\nSwoole绝大部分功能都只能运行在 CLI 模式下，也正因为此开发者可以完全的掌控Server的一切，与传统的 php-fpm 模式不同，Swoole需要开发者自行接管各种相关事件，和管理变量的生命周期等。\n与传统Web开发的区别\n\n我们知道 php-fpm 是 fast-cgi 运行模式的进程管理器，当启动Server时 php-fpm 会预创建若干个 fast-cgi 处理进程；\n每当请求到达 Nginx 时 Nginx 检查到请求的是.php文件时，就将请求转发给 php-fpm Server 然后由 php-fpm 交给某个空闲的进程处理，当处理完成后由 php-fpm 返回给 Nginx 然后由 Nginx 响应给用户。\n传统PHP开发者几乎无需关注这其中发生的过程甚至根本不了解，正所谓成也萧何败萧何，一方面虽然降低了开发者入门的门槛但另一方面也使得大量的PHP开发者几乎不了解也不懂的真正的服务端开发。\n而 SwooleServer 则是相当于取代了 php-fpm 作为管理器的位置， 由于Swoole 是运行在 CLI 模式下， 所以可以常驻运行和以守护进程运行， 但也正因为如此，也需要开发者自行处理变量的销毁及各种异常和超时的处理。","link":"/NoobCourse/Swoole/start.html"},{"id":40,"title":"运行机制","content":"Swoole 的运行模式\n\n注： 以下内容主要指 SwooleServer 。\nSwoole 做了什么\n\nSwoole 是 php 的一个扩展，但是他又不是普通的扩展，其最明显的特点就是：一但运行后就会接管PHP的控制权，进入事件循环。 当某种IO事件发生时， Swoole 会回调开发者设置的指定PHP函数。\n也就是说 SwooleServer 更像是一个用 C 语言封装好的一个 Tcp/Udp 支持 多线程， EventLoop，事件驱动，异步 等功能的框架。开发者不需要关心底层的各种实现，直接的在业务层面进行开发即可。\n什么是IO事件\n\n很多 php 程序员没有使用过其他语言开发Server，也不太了解除了php-fpm以外运行模式的php程序，初次使用Swoole时总是会有各种摸不到头脑的事情。其实IO我们经常提起如： 磁盘IO ，网络IO 在这里Swoole所指的IO事件实际上是指 网络IO 事件。\n在日常生活中你留下了一个邮箱，当有人给你发送邮件的时候，你就会收到邮件提醒；而对于你而言，你并不关心邮件是如何送达的，你只关心你有没有收到邮件，当你收到邮件之后会根据邮件的内容和发送人去做各种各样的处理。在这个比喻中，Swoole就承担了底层网络事件的监听及各种底层事件处理，当收到邮件(请求)时，会触发收件(接收)提醒，然后将控制权转交给你(预先注册的事件回调函数)，来进行后续的处理。\nSwoole 的运行流程\n\n初始化\n&lt;?php\n\n// new 一个SwoolerServer对象 并指定监听端口 和运行模式 以及Socket类型\n// 此时的一切一切 都是开发者进行配置的时间，没有任何其他事情发生\n$server = new Swoole\\Server('0.0.0.0', 9501, SWOOLE_PROCESS, SWOOLE_SOCK_TCP);\n\n// 设置运行参数， 就像你平时做的那样，给$server 对象配置相关的参数\n$server-&gt;set([\n    'worker_num' =&gt; 4,    // 工作进程数量\n    'daemonize' =&gt; true,  // 是否以守护进程模式运行\n    'backlog' =&gt; 128,     // Listen队列长度\n]);\n\n// 注册事件回调函数\n// 这里指 当底层Tcp新连接进入事件时 交给Tcp 类的 onConnect 静态方法处理\n$server-&gt;on('Connect', [Tcp::class, 'onConnect']);\n// 这里指 当收到数据时 交给Tcp 类的 onReceive 静态方法处理\n$server-&gt;on('Receive', [Tcp::class, 'onReceive']);\n// 这里指 当Tcp客户端连接关闭时 交给Tcp 类的 onClose 静态方法处理\n$server-&gt;on('Close', [Tcp::class, 'onClose']);\n在上面的示例当中，实际上Swoole还尚未启动，但是我们已经预先配置了许多必要的配置条件。鉴于有的新人还尚不了解什么叫做 回调函数，在这里我简单的讲解一下:\n\n所谓的回调函数(CallBack) 就好比是张开了夹子的捕鼠器，我们设定当有老鼠踩到捕鼠器的时候，他会关闭夹子然后捉住老鼠，我们放置捕鼠器的时候，捕鼠器并没有真的抓老鼠。这个设定就是回调，他不立刻执行，会在遇到触发条件(事件)时执行，在上面的示例当中我们放置了3个捕鼠器(回调函数)，我们只需要知道他会在特定老鼠(事件)踩到的时候(发生的时候)去执行我们期望的功能就好。\n\nServer Start\n// 启动Swole Server 将由 Swoole 接管php运行\n$server-&gt;start();\n至此Swoole 完全的接管了php的运行，并且监听相应端口并当发生事件时去执行开发者自定义的事件回调。\n仅仅如此吗？\n事实上Swoole 在启动的时候做了非常多的事情:  \n\nSwoole 运行流程图：\n  \nSwoole 进程关系图：\n\n\n上图中我们可以了解，Swoole 会创建一个 Manager 进程专门 管理 Work 和 Task 进程。 而 Work 进程则直接通过 Unix Socket 和 Master 进程通讯。\n待续","link":"/NoobCourse/Swoole/runningMode.html"},{"id":41,"title":"生命周期","content":"Swoole的生命周期\n\nphp-fpm中的生命周期\n\n传统基于php-fpm的web开发通常淡化了全局期变量的影响，这对于开发者而言，显然是降低了许多上手难度的；但也导致了许多新人对全局期变量会产生的影响没有深刻理解。\n我们知道，php-fpm收到请求后会分配一个work进程去处理这条请求，而work会去读取并执行.php文件(在通常情基于框架的开发中，这个.php文件可能是index.php)。也就是说在传统模式中，每个请求都是独立在自己的进程中执行的，因为进程是隔离的而php-fpm又是同步阻塞的，所以我们可以很好的清楚和了解是谁在什么时候创建了变量、修改了变量、销毁了变量。\n简单举个例子\n可可酱是商店的一名售货员，这个店只有他一个人。当客户来了之后需要购买一瓶可乐，可可酱检查了货架确认有可乐，随后告诉客户这瓶可乐价格是￥3.5元，客户付钱给可可酱，可可酱收到钱后把可乐交给了客户。\n后来发现客人太多，只有可可酱一个人的时候后面的客户需要排队很久，于是老板决定再雇一名售货员，于是加入了小明。\n还是上面的场景，但是由于小明的加入，小明和可可酱同时接待了2名客户，可可酱检查了货架确认还有一箱可乐的时候，和客人沟通可乐的价格时，小明的客户需要购买一箱可乐，于是小明就取走了一箱可乐，当可可酱收了钱准备拿可乐的时候，发现没有可乐了，然后被客户打了一顿。\n在上面的场景中，就是一个变量被修改而导致后续逻辑混乱的场景，在传统的fpm开发中，往往只会在访问数据库的时候出现这种场景。但是如果假设一个fpm进程可以同时处理多条请求的时候，你如果将用户信息存放在全局变量中，那么你就无法再可靠的判断当前用户是谁了。\nswoole_server中对象的4层生命周期\n\n以下内容摘自swoole文档\n开发swoole程序与普通LAMP下编程有本质区别。在传统的Web编程中，PHP程序员只需要关注request到达，request结束即可。而在swoole程序中程序员可以操控更大范围，变量/对象可以有四种生存周期。\n\n变量、对象、资源、require/include的文件等下面统称为对象\n\n程序全局期\n在swoole_server-&gt;start之前就创建好的对象，我们称之为程序全局生命周期。这些变量在程序启动后就会一直存在，直到整个程序结束运行才会销毁。\n有一些服务器程序可能会连续运行数月甚至数年才会关闭/重启，那么程序全局期的对象在这段时间持续驻留在内存中的。程序全局对象所占用的内存是Worker进程间共享的，不会额外占用内存。\n这部分内存会在写时分离（COW），在Worker进程内对这些对象进行写操作时，会自动从共享内存中分离，变为进程全局对象。\n\n程序全局期include/require的代码，必须在整个程序shutdown时才会释放，reload无效\n\n进程全局期\nswoole拥有进程生命周期控制的机制，一个Worker子进程处理的请求数超过max_request配置后，就会自动销毁。Worker进程启动后创建的对象（onWorkerStart中创建的对象），在这个子进程存活周期之内，是常驻内存的。onConnect/onReceive/onClose 中都可以去访问它。\n\n进程全局对象所占用的内存是在当前子进程内存堆的，并非共享内存。对此对象的修改仅在当前Worker进程中有效\n进程期include/require的文件，在reload后就会重新加载  \n\n会话期\nonConnect到onClose是一次TCP的会话周期，http keep-alive时，一个连接可能会有多个request。\nhttp是无状态的，一个用户可能也不止一个连接，可以通过创建一个session来关联同一个用户的不同请求。\n请求期\n请求期就是指一个完整的请求发来，也就是onReceive收到请求开始处理，直到返回结果发送response。这个周期所创建的对象，会在请求完成后销毁。\nswoole中请求期对象与普通PHP程序中的对象就是一样的。请求到来时创建，请求结束后销毁。\n总结\n\n在Swoole中，一个work进程处理完请求后并不会销毁(甚至可能同时处理多个请求)，所以务必要明确你创建的变量的生命周期，以防止出现逻辑上的问题。","link":"/NoobCourse/Swoole/lifecycle.html"},{"id":42,"title":"composer使用","content":"Composer\nComposer 是 PHP5.3以上 的一个依赖管理工具。它允许你声明项目所依赖的代码库，它会在你的项目中为你安装他们。Composer 不是一个包管理器。是的，它涉及 &quot;packages&quot; 和 &quot;libraries&quot;，但它在每个项目的基础上进行管理，在你项目的某个目录中（例如 vendor）进行安装。默认情况下它不会在全局安装任何东西。因此，这仅仅是一个依赖管理。\n\n可以这么理解,composer是一个实现了自动加载的框架,它可以通过配置的声明,下载相应的依赖,代码库,并通过配置,使其能psr-4规范被正确的自动引入\n详细文档可查看composer文档:https://github.com/5-say/composer-doc-cn\n\ncomposer使用步骤\n\n安装composer\n创建composer项目,自动生成composer.json\n通过composer.json配置需要加载的代码库\n通过composer install下载代码库,依赖\n框架引入composer的autoload.php\n即可实现自动加载代码\n\n常用命令\ncomposer install;  #安装包,根据composer.json\ncomposer update;   #更新包,升级composer.json的所有代码库(如果能升级的话)\ncomposer search 关键字; #搜索包,搜索composer可用的包\ncomposer require 包名称; #引入包,会在composer.json新增一条包配置,并下载该代码包 \ncomposer remove 包名称; #删除包\ncomposer dump-autoload;#生成当前命名空间与类库文件路径的一个映射，运行时加载会直接读取这个映射，加快文件的加载速度。","link":"/NoobCourse/composer.html"},{"id":43,"title":"easyswoole","content":"EasySwoole\nEasySwoole 是一款基于Swoole Server 开发的常驻内存型的分布式PHP框架，专为API而生，摆脱传统PHP运行模式在进程唤起和文件加载上带来的性能损失。EasySwoole 高度封装了 Swoole Server 而依旧维持 Swoole Server 原有特性，支持同时混合监听HTTP、自定义TCP、UDP协议，让开发者以最低的学习成本和精力编写出多进程，可异步，高可用的应用服务。","link":"/NoobCourse/EasySwoole/introduction.html"},{"id":44,"title":"设计理念","content":"设计理念\n以下是作者原话:\n最早接触Swoole，是2015年年初，为实现一个可以实时控制的多进程爬虫而接触的Swoole，进而为Swoole的各种便捷、高效所着迷。   \n为此，做了综合技术评审之后，公司决定开始全线推展Swoole，并利用Swoole实现承载每天对外过亿的任务爬取与投递服务。2017年年初，在[Rango](http://rango.swoole.com/)的鼓励下,我决定将框架进行开源，并在Rango的建议下，命名为EasySwoole。\n目前为止,EasySwoole框架文档越来越完善,秉承着Easy学swoole,编写了这次的新手入门教程,让更多的phper能够更好,更快,更加容易的入门swoole,拥抱swoole的怀抱","link":"/NoobCourse/EasySwoole/designIdea.html"},{"id":45,"title":"组件说明","content":"组件设计\nEasySwoole3.x版本采用组件分离设计,可自行选择需要的组件进行添加使用,框架本身只实现了基础的封装,框架变的更加简洁,轻便\n组件列表\n目前EasySwoole3.x开源组件如下:\n\nvalidate 验证组件\nhttp   http组件,实现了对http控制器的调度封装等\nmysqli 协程版mysqli组件\nrpc    rpc组件,可实现rpc分布式\nsocket  socket组件,实现了对tcp/udp的控制器调度\ntrace   trace组件,代码追踪\ncomponent  基础组件库\nutility  工具类库\nverifyCode  验证码生成组件\nspl   spl组件\ncurl  curl组件\n","link":"/NoobCourse/EasySwoole/section.html"},{"id":46,"title":"运行过程","content":"EasySwoole运行步骤\nEasySwoole的框架运行步骤大概为以下几步:\n\n从php easyswoole start开始,首先进行了目录常量定义,临时目录,日志目录定义,\n触发initialize,这个事件你可以进行一些服务注册,修改临时目录,日志目录等\n获取框架配置,监听ip,端口,worker进程数,子服务配置,回调等,准备开启swoole服务\n触发mainServerCreate,这个事件你可以自行重新配置监听ip,端口,回调事件,框架异常,等等\n框架根据配置,启动swoole服务,附带子服务(如果有配置的话)\n\n到这个时候,框架已经是启动成功了,由于swoole_server的特性,开启之后会常驻内存(进程会一直运行,可以理解成一直在while(1){}),等待请求进入然后回调.\n用户请求步骤:\n\n用户请求\nswoole_server触发回调事件,经过框架解析\n触发 onRequest(http服务时),onReceive(tcp服务时)\n经过http组件的调度,调用控制器方法完毕\n触发 afterRequest 事件,表明这次请求已经要结束\nes将响应数据交回给swoole_server,给客户端响应数据\n","link":"/NoobCourse/EasySwoole/runSteps.html"},{"id":47,"title":"demo","content":"Demo\n目前EasySwoole文档相当完善,并且每个功能点都有代码示例,可通过下载demo,与文档对比学习EasySwoole框架:\nhttps://github.com/easy-swoole/demo","link":"/NoobCourse/EasySwoole/demo.html"},{"id":48,"title":"提问的艺术","content":"提问的艺术\n在开发过程当中,难免会遇到一些问题,而提问是最不费脑并且可能是最快的一种方式,但是,你的问题不一定会被人家所理解,但是你应该学会怎么提问\n提问之前\n在提问之前,首先要确保以下几个点:\n\n有做好可能解决不了的心理准备\n或许应该准备好付费的情况\n确定这个问题是因为实现什么而出现的,是否可以换种实现方式\n有认真思考过该问题的解决方案\n有尝试过搜索该问题的解决方案\n确定 开发手册/文档中 没有该问题的解决方案\n确定你有该问题的基础知识\n有做一系列的排查,并将问题确定在一个范围内\n\n解决不了\n当你的问题难度太大时,可能没有人能回答你的问题,你得做好解决不了的准备,解决不了请不要恼羞成怒,做出一些不理智的事情,或许可以尝试下付费解决,也或许可以换一种解决的方式(放弃问题的源头,用另一种方式实现你的逻辑)\n认真思考问题的解决方案\n当问题特别明显,只要有动脑就能解决这个问题时,没有人会喜欢回答这种基础问题,\n例如:\n当你知道echo &quot;hello world&quot;语句,却不知道怎么输出&quot;EasySwoole天下第一&quot;时\n当你知道如何移动文件到/tmp目录,却不知道移动到指定日期的目录时\n当你知道mysql有解释器可以查看是否有使用到索引,却不知道如何看组合索引是否有效时\n当报错信息出现的情况,却不知道去搜索时\n搜索问题的解决方案\n同样,当一个问题直接搜索就能出现答案,却一直拿出来问时,没有人会给伸嘴党喂饭,这是对回答者的一种侮辱\n请在提问的时候,先尝试在搜索引擎中搜索,或许答案就在第一页\n开发手册\n当你在搜索引擎没有找到一些 生僻/不知名/不公开 的一些问题时,或许你得考虑下是否有一份文档还没有看完\n既然搜索引擎都找不到的问题,那你问对该项目毫不知情的人有什么用呢?\n既然有开发文档,那你为什么不尝试下在开发文档中发现这个问题的解决方案呢?\n问题的基础\n千万不要问你对该问题一无所知的问题,当你没学过php时,请不要问为什么if(){}括号里不加条件就会报错的问题\n当你提出一个问题的,该问题相应的基础你应该要会,否则你会被人耻笑.\n例如:\n当你没看完新手教程,问swoole为什么运行之后改代码要重启\n当你没看完面对对象,问为什么不use命名空间就会报错\n当你连接websocket时,问为什么会发起一个http请求  \n排查问题\n在提问之前,首先你得学会排查这个问题,确定问题的一个大致范围.否则会让人无从回答.\n例如:\n当你上传文件这个逻辑出现问题时,你问:&quot;为什么我没法上传文件&quot;,是没有人能回答的了你的,你得自行排查,直到一个小范围.\n例如:  \n\n上传文件,选择文件之后,发生错误.  \n选择文件成功,发起http请求时出错.  \n发起http请求成功,到后端接收不到文件信息.  \n接收文件信息成功,无法保存上传文件.\n将一个大问题分解成一个个步骤,自行测试每个步骤.直到某个步骤出错(如果每个步骤都有错,那就一个个步骤慢慢解决)\n\n提问  (首先确保你看完了上面的 提问之前 小节)\n在提问时,我们应该避免以下几种问法:\n\n在吗?\n大神救我\n你好\n大佬求带\n有没有人用过xxx(说一个框架,或者一个不知名的项目)\n大神这个是怎么做的(直接要代码)\n可以问个问题吗?(不说问题,等别人回答可不可以)\n这个代码有什么错?(发出一串代码,不说问题)\n这个代码怎么改?(发出一串代码,不说怎么改,不说问题)\n为什么我这个有问题?(截图一段&quot;xxxxx&quot;自行判断输出的错误信息不截图代码)\n能不能咨询一下(某种语言,某种框架,某种项目 一个大范围的概念)\n\n当然,没有人会跟钱过不去,只要给钱,可无视一切\n\n\n\n正确的提问包含以下几点:  \n\n描述准确,准确描述你要实现的功能,问题出现之前以及出现之后的现象\n截图准确,不要截一些和问题无关,或者对解决问题没有任何帮助的图\n态度端正,虚心请教,没有人有义务帮你.\n\n问题可分为以下几种:\n\n概念问题,某种抽象概念的不理解\n代码问题,代码出现非预期的情况,报错等\n框架问题,出现框架报错,运行出错,运行逻辑不理解等问题\n逻辑问题,对某种功能实现的逻辑不理解\n性能优化问题\n\n每种问题的提问方式如下:\n概念问题\n概念问题,我们必须要描述准确,并且有自行了解过概念的基础,例如:\n\n我不太清楚为什么要用面对对象,直接函数封装不行吗?\n为什么协程要是用mysql连接池\n等\n\n代码问题\n代码问题,我们需要截图代码,以及报错信息,并且说明自己要实现什么功能,例如:\n\n我想要实现文件上传,我已经尝试了修改权限,但是不知道为什么代码会报错(附上错误信息,以及代码)\n等\n\n框架问题\n框架问题,我们需要详细的说明框架的哪个部分,以及发生了什么问题,例如:\n\n使用EasySwoole时,发现在生产模式下,调用配置文件错误\n使用tp3.2时,上传文件总是报文件夹不存在,但是文件夹存在\n使用tp3.2时,session生存时间无法配置\n\n逻辑问题\n逻辑问题,我们需要详细描述某个功能的哪部分逻辑,例如:\n\n请问session过期是怎么实现的?\n请问mysql连接池是怎么实现的?\n\n性能优化问题\n性能优化问题,需要先确认慢的地方,然后截图,例如:\n\n我发现这段代码执行特别慢,有什么错误吗?(附上代码截图)\n这段sql我想实现xxxxx查询,但是非常慢,能优化吗?(附上sql语句,表结构,解释器截图)\n\n\n可查看https://github.com/tioncico/How-To-Ask-Questions-The-Smart-Way\n","link":"/NoobCourse/artOfAskingQuestions.html"},{"id":49,"title":"框架更新记录","content":"框架更新记录\n\n框架更新记录仅仅整理自2020年10-24后的记录，其余记录以老版本文档或github记录为准。\n\n3.4.6 - 2021-06-13\n修复\n\n修复定时任务在极端情况下多次执行的问题\n\n3.4.5 - 2021-04-26\n修复\n\n修复 trigger 不记录日志问题\n\n变更\n\n移除框架主库 phpunit/phpunit 组件，改为 easyswoole/phpunit 组件。\n\n3.4.4 - 2021-03-08\n优化\n\n优化完善默认的日志处理机制，详细请看 配置文件 章节\n\n集成 http-annotatiaon 2.x 的注解文档生成命令，用户可以方便地使用命令生成 api 文档\n\n3.4.3 - 2021-02-23\n新增\n\n新增 EASYSWOOLE_RUNNING 常量 \n\n优化\n\n调整依赖的 http-annotation 注解组件 为 2.x\n\n优化对日志等级(level)的设置，详细请看 配置文件 章节\n\n优化用户可在配置文件中配置日志处理器，详细请看 日志 章节\n\n优化调整Crontab定时任务组件状态显示、执行.\n\n移除\n\n废弃 SysConst::EXECUTE_COMMAND 常量\n\n3.4.2 - 2020-12-22\n优化\n\n\ntask优化,更加灵活的配置.\n\ncrontab优化,避免极端情况下任务不执行.\n\nhttp-dispatcher优化,更加灵活的注册路由.\n\n3.4.1 - 2020-11-18\n新增\n\n增加SysConst::EXECUTE_COMMAND,此常量可获取主框架内部所执行的command.\n\ninstall命令函数检查symlink和readlink。\n\n修复\n\n修复worker异常退出，没有清理table信息。\n\n移除\n\n移除 command及 bridge 中动态配置 config 的功能，因为 3.4.x 的配置的存储不是使用 swoole-table 来存储。\n\n3.4.0 - 2020-10-24\n与3.3.x不兼容，需进行调整.\n3.3.x -&gt; 3.4.x需要重新执行php vendor/bin/easyswoole install.\n新增\n\n\nCore::getInstance()-&gt;runMode();方法. 可通过此方法修改运行文件,默认dev,也可以通过command进行修改.\n\n变更\n\n\ncommand命令变更.\n\n\n自定义command需进行调整.\n\n\nconfig从swoole-table改为splArray,用户可自行调整.\n\n\nonRequest及afterRequest全局事件\n变更为(initialize注册即可):\n\\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::HTTP_GLOBAL_ON_REQUEST, callback);\n\\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::HTTP_GLOBAL_AFTER_REQUEST, callback);\ncallback为回调函数,注入参数为：\nfunction (\\EasySwoole\\Http\\Request $request, \\EasySwoole\\Http\\Response $response){}\nonRequest事件需要返回bool,来决定程序是否继续进行dispatcher.\n\n\n移除\n\n\n移除EasySwooleEvent中onRequest及afterRequest全局事件.\n\n\n移除Core::getInstance()-&gt;isDev();方法.\n\n\n移除Core::getInstance()-&gt;globalInitialize();,可自行调用EasySwooleEvent::initialize().\n\n","link":"/Update/main.html"},{"id":50,"title":"组件更新记录","content":"组件更新记录\n\n框架更新记录仅仅整理自2020年10-24后的记录，其余记录以老版本文档或github记录为准。\n\nJWT\n1.2.0 - 2021-07-05\n新增\n\n新增对 Json Web Token 的前缀设置支持\n\n修复\n\n修复不能使用 RS256 签名算法生成 Json Web Token 的问题\n\nHttp-Annotation\n2.2.0 - 2021-07-01\n新增\n\n\nParam 参数注解增加支持对中文字符串长度的相关验证（mbLength、mbLengthMax、mbLengthMin、betweenMbLen）（validate 2.1.0）\n\nApi 注解增加支持对路由设置路由前缀（prefix）及忽略路由前缀 （ignorePrefix）配置项\n\nValidate\n2.1.0 - 2021-07-01\n新增\n\n新增 mbLength、mbLengthMax、mbLengthMin、betweenMbLen 等验证规则，支持对中文字符串长度相关的单独验证\n\n废弃\n\n取消原有 length 对中文字符串长度的验证\n\nHttp\n2.0.3 - 2021-06-26\n修复\n\n修复由于 PHP 8 的 libxml_disable_entity_loader 函数废弃导致 PHP 8 下的 xml 请求参数无法接收的兼容问题\n\nPay\n1.2.20 - 2021-06-25\n修复\n\n修复微信支付组件中由于 PHP 8 的 libxml_disable_entity_loader 函数废弃导致 PHP 8 的不兼容问题\n修复微信支付组件的扫码支付 notify_url 参数导致无法支付的问题\n\nWechat\n2.0 - 2021-05-25\n新增\n\n发布 WeChat 2.0 正式版本，全新的基于协程实现的微信组件，告别同步阻塞。\n支持企业微信 SDK相关 API\n\nphpunit\n1.1.0 - 2021-04-12\n优化\n\n允许捕获 phpunit exit code\n\n优化适配 command 命令库，适配集成到框架基础管理命令\n优化适配非协程环境\n\nWechat\n1.2.4 - 2021-02-26\n新增\n\n获取小程序scheme码.\n\nHttp-client\n1.5.0 - 2021-02-23\n变更\n\n废弃驱动层.\n\nQueue\n3.0.1 - 2021-02-23\n新增\n\n任务消费onException支持.\n\n3.0.0 - 2021-02-22\nQueue3.x版本发布.\n\n支持常规任务\n支持延迟任务\n支持可信任务\n\nJwt\n1.1.4 - 2021-02-23\n新增\n\n新增支持RS256.\n\n修复\n\n\ncomposer.json 没有引入必要的依赖.\n\n优化\n\n优化verify signature方式，以便支持pub key verify.\n\nLog\n1.1.1 - 2021-03-01\n\n解决阿里云镜像未同步问题.\n\n1.1.0 - 2021-02-02\n新增\n\n常量LOG_LEVEL_DEBUG\n\n\nValidate\n1.2.8 - 2021-01-27\n新增\n\n\nlessThanWithColumn 验证字段的值必须小于with的字段(仅限int)\n\ngreaterThanWithColumn 验证字段的值必须大于with的字段(仅限int)\n\nMysqli\n2.2.8 - 2021-01-27\n新增\n\n支持mysql8.0+锁.\n\n修复\n\n修复拼接sql,+86等字符串被转为86.\n\n错误视图(Whoops)\n3.1.0 - 2021-01-20\n修复\n\n修复错误视图不兼容 template 1.1.0 组件接口，对 Whoops 组件依赖约束版本\n\n辅助类组件(IntStr)\n1.2.2 - 2021-01-08\n新增\n\n新增 IntStr 工具类，实现 字符串 和 数字 的相互转换，可用于 生成短链接，详见 IntStr 工具类\n\n\nPool\n1.0.12 - 2021-01-07\n优化\n\n优化 pool 组件的负载阀值，在并发峰值非持续性情况下，对池内连接进行负载，自动调控池内连接，让 pool 组件并发处理能力更强，详见 pool组件 loadAverageTime参数\n\n\nSnowFlake(雪花算法)\n1.2.0 - 2021-01-05\n优化\n\n缩短数据中心位至 5 bit: 0 ~ 31\n\n增长进程编号位至 7 bit: 0 ~ 127\n\n同毫秒序号为 11 bit: 0 ~ 2047\n\n理论上，当使用一秒一个数据中心，128 进程时，可以允许产生 1 * 128 * 1000 * 2047 = 26201600 个唯一 ID\n\n\nOrm\n1.4.33 - 2021-03-01\n\n\n新增replace into操作.\n\n1.4.32 - 2021-01-12\n修复\n\n修复where方法传入php内置函数关键字,is_callable为true.\n\n1.4.31 - 2020-12-22\n新增\n\n\nduplicate key支持.\n\ncollection增加toRawArray.\n\nwhere方法支持闭包函数.\n\n变更\n\n\ngetClientPool()方法调整为__getClientPool().\n\nupdate取消预算inc dec,直接为field = filed + 1.\n\n修复\n\n修复字段预定义属性不生效.\n屏蔽KeepMin异常导致进程退出.\n修复循环执行事务不生效问题.\n\n1.4.30 - 2020-11-2\n新增\n\n\nEasySwoole\\ORM\\Exception增加lastQueryResult.\n\n1.4.29 - 2020-10-29\n修复\n\n修复with关联调用setter问题.\n\nRedis-Pool\n2.2.1 - 2020-12-29\n2.1.x -&gt; 2.2.x不兼容,谨慎更新.\n变更\n\n\nclass名字进行合理化修改.\n\nclass参数顺序调整,调用更加合理化.\n调整invoke使用.\n\nRedis\n1.3.8 - 2021-02-27\n调整\n\n调整组件内部命名不规范问题.\n\n1.3.7 - 2020-12-24\n修复\n\n\nredis-cluster中,单个节点存在多个slot区间,无法识别问题.\n\n1.3.6 - 2020-12-14\n新增\n\nBZPopMax\nBZPopMin\nZPopMax\nZPopMin\n\n优化\n\nSPop\n\nHttp-Annotation\n1.5.0 - 2021-01-27\n新增\n\n\nParam注解增加lessThanWithColumn验证(validate 1.2.8+)\n\nParam注解增加greaterThanWithColumn验证(validate 1.2.8+)\n\n1.4.6 - 2021-01-05\n优化\n\n优化scanner非php文件.\n\n1.4.5 - 2021-01-02\n新增\n\n\nInject注解,支持注入class且参数传入.\n\n1.4.4 - 2020-12-23\n修复\n\n修复生成注解文档左侧栏标题错误问题.\n\nRpc\n5.0.3 - 2020-12-23\n增加\n\n可设置client中success及fail回调.\n可设置client调用参数.\n\nreqeuest及response中uuid\n\n\nresponse中status2msg.\n\n优化\n\n带权获取节点.\n\n5.0.1 - 2020-12-18\n修复\n\n局域网内udp-broadcast问题.\n\n5.0.0 - 2020-12-17\nrpc组件5.x版本发布.\n\n完善的节点管理机制.\n无主化服务发现.\n允许节点主动上下线.\n调用流程改为Service-Module-Action模式.\n开放全局onRequest.\n优化数据包结构,缩减通讯宽带.\n\nTemplate\n1.1.0 - 2020-12-29\n1.0.x -&gt; 1.1.x不兼容.\n\n数据包结构变更\n\ninterface变更.\n","link":"/Update/component.html"},{"id":51,"title":"文档贡献","content":"文档编写规范事项\n文档风格\n为了保障EasySwoole文档的风格基本统一，方便使用者阅读，请使用下面提供的示例风格编写文档内容。\n多版本\n每个章节文档默认显示最新版本对应的文档。如果组件错在多个版本，或者需要特殊说明。则请在对应章节文档开头处写上对应的版本连接。\n效果如：说明2或者如说明2\n风格1：\n[说明2](/Update/doc2.md)\n风格2：\n&lt;layerOpen href=\"/Update/doc2.md\"&gt;说明2&lt;/layerOpen&gt;\n层级风格\nEasySwoole 文档采用三级目录风格，语言-&gt;模块-&gt;章节 的形式进行组织内容，如某内容并不具体属于某模块，可以省略，具体组织方式如下：\n└── 语言\n    ├── 模块-1\n    │   └── 章节.md\n    ├── 模块-2\n    └── 章节.md\n分层原则\n\n\n语言 毫无争议，目前仅支持zh-cn和en\n\n\n模块 通常为相似功能的集合，或某个较为复杂的组件，新增一个模块应当谨慎\n\n章节 应当强调阅读顺序，从上到下渐进，非模块的章节可以长一些，相反模块的章节不应当过长\n\n关键词风格\n文档系统会对 .md 格式的特定语法进行美化，为了方便大家统一风格，请使用以下语法进行关键词修饰。\n希望用户在终端执行命令\n如果希望用户在终端执行某命令，可以使用 引用 语法。\n&gt; composer require easyswoole/easyswoole=3.4.x\n效果如下：\n\ncomposer require easyswoole/easyswoole=3.4.x\n\n如果希望用户在特定的地方执行命令，最好使用 重点 注释说明\n*请在终端执行以下命令*\n&gt; composer require easyswoole/easyswoole=3.4.x\n效果如下：\n请在终端执行以下命令\n\ncomposer require easyswoole/easyswoole=3.4.x\n\n高亮关键名词\n如果希望在描述中高亮某些名词，可以使用 反引号 进行修饰\n强大的 `TCP/UDP Server` 框架，`多线程`，`EventLoop`，`事件驱动`，`异步`，`Worker进程组`，`Task异步任务`，`毫秒定时器`，`SSL/TLS隧道加密`\n效果如下：\n强大的 TCP/UDP Server 框架，多线程，EventLoop，事件驱动，异步，Worker进程组，Task异步任务，毫秒定时器，SSL/TLS隧道加密\n描述函数或者 function\n\n描述函数和 function 必须简述其作用和输入输出参数，使用 代码块 指令最方便\n```php\nDbManager::getInstance()-&gt;invoke(callable function(MysqlClient $client));\n希望用户注意或警告用户\n如果希望提醒用户或者警告用户，可以使用扩展语法[^非md语法] tip warning 进行描述\n::: tip\n旧版本的invoke没有return值，请更新orm版本。\n:::\n\n::: warning  \n    注意EasySwoole的Temp目录不在虚拟机与宿主机共享目录下，否则会导致没有权限创建UnixSocket链接\n:::\n效果如下：\n旧版本的invoke没有return值，请更新orm版本。\n注意EasySwoole的Temp目录不在虚拟机与宿主机共享目录下，否则会导致没有权限创建UnixSocket链接\n章节案例\n组件库基本结构\n组件库的章节主要围绕如何让用户快速上手组件，和如果遇到问题如何解决构成的；优秀的文档应该是站在用户的角度进行编写的，提供可运行的代码片段非常重要。\n# 组件名称\n\n在章节开头描述组件的作用和用途，以及依赖的其他组件或者注意事项；以及组件主要是用来做什么的。\n\n## 组件要求\n\n最好在这里说明组件要求，防止用户在安装时遭遇失败。\n\n- php &gt;= 7.1\n- swoole &gt;= 4.4\n\n## 安装方法\n\n&gt; composer require 组件名称\n\n## 仓库地址\n\n在这里给出GitHub的仓库地址 使用[仓库名称](https://github.com/easy-swoole) 来创建一个超链接\n\n## 基本使用\n\n在这里描述组件的常用方法，以及用来做什么，具体怎么使用；给出代码。\n\n## 进阶使用\n\n在这里描述组件的进阶使用方法，比如可以用作其他相关业务，给出示例。\n\n## 相关仓库\n\n在这里给出组件的demo仓库，或基于此组件的开源项目。\n非组件库案例\n非组件案例一般是指常用的核心功能，或者是某个经典案例示例。\n# 功能名称\n\n## 功能介绍\n\n在这里介绍功能的主要用途，和通常适用于什么场景。\n\n## 相关Class位置\n\n在这里给出Class的Github地址，或是完整的`namespace`\n\n- HttpController\n    - [GitHub](https://github.com/easy-swoole/http/blob/master/src/AbstractInterface/Controller.php)\n    - `namespace`: `EasySwoole\\Http\\AbstractInterface`\n\n## 核心方法\n\n在这里给出核心或常用方法的原型；\n\n## 注意事项\n\n在这里给出常见的注意事项\n\n版本痕迹\n如果某个方法是特定版本增加，应当使用 重点 或 tip 语法进行描述。\n*3.3.4新增*\n\n::: tip\n3.3.4新增\n:::\n效果如下：\n3.3.4新增\n3.3.4新增","link":"/Update/doc.html"},{"id":52,"title":"环境要求","content":"环境要求\n满足基本的环境要求才能运行框架，EasySwoole 框架对环境的要求十分简单，只需要满足运行 Swoole 扩展的条件，并且 PHP 版本在 7.3 以上即可\n\n\nGitHub  喜欢记得点个 star\n\n\nGithub for Doc 文档贡献\n\n基础运行环境\n\n保证 PHP 版本大于等于 7.3\n\n保证 Swoole 拓展版本大于等于 4.4.23\n\n需要 pcntl 拓展的任意版本\n使用 Linux / FreeBSD / MacOS 这三类操作系统\n使用 Composer 作为依赖管理工具\n\n参考下面的建议，它们都不是必须的，但是有助于更高效的使用框架和进行开发\n\n使用 Ubuntu14 / CentOS 7.0 或更高版本操作系统\n\n其他\n\n\nQQ 交流群\n\nVIP群 579434607 （本群需要付费599元）\nEasySwoole 官方一群 633921431(已满)\nEasySwoole 官方二群 709134628(已满)\nEasySwoole 官方三群 932625047(已满)\nEasySwoole 官方四群 779897753(已满)\nEasySwoole 官方五群 853946743 \n\n\n\n商业支持：\n\nQQ 291323003\nEMAIL admin@fosuss.com\n\n\n\n作者微信\n\n\n\n捐赠 您的捐赠是对 EasySwoole 项目开发组最大的鼓励和支持。我们会坚持开发维护下去。 您的捐赠将被用于：\n\n持续和深入地开发\n文档和社区的建设和维护\n\n\n\nEasySwoole 的文档使用 EasySwoole 框架 提供服务，采用 MarkDown 格式 和自定义格式编写，若您在使用过程中，发现文档有需要纠正 / 补充的地方，请 fork 项目的文档仓库，进行修改补充，提交 Pull Request 并联系我们。\n\n","link":"/QuickStart/environment.html"},{"id":53,"title":"安装 swoole","content":"安装 Swoole\n下载\n首先进入 Swoole 的 Github 下载地址: https://github.com/swoole/swoole-src/releases\n如果没有特殊需求，请选择最新稳定版本开始下载(我这里是稳定版v4.4.23):   \n## 下载\ntioncico@tioncico-PC:/tmp$ wget https://github.com/swoole/swoole-src/archive/v4.4.23.tar.gz\n# 如果使用 github 下载慢，请到 pecl 进行下载 \n# tioncico@tioncico-PC:/tmp$ wget https://pecl.php.net/get/swoole-4.4.23.tgz \n\n## 解压到当前目录\ntioncico@tioncico-PC:/tmp$ tar -zvxf v4.4.23.tar.gz\n\n## cd 到解压之后的目录\ntioncico@tioncico-PC:/tmp$ cd swoole-src-4.4.23/ \n\n## 使用 phpize 创建 php 编译检测脚本 ./configure\n##【注意：需要选择 php 对应版本的 phpize，这里使用的是绝对路径，否则编译安装无法生效】\ntioncico@tioncico-PC:/tmp/swoole-src-4.4.23$ /usr/local/php-7.2.2/bin/phpize\n\n## 创建编译文件，第一个 --with，后面是 php-config 的所在路径(这个路径一般和 php 在同一个目录) /usr/local/php-7.2.2/bin/php-config，第二个 --enable，是开启 Swoole 的 ssl 功能，第三个 --enable(可选参数)，是开启 Swoole 支持 http2 相关的功能\ntioncico@tioncico-PC:/tmp/swoole-src-4.4.23$ ./configure --with-php-config=/usr/local/php-7.2.2/bin/php-config --enable-openssl --enable-http2\n\n## 编译 Swoole 并把编译好的文件移动到 php 的扩展目录(前面的配置 php 版本的扩展目录) 需要root权限\ntioncico@tioncico-PC:/tmp/swoole-src-4.4.23$ sudo make &amp;&amp; make install \n\n## 编译成功会显示如下：\nBuild complete.\nDon't forget to run 'make test'.\n\nInstalling shared extensions:     /usr/local/php-7.2.2/lib/php/extensions/no-debug-non-zts-20160303/\nInstalling header files:          /usr/local/php-7.2.2/include/php/\n\n这个时候已经安装成功，需要修改 php 配置文件 php.ini，在最后面增加如下内容:\nextension=swoole.so\n注意：不知道 php.ini 所在目录时，您可以通过运行 php --ini 确定。\n例如，我这里 php.ini 是在 /usr/local/php-7.2.2/etc 目录：\ntioncico@tioncico-PC:/tmp/swoole-src-4.4.23$ php --ini\nConfiguration File (php.ini) Path: /usr/local/php-7.2.2/etc\nLoaded Configuration File:         /usr/local/php-7.2.2/etc/php.ini\nScan for additional .ini files in: (none)\nAdditional .ini files parsed:      (none)\n成功安装 Swoole 之后，通过 php --ri swoole 查看 Swoole 扩展 的信息:\ntioncico@tioncico-PC:/tmp/swoole-src-4.4.23$ php --ri swoole\n\nswoole\n\nSwoole =&gt; enabled\nAuthor =&gt; Swoole Team &lt;team@swoole.com&gt;\nVersion =&gt; 4.4.23\nBuilt =&gt; Jan 23 2021 18:16:30\ncoroutine =&gt; enabled\nepoll =&gt; enabled\neventfd =&gt; enabled\nsignalfd =&gt; enabled\ncpu_affinity =&gt; enabled\nspinlock =&gt; enabled\nrwlock =&gt; enabled\nopenssl =&gt; OpenSSL 1.0.2k-fips  26 Jan 2017\nhttp2 =&gt; enabled\npcre =&gt; enabled\nzlib =&gt; 1.2.7\nmutex_timedlock =&gt; enabled\npthread_barrier =&gt; enabled\nfutex =&gt; enabled\nasync_redis =&gt; enabled\n\nDirective =&gt; Local Value =&gt; Master Value\nswoole.enable_coroutine =&gt; On =&gt; On\nswoole.enable_library =&gt; On =&gt; On\nswoole.enable_preemptive_scheduler =&gt; Off =&gt; Off\nswoole.display_errors =&gt; On =&gt; On\nswoole.use_shortname =&gt; On =&gt; On\nswoole.unixsock_buffer_size =&gt; 8388608 =&gt; 8388608\n到此，Swoole 扩展就安装完毕。\n常见问题\nphpize 命令不存在\n安装 phpize\nyum install php-devel ## centos\nsudo apt-get install php-dev  ## ubuntu\n提示 swoole.so.so 类似的报错\n说明你的 phpize 版本和 php-config 设定的版本不一致，请重新编译\nphpize 命令也可以使用绝对路径: php安装路径/bin/phpize 用于执行创建编译文件。\n在之后的 --with-php-config 也得使用同样的路径: php安装路径/bin/php-config\n安装成功 php --ri 没有 Swoole 扩展信息\n说明你的 php 命令行版本，和安装 Swoole 的 php 版本不一致，可以通过: php安装路径/bin/php --ri swoole 进行确认是否安装成功","link":"/QuickStart/installSwoole.html"},{"id":54,"title":"框架安装","content":"框架安装\n\n\nGitHub  喜欢记得给我们点个 star\n\n\nGithub for Doc 文档贡献\n\n注意事项，请看完再进行安装\n\n框架使用 Composer 作为依赖管理工具，在开始安装框架前，请确保已经按上一章节的要求配置好环境并安装好了 Composer 工具\n关于 Composer 的安装可以参照 Composer中国全量镜像 的安装教程\n目前推荐的镜像为阿里云或者梯子拉取源站\n在安装过程中，会提示用户选择是否释放框架的 Index.php、Router.php 文件到项目目录(默认不会释放，也不会生成 App 目录)，请保证项目目录有可写入权限\n安装完成之后，如果没有自动生成 App 目录，请自行根据 Hello World 章节 章节进行配置\n部分机器(例如 Docker 环境)在使用框架时遇到类似 DNS Lookup resolve failed... 错误，请更换机器的 DNS 为阿里云公共 DNS 223.5.5.5 和 223.6.6.6。具体更换步骤可查看 更换 DNS\n\n\n框架更新说明(安装之前必看)\n\n更新说明\n\n很多同学，在使用 Swoole 4.6.x 扩展时，在使用 EasySwoole 进行开发时（一般是在使用到 Swoole 协程时），遇到了类似如下错误：\\[FATAL ERROR\\]: all coroutines (count: 1) are asleep - deadlock!，这个错误属于 Swoole 4.6.x 扩展的 debug 信息，详细可查看 协程配置，如果不想看到这个信息，可在 bootstrap 事件（即项目根目录的 bootstrap.php 文件）中最开始的位置，对协程的使用进行配置。配置示例代码如下：\n&lt;?php\ndate_default_timezone_set('Asia/Shanghai');\n// 关闭死锁检测相关堆栈信息输出到日志\n\\Swoole\\Coroutine::set(['enable_deadlock_check' =&gt; false]);\n切换 Composer 镜像\n# 由于最近阿里云composer镜像不稳定，暂时废弃使用，请使用其他稳定的镜像\n# composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/\n\n# 推荐暂时使用腾讯云镜像（如果使用此镜像还是不行请自行更换其他源下载）\ncomposer config -g repo.packagist composer https://mirrors.cloud.tencent.com/composer/\n删除镜像\ncomposer config -g --unset repos.packagist\nComposer 安装\n按下面的步骤进行手动安装\ncomposer require easyswoole/easyswoole=3.4.x\nphp vendor/easyswoole/easyswoole/bin/easyswoole install\n或者\ncomposer require easyswoole/easyswoole=3.4.x\nphp vendor/bin/easyswoole install\n如果执行成功，则会有如下界面:\n首次安装，会提示您是否选择释放(release) Index.php、Router.php 和 App 目录到项目目录\nphp vendor/easyswoole/easyswoole/bin/easyswoole install\n ______                          _____                              _        \n|  ____|                        / ____|                            | |       \n| |__      __ _   ___   _   _  | (___   __      __   ___     ___   | |   ___ \n|  __|    / _` | / __| | | | |  \\___ \\  \\ \\ /\\ / /  / _ \\   / _ \\  | |  / _ \\\n| |____  | (_| | \\__ \\ | |_| |  ____) |  \\ V  V /  | (_) | | (_) | | | |  __/\n|______|  \\__,_| |___/  \\__, | |_____/    \\_/\\_/    \\___/   \\___/  |_|  \\___|\n                         __/ |                                                \n                        |___/\ndo you want to release Index.php? [ Y / N (default) ] : Y\ndo you want to release Router.php? [ Y / N (default) ] : Y\ninstall success,enjoy!!!\ndont forget run composer dump-autoload !!!\n\n注意，上述输入了 Y 、 Y，表示选择了 release(释放) Index.php、Router.php 和 App 目录在项目根目录，默认 N 、 N 是不释放的，也不会自动生成 App 目录和 App 命名空间。\n\n新版安装注意事项\n\n新版的 EasySwoole 安装默认不会提供 App 命名空间，还有 Index 控制器\n重复安装时需要填写 N，不需要覆盖已经有的 EasySwooleEvent.php、index.php、dev.php、produce.php 等文件\n当提示 exec 函数被禁用时，请自己手动执行 composer dump-autoload 命令更新命名空间\n当提示 symlink 与 readlink 函数被禁用时，请自行修改 php.ini 配置文件取消这些函数的禁用\n\n重复安装时，会提示您是否选择 replace(覆盖) 如下文件 Index.php、Router.php、dev.php、produce.php、bootstrap.php、EasySwooleEvent.php，你可以根据需要选择是否覆盖(replace)，执行界面如下：\nphp vendor/easyswoole/easyswoole/bin/easyswoole install\n ______                          _____                              _        \n|  ____|                        / ____|                            | |       \n| |__      __ _   ___   _   _  | (___   __      __   ___     ___   | |   ___ \n|  __|    / _` | / __| | | | |  \\___ \\  \\ \\ /\\ / /  / _ \\   / _ \\  | |  / _ \\\n| |____  | (_| | \\__ \\ | |_| |  ____) |  \\ V  V /  | (_) | | (_) | | | |  __/\n|______|  \\__,_| |___/  \\__, | |_____/    \\_/\\_/    \\___/   \\___/  |_|  \\___|\n                         __/ |                                                \n                        |___/                                                \nIndex.php has already existed, do you want to replace it? [ Y / N (default) ] : N\nRouter.php has already existed, do you want to replace it? [ Y / N (default) ] : N\ndev.php has already existed, do you want to replace it? [ Y / N (default) ] : N\nproduce.php has already existed, do you want to replace it? [ Y / N (default) ] : N\nbootstrap.php has already existed, do you want to replace it? [ Y / N (default) ] : N\nEasySwooleEvent.php has already existed, do you want to replace it? [ Y / N (default) ] : N\ninstall success,enjoy!!!\ndont forget run composer dump-autoload !!!\n安装报错\n当执行安装脚本，出现类似以下错误时：\ndir=$(cd \"${0%[/\\\\]*}\" &gt; /dev/null; cd '../easyswoole/easyswoole/bin' &amp;&amp; pwd)\n\nif [ -d /proc/cygdrive ]; then\n    case $(which php) in\n        $(readlink -n /proc/cygdrive)/*)\n            # We are in Cygwin using Windows php, so the path must be translated\n            dir=$(cygpath -m \"$dir\");\n            ;;\n    esac\nfi\n\n\"${dir}/easyswoole\" \"$@\"\n请检查环境是否为宝塔等其他集成面板，或者是 php.ini 配置项中禁用了 symlink 与 readlink 函数，如果禁用了，请关闭这两个函数的禁用，并删除 vender 目录，然后重新执行 composer require 或者是 composer install 或者是 composer update。\n如果取消了函数禁用并且删除 vendor 目录，并重新执行 composer install 之后。依旧出现以上错误时，大概率是因为虚拟机等权限原因导致软链接失效。可使用 php vendor/easyswoole/easyswoole/bin/easyswoole 命令进行启动框架。或者直接修改项目根目录的 easyswoole 文件，引入 vendor/easyswoole/easyswoole/bin/easyswoole。\n安装 IDE 代码提示组件\n\ncomposer require easyswoole/swoole-ide-helper\n\n启动框架\n中途没有报错的话，执行：\n# 启动框架\nphp easyswoole server start\n此时可以访问 http://localhost:9501 就看到框架的欢迎页面，表示框架已经安装成功。\n可能的问题\n\n\nnot controller class match\n\n\ncomposer.json 注册 App 这个名称空间了吗？\n执行过 composer dump-autoload 了吗？\n存在 Index 控制器，但是文件大小写、路径都对了吗？\n\n\n\ntask socket listen fail\n\n注意，在部分环境下，例如 win10 的 docker 环境中，不可把虚拟机共享目录作为 EasySwoole 的 Temp 目录，否则会因为权限不足无法创建 socket，产生报错：listen xxxxxx.sock fail，为此可以手动在 dev.php 配置文件里把 Temp 目录改为其他路径即可，如：'/tmp'\n\n\n\n\n外网无法正常访问\n\n注意：用户如果外网无法正常访问时，请检查机器环境的防火墙/安全组是否开放 9501 或其他对应端口。详细解决方案请看 常见问题\n\n\n\n\n其他\n\n\nQQ 交流群\n\nVIP 群 579434607 （本群需要付费599元）\nEasySwoole 官方一群 633921431(已满)\nEasySwoole 官方二群 709134628(已满)\nEasySwoole 官方三群 932625047(已满)\nEasySwoole 官方四群 779897753(已满)\nEasySwoole 官方五群 853946743\n\n\n\n商业支持：\n\nQQ 291323003\nEMAIL admin@fosuss.com\n\n\n\n作者微信\n\n\n\n捐赠 您的捐赠是对 EasySwoole 项目开发组最大的鼓励和支持。我们会坚持开发维护下去。 您的捐赠将被用于：\n\n持续和深入地开发\n文档和社区的建设和维护\n\n\n\n\n        if(localStorage.getItem('isNew') != 1){\n            localStorage.setItem('isNew',1);\n            layer.confirm('是否给 EasySwoole 点个赞',{offset:'c'},function (index) {\n                 layer.msg('感谢您的支持',{offset:'c'});\n                     setTimeout(function () {\n                         window.open('https://github.com/easy-swoole/easyswoole');\n                  },1500);\n             });              \n        }\n","link":"/QuickStart/install.html"},{"id":55,"title":"helloworld","content":"Hello World\n目录检查\n我们在执行完框架的安装步骤后，可以在项目根目录下看到一个自动生成的 App 目录。目录结构如下：\n./App\n└── HttpController\n    ├── Index.php\n    └── Router.php\n如果缺少该目录，请返回 框架安装步骤，进行重新安装，然后选择愿意释放 App 目录到项目根目录。\n自动加载检查\n打开 composer.json 文件，检查是否有注册了 App 命名空间。\n注册成功 App 命名空间时 composer.json 文件结构大体如下：\n{\n    \"require\": {\n        \"easyswoole/easyswoole\": \"3.4.x\",\n    },\n    \"autoload\": {\n        \"psr-4\": {\n            \"App\\\\\": \"App/\"\n        }\n    }\n}\n在 composer.json 文件中，如果在 psr-4 处，缺少 App 命名空间的映射，那么请自行手动补充。\n更新自动加载\n执行如下命令用于更新命名空间：\ncomposer dump-autoload\n启动服务\n在项目根目录下执行如下命令以守护模式启动 easyswoole\nphp easyswoole server start -d\n在没有修改主服务端口的情况下，EasySwoole 默认的 HTTP 服务端口为 9501。我们可以 CURL 本地端口验证服务是否成功启动。\ncurl -I 127.0.0.1:9501\n\nHTTP/1.1 200 OK\nServer: EasySwoole\nContent-Type: text/html;charset=utf-8\nConnection: keep-alive\nDate: Sat, 18 Jul 2020 03:32:15 GMT\nContent-Length: 13143\n看到 200 状态码说明服务已经成功启动。\n注意：用户如果外网无法正常访问时，请检查机器环境的防火墙/安全组是否开放 9501 或其他对应端口。详细解决方案请看 常见问题\n停止服务\n在使用守护模式启动 EasySwoole 的时候，我们可以执行以下命令用于停止服务。\nphp easyswoole server stop\n若没用使用守护模式启动，则按键盘 Ctrl+C 键的时候，服务就会自动停止。若为远程终端，并且没有使用守护模式启动 EasySwoole，则在终端掉线的时候，会导致服务停止，甚至是服务成为僵尸进程，需要执行 killall 命令清除进程。","link":"/QuickStart/helloworld.html"},{"id":56,"title":"基础管理命令","content":"基本管理命令\n框架安装\n\nphp easyswoole install\n\n服务管理\n注意：以下命令只针对 EasySwoole 3.4.x 及以后版本，EasySwoole 3.4.x 之前版本管理命令请查看 旧版本管理命令 \nEasySwoole 框架主命令。\n可执行 php easyswoole server -h 来查看具体操作。\n服务启动\n\nphp easyswoole server start\n\n守护进程方式启动\n\nphp easyswoole server start -d\n\n指定配置文件启动服务\n默认为 dev，即 -mode 参数默认为 dev，即默认以项目根目录的 dev.php 作为框架运行的配置文件。\n指定以项目根目录的 produce.php 作为框架运行的配置文件，请运行如下命令：\n-d 可选参数：守护进程\n\nphp easyswoole server start -mode=produce\n\n停止服务\n\nphp easyswoole server stop\n\n强制停止服务\n\nphp easyswoole server stop -force\n\n热重启\n仅会重启 worker 进程\n\nphp easyswoole server reload\n\n重启服务\n-d 可选参数：守护进程\n\nphp easyswoole server restart\n\n服务状态\n\nphp easyswoole server status\n\n进程管理\nEasySwoole 内置对于 Process 的命令行操作，方便开发者友好地去管理 Process。\n可执行 php easyswoole process -h 来查看具体操作。\n显示所有进程\n\nphp easyswoole process show\n\n如果想要以 MB 形式显示：\n\nphp easyswoole process show -d\n\n杀死指定进程(PID)\n\nphp easyswoole process kill --pid=PID\n\n杀死指定进程组(GROUP)\n\nphp easyswoole process kill --group=GROUP_NAME\n\n杀死所有进程\n\nphp easyswoole process killAll\n\n强制杀死进程\n需要带上 -f 参数，例如：\n\nphp easyswoole process kill --pid=PID -f\n\nCrontab 管理\nEasySwoole 内置对于 Crontab 的命令行操作，方便开发者友好地去管理 Crontab。\n可执行 php easyswoole crontab -h 来查看具体操作。\n查看所有注册的 Crontab\n\nphp easyswoole crontab show\n\n停止指定的 Crontab\n\nphp easyswoole crontab stop --name=TASK_NAME\n\n恢复指定的 Crontab\n\nphp easyswoole crontab resume --name=TASK_NAME\n\n立即跑一次指定的 Crontab\n\nphp easyswoole crontab run --name=TASK_NAME\n\nTask 管理\n查看 Task 进程状态\n\nphp easyswoole task status\n\n单元测试\n注意：需要先使用命令 composer require easyswoole/phpunit 安装单元测试组件包，然后才可以执行如下命令。详细使用请看 单元测试 章节。\n协程方式执行单元测试\n单元测试用例存放在项目根目录的 tests 目录。\n\nphp easyswoole phpunit tests\n\n非协程方式执行单元测试\n单元测试用例存放在项目根目录的 tests 目录。\n\nphp easyswoole phpunit tests --no-coroutine\n\n生成 API 文档\n注意：此命令在 EasySwoole 3.4.4 及以上版本中才可用。\nEasySwoole 内置了针对 注解控制器 中的注解方法生成对应 API 接口文档的命令，方便开发者可以更加高效地提供 API 接口文档用于对接。关于 注解 如何使用，详细请看 注解 章节。\n可执行 php easyswoole doc -h 来查看具体操作。\n指定需要生成 API 文档的控制器目录\n\nphp easyswoole doc --dir=App/HttpController/\n\n指定生成 API 文档的额外说明\n\nphp easyswoole doc --extra=API_README.md\n\n指定需要生成 API 文档的控制器目录和文档额外说明\n\nphp easyswoole doc --extra=API_README.md --dir=App/HttpController/\n\n以上命令执行完成之后，开发者即可在项目根目录看到 easyDoc.html API 接口文档。","link":"/QuickStart/command.html"},{"id":57,"title":"开发者必读","content":"开发者必读\n\n\nGitHub  喜欢记得点个 star\n\n\n社区答疑\n\n\nQQ 交流群 \n\nVIP群 579434607 （本群需要付费599元）\nEasySwoole 官方一群 633921431(已满)\nEasySwoole 官方二群 709134628(已满)\nEasySwoole 官方三群 932625047(已满)\nEasySwoole 官方四群 779897753(已满)\nEasySwoole 官方五群 853946743\n\n\n\n商业支持：\n\nQQ 291323003\nEMAIL admin@fosuss.com\n\n\n\n注意事项\n\n不要在代码中执行 sleep 以及其他睡眠函数，这样会导致整个进程阻塞；协程中可以使用 Co::sleep()；\n\nexit/die 是危险的，会导致 Worker 进程退出；\n可通过 register_shutdown_function 来捕获致命错误，在进程异常退出时做一些清理工作；\n\nPHP 代码中如果有异常抛出，必须在回调函数中进行 try/catch 捕获异常，否则会导致工作进程退出；\n\nEasySwoole 不支持 set_exception_handler，必须使用 try/catch 方式处理异常；\n在控制器中不能写共享 Redis 或 MySQL 等网络服务客户端连接的逻辑，每次访问控制器都必须 new 一个连接\n\n类/函数重复定义\n\n新手非常容易犯这个错误，由于 EasySwoole 是常驻内存的，所以加载类/函数定义的文件后不会释放。因此引入类/函数的 php 文件时必须要使用 include_once 或 require_once，否则会发生 cannot redeclare function/class 的致命错误。\n\n建议使用 composer 做自动加载\n进程隔离与内存管理\n进程隔离也是很多新手经常遇到的问题。修改了全局变量的值，为什么不生效？原因就是全局变量在不同的进程，内存空间是隔离的，所以无效。\n所以使用 EasySwoole 开发 Server 程序需要了解 进程隔离 问题。\n\n\n不同的进程中 PHP 变量不是共享，即使是全局变量，在 A 进程内修改了它的值，在 B 进程内是无效的，如果需要在不同的Worker 进程内共享数据，可以用 Redis、MySQL、文件、Swoole\\Table、APCu、shmget 等工具实现 Worker 进程内共享数据\n\n\n不同进程的文件句柄是隔离的，所以在 A 进程创建的 Socket 连接或打开的文件，在 B 进程内是无效，即使是将它的 fd 发送到 B 进程也是不可用的。(句柄不能进程共享)\n\n\n进程克隆。在 Server 启动时，主进程会克隆当前进程状态，此后开始进程内数据相互独立，互不影响。有疑问的新手可以先弄懂PHP 的 pcntl 扩展\n\n\n\nEasySwoole 中对象的4层生命周期\n开发 Swoole 程序与普通 LAMP 下编程有本质区别。在传统的 Web 编程中，PHP 程序员只需要关注 request 到达，request 结束即可。而在 Swoole 程序中程序员可以操控更大范围，变量/对象可以有四种生存周期。\n变量、对象、资源、require/include 的文件等下面统称为对象\n程序全局期\n在 EasySwoole 框架根目录的 bootstrap.php 文件和 EasySwooleEvent.php 文件中的 initialize 事件函数中创建好的对象，我们称之为程序全局生命周期对象。这些变量只要没有被作用域销毁，在程序启动后就会一直存在，直到整个程序结束运行才会销毁。\n有一些服务器程序可能会连续运行数月甚至数年才会关闭/重启，那么程序全局期的对象在这段时间内会持续驻留在内存中的。程序全局期对象所占用的内存是 Worker 进程间共享的，不会额外占用内存。  \n例如:\n\n在 EasySwooleEvent.php 文件中的 initialize 事件函数中使用 Di 注入一个对象，那么在程序开始之后，在EasySwoole 的控制器中，或者其他地方都可以通过 Di 直接调用这个对象\n在 bootstrap.php 中引入一个文件 test.php，该文件定义了一个静态变量，那么在 EasySwoole 的控制器，或者其他地方都可以调用这个静态变量\n\n这部分内存会在写时分离（COW），在 Worker 进程内对这些对象进行写操作时，会自动从共享内存中分离，变为进程全局对象。\n例如:\n\n在 EasySwooleEvent.php 文件中的 initialize 事件函数中使用 Di 注入一个对象，并在用户 A 访问控制器时修改了这个对象的属性，那么其他用户访问控制器的时候，获取这个对象属性时，可能是未改变的状态(因为不同用户访问的控制器所在的进程不同，其他进程不会修改到这个变量，所以需要注意这个问题)；\n在 bootstrap.php 中引入一个文件 test.php，该文件定义了一个静态变量 $a = 1，用户 A 访问控制器时修改了变量 $a = 2，可能在其他用户访问时，依然还是 $a = 1 的状态。\n\n程序全局期 include/require 的代码，必须在整个程序 shutdown 时才会释放，reload 无效\n进程全局期\nSwoole 拥有进程生命周期控制的机制，Worker 进程启动后创建的对象（onWorkerStart 中创建的对象或者在控制器中创建的对象），在这个子进程存活周期之内，是常驻内存的。  \n例如:\n\n程序全局生命周期对象被控制器修改之后，该对象会复制一份出来到控制器所属的进程，这个对象只能被这个进程访问，其他进程访问的依旧是全局对象。\n给服务注册 onWorkerStart 事件(在 EasySwooleEvent.php 中的 mainServerCreate 事件中进行注册 onWorkerStart 事件)时创建的对象，只会在该 Worker 进程才能获取到。\n\n进程全局对象所占用的内存是在当前子进程内存堆的，并非共享内存。对此对象的修改仅在当前 Worker 进程中有效，进程全局期 include/require 的文件，在 reload 后就会重新加载\n会话期\n会话期是在 onConnect 后创建，或者在第一次 onReceive 时创建，onClose 时销毁。一个客户端连接进入后，创建的对象会常驻内存，直到此客户端断开连接才会销毁。  \n在 LAMP 中，一个客户端浏览器访问多次网站，就可以理解为会话期。但传统 PHP 程序，并不能感知到。只有单次访问时使用 session_start，访问 $_SESSION 全局变量才能得到会话期的一些信息。\nSwoole 中会话期的对象直接是常驻内存的，不需要 session_start 之类操作。可以直接访问对象，并执行对象的方法。\n请求期\n请求期是指一个完整的请求发来，也就是 onReceive 收到请求开始处理，直到返回结果发送 response。这个周期所创建的对象，会在请求完成后销毁。\nSwoole 中请求期对象与普通 PHP 程序中的对象就是一样的。请求到来时创建，请求结束后销毁。\nswoole_server 中内存管理机制\nswoole_server 启动后内存管理的底层原理与普通 php-cli 程序一致。具体请参考 Zend VM 内存管理方面的文章。\n局部变量\n在事件回调函数返回后，所有局部对象和变量会全部回收，不需要 unset 。如果变量是一个资源类型，那么对应的资源也会被 PHP 底层释放。\nfunction test()\n{\n    $a = new Object;\n    $b = fopen('/data/t.log', 'r+');\n    $c = new swoole_client(SWOOLE_SYNC);\n    $d = new swoole_client(SWOOLE_SYNC);\n    global $e;\n    $e['client'] = $d;\n}\n$a, $b, $c 都是局部变量，当此函数 return 时，这3个变量会立即释放，对应的内存会立即释放，打开的 IO 资源文件句柄会立即关闭。\n$d 也是局部变量，但是 return 前将它保存到了全局变量 $e，所以不会释放。当执行 unset($e['client']) 时，并且没有任何其他 PHP 变量仍然在引用 $d 变量，那么 $d 就会被释放。\n全局变量\n在 PHP 中，有3类全局变量。\n\n使用 global 关键词声明的变量\n使用 static 关键词声明的类静态变量、函数静态变量\n\nPHP 的超全局变量，包括 $_GET、$_POST、$GLOBALS 等\n\n全局变量和对象，类静态变量，保存在 swoole_server 对象上的变量不会被释放。需要程序员自行处理这些变量和对象的销毁工作。\nclass Test\n{\n    static $array = array();\n    static $string = '';\n}\n\nfunction onReceive($serv, $fd, $reactorId, $data)\n{\n    Test::$array[] = $fd;\n    Test::$string .= $data;\n}\n\n在事件回调函数中需要特别注意非局部变量的 array 类型值，某些操作如 TestClass::$array[] = \"string\" 可能会造成内存泄漏，严重时可能发生爆内存，必要时应当注意清理大数组。\n在事件回调函数中，非局部变量的字符串进行拼接操作是必须小心内存泄漏，如 TestClass::$string .= $data，可能会有内存泄漏，严重时可能发生爆内存。\n\n解决方法\n\n同步阻塞并且请求响应式无状态的 Server 程序可以设置 max_request，当 Worker进程/Task进程 结束运行时或达到任务上限后进程自动退出。该进程的所有变量/对象/资源均会被释放回收。\n程序内在 onClose 或设置定时器及时使用 unset 清理变量，回收资源\n\n内存管理部分参照了 Swoole 官方文档。\n约定规范\n\n项目中类名称与类文件(文件夹)命名，均为大驼峰，变量与类方法为小驼峰。\n在 HTTP 服务响应中，业务逻辑代码中 echo $var 并不会将 $var 内容输出至浏览器页面相应内容中，请调用 Response 实例中的 wirte() 方法实现。\n","link":"/QuickStart/notice.html"},{"id":58,"title":"常见问题","content":"常见问题\n端口占用\n出现类似 WARNING   swSocket_bind(:483): bind(0.0.0.0:9501) failed, Error: Address already in use[98] 如下错误，可判定为端口被占用。\n可以通过 lsof 命令来查询端口占用\n&gt; lsof -i:9501\nCOMMAND PID USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME\nphp      57 root    3u  IPv4 1744902      0t0  TCP *:9501 (LISTEN)\n可以根据返回的 pid 使用 kill 命令来关闭占用端口的相关进程\n&gt; kill -9 57\n也可以通过修改 easyswoole 的监听端口的方式启动 easyswoole 的服务，修改文件在dev.php（线上环境则应在produce.php）中\n&lt;?php\nreturn [\n    'SERVER_NAME' =&gt; \"EasySwoole\",\n    'MAIN_SERVER' =&gt; [\n        'LISTEN_ADDRESS' =&gt; '0.0.0.0',\n        'PORT' =&gt; 9501, // 此处修改 easyswoole 监听端口号\n        ...\n    ],\n    'TEMP_DIR' =&gt; null,\n    'LOG_DIR' =&gt; null\n];\n然后重新启动服务，即可成功启动服务。\nSocket 监听失败\n\n判断是否为端口占用所导致的监听失败，这里还是采用 lsof 命令来查看端口\n\n&gt; lsof -i:9501\n\n\n1024 以下端口需要 root 权限监听，所以这里要特别注意\n\n外网无法访问\n注意：当服务成功启动后，如果外网无法访问，可以使用 telnet 客户端查看对应的端口是否开放成功，前提是首先环境得有 telnet 客户端 (具体如何安装 telnet 客户端请用户自行百度谷歌查询)，检查端口开放命令如下：telnet 公网ip/内网ip 端口号，例如：telnet 192.168.0.1 9501。端口开放成功，则会立刻跳转，不成功，则会有对应的提示。用户可根据对应的提示进行判断。\n\n\n检查服务监听端口是否为 0.0.0.0\n\n\n检查防火墙是否对外开放\n\n\n&gt; netstat -anp\n\n// 如果相关端口被防火墙拦截，需要放开\n&gt; firewall-cmd --zone=public --add-port=9501/tcp --permanent\n如果为阿里云、腾讯云等云服务器，请检查服务器安全组是否放行对应端口。同样可以使用上述注意事项的 telnet 客户端自行检查。\n以上 shell 命令适用于 centos 7，其它 linux 发行版请自行查找相关命令。\n请求数据时 DNS 报错\n\n原因：有时会发现在使用 Swoole 的 MySQL、HttpClient、Redis 等客户端发送请求时，出现了 DNS 错误，类似于 DNS Lookup resolve failed... 错误，这是由于 Swoole 底层对一些 DNS 不是很友好。\n解决方法：建议使用阿里云公共 DNS，具体如何配置阿里云公共 DNS，请看 https://www.alidns.com/knowledge?type=SETTING_DOCS#user_linux\n\n","link":"/QuickStart/problem.html"},{"id":59,"title":"配置文件","content":"配置文件\nEasySwoole 框架提供了非常灵活自由的全局配置功能，配置文件采用 PHP 返回数组方式定义，对于一些简单的应用，无需修改任何配置，对于复杂的要求，还可以自行扩展自己独立的配置文件和进行动态配置。\n框架安装完成后系统默认的全局配置文件是项目根目录下的 produce.php 、 dev.php 文件，(在 3.1.2 版本之前是 dev.env、produce.env)，3.4.x 版本(最新版)支持在启动 EasySwoole 框架时以指定的配置文件( dev.php / produce.php)运行，详细启动命令请看 基本管理命令章节。\n配置文件内容如下:\n&lt;?php\n\nreturn [\n    // 服务名称\n    'SERVER_NAME'   =&gt; \"EasySwoole\",\n    'MAIN_SERVER'   =&gt; [\n        // 监听地址\n        'LISTEN_ADDRESS' =&gt; '0.0.0.0',\n        // 监听端口\n        'PORT'           =&gt; 9501,\n        // 可选 EASYSWOOLE_SERVER,EASYSWOOLE_WEB_SERVER EASYSWOOLE_WEB_SOCKET_SERVER\n        'SERVER_TYPE'    =&gt; EASYSWOOLE_WEB_SERVER, \n        // 可选 SWOOLE_TCP SWOOLE_TCP6 SWOOLE_UDP SWOOLE_UDP6 SWOOLE_UNIX_DGRAM SWOOLE_UNIX_STREAM\n        'SOCK_TYPE'      =&gt; SWOOLE_TCP,\n        // 默认 Server 运行模式\n        'RUN_MODEL'      =&gt; SWOOLE_PROCESS,\n        // Swoole_Server 运行配置（ 完整配置可见[Swoole 文档](http://swoole.easyswoole.com/ServerStart/Tcp/method.html) 的 mode 参数 ）\n        'SETTING'        =&gt; [\n            // 运行的 worker 进程数量\n            'worker_num'            =&gt; 8,\n            // 设置异步重启开关。设置为 true 时，将启用异步安全重启特性，Worker 进程会等待异步事件完成后再退出。\n            'reload_async'          =&gt; true,\n            // 开启后自动在 onTask 回调中创建协程\n            'task_enable_coroutine' =&gt; true,\n            'max_wait_time'         =&gt; 3,\n            // (可选参数）使用 http 上传大文件时可以进行配置\n            // 'package_max_length' =&gt; 100 * 1024 * 1024, // 即 100 M\n\n            // (可选参数) 允许处理静态文件 html 等，详细请看 http://swoole.easyswoole.com/ServerStart/Http/serverSetting.html\n            // 'document_root' =&gt; '/easyswoole/public',\n            // 'enable_static_handler' =&gt; true,\n        ],\n        // 设置 EasySwoole 框架独立实现的 Task 任务组件的配置\n        'TASK'=&gt;[\n            'workerNum'     =&gt; 4,\n            'maxRunningNum' =&gt; 128,\n            'timeout'       =&gt; 15\n        ]\n    ],\n    // 临时文件存放的目录\n    'TEMP_DIR'      =&gt; null,\n\n    ### 日志相关配置 (目前最新)EasySwoole 3.4.4 及以后版本支持\n    \"LOG\" =&gt; [\n        // 设置记录日志文件时日志文件存放目录\n        'dir' =&gt; null,\n        // 设置记录日志时的日志最低等级，低于此等级的日志不进行记录和显示\n        'level' =&gt; \\EasySwoole\\Log\\LoggerInterface::LOG_LEVEL_DEBUG,\n        // 设置日志处理器 `handler` (handler)\n        'handler' =&gt; null,\n        // 设置开启控制台日志记录到日志文件\n        'logConsole' =&gt; true,\n        // 设置开启在控制台显示日志\n        'displayConsole'=&gt;true,\n        // 设置打印日志时忽略哪些分类的日志不进行记录\n        'ignoreCategory' =&gt; []\n    ],\n\n    ### 日志相关配置 EasySwoole 3.4.3 版本支持\n    // \"LOG\" =&gt; [\n    //    'dir' =&gt; null,\n    //    'level' =&gt; \\EasySwoole\\Log\\LoggerInterface::LOG_LEVEL_DEBUG,\n    //    'handler' =&gt; null,\n    // ],\n\n    ### 日志相关配置 EasySwoole 3.4.3 之前支持\n    // 日志文件存放的目录\n    // 'LOG_DIR'       =&gt; null,\n];\n\n以上配置关于日志的相关配置的说明，详细请看 日志 章节。\n\n上述参数补充说明：\n\nMAIN_SERVER.SERVER_TYPE: \n\nEASYSWOOLE_WEB_SERVER: 表示框架主服务为 Http 服务(框架默认提供的服务类型)\nEASYSWOOLE_SERVER: 表示框架主服务为 Tcp 服务\nEASYSWOOLE_WEB_SOCKET_SERVER: 表示框架主服务为 WebSocket 服务\n\n\n\nEASYSWOOLE_SERVER、EASYSWOOLE_WEB_SOCKET_SERVER类型，都需要在 EasySwooleEvent.php 的 mainServerCreate 事件中自行设置回调( receive 或 message )，否则将出错。具体设置对应的回调的方式请参考 Tcp 服务章节 和 WebSocket 服务章节。关于同时支持多个服务的使用也请查看 Tcp 服务章节 和 WebSocket 服务章节。\n注意：目前框架 3.4.x 的配置驱动默认为 SplArray，自定义配置驱动可查看本文最后章节。\n注意：EasySwoole 3.4.x 之前版本的配置驱动使用的是 \\Swoole\\Table，由于 swoole_table 的特殊特性，不适合存储大量/大长度的配置，如果是存储支付秘钥、签名等大长度字符串，建议使用类常量方法定义，而不是通过 dev.php 存储。如果你必须用配置文件存储，请看本文下文的自定义 config 驱动。\n配置操作类\n配置操作类为 \\EasySwoole\\EasySwoole\\Config 类，使用方式非常简单，具体请看下面的代码示例，操作类还提供了 load 方法重载全部配置，基于这个方法，可以自己定制更多的高级操作。\n设置和获取配置项都支持点语法分隔，具体请看下面获取配置的代码示例\n&lt;?php\n\n$instance = \\EasySwoole\\EasySwoole\\Config::getInstance();\n\n// 获取配置 按层级用点号分隔\n$instance-&gt;getConf('MAIN_SERVER.SETTING.task_worker_num');\n\n// 设置配置 按层级用点号分隔\n$instance-&gt;setConf('DATABASE.host', 'localhost');\n\n// 获取全部配置\n$conf = $instance-&gt;getConf();\n\n// 用一个数组覆盖当前配置项\n$conf['DATABASE'] = [\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 13306\n];\n$instance-&gt;load($conf);\n需要注意的是 由于进程隔离的原因，在 Server 启动后，动态新增修改的配置项，只对执行操作的进程生效，如果需要全局共享配置需要自己进行扩展\n添加用户配置项\n每个用户都有自己的配置项，添加自己的配置项非常简单，其中一种方法是直接在配置文件中添加即可，如下面的例子:\n下面示例中添加了自定义的 MySQL 和 Redis 配置。\n&lt;?php\nreturn [\n    'SERVER_NAME' =&gt; \"EasySwoole\",\n    'MAIN_SERVER' =&gt; [\n        'LISTEN_ADDRESS' =&gt; '0.0.0.0',\n        'PORT' =&gt; 9501,\n        'SERVER_TYPE' =&gt; EASYSWOOLE_WEB_SERVER, // 可选为 EASYSWOOLE_SERVER  EASYSWOOLE_WEB_SERVER EASYSWOOLE_WEB_SOCKET_SERVER\n        'SOCK_TYPE' =&gt; SWOOLE_TCP,\n        'RUN_MODEL' =&gt; SWOOLE_PROCESS,\n        'SETTING' =&gt; [\n            'worker_num' =&gt; 8,\n            'reload_async' =&gt; true,\n            'max_wait_time'=&gt;3,\n            'document_root'            =&gt; EASYSWOOLE_ROOT . '/Static',\n            'enable_static_handler'    =&gt; true,\n        ],\n        'TASK'=&gt;[\n            'workerNum'=&gt;0,\n            'maxRunningNum'=&gt;128,\n            'timeout'=&gt;15\n        ]\n    ],\n    'TEMP_DIR' =&gt; null,\n    'LOG_DIR' =&gt; null,\n\n    // 添加 MySQL 及对应的连接池配置\n    /*################ MYSQL CONFIG ##################*/\n    'MYSQL' =&gt; [\n        'host'          =&gt; '127.0.0.1', // 数据库地址\n        'port'          =&gt; 3306, // 数据库端口\n        'user'          =&gt; 'root', // 数据库用户名\n        'password'      =&gt; 'root', // 数据库用户密码\n        'timeout'       =&gt; 45, // 数据库连接超时时间\n        'charset'       =&gt; 'utf8', // 数据库字符编码\n        'database'      =&gt; 'easyswoole', // 数据库名\n        'autoPing'      =&gt; 5, // 自动 ping 客户端链接的间隔\n        'strict_type'   =&gt; false, // 不开启严格模式\n        'fetch_mode'    =&gt; false,\n        'returnCollection'  =&gt; false, // 设置返回结果为 数组\n        // 配置 数据库 连接池配置，配置详细说明请看连接池组件 https://www.easyswoole.com/Components/Pool/introduction.html\n        'intervalCheckTime' =&gt; 15 * 1000, // 设置 连接池定时器执行频率\n        'maxIdleTime'   =&gt; 10, // 设置 连接池对象最大闲置时间 (秒)\n        'maxObjectNum'  =&gt; 20, // 设置 连接池最大数量\n        'minObjectNum'  =&gt; 5, // 设置 连接池最小数量\n        'getObjectTimeout'  =&gt; 3.0, // 设置 获取连接池的超时时间\n        'loadAverageTime'   =&gt; 0.001, // 设置 负载阈值\n    ],\n\n    // 添加 Redis 及对应的连接池配置\n    /*################ REDIS CONFIG ##################*/\n    'REDIS' =&gt; [\n        'host'          =&gt; '127.0.0.1', // Redis 地址\n        'port'          =&gt; '6379', // Redis 端口\n        'auth'          =&gt; 'easyswoole', // Redis 密码\n        'timeout'       =&gt; 3.0, // Redis 操作超时时间\n        'reconnectTimes' =&gt; 3, // Redis 自动重连次数\n        'db'            =&gt; 0, // Redis 库\n        'serialize'     =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE, // 序列化类型，默认不序列化\n        'packageMaxLength' =&gt; 1024 * 1024 * 2, // 允许操作的最大数据\n        // 配置 Redis 连接池配置，配置详细说明请看连接池组件 https://www.easyswoole.com/Components/Pool/introduction.html\n        'intervalCheckTime' =&gt; 15 * 1000, // 设置 连接池定时器执行频率\n        'maxIdleTime'   =&gt; 10, // 设置 连接池对象最大闲置时间 (秒)\n        'maxObjectNum'  =&gt; 20, // 设置 连接池最大数量\n        'minObjectNum'  =&gt; 5, // 设置 连接池最小数量\n        'getObjectTimeout'  =&gt; 3.0, // 设置 获取连接池的超时时间\n        'loadAverageTime'   =&gt; 0.001, // 设置 负载阈值\n    ],\n];\n生产与开发配置分离\n在 php easyswoole server start 命令下，默认为开发模式，加载 dev.php (3.1.2 之前为 dev.env)\n运行 php easyswoole server start -mode=produce 命令时，为生产模式，加载 produce.php (3.1.2 之前为 produce.env)\n旧版本 EasySwoole (3.4.x 以前的版本)，在 php easyswoole start 命令下，默认为开发模式，加载 dev.php (3.1.2 之前为 dev.env)。运行 php easyswoole start produce 命令时，为生产模式，加载 produce.php (3.1.2 之前为 produce.env)\nDI 注入配置\nEasySwoole 3.x 提供了几个 Di 参数配置，可自定义配置脚本错误异常处理回调、控制器命名空间、最大解析层级等。\n&lt;?php\n// 配置错误处理回调\n\\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::ERROR_HANDLER, function () {\n});\n\n// 配置脚本结束回调\n\\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::SHUTDOWN_FUNCTION, function () {\n});\n\n// 配置控制器命名空间\n\\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::HTTP_CONTROLLER_NAMESPACE, 'App\\\\HttpController\\\\');\n\n// 配置 HTTP 控制器最大解析层级\n\\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::HTTP_CONTROLLER_MAX_DEPTH, 5);\n\n// 配置http控制器异常回调\n\\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::HTTP_EXCEPTION_HANDLER, function () {});\n\n// HTTP 控制器对象池最大数量\n\\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::HTTP_CONTROLLER_POOL_MAX_NUM, 15);\n自定义 Config 驱动\nEasySwoole 在 3.2.5 版本后，默认配置驱动存储从 SplArray 改为了 swoole_table，修改配置之后，所有进程同时生效。在 3.4.x 版本后，由于特殊原因，默认配置驱动存储又从 swoole_table 改为了 SplArray，修改配置之后，仅在当前进程生效。所以在 3.2.5 ~ 3.3.7 版本中，默认配置驱动存储为 swoole_table。\nAbstractConfig\n\\EasySwoole\\Config\\AbstractConfig 抽象类提供了以下几个方法，用于给其他 config 驱动继承：\n\n\nisDev()\n该方法在 3.4.x 版本中已移除，请用 \\EasySwoole\\EasySwoole\\Core::getInstance()-&gt;runMode() == 'dev' 判断是否为开发环境。\n(在 3.4.x 之前版本可通过该方法获得当前运行环境是否为开发环境)\n\n\nabstract function getConf($key = null);\n获取一个配置\n\n\nabstract function setConf($key, $val): bool;\n设置一个参数\n\n\nabstract function load(array $array): bool;\n重新加载配置项\n\n\nabstract function merge(array $array): bool;\n合并配置项\n\n\nabstract function clear(): bool;\n清除所有配置项\n\n\n自定义配置存储驱动\n在 EasySwoole 中，自带了 SplArray 和 swoole_table 驱动实现，可自行查看源码进行深入了解。 \n目前最先版本默认驱动为 SplArray。 \n如需要修改配置存储驱动，配置步骤如下:  \n\n继承 AbstractConfig 实现各个方法\n在 Bootstrap 事件 事件中修改 config 驱动(直接在 bootstrap.php 文件中加入如下代码即可)\n\n&lt;?php\n\\EasySwoole\\EasySwoole\\Config::getInstance(new \\EasySwoole\\Config\\SplArrayConfig());\n由于 bootstrap 事件 是由 EasySwoole 启动脚本执行，当你需要写 cli 脚本需要初始化 EasySwoole 框架基础组件时，需要自行引入 bootstrap.php 文件。\n动态配置问题\n由于 swoole 是多进程的，如果使用 SplArray 方式存储，在单个进程修改配置后，其他进程将不会生效，使用swoole_table 方式的则会全部生效，需要特别注意。\n在 EasySwoole 3.4.x 之前版本，框架采用 swoole_table 作为默认配置驱动存储。所以当你在控制器( worker 进程)中修改某一项配置时，由于进程隔离，修改的配置不会在其他进程生效，所以我们可以使用动态配置: 动态配置将配置数据存储在 swoole_table 中，获取/修改配置数据时是从 swoole_table 直接操作，所有进程都可以使用。但是在目前最新版本中默认配置驱动存储变成了 SplArray，在单个进程修改配置后，其他进程将不会生效，需要特别注意。\n其他\n\n\nQQ 交流群\n\nVIP 群 579434607 （本群需要付费 599 元）\nEasySwoole 官方一群 633921431(已满)\nEasySwoole 官方二群 709134628(已满)\nEasySwoole 官方三群 932625047(已满)\nEasySwoole 官方四群 779897753(已满)\nEasySwoole 官方五群 853946743 \n\n\n\n商业支持：\n\nQQ 291323003\nEMAIL admin@fosuss.com\n\n\n\n作者微信\n\n\n\n捐赠\n您的捐赠是对 EasySwoole 项目开发组最大的鼓励和支持。我们会坚持开发维护下去。 您的捐赠将被用于:\n\n持续和深入地开发\n文档和社区的建设和维护\n\n\n\nEasySwoole 的文档使用 EasySwoole 框架 提供服务，采用 MarkDown 格式 和自定义格式编写，若您在使用过程中，发现文档有需要纠正 / 补充的地方，请 fork 项目的文档仓库，进行修改补充，提交 Pull Request 并联系我们。\n\n","link":"/QuickStart/config.html"},{"id":60,"title":"反向代理","content":"Proxy\n由于 Swoole Server 对 HTTP 协议的支持并不完整，建议仅将 EasySwoole 作为后端服务，并且在前端增加 Nginx 或 Apache 作为代理，参照下面的例子添加转发规则\nNginx\nserver {\n    root /data/wwwroot/;\n    server_name local.swoole.com;\n    location / {\n        proxy_http_version 1.1;\n        proxy_set_header Connection \"keep-alive\";\n        proxy_set_header X-Real-IP $remote_addr;\n        if (!-f $request_filename) {\n             proxy_pass http://127.0.0.1:9501;\n        }\n    }\n}\n具体部署时的 nginx 代理配置，还可参考 Deploy-Nginx 章节。\n代理之后，可通过 $request->getHeader('x-real-ip')[0] 获取客户端真实ip \nApache\n&lt;IfModule mod_rewrite.c&gt;\n  Options +FollowSymlinks\n  RewriteEngine On\n  RewriteCond %{REQUEST_FILENAME} !-d\n  RewriteCond %{REQUEST_FILENAME} !-f\n  # RewriteRule ^(.*)$ index.php/$1 [QSA,PT,L]  fcgi 下无效\n  RewriteRule ^(.*)$  http://127.0.0.1:9501/$1 [QSA,P,L]\n   # 请开启 proxy_mod proxy_http_mod request_mod\n&lt;/IfModule&gt;\n其他\n\n\n项目文档仓库\n\n\nDEMO\n\n\nQQ 交流群\n\nVIP 群 579434607 （本群需要付费 599 元）\nEasySwoole 官方一群 633921431(已满)\nEasySwoole 官方二群 709134628(已满)\nEasySwoole 官方三群 932625047(已满)\nEasySwoole 官方四群 779897753(已满)\nEasySwoole 官方五群 853946743\n\n\n\n商业支持：\n\nQQ 291323003\nEMAIL admin@fosuss.com\n\n\n\n作者微信\n\n\n\n捐赠 您的捐赠是对 EasySwoole 项目开发组最大的鼓励和支持。我们会坚持开发维护下去。 您的捐赠将被用于:\n\n持续和深入地开发\n文档和社区的建设和维护\n\n\n\nEasySwoole 的文档使用 EasySwoole 框架 提供服务，采用 MarkDown 格式 和自定义格式编写，若您在使用过程中，发现文档有需要纠正 / 补充的地方，请 fork 项目的文档仓库，进行修改补充，提交 Pull Request 并联系我们。\n\n","link":"/QuickStart/proxy.html"},{"id":61,"title":"开发工具","content":"开发工具\nIDE 代码提示组件\n为了让用户能够更高效地进行 EasySwoole 开发，我们提供了 IDE 代码提示组件。在 PhpStrom 等 IDE 环境下开发时，该组件能够对 Swoole 内置函数、类等自动提示，该组件安装方法如下：\n\ncomposer require easyswoole/swoole-ide-helper\n\nIDE 注解提示组件\n用户在使用 EasySwoole 注解组件 进行 EasySwoole 开发时，仍需要 use 注解相对应的命名空间。这显然不是一个高效的做法。我们推荐在 PhpStorm 环境下进行开发，并且在 PhpStorm 中安装 Jetbrain 自带的 PHP Annotation 组件，可以提供注解命名空间自动补全、注解属性代码提醒、注解类跳转等非常有帮助的。(PhpStorm 2019 以上版本的 IDE，该组件可能不能正常使用。)","link":"/QuickStart/developTools.html"},{"id":62,"title":"基础开发示例","content":"基础开始示例\ndemo 地址\n基础开发示例已经开源，源码地址：https://github.com/easy-swoole/demo/tree/3.x\n安装\n框架安装\n\n我们先把当前的 php 环境安装好 swoole 拓展，安装 swoole 扩展 步骤可查看 安装 Swoole 章节，然后执行 php --ri swoole 确保可以看到 swoole 拓展版本为 4.4.23\n\n建立一个目录，名为 Test ，执行 composer require easyswoole/easyswoole=3.4.x 引入 easyswoole\n\n执行 php vendor/bin/easyswoole install 进行安装，然后输入 Y、Y\n\n\n组件引入\n// 引入 IDE 代码提示组件\ncomposer require easyswoole/swoole-ide-helper\n\n// 引入 http-annotation 注解处理组件\ncomposer require easyswoole/http-annotation \n命名空间注册\n编辑 Test 根目录下的 composer.json 文件，如果自动加载中没有 App 命名空间，请在 autoload.psr-4 中加入 \"App\\\\\": \"App/\"，然后执行 composer dumpautoload -o 进行名称空间的更新。composer.json 文件大体结构如下：\n{\n    \"require\": {\n        \"easyswoole/easyswoole\": \"3.x\",\n        \"easyswoole/swoole-ide-helper\": \"^1.3\",\n        \"easyswoole/http-annotation\": \"^2.0\"\n    },\n    \"autoload\": {\n        \"psr-4\": {\n            \"App\\\\\": \"App/\"\n        }\n    }\n}\n安装后目录结构\nTest                    项目部署目录\n├─App                     应用目录\n│  ├─HttpController      控制器目录(如果没有，请自行创建)\n├─Log                     日志文件目录（启动后创建）\n├─Temp                    临时文件目录（启动后创建）\n├─vendor                  第三方类库目录\n├─bootstrap.php           框架 bootstrap 事件\n├─composer.json           Composer 架构\n├─composer.lock           Composer 锁定\n├─EasySwooleEvent.php     框架全局事件\n├─easyswoole              框架管理脚本\n├─dev.php                 开发配置文件\n├─produce.php             生产配置文件\n连接池实现\n配置项\n我们在 dev.php 配置文件中，加入以下配置信息，注意：请根据自己的 mysql 服务器信息填写账户密码。\n&lt;?php\n\nreturn [\n    // ...... 这里省略\n    'MAIN_SERVER' =&gt; [\n        // ...... 这里省略\n    ],\n    // ...... 这里省略\n\n    // 添加 MySQL 及对应的连接池配置\n    /*################ MYSQL CONFIG ##################*/\n    'MYSQL' =&gt; [\n        'host'          =&gt; '127.0.0.1', // 数据库地址\n        'port'          =&gt; 3306, // 数据库端口\n        'user'          =&gt; 'root', // 数据库用户名\n        'password'      =&gt; 'easyswoole', // 数据库用户密码\n        'timeout'       =&gt; 45, // 数据库连接超时时间\n        'charset'       =&gt; 'utf8', // 数据库字符编码\n        'database'      =&gt; 'easyswoole_demo', // 数据库名\n        'autoPing'      =&gt; 5, // 自动 ping 客户端链接的间隔\n        'strict_type'   =&gt; false, // 不开启严格模式\n        'fetch_mode'    =&gt; false,\n        'returnCollection'  =&gt; false, // 设置返回结果为 数组\n        // 配置 数据库 连接池配置，配置详细说明请看连接池组件 https://www.easyswoole.com/Components/Pool/introduction.html\n        'intervalCheckTime' =&gt; 15 * 1000, // 设置 连接池定时器执行频率\n        'maxIdleTime'   =&gt; 10, // 设置 连接池对象最大闲置时间 (秒)\n        'maxObjectNum'  =&gt; 20, // 设置 连接池最大数量\n        'minObjectNum'  =&gt; 5, // 设置 连接池最小数量\n        'getObjectTimeout'  =&gt; 3.0, // 设置 获取连接池的超时时间\n    ],\n];\n进行如上配置之后，我们需要在 MySQL 服务端创建一个名为 easyswoole_demo 的数据库，选择字符串编码为 utf8，字符排序规则为 utf8_general_ci，\n引入数据库 ORM 库\n执行以下命令用于实现数据库 ORM 库的引入。\ncomposer require easyswoole/orm=1.4.x\n注册数据库连接池\n编辑 Test 项目根目录下的 EasySwooleEvent.php 文件，在 initialize 或 mainServerCreate 事件函数中进行 ORM 的连接池的注册，内容如下：\n&lt;?php\n\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\nuse EasySwoole\\ORM\\Db\\Connection;\nuse EasySwoole\\ORM\\DbManager;\n\nclass EasySwooleEvent implements Event\n{\n    public static function initialize()\n    {\n        date_default_timezone_set('Asia/Shanghai');\n\n        ###### 注册 mysql orm 连接池 ######\n        $config = new \\EasySwoole\\ORM\\Db\\Config(Config::getInstance()-&gt;getConf('MYSQL'));\n        // 【可选操作】我们已经在 dev.php 中进行了配置\n        # $config-&gt;setMaxObjectNum(20); // 配置连接池最大数量\n        DbManager::getInstance()-&gt;addConnection(new Connection($config));\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        // 或者 在此函数中注册 和上面等价\n        ###### 注册 mysql orm 连接池 ######\n        // $config = new \\EasySwoole\\ORM\\Db\\Config(Config::getInstance()-&gt;getConf('MYSQL'));\n        // 【可选操作】我们已经在 dev.php 中进行了配置\n        # $config-&gt;setMaxObjectNum(20); // 配置连接池最大数量\n        // DbManager::getInstance()-&gt;addConnection(new Connection($config));\n    }\n}\n在 initialize 事件中注册数据库连接池，使用这个 $config 可同时配置连接池大小等。\n具体查看 ORM 组件章节 的使用。\n模型定义\n管理员模型\n新增管理员用户表\n运行如下 sql 脚本，创建管理员用户表 admin_list。\nDROP TABLE IF EXISTS `admin_list`;\nCREATE TABLE `admin_list`  (\n  `adminId` int(11) NOT NULL AUTO_INCREMENT,\n  `adminName` varchar(15) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `adminAccount` varchar(18) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `adminPassword` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `adminSession` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `adminLastLoginTime` int(11) NULL DEFAULT NULL,\n  `adminLastLoginIp` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  PRIMARY KEY (`adminId`) USING BTREE,\n  UNIQUE INDEX `adminAccount`(`adminAccount`) USING BTREE,\n  INDEX `adminSession`(`adminSession`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci;\n\nINSERT INTO `admin_list` VALUES (1, '仙士可', 'xsk', 'e10adc3949ba59abbe56e057f20f883e', '', 1566279458, '192.168.159.1');\n新增 model 文件\n新建 App/Model/Admin/AdminModel.php 文件，编辑内容如下：\n&lt;?php\n\nnamespace App\\Model\\Admin;\n\nuse EasySwoole\\ORM\\AbstractModel;\n\n/**\n * Class AdminModel\n * @property $adminId\n * @property $adminName\n * @property $adminAccount\n * @property $adminPassword\n * @property $adminSession\n * @property $adminLastLoginTime\n * @property $adminLastLoginIp\n */\nclass AdminModel extends AbstractModel\n{\n    protected $tableName = 'admin_list';\n\n    protected $primaryKey = 'adminId';\n\n    /**\n     * @getAll\n     * @keyword adminName\n     * @param  int  page  1\n     * @param  string  keyword\n     * @param  int  pageSize  10\n     * @return array[total,list]\n     */\n    public function getAll(int $page = 1, string $keyword = null, int $pageSize = 10): array\n    {\n        $where = [];\n        if (!empty($keyword)) {\n            $where['adminAccount'] = ['%' . $keyword . '%', 'like'];\n        }\n        $list = $this-&gt;limit($pageSize * ($page - 1), $pageSize)-&gt;order($this-&gt;primaryKey, 'DESC')-&gt;withTotalCount()-&gt;all($where);\n        $total = $this-&gt;lastQueryResult()-&gt;getTotalCount();\n        return ['total' =&gt; $total, 'list' =&gt; $list];\n    }\n\n    /*\n     * 登录成功后请返回更新后的bean\n     */\n    public function login(): ?AdminModel\n    {\n        $info = $this-&gt;get(['adminAccount' =&gt; $this-&gt;adminAccount, 'adminPassword' =&gt; $this-&gt;adminPassword]);\n        return $info;\n    }\n\n    /*\n     * 以account进行查询\n     */\n    public function accountExist($field = '*'): ?AdminModel\n    {\n        $info = $this-&gt;field($field)-&gt;get(['adminAccount' =&gt; $this-&gt;adminAccount]);\n        return $info;\n    }\n\n    public function getOneBySession($field = '*'): ?AdminModel\n    {\n        $info = $this-&gt;field($field)-&gt;get(['adminSession' =&gt; $this-&gt;adminSession]);\n        return $info;\n    }\n\n    public function logout()\n    {\n        return $this-&gt;update(['adminSession' =&gt; '']);\n    }\n}\n针对上述类似 : ?AdminModel，不懂这种函数返回值类型声明的同学，请查看 函数返回值类型声明，属于 PHP 7 的新特性。\n关于 model 的定义可查看 ORM 模型定义章节。\n关于 IDE 自动提示，只要你在类上面注释中加上 @property $adminId，IDE 就可以自动提示类的这个属性。\n普通用户模型\n普通用户模型和管理员模型同理。\n建表\n运行如下 sql 脚本，创建普通用户表 user_list。\nDROP TABLE IF EXISTS `user_list`;\nCREATE TABLE `user_list`  (\n  `userId` int(11) NOT NULL AUTO_INCREMENT,\n  `userName` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,\n  `userAccount` varchar(18) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,\n  `userPassword` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,\n  `phone` varchar(18) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,\n  `addTime` int(11) NULL DEFAULT NULL,\n  `lastLoginIp` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `lastLoginTime` int(10) NULL DEFAULT NULL,\n  `userSession` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `state` tinyint(2) NULL DEFAULT NULL,\n  `money` int(10) NOT NULL DEFAULT 0 COMMENT '用户余额',\n  `frozenMoney` int(10) NOT NULL DEFAULT 0 COMMENT '冻结余额',\n  PRIMARY KEY (`userId`) USING BTREE,\n  UNIQUE INDEX `pk_userAccount`(`userAccount`) USING BTREE,\n  INDEX `userSession`(`userSession`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci;\n\nINSERT INTO `user_list` VALUES (1, '仙士可', 'xsk', 'e10adc3949ba59abbe56e057f20f883e', '', 1566279458, '192.168.159.1', 1566279458, '', 1, 1, 1);\n新增 model 文件\n新建 App/Model/User/UserModel.php 文件，编辑内容如下：\n&lt;?php\n\nnamespace App\\Model\\User;\n\nuse EasySwoole\\ORM\\AbstractModel;\n\n/**\n * Class UserModel\n * @property $userId\n * @property $userName\n * @property $userAccount\n * @property $userPassword\n * @property $phone\n * @property $money\n * @property $addTime\n * @property $lastLoginIp\n * @property $lastLoginTime\n * @property $userSession\n * @property $state\n */\nclass UserModel extends AbstractModel\n{\n    protected $tableName = 'user_list';\n\n    protected $primaryKey = 'userId';\n\n    const STATE_PROHIBIT = 0; // 禁用状态\n    const STATE_NORMAL = 1; // 正常状态\n\n    /**\n     * @getAll\n     * @keyword userName\n     * @param  int  page  1\n     * @param  string  keyword\n     * @param  int  pageSize  10\n     * @return array[total,list]\n     */\n    public function getAll(int $page = 1, string $keyword = null, int $pageSize = 10): array\n    {\n        $where = [];\n        if (!empty($keyword)) {\n            $where['userAccount'] = ['%' . $keyword . '%', 'like'];\n        }\n        $list = $this-&gt;limit($pageSize * ($page - 1), $pageSize)-&gt;order($this-&gt;primaryKey, 'DESC')-&gt;withTotalCount()-&gt;all($where);\n        $total = $this-&gt;lastQueryResult()-&gt;getTotalCount();\n        return ['total' =&gt; $total, 'list' =&gt; $list];\n    }\n\n    public function getOneByPhone($field = '*'): ?UserModel\n    {\n        $info = $this-&gt;field($field)-&gt;get(['phone' =&gt; $this-&gt;phone]);\n        return $info;\n    }\n\n    /*\n     * 登录成功后请返回更新后的bean\n     */\n    public function login(): ?UserModel\n    {\n        $info = $this-&gt;get(['userAccount' =&gt; $this-&gt;userAccount, 'userPassword' =&gt; $this-&gt;userPassword]);\n        return $info;\n    }\n\n    public function getOneBySession($field = '*'): ?UserModel\n    {\n        $info = $this-&gt;field($field)-&gt;get(['userSession' =&gt; $this-&gt;userSession]);\n        return $info;\n    }\n\n    public function logout()\n    {\n        return $this-&gt;update(['userSession' =&gt; '']);\n    }\n}\nbanner 模型\n建表\n运行如下 sql 脚本，创建 banner 表 banner_list。\nDROP TABLE IF EXISTS `banner_list`;\nCREATE TABLE `banner_list`  (\n  `bannerId` int(11) NOT NULL AUTO_INCREMENT,\n  `bannerName` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `bannerImg` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT 'banner图片',\n  `bannerDescription` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `bannerUrl` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '跳转地址',\n  `state` tinyint(3) NULL DEFAULT NULL COMMENT '状态0隐藏 1正常',\n  PRIMARY KEY (`bannerId`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8 COLLATE = utf8_general_ci;\n\nINSERT INTO `banner_list` VALUES (1, '测试banner', 'asdadsasdasd.jpg', '测试的banner数据', 'www.php20.cn', 1);\n新增model文件\n新建 App/Model/Admin/BannerModel.php 文件，编辑内容如下：\n&lt;?php\n\nnamespace App\\Model\\Admin;\n\nuse EasySwoole\\ORM\\AbstractModel;\n\n/**\n * Class BannerModel\n * @property $bannerId\n * @property $bannerImg\n * @property $bannerUrl\n * @property $state\n */\nclass BannerModel extends AbstractModel\n{\n    protected $tableName = 'banner_list';\n\n    protected $primaryKey = 'bannerId';\n\n    public function getAll(int $page = 1, int $state = 1, string $keyword = null, int $pageSize = 10): array\n    {\n        $where = [];\n        if (!empty($keyword)) {\n            $where['bannerUrl'] = ['%' . $keyword . '%', 'like'];\n        }\n        $where['state'] = $state;\n        $list = $this-&gt;limit($pageSize * ($page - 1), $pageSize)-&gt;order($this-&gt;primaryKey, 'DESC')-&gt;withTotalCount()-&gt;all($where);\n        $total = $this-&gt;lastQueryResult()-&gt;getTotalCount();\n        return ['total' =&gt; $total, 'list' =&gt; $list];\n    }\n}\n控制器定义\n全局基础控制器定义\n新建 App/Httpcontroller/BaseController.php 文件，编辑内容如下：\n&lt;?php\n\nnamespace App\\HttpController;\n\nuse EasySwoole\\EasySwoole\\ServerManager;\nuse EasySwoole\\HttpAnnotation\\AnnotationController;\n\nclass BaseController extends AnnotationController\n{\n    public function index()\n    {\n        $this-&gt;actionNotFound('index');\n    }\n\n    /**\n     * 获取用户的真实IP\n     * @param string $headerName 代理服务器传递的标头名称\n     * @return string\n     */\n    protected function clientRealIP($headerName = 'x-real-ip')\n    {\n        $server = ServerManager::getInstance()-&gt;getSwooleServer();\n        $client = $server-&gt;getClientInfo($this-&gt;request()-&gt;getSwooleRequest()-&gt;fd);\n        $clientAddress = $client['remote_ip'];\n        $xri = $this-&gt;request()-&gt;getHeader($headerName);\n        $xff = $this-&gt;request()-&gt;getHeader('x-forwarded-for');\n        if ($clientAddress === '127.0.0.1') {\n            if (!empty($xri)) {  // 如果有 xri 则判定为前端有 NGINX 等代理\n                $clientAddress = $xri[0];\n            } elseif (!empty($xff)) {  // 如果不存在 xri 则继续判断 xff\n                $list = explode(',', $xff[0]);\n                if (isset($list[0])) $clientAddress = $list[0];\n            }\n        }\n        return $clientAddress;\n    }\n\n    protected function input($name, $default = null)\n    {\n        $value = $this-&gt;request()-&gt;getRequestParam($name);\n        return $value ?? $default;\n    }\n}\n上述新增的基础控制器 (BaseController.php) 里面的方法用于获取用户 ip，以及获取 api 参数。\n上述新增的基础控制器 (BaseController.php) 继承了 \\EasySwoole\\Http\\AbstractInterface\\AnnotationController ，这个是注解支持控制器，具体使用可查看 注解章节\napi 基础控制器定义\n新建 App/Httpcontroller/Api/ApiBase.php 文件，编辑内容如下：\n&lt;?php\n\nnamespace App\\HttpController\\Api;\n\nuse App\\HttpController\\BaseController;\nuse EasySwoole\\EasySwoole\\Core;\nuse EasySwoole\\EasySwoole\\Trigger;\nuse EasySwoole\\Http\\Message\\Status;\nuse EasySwoole\\HttpAnnotation\\Exception\\Annotation\\ParamValidateError;\n\nabstract class ApiBase extends BaseController\n{\n    public function index()\n    {\n        // TODO: Implement index() method.\n        $this-&gt;actionNotFound('index');\n    }\n\n    protected function actionNotFound(?string $action): void\n    {\n        $this-&gt;writeJson(Status::CODE_NOT_FOUND);\n    }\n\n    public function onRequest(?string $action): ?bool\n    {\n        if (!parent::onRequest($action)) {\n            return false;\n        }\n        return true;\n    }\n\n    protected function onException(\\Throwable $throwable): void\n    {\n        if ($throwable instanceof ParamValidateError) {\n            $msg = $throwable-&gt;getValidate()-&gt;getError()-&gt;getErrorRuleMsg();\n            $this-&gt;writeJson(400, null, \"{$msg}\");\n        } else {\n            if (Core::getInstance()-&gt;runMode() == 'dev') {\n                $this-&gt;writeJson(500, null, $throwable-&gt;getMessage());\n            } else {\n                Trigger::getInstance()-&gt;throwable($throwable);\n                $this-&gt;writeJson(500, null, '系统内部错误，请稍后重试');\n            }\n        }\n    }\n}\n上述 api 基类控制器 (ApiBase.php)，用于拦截注解异常，以及 api 异常时给用户返回一个 json 格式错误信息。\n公共基础控制器定义\n新建 App/Httpcontroller/Api/Common/CommonBase.php 文件，编辑内容如下：\n&lt;?php\n\nnamespace App\\HttpController\\Api\\Common;\n\nuse App\\HttpController\\Api\\ApiBase;\n\nclass CommonBase extends ApiBase\n{\n\n}\n公共控制器\n公共控制器放不需要登陆即可查看的控制器，例如 banner 列表查看：\n新增 App/HttpController/Api/Common/Banner.php 文件，编辑内容如下：\n&lt;?php\n\nnamespace App\\HttpController\\Api\\Common;\n\nuse App\\Model\\Admin\\BannerModel;\nuse EasySwoole\\Http\\Message\\Status;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\Param;\n\n/**\n * Class Banner\n */\nclass Banner extends CommonBase\n{\n\n    /**\n     * getOne\n     * @Param(name=\"bannerId\", alias=\"主键id\", required=\"\", integer=\"\")\n     * @throws \\EasySwoole\\ORM\\Exception\\Exception\n     * @throws \\Throwable\n     * @author Tioncico\n     * Time: 14:03\n     */\n    public function getOne()\n    {\n        $param = $this-&gt;request()-&gt;getRequestParam();\n        $model = new BannerModel();\n        $bean = $model-&gt;get($param['bannerId']);\n        if ($bean) {\n            $this-&gt;writeJson(Status::CODE_OK, $bean, \"success\");\n        } else {\n            $this-&gt;writeJson(Status::CODE_BAD_REQUEST, [], 'fail');\n        }\n    }\n\n    /**\n     * getAll\n     * @Param(name=\"page\", alias=\"页数\", optional=\"\", integer=\"\")\n     * @Param(name=\"limit\", alias=\"每页总数\", optional=\"\", integer=\"\")\n     * @Param(name=\"keyword\", alias=\"关键字\", optional=\"\", lengthMax=\"32\")\n     * @throws \\EasySwoole\\ORM\\Exception\\Exception\n     * @author Tioncico\n     * Time: 14:02\n     */\n    public function getAll()\n    {\n        $param = $this-&gt;request()-&gt;getRequestParam();\n        $page = $param['page'] ?? 1;\n        $limit = $param['limit'] ?? 20;\n        $model = new BannerModel();\n        $data = $model-&gt;getAll($page, 1, $param['keyword'] ?? null, $limit);\n        $this-&gt;writeJson(Status::CODE_OK, $data, 'success');\n    }\n}\n注意：可以看到，在上文 getAll 方法中，有个特殊的 @Param(name=\"page\", alias=\"页数\", optional=\"\", integer =\"\") 的注释，这个是有特殊含义的，是注解支持写法，类似 Java 语言的注解，可以使用这种注解写法，也可以不使用，用户可自行选择。当写上这个注释之后，将会约束 page 参数必须是 int ，具体的验证机制可查看 validate 验证器 章节。不写这个注释则没有约束。框架中如何使用注解请查看 注解 章节\n使用 php easyswoole server start 命令启动框架服务之后，访问链接：http://127.0.0.1:9501/api/common/banner/getAll (示例访问地址) 即可看到如下结果：{\"code\":200,\"result\":{\"total\":1,\"list\":[{\"bannerId\":1,\"bannerName\":\"测试banner\",\"bannerImg\":\"asdadsasdasd.jpg\",\"bannerDescription\":\"测试的banner数据\",\"bannerUrl\":\"www.php20.cn\",\"state\":1}]},\"msg\":\"success\"} (需要有数据才能看到具体输出)。\n管理员基础控制器定义\n新建 App/HttpController/Api/Admin/AdminBase.php 文件，编辑内容如下：\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: yf\n * Date: 2018/10/26\n * Time: 5:39 PM\n */\n\nnamespace App\\HttpController\\Api\\Admin;\n\nuse App\\HttpController\\Api\\ApiBase;\nuse App\\Model\\Admin\\AdminModel;\nuse EasySwoole\\Http\\Message\\Status;\n\nclass AdminBase extends ApiBase\n{\n    // public 才会根据协程清除\n    public $who;\n    // session 的 cookie头\n    protected $sessionKey = 'adminSession';\n    // 白名单\n    protected $whiteList = [];\n\n    /**\n     * onRequest\n     * @param null|string $action\n     * @return bool|null\n     * @throws \\Throwable\n     * @author yangzhenyu\n     * Time: 13:49\n     */\n    public function onRequest(?string $action): ?bool\n    {\n        if (parent::onRequest($action)) {\n            // 白名单判断\n            if (in_array($action, $this-&gt;whiteList)) {\n                return true;\n            }\n            // 获取登入信息\n            if (!$this-&gt;getWho()) {\n                $this-&gt;writeJson(Status::CODE_UNAUTHORIZED, '', '登入已过期');\n                return false;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * getWho\n     * @return null|AdminModel\n     * @author yangzhenyu\n     * Time: 13:51\n     */\n    public function getWho(): ?AdminModel\n    {\n        if ($this-&gt;who instanceof AdminModel) {\n            return $this-&gt;who;\n        }\n        $sessionKey = $this-&gt;request()-&gt;getRequestParam($this-&gt;sessionKey);\n        if (empty($sessionKey)) {\n            $sessionKey = $this-&gt;request()-&gt;getCookieParams($this-&gt;sessionKey);\n        }\n        if (empty($sessionKey)) {\n            return null;\n        }\n        $adminModel = new AdminModel();\n        $adminModel-&gt;adminSession = $sessionKey;\n        $this-&gt;who = $adminModel-&gt;getOneBySession();\n        return $this-&gt;who;\n    }\n}\n管理员登录控制器\n新建 App/HttpController/Api/Admin/Auth.php 文件，编辑内容如下：\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: yf\n * Date: 2018/10/26\n * Time: 5:39 PM\n */\n\nnamespace App\\HttpController\\Api\\Admin;\n\nuse App\\Model\\Admin\\AdminModel;\nuse EasySwoole\\Http\\Message\\Status;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\Param;\n\nclass Auth extends AdminBase\n{\n    protected $whiteList = ['login'];\n\n    /**\n     * login\n     * 登陆,参数验证注解写法\n     * @\\EasySwoole\\HttpAnnotation\\AnnotationTag\\Param(name=\"account\", alias=\"帐号\", required=\"\", lengthMax=\"20\")\n     * @Param(name=\"password\", alias=\"密码\", required=\"\", lengthMin=\"6\", lengthMax=\"16\")\n     * @throws \\EasySwoole\\ORM\\Exception\\Exception\n     * @throws \\Throwable\n     * @author Tioncico\n     * Time: 10:18\n     */\n    public function login()\n    {\n        $param = $this-&gt;request()-&gt;getRequestParam();\n        $model = new AdminModel();\n        $model-&gt;adminAccount = $param['account'];\n        $model-&gt;adminPassword = md5($param['password']);\n\n        if ($user = $model-&gt;login()) {\n            $sessionHash = md5(time() . $user-&gt;adminId);\n            $user-&gt;update([\n                'adminLastLoginTime' =&gt; time(),\n                'adminLastLoginIp'   =&gt; $this-&gt;clientRealIP(),\n                'adminSession'       =&gt; $sessionHash\n            ]);\n\n            $rs = $user-&gt;toArray();\n            unset($rs['adminPassword']);\n            $rs['adminSession'] = $sessionHash;\n            $this-&gt;response()-&gt;setCookie('adminSession', $sessionHash, time() + 3600, '/');\n            $this-&gt;writeJson(Status::CODE_OK, $rs);\n        } else {\n            $this-&gt;writeJson(Status::CODE_BAD_REQUEST, '', '密码错误');\n        }\n    }\n\n    /**\n     * logout\n     * 退出登录,参数注解写法\n     * @Param(name=\"adminSession\", from={COOKIE}, required=\"\")\n     * @return bool\n     * @author Tioncico\n     * Time: 10:23\n     */\n    public function logout()\n    {\n        $sessionKey = $this-&gt;request()-&gt;getRequestParam($this-&gt;sessionKey);\n        if (empty($sessionKey)) {\n            $sessionKey = $this-&gt;request()-&gt;getCookieParams('adminSession');\n        }\n        if (empty($sessionKey)) {\n            $this-&gt;writeJson(Status::CODE_UNAUTHORIZED, '', '尚未登入');\n            return false;\n        }\n        $result = $this-&gt;getWho()-&gt;logout();\n        if ($result) {\n            $this-&gt;writeJson(Status::CODE_OK, '', \"登出成功\");\n        } else {\n            $this-&gt;writeJson(Status::CODE_UNAUTHORIZED, '', 'fail');\n        }\n    }\n\n    public function getInfo()\n    {\n        $this-&gt;writeJson(200, $this-&gt;getWho()-&gt;toArray(), 'success');\n    }\n}\n使用 php easyswoole server start 命令启动框架服务之后，访问链接：http://127.0.0.1:9501/Api/Admin/Auth/login?account=xsk&password=123456 (示例访问地址) 即可返回如下结果：``\n{\n  \"code\": 200,\n  \"result\": {\n    \"adminId\": 1,\n    \"adminName\": \"仙士可\",\n    \"adminAccount\": \"xsk\",\n    \"adminSession\": \"b27caf58312d5d4ffc9de42ebf322135\",\n    \"adminLastLoginTime\": 1615653249,\n    \"adminLastLoginIp\": \"192.168.65.1\"\n  },\n  \"msg\": null\n}\n管理员用户管理控制器\n新增 App/httpController/Api/Admin/User.php 文件，编辑内容如下：\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: yf\n * Date: 2018/10/26\n * Time: 5:39 PM\n */\n\nnamespace App\\HttpController\\Api\\Admin;\n\nuse App\\Model\\User\\UserModel;\nuse EasySwoole\\Http\\Message\\Status;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\Param;\n\nclass User extends AdminBase\n{\n    /**\n     * getAll\n     * @Param(name=\"page\", alias=\"页数\", optional=\"\", integer=\"\")\n     * @Param(name=\"limit\", alias=\"每页总数\", optional=\"\", integer=\"\")\n     * @Param(name=\"keyword\", alias=\"关键字\", optional=\"\", lengthMax=\"32\")\n     * @author Tioncico\n     * Time: 14:01\n     */\n    function getAll()\n    {\n        $page = (int)$this-&gt;input('page', 1);\n        $limit = (int)$this-&gt;input('limit', 20);\n        $model = new UserModel();\n        $data = $model-&gt;getAll($page, $this-&gt;input('keyword'), $limit);\n        $this-&gt;writeJson(Status::CODE_OK, $data, 'success');\n    }\n\n    /**\n     * getOne\n     * @Param(name=\"userId\", alias=\"用户id\", required=\"\", integer=\"\")\n     * @throws \\EasySwoole\\ORM\\Exception\\Exception\n     * @throws \\Throwable\n     * @author Tioncico\n     * Time: 11:48\n     */\n    function getOne()\n    {\n        $param = $this-&gt;request()-&gt;getRequestParam();\n        $model = new UserModel();\n        $rs = $model-&gt;get($param['userId']);\n        if ($rs) {\n            $this-&gt;writeJson(Status::CODE_OK, $rs, \"success\");\n        } else {\n            $this-&gt;writeJson(Status::CODE_BAD_REQUEST, [], 'fail');\n        }\n    }\n\n    /**\n     * add\n     * @Param(name=\"userName\", alias=\"用户昵称\", optional=\"\", lengthMax=\"32\")\n     * @Param(name=\"userAccount\", alias=\"用户名\", required=\"\", lengthMax=\"32\")\n     * @Param(name=\"userPassword\", alias=\"用户密码\", required=\"\", lengthMin=\"6\",lengthMax=\"18\")\n     * @Param(name=\"phone\", alias=\"手机号码\", optional=\"\", lengthMax=\"18\",numeric=\"\")\n     * @Param(name=\"state\", alias=\"用户状态\", optional=\"\", inArray=\"{0,1}\")\n     * @author Tioncico\n     * Time: 11:48\n     */\n    function add()\n    {\n        $param = $this-&gt;request()-&gt;getRequestParam();\n        $model = new UserModel($param);\n        $model-&gt;userPassword = md5($param['userPassword']);\n        $rs = $model-&gt;save();\n        if ($rs) {\n            $this-&gt;writeJson(Status::CODE_OK, $rs, \"success\");\n        } else {\n            $this-&gt;writeJson(Status::CODE_BAD_REQUEST, [], $model-&gt;lastQueryResult()-&gt;getLastError());\n        }\n    }\n\n    /**\n     * update\n     * @Param(name=\"userId\", alias=\"用户id\", required=\"\", integer=\"\")\n     * @Param(name=\"userPassword\", alias=\"会员密码\", optional=\"\", lengthMin=\"6\",lengthMax=\"18\")\n     * @Param(name=\"userName\", alias=\"会员名\", optional=\"\",  lengthMax=\"32\")\n     * @Param(name=\"state\", alias=\"状态\", optional=\"\", inArray=\"{0,1}\")\n     * @Param(name=\"phone\", alias=\"手机号\", optional=\"\",  lengthMax=\"18\")\n     * @throws \\EasySwoole\\ORM\\Exception\\Exception\n     * @throws \\Throwable\n     * @author Tioncico\n     * Time: 11:54\n     */\n    function update()\n    {\n        $model = new UserModel();\n        /**\n         * @var $userInfo UserModel\n         */\n        $userInfo = $model-&gt;get($this-&gt;input('userId'));\n        if (!$userInfo) {\n            $this-&gt;writeJson(Status::CODE_BAD_REQUEST, [], '未找到该会员');\n        }\n        $password = $this-&gt;input('userPassword');\n        $update = [\n            'userName' =&gt; $this-&gt;input('userName', $userInfo-&gt;userName),\n            'userPassword' =&gt; $password ? md5($password) : $userInfo-&gt;userPassword,\n            'state' =&gt; $this-&gt;input('state', $userInfo-&gt;state),\n            'phone' =&gt; $this-&gt;input('phone', $userInfo-&gt;phone),\n        ];\n\n        $rs = $model-&gt;update($update);\n        if ($rs) {\n            $this-&gt;writeJson(Status::CODE_OK, $rs, \"success\");\n        } else {\n            $this-&gt;writeJson(Status::CODE_BAD_REQUEST, [], $model-&gt;lastQueryResult()-&gt;getLastError());\n        }\n    }\n\n    /**\n     * delete\n     * @Param(name=\"userId\", alias=\"用户id\", required=\"\", integer=\"\")\n     * @throws \\EasySwoole\\ORM\\Exception\\Exception\n     * @throws \\Throwable\n     * @author Tioncico\n     * Time: 14:02\n     */\n    function delete()\n    {\n        $param = $this-&gt;request()-&gt;getRequestParam();\n        $model = new UserModel();\n        $rs = $model-&gt;destroy($param['userId']);\n        if ($rs) {\n            $this-&gt;writeJson(Status::CODE_OK, $rs, \"success\");\n        } else {\n            $this-&gt;writeJson(Status::CODE_BAD_REQUEST, [], '删除失败');\n        }\n    }\n}\n后台管理员登录之后，可通过此文件的接口，去进行会员的增删改查操作 (即 CURD)。\n请求地址为：(示例访问地址) http://127.0.0.1:9501/Api/Admin/User/getAll (等方法)\n普通用户基础控制器定义\n新增 App/HttpController/Api/User/UserBase.php 文件，编辑内容如下：\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: yf\n * Date: 2018/10/26\n * Time: 5:39 PM\n */\n\nnamespace App\\HttpController\\Api\\User;\n\nuse App\\HttpController\\Api\\ApiBase;\nuse App\\Model\\User\\UserModel;\nuse EasySwoole\\Http\\Message\\Status;\n\nclass UserBase extends ApiBase\n{\n    protected $who;\n    // session 的 cookie 头\n    protected $sessionKey = 'userSession';\n    // 白名单\n    protected $whiteList = ['login', 'register'];\n\n    /**\n     * onRequest\n     * @param null|string $action\n     * @return bool|null\n     * @throws \\Throwable\n     * @author yangzhenyu\n     * Time: 13:49\n     */\n    function onRequest(?string $action): ?bool\n    {\n        if (parent::onRequest($action)) {\n            // 白名单判断\n            if (in_array($action, $this-&gt;whiteList)) {\n                return true;\n            }\n            // 获取登入信息\n            if (!$data = $this-&gt;getWho()) {\n                $this-&gt;writeJson(Status::CODE_UNAUTHORIZED, '', '登入已过期');\n                return false;\n            }\n            // 刷新 cookie 存活\n            $this-&gt;response()-&gt;setCookie($this-&gt;sessionKey, $data-&gt;userSession, time() + 3600, '/');\n\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * getWho\n     * @author yangzhenyu\n     * Time: 13:51\n     */\n    function getWho(): ?UserModel\n    {\n        if ($this-&gt;who instanceof UserModel) {\n            return $this-&gt;who;\n        }\n        $sessionKey = $this-&gt;request()-&gt;getRequestParam($this-&gt;sessionKey);\n        if (empty($sessionKey)) {\n            $sessionKey = $this-&gt;request()-&gt;getCookieParams($this-&gt;sessionKey);\n        }\n        if (empty($sessionKey)) {\n            return null;\n        }\n        $userModel = new UserModel();\n        $userModel-&gt;userSession = $sessionKey;\n        $this-&gt;who = $userModel-&gt;getOneBySession();\n        return $this-&gt;who;\n    }\n}\n普通用户登录控制器\n新增 App/HttpController/Api/User/Auth.php 文件，编辑内容如下：\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: yf\n * Date: 2018/10/26\n * Time: 5:39 PM\n */\n\nnamespace App\\HttpController\\Api\\User;\n\nuse App\\HttpController\\Api\\User\\UserBase;\nuse App\\Model\\User\\UserModel;\nuse EasySwoole\\Http\\Message\\Status;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\Param;\n\nclass Auth extends UserBase\n{\n    protected $whiteList = ['login', 'register'];\n\n    /**\n     * login\n     * @Param(name=\"userAccount\", alias=\"用户名\", required=\"\", lengthMax=\"32\")\n     * @Param(name=\"userPassword\", alias=\"密码\", required=\"\", lengthMin=\"6\",lengthMax=\"18\")\n     * @throws \\EasySwoole\\ORM\\Exception\\Exception\n     * @throws \\Throwable\n     * @author Tioncico\n     * Time: 15:06\n     */\n    public function login()\n    {\n        $param = $this-&gt;request()-&gt;getRequestParam();\n        $model = new UserModel();\n        $model-&gt;userAccount = $param['userAccount'];\n        $model-&gt;userPassword = md5($param['userPassword']);\n\n        if ($userInfo = $model-&gt;login()) {\n            $sessionHash = md5(time() . $userInfo-&gt;userId);\n            $userInfo-&gt;update([\n                'lastLoginIp' =&gt; $this-&gt;clientRealIP(),\n                'lastLoginTime' =&gt; time(),\n                'userSession' =&gt; $sessionHash\n            ]);\n            $rs = $userInfo-&gt;toArray();\n            unset($rs['userPassword']);\n            $rs['userSession'] = $sessionHash;\n            $this-&gt;response()-&gt;setCookie('userSession', $sessionHash, time() + 3600, '/');\n            $this-&gt;writeJson(Status::CODE_OK, $rs);\n        } else {\n            $this-&gt;writeJson(Status::CODE_BAD_REQUEST, '', '密码错误');\n        }\n    }\n\n    public function logout()\n    {\n        $sessionKey = $this-&gt;request()-&gt;getRequestParam('userSession');\n        if (empty($sessionKey)) {\n            $sessionKey = $this-&gt;request()-&gt;getCookieParams('userSession');\n        }\n        if (empty($sessionKey)) {\n            $this-&gt;writeJson(Status::CODE_UNAUTHORIZED, '', '尚未登入');\n            return false;\n        }\n        $result = $this-&gt;getWho()-&gt;logout();\n        if ($result) {\n            $this-&gt;writeJson(Status::CODE_OK, '', \"登出成功\");\n        } else {\n            $this-&gt;writeJson(Status::CODE_UNAUTHORIZED, '', 'fail');\n        }\n    }\n\n    public function getInfo()\n    {\n        $this-&gt;writeJson(200, $this-&gt;getWho(), 'success');\n    }\n}\n访问 http://127.0.0.1:9501/Api/User/Auth/login?userAccount=xsk&amp;userPassword=123456 即可登录成功。\n\n管理员登录：(示例访问地址) http://127.0.0.1:9501/Api/Admin/Auth/login?account=xsk&password=123456 \n公共请求 banner：(示例访问地址) http://127.0.0.1:9501/Api/Common/Banner/getAll\n会员登录：(示例访问地址) http://127.0.0.1:9501/Api/User/Auth/login?userAccount=xsk&userPassword=123456\n","link":"/QuickStart/example.html"},{"id":63,"title":"什么是协程","content":"协程\n协程不是进程或线程，其执行过程更类似于子例程，或者说不带返回值的函数调用。   \n一个程序可以包含多个协程，可以对比与一个进程包含多个线程，因而下面我们来比较协程和线程。而多个线程相对独立，有自己的上下文，切换受系统控制；\n而协程也相对独立，有自己的上下文，但是其切换由自己控制，由当前协程切换到其他协程由当前协程来控制。\n\n协程执行顺序\n原生 php 代码:\n&lt;?php\nfunction task1()\n{\n    for ($i = 0; $i &lt;= 300; $i++) {\n        // 写入文件，大概要 3000 微秒\n        usleep(3000);\n        echo \"写入文件{$i}\\n\";\n    }\n}\n\nfunction task2()\n{\n    for ($i = 0; $i &lt;= 500; $i++) {\n        // 发送邮件给 500 名会员，大概 3000 微秒\n        usleep(3000);\n        echo \"发送邮件{$i}\\n\";\n    }\n}\n\nfunction task3()\n{\n    for ($i = 0; $i &lt;= 100; $i++) {\n        // 模拟插入 100 条数据，大概 3000 微秒\n        usleep(3000);\n        echo \"插入数据{$i}\\n\";\n    }\n}\n\ntask1();\ntask2();\ntask3();\n在这个代码中，我们主要做了 3 件事：写入文件、发送邮件、及插入数据。\n再看下面这段代码：\n&lt;?php\nfunction task1($i)\n{\n    // 使用 $i 标识 写入文件,，大概要3000微秒\n    if ($i &gt; 300) {\n        return false;// 超过 300 不用写了\n    }\n    echo \"写入文件{$i}\\n\";\n    usleep(3000);\n    return true;\n}\n\nfunction task2($i)\n{\n    // 使用 $i 标识 发送邮件，大概要 3000 微秒\n    if ($i &gt; 500) {\n        return false;// 超过 500 不用发送了\n    }\n    echo \"发送邮件{$i}\\n\";\n    usleep(3000);\n    return true;\n}\n\nfunction task3($i)\n{\n    // 使用 $i 标识 插入数据，大概要 3000 微秒\n    if ($i &gt; 100) {\n        return false;// 超过 100 不用插入\n    }\n    echo \"插入数据{$i}\\n\";\n    usleep(3000);\n    return true;\n}\n\n$i = 0;\n$task1Result = true;\n$task2Result = true;\n$task3Result = true;\nwhile (true) {\n    $task1Result &amp;&amp; $task1Result = task1($i);\n    $task2Result &amp;&amp; $task2Result = task2($i);\n    $task3Result &amp;&amp; $task3Result = task3($i);\n    if ($task1Result === false &amp;&amp; $task2Result === false &amp;&amp; $task3Result === false) {\n        break;// 全部任务完成,退出循环\n    }\n    $i++;\n}\n这段代码也是做了 3 件事，写入文件、发送邮件和插入数据。但是和上面的不同的是，这段代码将这 3 件事交叉执行，每个任务执行完一次之后，切换到另一个任务，如此循环。类似于这样的执行顺序，就是协程。\n\n协程是指一种用代码实现任务交叉执行的逻辑，协程可以使得代码 1 中的 3 个函数交叉运行，在实现了协程的框架中，我们不需要通过代码 2 的方法实现任务交叉执行。直接可让代码 1 中的 while(1)，执行一次后切换。\n\n协程的实现\n在 php 中，实现协程主要使用 2 种方式: \n\n\nyield 生成器实现 (详细原理可查看 http://www.php20.cn/article/148)\n\nswoole 扩展实现\n\nswoole 实现协程代码:\n&lt;?php\nfunction task1()\n{\n    for ($i = 0; $i &lt;= 300; $i++) {\n        // 写入文件，大概要 3000 微秒\n        usleep(3000);\n        echo \"写入文件{$i}\\n\";\n        Co::sleep(0.001);// 挂起当前协程，0.001 秒后恢复 // 相当于切换协程\n    }\n}\n\nfunction task2()\n{\n    for ($i = 0; $i &lt;= 500; $i++) {\n        // 发送邮件给 500 名会员，大概 3000 微秒\n        usleep(3000);\n        echo \"发送邮件{$i}\\n\";\n        Co::sleep(0.001);// 挂起当前协程，0.001 秒后恢复 // 相当于切换协程\n    }\n}\n\nfunction task3()\n{\n    for ($i = 0; $i &lt;= 100; $i++) {\n        // 模拟插入 100 条数据，大概 3000 微秒\n        usleep(3000);\n        echo \"插入数据{$i}\\n\";\n        Co::sleep(0.001);// 挂起当前协程，0.001 秒后恢复 // 相当于切换协程\n    }\n}\n\n$pid1 = go('task1');// go 函数是 swoole 的开启协程函数，用于开启一个协程\n$pid2 = go('task2');\n$pid3 = go('task3');\n以上代码，即可实现切换函数。\n\n为什么要用 sleep 挂起协程实现切换呢？因为 swoole 的协程是自动的，当协程内遇上 I/O 操作 (mysql、redis) 等时，swoole 的协程会自动切换，运行到下一个协程任务中 (切换后，I/O继续执行)，直到下一个协程任务完成或者被切换 (遇上 I/O)，如此反复，直到所有协程任务完成，则任务完成。\n\n协程与进程\n由上面的 协程执行顺序 中的代码 2，我们很容易发现，协程其实只是运行在一个进程中的函数，只是这个函数会被切换到下一个执行，可以这么说：\n\n协程只是一串运行在进程中的任务代码，只是这些任务代码可以交叉运行。\n注意，协程并不是多任务并行，属于多任务串行，每个进程在一个时间只执行了一个任务。\n","link":"/QuickStart/Coroutine/introduction.html"},{"id":64,"title":"创建协程","content":"协程\n从 4.0 版本开始 Swoole 提供了完整的协程（Coroutine）+ 通道（Channel）特性，带来全新的 CSP 编程模型。应用层可使用完全同步的编程方式，底层自动实现异步IO。\n协程可以理解为纯用户态的线程，其通过协作而不是抢占来进行切换。相对于进程或者线程，协程所有的操作都可以在用户态完成，创建和切换的消耗更低。Swoole 可以为每一个请求创建对应的协程，根据 IO 的状态来合理的调度协程，这会带来了以下优势：\n\n开发者可以无感知的用同步的代码编写方式达到 异步IO 的效果和性能，避免了传统异步回调所带来的离散的代码逻辑和陷入多层回调中导致代码无法维护；\n同时由于底层封装了协程，所以对比传统的 PHP 层协程框架，开发者不需要使用 yield 关键词来标识一个 协程IO操作，所以不再需要对 yield 的语义进行深入理解以及对每一级的调用都修改为 yield，这极大地提高了开发效率；\n可以满足大部分开发者的需求。对于私有协议，开发者可以使用协程的 TCP 或者 UDP 接口去方便的封装。\n\n注意事项\n\n全局变量：协程使得原有的异步逻辑同步化，但是在协程中的切换是隐式发生的，所以在协程中切换的前后不能保证 全局变量 以及 static 变量 的一致性。\n\nswoole 协程与 xdebug、xhprof、blackfire 等 zend 扩展不兼容，例如不能使用 xhprof 对 协程 server 进行性能分析采样。\n\n在 EasySwoole 中使用和创建协程\n当提示类似 PHP Fatal error:  Uncaught Swoole\\Error: API must be called in the coroutine in /root/easyswoole/test_coroutine.php:7 错误时，说明该 API 必须在协程环境下使用。\n在 EasySwoole 框架主进程中使用协程\n这里所说的主进程主要指的是在 EasySwoole 服务启动前调用协程 API 的需求，包括在 EasySwoole 的 bootstrap 事件、initialize 事件、mainServerCreate 事件 中使用协程。关于前文提到的事件详细请看 全局事件\n简单使用示例如下：\n&lt;?php\n$scheduler = new \\Swoole\\Coroutine\\Scheduler();\n$scheduler-&gt;add(function() {\n    /* 调用协程API */\n\n    // 用户可以在这里调用上述协程 API\n\n});\n$scheduler-&gt;start();\n// 清除全部定时器\n\\Swoole\\Timer::clearAll();\n在 EasySwoole 框架 Worker 进程中使用协程\n这里所说的 Worker 进程是指 EasySwoole 服务启动之后的进程中调用协程 API 的需求，主要包括在 Http 控制器、自定义进程 等进程中调用协程 API。\n简单使用示例如下：\n&lt;?php\n\\Swoole\\Coroutine::create(function () {\n    /* 调用协程API */\n\n    // 用户可以在这里调用上述协程 API\n});\n\n// 或者使用如下：\ngo(function() {\n    /* 调用协程API */\n\n    // 用户可以在这里调用上述协程 API\n});","link":"/QuickStart/Coroutine/coroutineCreate.html"},{"id":65,"title":"注意事项","content":"协程注意事项\n变量使用\n\n在协程中，需要特别注意，不要使用 $_GET、$_POST、$GLOBALS 等超全局变量，尤其是需要修改变量值并读取时，将造成协程间变量数据错乱。  \n协程中访问外部变量必须使用 use 关键字，或者传形参方式，不能引用变量。  \n如果需要做多协程之间的通信，可使用 channel 方式通信。\n\n扩展冲突\n\n\nswoole 协程与 xdebug、xhprof、blackfire 等 zend 扩展不兼容，例如不能使用 xhprof 对协程 server 进行性能分析采样。\n\n退出协程\n在 Swoole &gt;= v4.1.0 之后，使用 exit 退出将只退出当前协程，并在当前协程抛出一个 Swoole\\ExitException 异常。\n在 Swoole &lt; v4.1.0 时，如果使用 exit，将会造成整个进程退出，禁止使用。  \n通过拦截 Swoole\\ExitException 异常，可获得这次退出的具体异常信息。\n简单使用示例：\n&lt;?php\ngo(function () {\n    try {\n        test();\n    } catch (\\Swoole\\ExitException $exception) {\n        var_dump($exception);\n    }\n});\n\nfunction test()\n{\n    test2();\n}\nfunction test2()\n{\n    exit(2);\n}","link":"/QuickStart/Coroutine/notice.html"},{"id":66,"title":"waitgroup等待","content":"WaitGroup\nEasySwoole 基于 Swoole 的 Channel 封装实现了 Golang 的 sync.WaitGroup 功能。具体使用示例可以看下文：\n提供的方法\n\n\nadd 方法增加计数\n\ndone 表示任务已完成\n\nwait 等待所有任务完成恢复当前协程的执行\n\nWaitGroup 对象可以复用，add、done、wait 之后可以再次使用\n\n使用示例代码\n&lt;?php\ngo(function () {\n    $ret = [];\n\n    $wait = new \\EasySwoole\\Component\\WaitGroup();\n\n    $wait-&gt;add();\n    // 启动第 1 个协程\n    go(function () use ($wait, &amp;$ret) {\n        // 模拟耗时任务 1\n        \\co::sleep(0.1);\n        $ret[] = time();\n        $wait-&gt;done();\n    });\n\n    $wait-&gt;add();\n    // 启动第 2 个协程\n    go(function () use ($wait, &amp;$ret) {\n        // 模拟耗时任务 2\n        \\co::sleep(2);\n        $ret[] = time();\n        $wait-&gt;done();\n    });\n\n    // 挂起当前协程，等待所有任务完成后恢复\n    $wait-&gt;wait();\n\n    // 这里 $ret 包含了 2 个任务执行结果\n    var_dump($ret);\n});","link":"/QuickStart/Coroutine/waitGroup.html"},{"id":67,"title":"csp并发","content":"Csp 并发模式\n使用 子协程(go) + 通道(channel) 实现 Csp 并发模式并发执行。\n当我们需要并发执行某些不相干的请求，并得到结果的时候，例如：\n$sql1-&gt;exec();\n$sql2-&gt;exec();\n$sql2-&gt;exec();\n在以上的代码中，我们没办法最大的节约时间，因为 sql 语句都是顺序执行的，因此我们引入了 Csp 并发编程的概念。\n示例代码\n&lt;?php\ngo(function () {\n    $channel = new \\Swoole\\Coroutine\\Channel();\n    go(function () use ($channel) {\n        // 模拟执行sql\n        \\co::sleep(0.1);\n        $channel-&gt;push(1);\n    });\n    go(function () use ($channel) {\n        // 模拟执行sql\n        \\co::sleep(0.1);\n        $channel-&gt;push(2);\n    });\n    go(function () use ($channel) {\n        // 模拟执行sql\n        \\co::sleep(0.1);\n        $channel-&gt;push(3);\n    });\n\n    $i = 3;\n    while ($i--) {\n        var_dump($channel-&gt;pop());\n    }\n});\n当然，在以上的代码中，我们没有充分地考虑超时等情况\n进一步封装\n&lt;?php\ngo(function () {\n    $csp = new \\EasySwoole\\Component\\Csp();\n    $csp-&gt;add('t1', function () {\n        \\co::sleep(0.1);\n        return 't1 result';\n    });\n    $csp-&gt;add('t2', function () {\n        \\co::sleep(0.1);\n        return 't2 result';\n    });\n\n    var_dump($csp-&gt;exec());\n});\nexec 方法提供了一个默认参数：超时时间(默认为 5s)，当调用 $csp->exec() 后，最长等待 5s 左右会返回结果。如果你在 t2 函数中 co::sleep(6)，那么 5s 后，返回的数据中不会包含 t2 函数的返回数据。","link":"/QuickStart/Coroutine/csp.html"},{"id":68,"title":"上下文管理器","content":"Context上下文管理器\n在Swoole中，由于多个协程是并发执行的，因此不能使用类静态变量/全局变量保存协程上下文内容。使用局部变量是安全的，因为局部变量的值会自动保存在协程栈中，其他协程访问不到协程的局部变量。\n因Swoole属于常驻内存，在特殊情况下声明变量，需要进行手动释放，释放不及时，会导致非常大的内存开销，使服务宕掉。\nContextManager上下文管理器存储变量会自动释放内存，避免开发者不小心而导致的内存增长。\n原理\n\n通过当前协程id以key来存储该变量。\n注册defer函数。\n协程退出时，底层自动触发defer进行回收。\n\n安装\nEasySwoole默认加载该组件，无须开发者引入。在非EasySwoole框架中使用，开发者可自行引入。\n\ncomposer require easyswoole/component\n\n基础例子\nuse EasySwoole\\Component\\Context\\ContextManager;\ngo(function (){\n    ContextManager::getInstance()-&gt;set('key','key in parent');\n    go(function (){\n        ContextManager::getInstance()-&gt;set('key','key in sub');\n        var_dump(ContextManager::getInstance()-&gt;get('key').\" in\");\n    });\n    \\co::sleep(1);\n    var_dump(ContextManager::getInstance()-&gt;get('key').\" out\");\n});\n以上利用上下文管理器来实现协程上下文的隔离。\n自定义处理项\n例如，当有一个key，希望在协程环境中，get的时候执行一次创建，在协程退出的时候可以进行回收，就可以注册一个上下文处理项来实现。该场景可以用于协程内数据库短连接管理。\nuse EasySwoole\\Component\\Context\\ContextManager;\nuse EasySwoole\\Component\\Context\\ContextItemHandlerInterface;\n\nclass Handler implements ContextItemHandlerInterface\n{\n\n    function onContextCreate()\n    {\n        $class = new \\stdClass();\n        $class-&gt;time = time();\n        return $class;\n    }\n\n    function onDestroy($context)\n    {\n        var_dump($context);\n    }\n}\n\nContextManager::getInstance()-&gt;registerItemHandler('key',new Handler());\n\ngo(function (){\n    go(function (){\n        ContextManager::getInstance()-&gt;get('key');\n    });\n    \\co::sleep(1);\n    ContextManager::getInstance()-&gt;get('key');\n});","link":"/Components/Component/context.html"},{"id":69,"title":"php-fpm进程模型","content":"php-fpm进程模型\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://easyswoole.oss-cn-shenzhen.aliyuncs.com/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B1/php-fpm%E4%BB%8B%E7%BB%8D.mp4'\n        };\n    var player=new ckplayer(videoObject);\n\nphp多进程模型介绍(附录)\nphp多进程模型介绍(WorkMan作者公开的pdf)","link":"/Video/Basic/php-fpmProcessModel.html"},{"id":70,"title":"swoole进程模型","content":"swoole进程模型\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://easyswoole.oss-cn-shenzhen.aliyuncs.com/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B1/swoole%E7%9A%84%E7%AE%80%E4%BB%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B%7E2.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/Basic/swooleProcessModel.html"},{"id":71,"title":"swoole生命周期","content":"swoole生命周期\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://easyswoole.oss-cn-shenzhen.aliyuncs.com/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B1/swoole%E5%8F%98%E9%87%8F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/Basic/swooleLifeCycle.html"},{"id":72,"title":"协程简介","content":"协程简介\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://easyswoole.oss-cn-shenzhen.aliyuncs.com/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B1/%E5%8D%8F%E7%A8%8B%E7%AE%80%E4%BB%8B.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/Basic/coroutineIntroduction.html"},{"id":73,"title":"协程带来的影响","content":"协程带来的影响\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://easyswoole.oss-cn-shenzhen.aliyuncs.com/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B1/%E5%8D%8F%E7%A8%8B%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%BD%B1%E5%93%8D.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/Basic/impactOfCoroutine.html"},{"id":74,"title":"序章","content":"序章\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://easyswoole.oss-cn-shenzhen.aliyuncs.com/install/0-1-%e5%ba%8f%e7%ab%a0.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/Install/prologue.html"},{"id":75,"title":"安装git","content":"安装Git\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://easyswoole.oss-cn-shenzhen.aliyuncs.com/install/1-1-%e5%ae%89%e8%a3%85Git.mp4'\n        };\n    var player=new ckplayer(videoObject);\n\n附录\nGit的下载地址","link":"/Video/Install/installGit.html"},{"id":76,"title":"安装virtualbox和vagrant","content":"安装VirtualBox和Vagrant\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://easyswoole.oss-cn-shenzhen.aliyuncs.com/install/1-2-%e5%ae%89%e8%a3%85VirtualBox%e5%92%8cVagrant.mp4'\n        };\n    var player=new ckplayer(videoObject);\n\n附录\nVirtualBox下载地址\nVagrant下载地址\nVagrant的安装及使用-简书-陈小陌丿","link":"/Video/Install/installVagrant.html"},{"id":77,"title":"配置vagrantfile","content":"配置Vagrantfile\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://easyswoole.oss-cn-shenzhen.aliyuncs.com/install/1-3-%e9%85%8d%e7%bd%aeVagrantfile.mp4'\n        };\n    var player=new ckplayer(videoObject);\n\n附录\nVagrant的安装及使用-简书-陈小陌丿\nVagrant-CentOs7.6.box下载地址-微云\n密码：easysw","link":"/Video/Install/configureVagrantFile.html"},{"id":78,"title":"安装运行环境","content":"安装运行环境\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://easyswoole.oss-cn-shenzhen.aliyuncs.com/install/1-4-%e5%ae%89%e8%a3%85%e8%bf%90%e8%a1%8c%e7%8e%af%e5%a2%83.mp4'\n        };\n    var player=new ckplayer(videoObject);\n\n附录\n宝塔-官方网站","link":"/Video/Install/installEnvironment.html"},{"id":79,"title":"安装swoole","content":"安装Swoole\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://easyswoole.oss-cn-shenzhen.aliyuncs.com/install/1-5-%e5%ae%89%e8%a3%85Swoole.mp4'\n        };\n    var player=new ckplayer(videoObject);\n\n附录\nSwoole-GitHub-releases","link":"/Video/Install/installSwoole.html"},{"id":80,"title":"安装composer并配置共享目录","content":"安装Composer并设置共享目录\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://easyswoole.oss-cn-shenzhen.aliyuncs.com/install/1-6-%e5%ae%89%e8%a3%85composer%e5%92%8c%e8%ae%be%e7%bd%ae%e5%85%b1%e4%ba%ab%e7%9b%ae%e5%bd%95.mp4'\n        };\n    var player=new ckplayer(videoObject);\n\n附录\nComposer官方下载地址  不太推荐很慢\nComposer阿里云下载地址","link":"/Video/Install/installComposer.html"},{"id":81,"title":"安装easyswoole","content":"安装EasySwoole\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://easyswoole.oss-cn-shenzhen.aliyuncs.com/install/1-7-%e5%ae%89%e8%a3%85EasySwoole%e6%a1%86%e6%9e%b6.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/Install/installEasySwoole.html"},{"id":82,"title":"http解析与路由","content":"Http解析与路由\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://easyswoole.oss-cn-shenzhen.aliyuncs.com/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B1/EasySwooleHttp%E8%A7%A3%E6%9E%90%E5%92%8C%E8%B7%AF%E7%94%B1%E7%AE%80%E4%BB%8B.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/HttpRelated/route.html"},{"id":83,"title":"controller对象简介和池模型介绍","content":"Controller对象简介和池模型介绍\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://easyswoole.oss-cn-shenzhen.aliyuncs.com/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B1/EasySwooleController%E5%AF%B9%E8%B1%A1%E7%AE%80%E4%BB%8B%E5%92%8C%E6%B1%A0%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/HttpRelated/controllerCharacteristic.html"},{"id":84,"title":"异常处理","content":"异常处理\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://easyswoole.oss-cn-shenzhen.aliyuncs.com/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B1/HTTP%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/HttpRelated/exception.html"},{"id":85,"title":"安装及配置信息注册","content":"安装及配置信息注册\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://easyswoole.oss-cn-shenzhen.aliyuncs.com/es-orm/1.+%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E6%B3%A8%E5%86%8C.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/Orm/install.html"},{"id":86,"title":"定义模型","content":"定义模型\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://easyswoole.oss-cn-shenzhen.aliyuncs.com/es-orm/2.%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9E%8B.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/Orm/defineModel.html"},{"id":87,"title":"查询","content":"查询\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://easyswoole.oss-cn-shenzhen.aliyuncs.com/es-orm/3.%E6%9F%A5%E8%AF%A2.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/Orm/search.html"},{"id":88,"title":"新增","content":"新增\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://easyswoole.oss-cn-shenzhen.aliyuncs.com/es-orm/4.%E6%96%B0%E5%A2%9E.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/Orm/add.html"},{"id":89,"title":"删除","content":"删除\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://easyswoole.oss-cn-shenzhen.aliyuncs.com/es-orm/6.%E5%88%A0%E9%99%A4.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/Orm/del.html"},{"id":90,"title":"更新","content":"更新\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://easyswoole.oss-cn-shenzhen.aliyuncs.com/es-orm/7.%E6%9B%B4%E6%96%B0.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/Orm/update.html"},{"id":91,"title":"模型结果","content":"模型结果\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://easyswoole.oss-cn-shenzhen.aliyuncs.com/es-orm/8.%E6%A8%A1%E5%9E%8B%E7%BB%93%E6%9E%9C.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/Orm/modelResult.html"},{"id":92,"title":"读写分离","content":"读写分离\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://easyswoole.oss-cn-shenzhen.aliyuncs.com/es-orm/9.%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E3%80%82.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/Orm/readWrite.html"},{"id":93,"title":"聚合","content":"聚合\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://easyswoole.oss-cn-shenzhen.aliyuncs.com/es-orm/10.%E8%81%9A%E5%90%88.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/Orm/aggr.html"},{"id":94,"title":"事务","content":"事务\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://easyswoole.oss-cn-shenzhen.aliyuncs.com/es-orm/11.%E4%BA%8B%E5%8A%A1.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/Orm/trans.html"},{"id":95,"title":"修改器、获取器","content":"修改器、获取器\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://easyswoole.oss-cn-shenzhen.aliyuncs.com/es-orm/13.%E4%BF%AE%E6%94%B9%E5%99%A8%E3%80%81%E8%8E%B7%E5%8F%96%E5%99%A8.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/Orm/setterGetter.html"},{"id":96,"title":"invoke","content":"invoke\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://easyswoole.oss-cn-shenzhen.aliyuncs.com/es-orm/14.invoke.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/Orm/invoke.html"},{"id":97,"title":"并发查询","content":"并发查询\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://easyswoole.oss-cn-shenzhen.aliyuncs.com/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B1/%E5%8D%8F%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%9F%A5%E8%AF%A2.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/ExtraVideo/concurrentQuery.html"},{"id":98,"title":"csp编程","content":"Csp编程\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://easyswoole.oss-cn-shenzhen.aliyuncs.com/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B1/%E5%85%A5%E9%97%A8csp.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/ExtraVideo/Csp.html"},{"id":99,"title":"异步任务","content":"异步任务\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://easyswoole.oss-cn-shenzhen.aliyuncs.com/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B1/task.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/ExtraVideo/asyncTask.html"},{"id":100,"title":"自定义进程","content":"自定义进程\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://easyswoole.oss-cn-shenzhen.aliyuncs.com/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B1/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%9B%E7%A8%8B.mp4'\n        };\n    var player=new ckplayer(videoObject);\n\n\n文档传送门 👉 自定义进程","link":"/Video/ExtraVideo/customProcess.html"},{"id":101,"title":"http上传","content":"Http上传\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://easyswoole.oss-cn-shenzhen.aliyuncs.com/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B1/fileupload.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/ExtraVideo/httpUpload.html"},{"id":102,"title":"words-match文本检测","content":"Words-match\n\n\n\n    var videoObject = {\n            container: '.video',\n            variable: 'player',\n            video:'http://easyswoole.oss-cn-shenzhen.aliyuncs.com/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B1/words-match.mp4'\n        };\n    var player=new ckplayer(videoObject);\n","link":"/Video/ExtraVideo/words-match.html"},{"id":103,"title":"docker","content":"Docker部署\nDocker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux 或 Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。\n使用 Docker 部署前，需要用户自行安装Docker。\n部署前必看\n部分机器(例如 Docker 环境)在使用框架时遇到类似 DNS Lookup resolve failed... 错误，请更换机器的 DNS 为阿里云公共 DNS 223.5.5.5 和 223.6.6.6。具体更换步骤可查看 更换 DNS\n镜像拉取\n请在终端执行以下命令\n\ndocker pull easyswoole/easyswoole3\n\ndocker hub上的环境为 php7.4 + swoole4.4.26 + easyswoole 3.4.x\n框架启动\n\ndocker run -ti -p 9501:9501 easyswoole/easyswoole3\n\n默认工作目录为: /easyswoole\n命令执行完成，自动进入工作目录，执行 php easyswoole server start 启动服务，宿主机浏览器访问 http://127.0.0.1:9501/ 即可看到欢迎页。如果访问欢迎页遇到如下情形：not controller class match，请重新执行安装命令 php easyswoole install，并且输入 Y、Y，再次执行 php easyswoole server start 启动服务，就可以正常访问欢迎页了，详见 框架安装。\n如何开发\n可以利用 Docker 的映射功能，将宿主机目录映射到容器中。在被映射的目录中根据框架安装文档重新安装 easyswoole。在宿主机开发，容器内进行同步测试。\n注意，在部分环境下，例如 Win10 系统的 docker 环境。\n不可把虚拟机共享目录作为 EasySwoole 的 Temp 目录，将会因为权限不足无法创建socket。这将产生报错：listen xxxxxx.sock fail， 为此可以手动在dev.php 配置文件里把 Temp 目录改为其他路径即可,如：'/Tmp'\nDockerfile\nDockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。\nFROM centos:8\n\n#version defined\nENV SWOOLE_VERSION 4.4.26\nENV EASYSWOOLE_VERSION 3.4.x\n\n#install libs\nRUN yum install -y curl zip unzip  wget openssl-devel gcc-c++ make autoconf git epel-release\nRUN dnf -y install https://rpms.remirepo.net/enterprise/remi-release-8.rpm\n#install php\nRUN yum --enablerepo=remi install -y php74-php php74-php-devel php74-php-mbstring php74-php-json php74-php-simplexml php74-php-gd\n\nRUN ln -s /opt/remi/php74/root/usr/bin/php /usr/bin/php \\\n    &amp;&amp; ln -s /opt/remi/php74/root/usr/bin/phpize /usr/bin/phpize \\\n    &amp;&amp; ln -s /opt/remi/php74/root/usr/bin/php-config /usr/bin/php-config\n\n# composer\nRUN curl -sS https://getcomposer.org/installer | php \\\n    &amp;&amp; mv composer.phar /usr/bin/composer &amp;&amp; chmod +x /usr/bin/composer\n# use aliyun composer 由于最近阿里云镜像不稳定，废弃使用\n# RUN composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/\n\n# swoole ext\nRUN wget https://github.com/swoole/swoole-src/archive/v${SWOOLE_VERSION}.tar.gz -O swoole.tar.gz \\\n    &amp;&amp; mkdir -p swoole \\\n    &amp;&amp; tar -xf swoole.tar.gz -C swoole --strip-components=1 \\\n    &amp;&amp; rm swoole.tar.gz \\\n    &amp;&amp; ( \\\n    cd swoole \\\n    &amp;&amp; phpize \\\n    &amp;&amp; ./configure --enable-openssl \\\n    &amp;&amp; make \\\n    &amp;&amp; make install \\\n    ) \\\n    &amp;&amp; sed -i \"2i extension=swoole.so\" /etc/opt/remi/php74/php.ini \\\n    &amp;&amp; rm -r swoole\n\n# Dir\nWORKDIR /easyswoole\n# install easyswoole\nRUN cd /easyswoole \\\n    &amp;&amp; composer require easyswoole/easyswoole=${EASYSWOOLE_VERSION} \\\n    &amp;&amp; php vendor/easyswoole/easyswoole/bin/easyswoole install\n\nEXPOSE 9501","link":"/Deploy/docker.html"},{"id":104,"title":"nginx","content":"Nginx部署\nNginx是一款轻量级的Web服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。其特点是占有内存少，并发能力强。可以做为EasySwoole的前置服务器，实现负载均衡等。\nDockerfile\nFROM centos:8\nRUN yum install -y nginx\nVOLUME [\"/data\"]\n\nRUN echo \" \\\nuser nginx; \\\nworker_processes auto; \\\nerror_log /var/log/nginx/error.log; \\\npid /run/nginx.pid; \\\ninclude /usr/share/nginx/modules/*.conf; \\\nevents { \\\n    worker_connections 1024; \\\n} \\\nhttp { \\\n    sendfile            on; \\\n    tcp_nopush          on; \\\n    tcp_nodelay         on; \\\n    keepalive_timeout   65; \\\n    types_hash_max_size 2048; \\\n    include             /etc/nginx/mime.types; \\\n    default_type        application/octet-stream; \\\n    include /etc/nginx/conf.d/*.conf; \\\n    include /data/*.conf; \\\n} \" &gt; /etc/nginx/nginx.conf\n\nWORKDIR /hello\nRUN cd /hello &amp;&amp; echo \"hello world\" &gt; index.html\nRUN echo \" \\\nserver { \\\n    listen 80; \\\n    server_name _; \\\n    location / { \\\n       root /hello; \\\n    } \\\n} \" &gt; /etc/nginx/conf.d/hello.conf\n\nEXPOSE 80\nEXPOSE 443\nDocker使用\ndocker pull easyswoole/nginx\n# 启动容器\ndocker run --privileged -tid -p 80:80 -p 443:443 easyswoole/nginx /usr/sbin/init\n# 进入容器\ndocker exec -ti {CONTAINER ID} bash\n# 检查配置文件语法\nnginx -t\n# 启动nginx \nnginx \n# 停止nginx\nnginx -s stop\n\n可以自己启动的时候-v挂载配置文件目录到/data ,并可以根据实际情况再-v挂载一个目录用于存放静态文件\n\nhttp代理\n# 配置EasySwoole节点 至少需要一个\nupstream easyswoole {\n    server 127.0.0.1:9501;\n    server 127.0.0.1:9502;\n    server 127.0.0.1:9503;\n}\n\nserver {\n    # nginx所监听端口\n    listen 80; \n    # 域名\n    server_name proxy.easyswoole.com;\n\n    location / {\n        # 将客户端host及ip信息转发到对应节点  \n        proxy_set_header Host $http_host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n\n        # 转发Cookie，设置 SameSite\n        proxy_cookie_path / \"/;\";\n\n        # 代理访问真实服务器\n        proxy_pass http://easyswoole;\n    }\n}\nwebsocket代理\n# 配置EasySwoole节点 至少需要一个\nupstream easyswoole {\n    # 将负载均衡模式设置为IP hash，作用：不同的客户端每次请求都会与同一节点进行交互。\n    ip_hash;\n    server 127.0.0.1:9501;\n    server 127.0.0.1:9502;\n    server 127.0.0.1:9503;\n}\n\nserver {\n    listen 80;\n    server_name websocket.easyswoole.com;\n\n    location / {\n        # websocket的header\n        proxy_http_version 1.1;\n        # 升级http1.1到websocket协议\n        proxy_set_header Upgrade websocket;\n        proxy_set_header Connection \"Upgrade\";\n\n        # 将客户端host及ip信息转发到对应节点  \n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header Host $http_host;\n\n        # 客户端与服务端60s之内无交互，将自动断开连接。\n        proxy_read_timeout 60s ;\n\n        # 代理访问真实服务器\n        proxy_pass http://easyswoole;\n    }\n}","link":"/Deploy/nginx.html"},{"id":105,"title":"supervisor","content":"Supervisor部署\nSupervisor是用Python开发的一个client/server服务，是Linux/Unix系统下的一个进程管理工具，不支持Windows系统。很方便的监听、启动、停止、重启一个或多个进程。用Supervisor管理的进程，当一个进程意外被Kill，会自动将它重新拉起，不需要开发者自己编写shell进行进程管理来维护自己的服务。\n安装Supervisor\n采用Ubuntu系统下的安装方式进行演示：\n\napt-get -y install supervisor\n\n创建配置文件\n\nvim /etc/supervisor/conf.d/easyswoole.conf\n\n文件内容如下：\n# 设置应用名称为easyswoole\n[program:easyswoole]\n# 设置运行目录\ndirectory=/data/wwwroot/EasySwoole3.4.x\n# 项目的启动命令\ncommand=php easyswoole server start\n# 设置用户来运行该进程\nuser=www-data\n# 是否随着supervisor启动时 自动启动该应用\nautostart=true\n# 进程退出 是否自动重启进程\nautorestart=true\n# 进程启动多少秒之后被认为是启动成功 默认1s\nstartsecs=1\n# 失败最大尝试次数 默认3\nstartretries=3\n# stderr\nstderr_logfile=/data/wwwlog/easyswoole-stderr.log\n# stdout\nstdout_logfile=/data/wwwlog/easyswoole-stdout.log\n启动Supervisor\n\nservice supervisor start\n\nSupervisorctl\n启动EasySwoole应用\n\nsupervisorctl start easyswoole\n\n停止EasySwoole应用\n\nsupervisorctl stop easyswoole\n\n重启EasySwoole应用\n\nsupervisorctl restart easyswoole\n\n启动EasySwoole应用\n\nsupervisorctl start easyswoole\n\n查看所有监控的应用\n\nsupervisorctl status\n\n重新加载配置文件\n\nsupervisorctl update\n\n重启所有应用\n\nsupervisorctl reload\n","link":"/Deploy/supervisor.html"},{"id":106,"title":"双机热备","content":"双机热备\n1. 介绍\n\n文章主要介绍，EasySwoole 使用双机热备思路实现代码不中断部署。\n\n2. 学习案例\n\n\n\n先部署 9501 服务\n\n\n\n\n单起一个进程，定时轮询 Git 分支是否有新版本发布\n\n\n\n\n如有新版本发布，clone 一份\n\n\n\n\n\ncomposer update 更新库\n\n\n\n\n启动 9502 服务\n\n\n\n\n更改 nginx 配置为 9502 并重启\n\n\n\n\n只要有新版本发布，就轮询上面那几个步骤\n\n整个过程的简单架构图\n\n3. 需要提前了解的知识点\n\nNginx 负载均衡和反向代理\nEasySwoole 自定义进程\nNginx reload 和 restart 的区别\n双机热备\n\n4. Nginx 配置\nnginx.conf 配置文件示例\n\n当有新版本发布的时候 EasySwoole 自定义进程会将 nginx.conf 的端口改为最新服务的端口\n\nworker_processes  1;\n\nevents {\n    worker_connections  1024;\n}\n\nhttp {\n\n    include       mime.types;\n    default_type  application/octet-stream;\n\n    log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                      '$status $body_bytes_sent \"$http_referer\" '\n                      '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n    sendfile        on;\n\n    keepalive_timeout  65;\n\n    ### 轮询配置（这里是重点）\n    upstream  easyswoole_release_upstream {\n        server 127.0.0.1:9501;\n        server 127.0.0.1:9502;\n    }\n\n    include servers/*;\n}\n\nes-release.conf 站点配置文件\n该配置文件在 servers 目录下。（此示例是以 Mac 本地环境作为运行环境） \nserver {\n    listen 80;\n    server_name easyswoole.release.com;\n\n    location / {\n        root html;\n        index index.html index.htm;\n        proxy_pass http://easyswoole_release_upstream; ### 这里是重点\n    }\n    access_log /usr/local/etc/nginx/logs/es.access.log main;\n    error_log /usr/local/etc/nginx/logs/es.error.log error;\n}\n5. EasySwoole 代码实现\n\n代码只提供实现思路，并且这种脚本，最好单独去做，比如用 shell 脚本，防止服务宕机导致无法正常部署代码\n\n创建自定义进程类文件\n&lt;?php\n/**\n * This file is part of EasySwoole.\n *\n * @link https://www.easyswoole.com\n * @document https://www.easyswoole.com\n * @contact https://www.easyswoole.com/Preface/contact.html\n * @license https://github.com/easy-swoole/easyswoole/blob/3.x/LICENSE\n */\n\nnamespace App\\Release;\n\nuse EasySwoole\\Component\\Process\\AbstractProcess;\nuse Swoole\\Coroutine;\n\nclass Release extends AbstractProcess\n{\n    public function dolog($msg, $filename = '/Users/xxx/sites/release_log.log')\n    {\n        if ($msg) {\n            error_log($msg . PHP_EOL, 3, $filename);\n        }\n    }\n\n    protected function run($arg)\n    {\n        go(function () {\n            while (true) {\n                $shellLog = ' 2&gt;&gt; /Users/xxx/sites/release_log.log';\n                $this-&gt;dolog(date('Y-m-d H:i:s') . '开始检测代码是否更新 ===&gt; START &lt;=== ');\n                // 检查 Git 是否有新代码发布\n                $diffExec = 'cd ' . EASYSWOOLE_ROOT . '; git fetch; git diff --stat master origin/master;';\n                $this-&gt;dolog($diffExec);\n                $pullResult = exec($diffExec);\n\n                $this-&gt;dolog('git fetch res: =&gt; ' . json_encode($pullResult));\n\n                if ($pullResult !== '') {\n                    $this-&gt;dolog('有新版本发布' . json_encode($pullResult));\n                    // 新版本项目的目录\n                    $newVersionPath = '/Users/xxx/sites/release-' . time();\n\n                    // 开始 clone, 初始化代码\n                    ### 这里需要换成自己的 EasySwoole 项目的 github 地址\n                    $cloneExec = \"git clone https://github.com/huizhang-Easyswoole/release.git {$newVersionPath} {$shellLog};cd {$newVersionPath} {$shellLog};composer update {$shellLog}; {$shellLog}\";\n                    $this-&gt;dolog($cloneExec);\n\n                    $res = exec($cloneExec, $output, $returnVar);\n                    $this-&gt;dolog('git clone res: =&gt; ' . json_encode($res, JSON_UNESCAPED_UNICODE));\n                    $this-&gt;dolog('新版本代码 clone end');\n\n                    // 判断当前是哪个端口正在服务\n                    $lsofExec = \"lsof -i:9501 {$shellLog}\";\n                    $this-&gt;dolog($lsofExec);\n                    $lsofResult = exec($lsofExec);\n                    $newPort = 9501;\n                    $oldPort = 9502;\n                    if ($lsofResult !== '') {\n                        $newPort = 9502;\n                        $oldPort = 9501;\n                    }\n\n                    // 将另一个闲置的端口，替换到新版本中\n                    $this-&gt;dolog('开始替换端口' . $newPort);\n                    $devConfig = file_get_contents($newVersionPath . '/dev.php');\n                    $devConfig = str_replace($oldPort, $newPort, $devConfig);\n                    file_put_contents($newVersionPath . '/dev.php', $devConfig);\n\n                    // 启动新服务(这一刻新旧服务是同时存在的)\n                    $this-&gt;dolog('新服务启动');\n                    $startExec = \"cd {$newVersionPath}; php easyswoole server start -d {$shellLog}\";\n                    $this-&gt;dolog($startExec);\n                    exec($startExec);\n\n                    // 替换 Nginx 配置\n                    $this-&gt;dolog('开始替换 nginx 端口');\n                    ### 这里需要换成自己服务器环境 nginx 配置文件所在的目录\n                    $ngConfigPath = '/usr/local/etc/nginx/nginx.conf';\n                    $ngConfig = file_get_contents($ngConfigPath);\n                    $ngConfig = str_replace($oldPort, $newPort, $ngConfig);\n                    file_put_contents($ngConfigPath, $ngConfig);\n\n                    // 重启 Nginx 服务\n                    $this-&gt;dolog('重启 nginx ');\n                    $reloadNgExec = \"nginx -s reload {$shellLog}\";\n                    $this-&gt;dolog($reloadNgExec);\n                    exec($reloadNgExec);\n\n                    // 停掉旧服务\n                    $this-&gt;dolog('旧服务停掉');\n                    $stopExec = \"cd \" . EASYSWOOLE_ROOT . \"; php easyswoole server stop {$shellLog}\";\n                    $this-&gt;dolog($stopExec);\n                    exec($stopExec);\n\n                    // 每 30 秒同步一次代码\n                    Coroutine::sleep(30);\n                } else {\n                    Coroutine::sleep(10);\n                    $this-&gt;dolog('无新版本更新');\n                }\n            }\n        });\n    }\n}\n注册自定义进程\n在框架的 EasySwooleEvent 事件（即项目根目录的 EasySwoolEvent.php）中注册自定义进程，示例代码如下：\n&lt;?php\n/**\n * This file is part of EasySwoole.\n *\n * @link https://www.easyswoole.com\n * @document https://www.easyswoole.com\n * @contact https://www.easyswoole.com/Preface/contact.html\n * @license https://github.com/easy-swoole/easyswoole/blob/3.x/LICENSE\n */\n\nnamespace EasySwoole\\EasySwoole;\n\nuse App\\Release\\Release;\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\n\nclass EasySwooleEvent implements Event\n{\n    public static function initialize()\n    {\n        date_default_timezone_set('Asia/Shanghai');\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        ###### 注册 双机热备服务 自定义进程 ######\n        $processConfig = new \\EasySwoole\\Component\\Process\\Config([\n            'processName' =&gt; 'Es-release', // 设置 自定义进程名称\n            'processGroup' =&gt; 'Es-release', // 设置 自定义进程组名称\n        ]);\n        \\EasySwoole\\Component\\Process\\Manager::getInstance()-&gt;addProcess(new Release($processConfig));\n    }\n}\n6. 测试\n绑定 host\n127.0.0.1 easyswoole.release.com\n访问 easyswoole.release.com\n\n查看 Nginx 配置的端口\n➜  nginx cat nginx.conf | grep 950\n           server    127.0.0.1:9501;\n发布新版本\n\n重新 clone 一份代码，更改内容提交。\n\n查看Nginx配置的端口\n➜  nginx cat nginx.conf | grep 950\n           server    127.0.0.1:9502;","link":"/Deploy/deploy.html"},{"id":107,"title":"启动流程","content":"框架启动流程\n一、自动加载\n我们在执行如下命令的时候：\nphp easyswoole server start\n项目目录下的 easyswoole 这个文件，会搜索项目目录下是否存在 composer 所生成的 autoload.php 这个文件，用于实现 psr-4 自动加载，当文件不存在的时候，则终止框架启动。\n二、基础常量定义\n在搜索到了 autoload.php 文件后，框架启动脚本则会认定为已经成功注册了 composer 的自动加载机制，随后，会根据autoload.php 所在的位置，进行如下几个常量的预定义。\n\n\nIN_PHAR\n定义规则为 defined('IN_PHAR') or define('IN_PHAR', boolval(\\Phar::running(false)));，该常量可以用于判定当前服务是否在 PHAR 环境中。\n\n\nRUNNING_ROOT\n定义规则为 defined('RUNNING_ROOT') or define('RUNNING_ROOT', $realCwd);，该常量可以用于定义当前服务运行的根目录，是一个绝对路径。\n\n\nEASYSWOOLE_ROOT\n定义规则为 defined('EASYSWOOLE_ROOT') or define('EASYSWOOLE_ROOT', IN_PHAR ? \\Phar::running() : $realCwd);，该常量用于定义当前项目所在路径的根目录，是一个绝对路径。\n\n\n三、bootstrap 文件引入\nEasySwoole 启动脚本会判断在项目根目录下，也就是 EASYSWOOLE_ROOT.'/bootstrap.php' 这个文件是否存在，如果存在，那么则会执行一次 require_once。用户可以在框架没有做任何的真实初始化之前，做自己的预处理或者是预定义。(注：3.4.x及以上版本在框架安装时会自动生成一个 bootstrap 文件在项目根目录，3.4.x 之前的版本需要用户自行添加。)\n四、启动命令解析\nEasySwoole 主框架定义了一个命令容器，完整命名空间为 \\EasySwoole\\EasySwoole\\Command\\CommandRunner，这个是一个单例对象，是对 \\EasySwoole\\Command\\CommandManager 对象的进一步调用封装。在对象的构造函数中，默认注册了 EasySwoole 自带的几个命令：\n\nCrontab\nInstall\nPhpUnit\nProcess\nServer\nTask\n\n以如下启动命令为例：\nphp easyswoole server start -d\n\n-d 可选，为守护启动参数\n\nCommandRunner 会执行 server 命令的 start 行为，其中，server 命令的完整实现在 \\EasySwoole\\EasySwoole\\Command\\DefaultCommand\\Server。\nServer 主命令\nserver 主命令被执行时，做了以下操作：\n\n判断是否指定了运行模式\n$mode = CommandManager::getInstance()-&gt;getOpt('mode');\nif(!empty($mode)){\n  Core::getInstance()-&gt;runMode($mode);\n}\n\n执行框架的初始化\n\\EasySwoole\\EasySwoole\\Core::getInstance()-&gt;initialize()\n\n\nStart 行为\n在 start 行为中，做了如下两件事：\n\n获取配置对象并设置运行时必须参数\n执行框架的最终启动\n\\EasySwoole\\EasySwoole\\Core::getInstance()-&gt;createServer()-&gt;start();\n\n","link":"/FrameDesign/start.html"},{"id":108,"title":"servermanager.php","content":"ServerManager\nServerManager 是 EasySwoole 框架中，用于全局存储 Swoole 对象实例 所用的一个单例对象。完整的代码实现在 \\EasySwoole\\EasySwoole\\ServerManager。\n关键函数\n__construct\n在构造函数中，ServerManager 实例化了一个事件注册器 \\EasySwoole\\EasySwoole\\Swoole\\EventRegister，本质上这是一个数组容器。该容器用于存储注册给 Swoole 实例的事件回调。\ncreateSwooleServer\n该函数会根据所传递的参数与配置项，创建一个 Swoole 实例，并把该实例赋值存储到 ServerManager 对象 的 swooleServer 属性中。\naddServer\n该函数用于调用 Swoole 实例 的 addlistener 方法，创建一个 Swoole的子服务，并返回该主服务的事件注册器 EventRegister，注意该注册器的作用域仅仅在对应的子服务中。\nstart\n该函数用于调用 Swoole 实例 的 start 方法，也就是实质性地启动一个 Swoole 服务。该函数做了如下事情：\n\n注册主实例的事件回调\n注册各个子服务的事件回调\n启动服务\n\n其他函数\n\n\n\n名称\n参数\n功能描述\n\n\n\n\ngetSwooleServer\nstring $serverName = null\n用于获取当前的 Swoole 实例 或者是对应子服务的 subPort 对象\n\n\ngetEventRegister\nstring $serverName = null\n用于获取 主Swoole实例 或者是对应子服务的subPort对象 的事件回调注册容器\n\n\nisStart\n-\n用于判断当前服务是否已经启动\n\n\n","link":"/FrameDesign/serverManager.html"},{"id":109,"title":"core.php","content":"Core\nCore 是 EasySwoole 框架中核心的基础架构对象，这是一个单例对象，它的完整实现在 \\EasySwoole\\EasySwoole\\Core。\n关键函数\n__construct\n在构造函数中，做了以下两件事：\n\n常量定义\n\ndefined('SWOOLE_VERSION') or define('SWOOLE_VERSION', intval(phpversion('swoole')));\ndefined('EASYSWOOLE_ROOT') or define('EASYSWOOLE_ROOT', realpath(getcwd()));\ndefined('EASYSWOOLE_SERVER') or define('EASYSWOOLE_SERVER', 1);\ndefined('EASYSWOOLE_WEB_SERVER') or define('EASYSWOOLE_WEB_SERVER', 2);\ndefined('EASYSWOOLE_WEB_SOCKET_SERVER') or define('EASYSWOOLE_WEB_SOCKET_SERVER', 3);\n\n\n全局 EasySwooleEvent.php 事件引入\n\n\n在该构造函数中尝试重新定义 EASYSWOOLE_ROOT 常量是为了支持用户自定义脚本启动\n\nrunMode\n可以通过调用此函数获取框架当前运行的模式，默认模式为 dev。可在框架启动时指定模式和要加载的配置文件，详细见 基础管理命令。然后在框架任何地方调用此函数以获取当前运行的模式，方便调试。\n使用示例：在控制器中调用\nif (\\EasySwoole\\EasySwoole\\Core::getInstance()-&gt;runMode() == 'dev') {\n    // 开发模式下执行的逻辑\n}\ninitialize\n框架核心骨架初始化，做了以下几件事\n\n根据运行模式加载配置文件\n初始化临时目录和日志目录\n初始化错误处理器\n调用全局 EasySwooleEvent.php 中的 initialize 事件\n\ncreateServer\n根据配置文件，调用 ServerManager 初始化对应的 Swoole实例，并执行以下事情：\n\n调用全局 EasySwooleEvent.php 中的 mainServerCreate 事件\n注册框架系统默认的事件回调\n附加处理，例如注册 CronTab 进程、注册 Task 进程等\n\nstart\n根据配置文件中设置的服务名称，设置服务名称和进程的名称，调用 ServerManager，启动框架。","link":"/FrameDesign/core.html"},{"id":110,"title":"bootstrap 事件","content":"bootstrap 事件\nbootstrap 事件允许在框架未初始化之前，先进行初始化其他需要的业务代码。该事件是在 EasySwoole 3.2.5版本之后 新增的。\n在框架安装之后产生的 easyswoole 启动脚本文件中，将会自动判断框架根目录下是否有 bootstrap.php 文件，如果有则加载此文件。\n目前框架最新版本的 bootstrap.php(即 bootstrap 事件)会在框架安装时在项目根目录中自动生成。所以如果用户想要执行自己需要的初始化业务代码：如 注册命令行支持、全局通用函数、启动前调用协程 API等功能，就可以在 bootstrap.php 中进行编写实现。\n\n注：EasySwoole 3.4.x 版本之前 bootstrap.php 文件需要用户在项目根目录下自行创建该文件 bootstrap.php。\n注：如果你是框架旧版升级到框架新版，需要删除框架根目录的 easyswoole 文件，然后重新运行 php ./vendor/easyswoole/easyswoole/bin/easyswoole install 进行重新安装(报错或者其他原因请重新看 框架安装章节-执行安装步骤)，重新安装完成之后，即可正常使用 bootstrap 事件\n\n在框架启用前(在 bootstrap 事件中)调用协程 API\n开发者在 EasySwoole 主服务启动前调用协程 api，必须使用如下操作：\n$scheduler = new \\Swoole\\Coroutine\\Scheduler();\n$scheduler-&gt;add(function() {\n    /* 调用协程API */\n});\n$scheduler-&gt;start();\n// 清除全部定时器\n\\Swoole\\Timer::clearAll();\n具体使用示例如下：\n&lt;?php\n// 全局 bootstrap 事件\ndate_default_timezone_set('Asia/Shanghai');\n\nuse Swoole\\Coroutine\\Scheduler;\n$scheduler = new Scheduler();\n$scheduler-&gt;add(function() {\n    /* 调用协程 API */\n});\n$scheduler-&gt;start();\n// 清除全部定时器\n\\Swoole\\Timer::clearAll();","link":"/FrameDesign/event/bootstrap.html"},{"id":111,"title":"initialize 事件","content":"initialize 事件(即框架初始化事件)\n框架初始化事件，在执行 initialize 初始化事件时，EasySwoole 框架此刻已经完成了如下工作：\n\n加载配置文件\n初始化 Log/Temp 目录，完成系统默认 Log/Temp 目录的定义\n\n函数原型\npublic static function initialize(): void\n{\n}\n开发者自定义处理\n开发者可以在 initialize 事件可以进行如下修改：\n\n修改框架默认使用的 error_report 级别，使用自定义的 error_report 级别\n修改框架默认使用的 Logger 处理器，使用自定义的 Logger 处理器\n修改框架默认使用的 Trigger 处理器，使用自定义的 Trigger 处理器\n修改框架默认使用的 Error 处理器，使用自定义的 Error 处理器\n修改框架默认使用的 Shutdown 处理器，使用自定义的 Shutdown 处理器\n修改框架默认使用的 HttpException 全局处理器，使用自定义的 HttpException 全局处理器\n设置 Http 全局 OnRequest 及 AfterRequest 事件\n注册数据库、Redis 连接池\n\n具体可查看 SysConst.php\n使用示例代码：\n&lt;?php\n\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\n\nclass EasySwooleEvent implements Event\n{\n    public static function initialize()\n    {\n        // TODO: Implement initialize() method.\n        date_default_timezone_set('Asia/Shanghai');\n\n        // 开发者自定义设置 错误级别\n        \\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::ERROR_REPORT_LEVEL, E_ALL);\n\n        // 开发者自定义设置 日志处理类(该类需要实现 \\EasySwoole\\Log\\LoggerInterface，开发者可自行查看并实现，方便开发者自定义处理日志)\n        $logDir = EASYSWOOLE_LOG_DIR; // 定义日志存放目录\n        $loggerHandler = new \\EasySwoole\\Log\\Logger($logDir); // 定义日志处理对象\n        \\EasySwoole\\Component\\Di::getInstance()-&gt;set(SysConst::LOGGER_HANDLER, $loggerHandler);\n\n        // 开发者自定义设置 Trace 追踪器(该类需要实现 \\EasySwoole\\Trigger\\TriggerInterface，开发者可自行查看并实现，方便开发者自定义处理 Trace 链路)\n        // Trace 追踪器需要依据上面的 logger_handler\n        \\EasySwoole\\Component\\Di::getInstance()-&gt;set(SysConst::TRIGGER_HANDLER, new \\EasySwoole\\Trigger\\Trigger($loggerHandler));\n\n        // 开发者自定义设置 error_handler\n        \\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::ERROR_HANDLER, function ($errorCode, $description, $file = null, $line = null) {\n            // 开发者对错误进行处理\n        });\n\n        // 开发者自定义设置 shutdown\n        \\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::SHUTDOWN_FUNCTION, function () {\n            // 开发者对 shutdown 进行处理\n        });\n\n        // 开发者自定义设置 HttpException 全局处理器\n        \\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::HTTP_EXCEPTION_HANDLER, function ($throwable, Request $request, Response $response) {\n            $response-&gt;withStatus(\\EasySwoole\\Http\\Message\\Status::CODE_INTERNAL_SERVER_ERROR);\n            $response-&gt;write(nl2br($throwable-&gt;getMessage() . \"\\n\" . $throwable-&gt;getTraceAsString()));\n            Trigger::getInstance()-&gt;throwable($throwable);\n        });\n\n        // 开发者自定义设置 onRequest v3.4.x+\n        \\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::HTTP_GLOBAL_ON_REQUEST, function (\\EasySwoole\\Http\\Request $request, \\EasySwoole\\Http\\Response $response) {\n            // v3.4.x 之前的版本 onRequest 事件在 EasySwoolEvent.php 中已定义，不必重新设置\n        });\n\n        // 开发者自定义设置 afterRequest v3.4.x+\n        \\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::HTTP_GLOBAL_AFTER_REQUEST, function (\\EasySwoole\\Http\\Request $request, \\EasySwoole\\Http\\Response $response) {\n            // v3.4.x 之前的版本 afterRequest 事件在 EasySwoolEvent.php 中已定义，不必重新设置\n        });\n\n        // 注册数据库连接及连接池(详见：https://www.easyswoole.com/Components/Orm/install.html)\n        // 注册 Redis 连接及连接池(详见：https://www.easyswoole.com/Components/Redis/introduction.html)\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n\n    }\n}\n启用前(在 initialize 事件中)调用协程 API\n开发者在 EasySwoole 主服务启动前调用协程 api，必须使用如下操作：\n$scheduler = new \\Swoole\\Coroutine\\Scheduler();\n$scheduler-&gt;add(function() {\n    /* 调用协程API */\n});\n$scheduler-&gt;start();\n// 清除全部定时器\n\\Swoole\\Timer::clearAll();\n具体使用示例：\n&lt;?php\n\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\n\nclass EasySwooleEvent implements Event\n{\n    public static function initialize()\n    {\n        // TODO: Implement initialize() method.\n        date_default_timezone_set('Asia/Shanghai');\n\n        $scheduler = new \\Swoole\\Coroutine\\Scheduler();\n        $scheduler-&gt;add(function() {\n            /* 调用协程API */\n        });\n        $scheduler-&gt;start();\n        // 清除全部定时器\n        \\Swoole\\Timer::clearAll();\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n\n    }\n}\n在 initialize 事件中调用连接池\ninitialize 事件在 EasySwoole 生命周期中属于 主进程，因此在主进程中创建了连接池可能会导致以下问题：\n\n创建了全局的定时器\n创建了全局的 EventLoop\n\n创建的连接被跨进程公用，因此我们以服务启动前调用数据库 ORM 为例：\n\n服务启动前调用数据库 ORM：\n\n下文 \\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf('MYSQL') 获取的 MYSQL 配置，详细参考 配置文件\n\n&lt;?php\n\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\n\nclass EasySwooleEvent implements Event\n{\n    public static function initialize()\n    {\n        // TODO: Implement initialize() method.\n        date_default_timezone_set('Asia/Shanghai');\n        $config = new \\EasySwoole\\ORM\\Db\\Config(\\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf('MYSQL'));\n        \\EasySwoole\\ORM\\DbManager::getInstance()-&gt;addConnection(new \\EasySwoole\\ORM\\Db\\Connection($config));\n        // 创建一个协程调度器\n        $scheduler = new \\Swoole\\Coroutine\\Scheduler();\n        $scheduler-&gt;add(function () {\n            $builder = new \\EasySwoole\\Mysqli\\QueryBuilder();\n            $builder-&gt;raw('select version()');\n            \\EasySwoole\\ORM\\DbManager::getInstance()-&gt;query($builder, true);\n            // 这边重置 ORM 连接池的 pool，避免连接被克隆到子进程，造成连接跨进程公用。\n            // DbManager 如果有注册多库连接，请记得一起 getConnection($name) 获取全部的 pool 去执行 reset\n            // 其他的连接池请获取到对应的 pool，然后执行 reset() 方法\n\n            // ORM 1.4.31 版本之前请使用 getClientPool() \n            // DbManager::getInstance()-&gt;getConnection()-&gt;getClientPool()-&gt;reset();\n            \\EasySwoole\\ORM\\DbManager::getInstance()-&gt;getConnection()-&gt;__getClientPool()-&gt;reset();\n        });\n        //执行调度器内注册的全部回调\n        $scheduler-&gt;start();\n        //清理调度器内可能注册的定时器，不要影响到swoole server 的event loop\n        \\Swoole\\Timer::clearAll();\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n\n    }\n}","link":"/FrameDesign/event/initialize.html"},{"id":112,"title":"mainservercreate 事件","content":"mainServerCreate 事件(即主服务创建事件)\n函数原型\n/**\n * @param \\EasySwoole\\EasySwoole\\Swoole\\EventRegister $register\n */\npublic static function mainServerCreate(EventRegister $register)\n{\n\n}\n已完成工作\n在执行主服务创建事件时，框架此时已经完成的工作有：\n\n\nbootstrap/initialize 事件加载完成\n主 SwooleServer 创建成功\n主 SwooleServer 注册了默认的 onRequest/onWorkerStart/onWorkerStop/onWorkerExit 事件。\n\n开发者可进行的操作有：\n\n注册主服务回调事件\n添加子服务监听\nSwooleTable/Atomic\n创建自定义进程\n启用前(在 mainServerCreate 事件中)调用协程 API\n\n注册主服务回调事件\n例如：为主服务注册 onWorkerStart 回调事件：\n/** @var \\EasySwoole\\EasySwoole\\Swoole\\EventRegister $register **/\n$register-&gt;add($register::onWorkerStart, function (\\Swoole\\Server $server,int $workerId){\n     var_dump($workerId . 'start');\n});\n例如：为主服务增加 onMessage 回调事件（前提是主服务类型为 WebSocket 服务）：\n// 给 server 注册相关事件，在 WebSocket 服务模式下 message 事件必须注册 \n/** @var \\EasySwoole\\EasySwoole\\Swoole\\EventRegister $register **/\n$register-&gt;set($register::onMessage,function (\\Swoole\\WebSocket\\Server $server, \\Swoole\\WebSocket\\Frame $frame){\n\n});\nset 方法和 add 方法是不同的, set 将会覆盖之前配置的事件回调, 而 add 是增加一个新的回调。\n添加子服务监听\n例如：添加一个 tcp 子服务监听\n/** @var \\Swoole\\Server\\Port $subPort **/\n$subPort = \\EasySwoole\\EasySwoole\\ServerManager::getInstance()-&gt;getSwooleServer()-&gt;addListener('0.0.0.0', 9503, SWOOLE_TCP);\n$subPort-&gt;on('receive', function (\\Swoole\\Server $server, int $fd, int $reactor_id, string $data){\n    var_dump($data);\n});\n// 配置 具体查看 Swoole 文档\n$subPort-&gt;set([\n\n]);\n\n具体可参考 TCP\n\nTable &amp;&amp; Atomic\n具体调用方式请看具体章节：\nTable\nAtomic\n创建自定义进程\n\n具体详细操作可到 基础使用 -&gt; 自定义进程中查看\n\n\\EasySwoole\\Component\\Process\\Manager::getInstance()-&gt;addProcess(new Test('test_process'));\n\nTest 是 EasySwoole\\Component\\Process\\AbstractProcess 抽象类的子类\n\n启用前(在 mainServerCreate 事件中)调用协程 API\n开发者在 EasySwoole 主服务启动前调用协程 api，必须使用如下操作：\n$scheduler = new \\Swoole\\Coroutine\\Scheduler();\n$scheduler-&gt;add(function() {\n    /* 调用协程API */\n});\n$scheduler-&gt;start();\n// 清除全部定时器\n\\Swoole\\Timer::clearAll();","link":"/FrameDesign/event/mainServerCreate.html"},{"id":113,"title":"onrequest 事件","content":"onRequest 事件(即收到请求事件)\n使用场景及原理\n当 EasySwoole 收到任何的 HTTP 请求时，均会执行该事件。可以使用该事件可以对 HTTP 请求全局拦截，包括对请求进行允许跨域等操作。\n使用方式说明\n框架对 onRequest 事件的实现在 3.4.x 及以后的版本 中做了新的改动，实现方式由原来旧版本在主服务创建事件(mainServerCreate 事件)中定义改变为在 initialize 事件 中使用 Di 方式注入。目前最新稳定版本框架(3.4.x)，具体实现及使用方式 (在 EasySwooleEvent.php 中的 initialize 事件中注入) 如下：\n&lt;?php\n\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\n\nclass EasySwooleEvent implements Event\n{\n    public static function initialize()\n    {\n        date_default_timezone_set('Asia/Shanghai');\n\n        // 实现 onRequest 事件\n        \\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::HTTP_GLOBAL_ON_REQUEST, function (\\EasySwoole\\Http\\Request $request, \\EasySwoole\\Http\\Response $response): bool {\n            ###### 对请求进行拦截 ######\n            // 不建议在这拦截请求，可增加一个控制器基类进行拦截\n            // 如果真要拦截，判断之后 return false; 即可\n            /*\n            $code = $request-&gt;getRequestParam('code');\n            if (0){ // empty($code)验证失败\n                $data = array(\n                    \"code\" =&gt; \\EasySwoole\\Http\\Message\\Status::CODE_BAD_REQUEST,\n                    \"result\" =&gt; [],\n                    \"msg\" =&gt; '验证失败'\n                );\n                $response-&gt;write(json_encode($data, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES));\n                $response-&gt;withHeader('Content-type', 'application/json;charset=utf-8');\n                $response-&gt;withStatus(\\EasySwoole\\Http\\Message\\Status::CODE_BAD_REQUEST);\n                return false;\n            }\n            return true;\n            */\n\n            ###### 处理请求的跨域问题 ######\n            $response-&gt;withHeader('Access-Control-Allow-Origin', '*');\n            $response-&gt;withHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\n            $response-&gt;withHeader('Access-Control-Allow-Credentials', 'true');\n            $response-&gt;withHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Requested-With');\n            if ($request-&gt;getMethod() === 'OPTIONS') {\n                $response-&gt;withStatus(\\EasySwoole\\Http\\Message\\Status::CODE_OK);\n                return false;\n            }\n            return true;\n        });\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n\n    }\n}\n旧版本(3.4.x 之前版本)框架的 onRequest 事件的实现如下所示：\n&lt;?php\n\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\n\nclass EasySwooleEvent implements Event\n{\n    public static function initialize()\n    {\n        // TODO: Implement initialize() method.\n        date_default_timezone_set('Asia/Shanghai');\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n\n    }\n\n    // 注册 onRequest 事件回调\n    public static function onRequest(Request $request, Response $response): bool\n    {\n        ###### 对请求进行拦截 ######\n        // 不建议在这拦截请求，可增加一个控制器基类进行拦截\n        // 如果真要拦截，判断之后 return false; 即可\n        /*\n        $code = $request-&gt;getRequestParam('code');\n        if (0){ // empty($code)验证失败\n            $data = array(\n                \"code\" =&gt; \\EasySwoole\\Http\\Message\\Status::CODE_BAD_REQUEST,\n                \"result\" =&gt; [],\n                \"msg\" =&gt; '验证失败'\n            );\n            $response-&gt;write(json_encode($data, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES));\n            $response-&gt;withHeader('Content-type', 'application/json;charset=utf-8');\n            $response-&gt;withStatus(\\EasySwoole\\Http\\Message\\Status::CODE_BAD_REQUEST);\n            return false;\n        }\n        return true;\n        */\n\n        ###### 处理请求的跨域问题 ######\n        $response-&gt;withHeader('Access-Control-Allow-Origin', '*');\n        $response-&gt;withHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\n        $response-&gt;withHeader('Access-Control-Allow-Credentials', 'true');\n        $response-&gt;withHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Requested-With');\n        if ($request-&gt;getMethod() === 'OPTIONS') {\n            $response-&gt;withStatus(\\EasySwoole\\Http\\Message\\Status::CODE_OK);\n            return false;\n        }\n        return true;\n    }\n}\n注意事项\n若在该事件中，执行 $response->end()，则该次请求不会进入路由匹配阶段。","link":"/FrameDesign/event/onRequest.html"},{"id":114,"title":"afterrequest 事件","content":"afterRequest 事件(即请求方法结束后执行事件)\n使用场景及原理\n该事件是在请求方法结束后执行。可以在该事件中做 trace，对请求进行追踪监视以及获取此次的响应内容。\n使用方式说明\n框架对 afterRequest 事件的实现在 3.4.x 及以后的版本 中做了新的改动，实现方式由原来旧版本在主服务创建事件(mainServerCreate 事件)中定义改变为在 initialize 事件 中使用 Di 方式注入。目前最新稳定版本框架(3.4.x)，具体实现及使用方式 (在 EasySwooleEvent.php 中的 initialize 事件中注入) 如下：\n&lt;?php\n\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\n\nclass EasySwooleEvent implements Event\n{\n    public static function initialize()\n    {\n        date_default_timezone_set('Asia/Shanghai');\n\n        // 实现 afterRequest 事件\n        \\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::HTTP_GLOBAL_AFTER_REQUEST, function (\\EasySwoole\\Http\\Request $request, \\EasySwoole\\Http\\Response $response): void {\n\n            // 示例：获取此次请求响应的内容\n            TrackerManager::getInstance()-&gt;getTracker()-&gt;endPoint('request');\n            $responseMsg = $response-&gt;getBody()-&gt;__toString();\n            Logger::getInstance()-&gt;console('响应内容:' . $responseMsg);\n            // 响应状态码：\n            // var_dump($response-&gt;getStatusCode());\n\n            // tracker 结束，结束之后，能看到中途设置的参数，调用栈的运行情况\n            TrackerManager::getInstance()-&gt;closeTracker();\n        });\n\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n\n    }\n}\n旧版本(3.4.x 之前版本)框架的 afterRequest 事件的实现如下所示：\n&lt;?php\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\n\nclass EasySwooleEvent implements Event\n{\n\n    public static function initialize()\n    {\n        // TODO: Implement initialize() method.\n        date_default_timezone_set('Asia/Shanghai');\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        // TODO: Implement mainServerCreate() method.\n    }\n\n    public static function onRequest(Request $request, Response $response): bool\n    {\n        // TODO: Implement onRequest() method.\n        return true;\n    }\n\n    // 注册 afterRequest 事件回调\n    public static function afterRequest(Request $request, Response $response): void\n    {\n        // TODO: Implement afterRequest() method.\n\n        // 示例：获取此次请求响应的内容\n        TrackerManager::getInstance()-&gt;getTracker()-&gt;endPoint('request');\n        $responseMsg = $response-&gt;getBody()-&gt;__toString();\n        Logger::getInstance()-&gt;console('响应内容:' . $responseMsg);\n        // 响应状态码：\n        // var_dump($response-&gt;getStatusCode());\n\n        // tracker 结束，结束之后，能看到中途设置的参数，调用栈的运行情况\n        TrackerManager::getInstance()-&gt;closeTracker();\n    }\n}","link":"/FrameDesign/event/afterRequest.html"},{"id":115,"title":"timer定时器","content":"Timer定时器\n框架对Swoole毫秒级定时器进行了封装，方便开发者快速上手。\n注意⚠️：定时器传入的时间参数为毫秒，若开启了 reload_async 配置时，请将定时器移动到自定义进程内，否则会导致worker进程无法reload。\n循环执行\n设置一个间隔时钟定时器，每隔一定的时间定时触发，直到进行 clear 操作才会停止，对应 Swoole 原生的定时器函数为 swoole_timer_tick\n函数原型\n/**\n* 循环调用\n* @param int      $ms 循环执行的间隔毫秒数 传入整数型\n* @param \\Closure $callback 定时器需要执行的操作 传入一个闭包\n* @param string    $name 定时器名称,用于取消该定时器\n* @param mixed ...$params 传入定时器的参数\n* @return int 返回整数型的定时器编号 可以用该编号停止定时器\n*/\npublic function loop(int $ms, callable $callback, $name = null, ...$params)\n示例代码\n// 每隔 10 秒执行一次\n\\EasySwoole\\Component\\Timer::getInstance()-&gt;loop(10 * 1000, function () {\n    echo \"this timer runs at intervals of 10 seconds\\n\";\n});\n延时执行\n设置一个延时定时器，延时指定的时间后触发对应的操作，只会执行一次操作，对应Swoole 原生的定时器函数为 swoole_timer_after\n函数原型\n/**\n* 延时调用\n* @param int      $ms 需要延迟执行的时间\n* @param \\Closure $callback 定时器需要执行的操作 传入一个闭包\n* @param mixed ...$params 传入定时器的参数\n* @return int 返回整数型的定时器编号 \n*/\npublic function after(int $ms, callable $callback, ...$params)\n示例代码\n// 10 秒后执行一次\n\\EasySwoole\\Component\\Timer::getInstance()-&gt;after(10 * 1000, function () {\n    echo \"ten seconds later\\n\";\n});\n清除定时器\n注意: 该操作不能用于清除其他进程的定时器，只作用于当前进程\n定时器创建成功时，会返回一个整数型编号，调用本函数传入该编号，即可提前停止定时器，对应 Swoole 原生的定时器函数为 swoole_timer_clear\n函数原型\n/**\n* 清除定时器\n* @param mixed $timerIdOrName 定时器编号或名称\n* @return bool\n*/\npublic function clear($timerIdOrName)\n示例代码\n// 创建一个2秒定时器\n$timerId = \\EasySwoole\\Component\\Timer::getInstance()-&gt;loop(2 * 1000, function () {\n    echo \"timeout\\n\";\n},'time');\n\n// 清除该定时器\nvar_dump(\\EasySwoole\\Component\\Timer::getInstance()-&gt;clear($timerId)); // bool(true)\nvar_dump($timerId); // int(1)\n\n// 定时器得不到执行 不输出：timeout\n应用实例\n注意：定时器不能在服务启动之前使用。在服务启动以后，添加的定时器仅在当前进程中有效。在 WorkerStart 事件中添加定时器时，请注意判断需要添加定时器的workerId，否则该定时器在每个进程中均会被执行。\n// 为第一个 Worker 添加定时器\nif ($workerId == 0) {\n    \\EasySwoole\\Component\\Timer::getInstance()-&gt;loop(10 * 1000, function () {\n        echo \"timer in the worker number 0\\n\";\n    });\n}\npublic static function mainServerCreate(EventRegister $register)\n{\n    $register-&gt;add(EventRegister::onWorkerStart, function (\\swoole_server $server, $workerId) {\n        //如何避免定时器因为进程重启而丢失\n        //例如在第一个进程 添加一个10秒的定时器\n        if ($workerId == 0) {\n            \\EasySwoole\\Component\\Timer::getInstance()-&gt;loop(10 * 1000, function () {\n                // 从数据库，或者是redis中，去获取下个就近10秒内需要执行的任务\n                // 例如:2秒后一个任务，3秒后一个任务 代码如下\n                \\EasySwoole\\Component\\Timer::getInstance()-&gt;after(2 * 1000, function () {\n                    //为了防止因为任务阻塞，引起定时器不准确，把任务给异步进程处理\n                    Logger::getInstance()-&gt;console(\"time 2\", false);\n                });\n                \\EasySwoole\\Component\\Timer::getInstance()-&gt;after(3 * 1000, function () {\n                    //为了防止因为任务阻塞，引起定时器不准确，把任务给异步进程处理\n                    Logger::getInstance()-&gt;console(\"time 3\", false);\n                });\n            });\n        }\n    });\n}\n经典案例-订单状态超时监控\n场景说明：在很多抢购的场景中，订单下单完成后，需要限制其付款时间，或者是在棋牌游戏中，需要对房间状态进行监控。那么我们可以先把待监控的订单或者是房间压入redis 队列中。那么就可以利用 定时器 + 异步进程，去实现对订单状态的循环监控。","link":"/Components/Component/timer.html"},{"id":116,"title":"crontab定时任务","content":"定时任务\n开发者执行定时任务会通过Linux的Crontab去实现，不方便去管理。EasySwoole提供了根据Linux下Crontab规则的定时任务，最小粒度为1分钟。\n创建一个定时任务\n需要定义一个定时任务类继承EasySwoole\\EasySwoole\\Crontab\\AbstractCronTask。\n定义执行规则\npublic static function getRule(): string\n{\n    // 定义执行规则 根据Crontab来定义\n    return '*/1 * * * *';\n}\n定义Crontab名称\npublic static function getTaskName(): string\n{\n    // 定时任务的名称\n    return 'custom crontab';\n}\n定义执行逻辑\npublic function run(int $taskId, int $workerIndex)\n{\n    // 定时任务的执行逻辑\n\n    // 开发者可投递给task异步处理\n    TaskManager::getInstance()-&gt;async(function (){\n        // todo some thing\n    });\n}\n定义异常捕获\npublic function onException(\\Throwable $throwable, int $taskId, int $workerIndex)\n{\n    // 捕获run方法内所抛出的异常\n}\n注册Crontab\n在EasySwoole全局的mainServerCreate事件中进行进程注册\n\nCrontab::getInstance()-&gt;addTask(CustomCrontab::class);\n\n完整示例代码\n&lt;?php\n\nnamespace App\\Crontab;\n\nuse EasySwoole\\EasySwoole\\Crontab\\AbstractCronTask;\nuse EasySwoole\\EasySwoole\\Task\\TaskManager;\n\nclass CustomCrontab extends AbstractCronTask\n{\n    public static function getRule(): string\n    {\n        // 定义执行规则 根据Crontab来定义\n        return '*/1 * * * *';\n    }\n\n    public static function getTaskName(): string\n    {\n        // 定时任务的名称\n        return 'CustomCrontab';\n    }\n\n    public function run(int $taskId, int $workerIndex)\n    {\n        // 定时任务的执行逻辑\n\n        // 开发者可投递给task异步处理\n        TaskManager::getInstance()-&gt;async(function (){\n            // todo some thing\n        });\n    }\n\n    public function onException(\\Throwable $throwable, int $taskId, int $workerIndex)\n    {\n        // 捕获run方法内所抛出的异常\n    }\n}\nCrontab表达式\n通用表达式：\n    *    *    *    *    *\n    -    -    -    -    -\n    |    |    |    |    |\n    |    |    |    |    |\n    |    |    |    |    +----- day of week (0 - 7) (Sunday=0 or 7)\n    |    |    |    +---------- month (1 - 12)\n    |    |    +--------------- day of month (1 - 31)\n    |    +-------------------- hour (0 - 23)\n    +------------------------- min (0 - 59)\n特殊表达式：\n@yearly                    每年一次 等同于(0 0 1 1 *) \n@annually                  每年一次 等同于(0 0 1 1 *)\n@monthly                   每月一次 等同于(0 0 1 * *) \n@weekly                    每周一次 等同于(0 0 * * 0) \n@daily                     每日一次 等同于(0 0 * * *) \n@hourly                    每小时一次 等同于(0 * * * *)\nCrontab管理\nEasySwoole内置对于Crontab的命令行操作，方便开发者友好的去管理Crontab。\n可执行php easyswoole crontab -h来查看具体操作。\n查看所有注册的Crontab\n\nphp easyswoole crontab show\n\n停止指定的Crontab\n\nphp easyswoole crontab stop --name=TASK_NAME\n\n恢复指定的Crontab\n\nphp easyswoole crontab resume --name=TASK_NAME\n\n立即跑一次指定的Crontab\n\nphp easyswoole crontab run --name=TASK_NAME\n\n版本强调\nEasySwoole3.3.0如何定义：\n&lt;?php\nnamespace App\\Crontab;\n\nuse EasySwoole\\EasySwoole\\Crontab\\AbstractCronTask;\n\nclass TaskOne extends AbstractCronTask\n{\n\n    public static function getRule(): string\n    {\n        // TODO: Implement getRule() method.\n        // 定时周期 （每小时）\n        return '@hourly';\n    }\n\n    public static function getTaskName(): string\n    {\n        // TODO: Implement getTaskName() method.\n        // 定时任务名称\n        return 'taskOne';\n    }\n\n    static function run(\\swoole_server $server, int $taskId, int $fromWorkerId,$flags=null)\n    {\n        // TODO: Implement run() method.\n        // 定时任务处理逻辑\n        var_dump('run once per hour');\n    }\n}","link":"/BaseUsage/crontab.html"},{"id":117,"title":"日志","content":"日志\n日志可以快速帮助开发者快速定位问题的根源、追踪程序执行的过程、追踪数据变化、数据统计和性能分析等。\n配置说明\nEasySwoole 在 3.4.4 版本中优化了框架默认的日志处理机制，允许用户更加方便地去自定义配置日志处理，可以直接在配置文件 (dev.php/produce.php) 中进行配置。(以后版本也将兼容以下配置特性)\n配置包括以下几方面：\n\n设置记录日志文件时日志文件存放目录 (dir)，用户可以自己设置日志存放目录(但是一定要保证日志有写入权限)，配置值为 路径，默认为 框架根目录的 Log 目录。\n设置记录日志时的日志最低等级 (level)，等级配置值默认为 \\EasySwoole\\Log\\LoggerInterface::LOG_LEVEL_DEBUG，等级值支持 \\EasySwoole\\Log\\LoggerInterface::LOG_LEVEL_DEBUG (0级)、\\EasySwoole\\Log\\LoggerInterface::LOG_LEVEL_INFO (1级)、\\EasySwoole\\Log\\LoggerInterface::LOG_LEVEL_NOTICE (2级)、\\EasySwoole\\Log\\LoggerInterface::LOG_LEVEL_WARNING (3级)、\\EasySwoole\\Log\\LoggerInterface::LOG_LEVEL_ERROR (4级)。例如当我们在配置文件中把日志等级设置为 \\EasySwoole\\Log\\LoggerInterface::LOG_LEVEL_INFO (1级) 时，就不会把我们在框架中调用打印小于这个等级的日志记录记录到日志文件中 (比如 LOG_LEVEL_DEBUG (0级) 就不会被记录到日志当中了，也不会显示在控制台了)。\n设置日志处理器 handler (handler)，默认使用框架内置 handler，用户可以自定义日志类实现 \\EasySwoole\\Log\\LoggerInterface 接口，来处理记录日志。配置值为 自定义处理类名，默认为 \\EasySwoole\\Log\\Logger。具体自定义实现日志处理器可看下文。\n设置记录日志到日志文件时是否在控制台打印日志 (logConsole)。配置值为 boolean 值，默认为 true，即开启。\n设置是否开启在控制台打印日志 (displayConsole)。配置值为 boolean 值，默认为 true，即开启。\n设置打印日志时忽略哪些分类的日志不进行记录 (ignoreCategory) 。配置值为 array 类型值，默认为 null (即不忽略任何分类的日志，任何分类的日志都进行在控制台显示打印并记录到文件)，配置忽略分类值支持 debug、info、notice、warning、error 作为配置值 array 中的可选值。例如：设置为 ['debug', 'notice'] 时，即当我们在框架中使用下面列举的使用日志的方法时，调用 debug 和 notice 方法记录日志时，不会把 debug 和 notice 分类的日志在控制台显示，也不会记录到日志文件中。\n\n下面为配置文件中配置示例：\n&lt;?php\n\nuse EasySwoole\\Log\\LoggerInterface;\n\nreturn [\n    // ... 这里省略\n    'MAIN_SERVER' =&gt; [\n        // ... 这里省略\n    ],\n    \"LOG\" =&gt; [\n        // 设置记录日志文件时日志文件存放目录\n        'dir' =&gt; null,\n        // 设置记录日志时的日志最低等级，低于此等级的日志不进行记录和显示\n        'level' =&gt; LoggerInterface::LOG_LEVEL_DEBUG,\n        // 设置日志处理器 `handler` (handler)\n        'handler' =&gt; null,\n        // 设置开启在记录日志到日志文件时在控制台打印日志\n        'logConsole' =&gt; true,\n        // 设置开启在控制台显示日志\n        'displayConsole'=&gt;true,\n        // 设置打印日志时忽略哪些分类的日志不进行记录\n        'ignoreCategory' =&gt; []\n    ],\n    // ... 这里省略\n];\n以上 level 和 ignoreCategory 的设置，更加方便用户在正式上线项目时，屏蔽那些在开发阶段的调试日志不进行记录和显示。当然对于 PHP 异常错误等级 的等级设置（即 error_reporting())，用户也可以设置，详细请查看 iniialize 事件中设置ERROR_LEVEL。\n\n注意：在 EasySwoole 3.4.3 版本中，仅支持对上述 dir、level、handler 的配置。而在 3.4.2 之前版本中，仅支持对上述 dir 的配置。\n\n日志使用\n以下方法可以在框架的 boostrap 事件之后的任意位置进行调用。调用之前请先看下文注意事项。\n在非框架中使用，例如是单元测试脚本，请执行 \\EasySwoole\\EasySwoole\\Core::getInstance()->initialize(); 用于初始化日志。\n在 EasySwoole 3.3.7 之前版本中，initialize 事件调用为：EasySwoole\\EasySwoole\\Core::getInstance()->initialize()->globalInitialize();。\nlog 记录显示日志\n// 打印和记录 `DEBUG` 等级、`debug` 分类的日志\n\\EasySwoole\\EasySwoole\\Logger::getInstance()-&gt;log('record level:DEBUG-category:debug log info',\\EasySwoole\\Log\\LoggerInterface::LOG_LEVEL_DEBUG,'debug');\n### [旧版本说明] 注意：当找不到 `\\EasySwoole\\Log\\LoggerInterface::LOG_LEVEL_DEBUG` 常量，请查看是否为 `\\EasySwoole\\EasySwoole\\Logger::LOG_LEVEL_INFO` \n\n// 打印和记录 `INFO` 等级、`info` 分类的日志\n\\EasySwoole\\EasySwoole\\Logger::getInstance()-&gt;log('record level:INFO-category:info log info',\\EasySwoole\\Log\\LoggerInterface::LOG_LEVEL_INFO,'info');\n\n// 打印和记录 `NOTICE` 等级、`notice` 分类的日志\n\\EasySwoole\\EasySwoole\\Logger::getInstance()-&gt;log('record level:NOTICE-category:notice log info',\\EasySwoole\\Log\\LoggerInterface::LOG_LEVEL_NOTICE,'notice');\n\n// 打印和记录 `WARNING` 等级、`warning` 分类的日志\n\\EasySwoole\\EasySwoole\\Logger::getInstance()-&gt;log('record level:WARNING-category:warning log info',\\EasySwoole\\Log\\LoggerInterface::LOG_LEVEL_WARNING,'warning');\n\n// 打印和记录 `ERROR` 等级、`error` 分类的日志\n\\EasySwoole\\EasySwoole\\Logger::getInstance()-&gt;log('record level:ERROR-category:error log info',\\EasySwoole\\Log\\LoggerInterface::LOG_LEVEL_ERROR,'error');\n运行结果：在控制台和日志文件 Log\\log_XxxxXx.log 中均可看到如下结果：\n// 格式说明: [记录日志时间][分类][等级]:[日志内容]\n[2021-03-18 22:52:09][debug][debug]:[record level:DEBUG-category:debug log info]\n[2021-03-18 22:52:09][info][info]:[record level:INFO-category:info log info]\n[2021-03-18 22:52:09][notice][notice]:[record level:NOTICE-category:notice log info]\n[2021-03-18 22:52:09][warning][warning]:[record level:WARNING-category:warning log info]\n[2021-03-18 22:52:09][error][error]:[record level:ERROR-category:error log info]\ninfo 日志\n// 打印和记录 `INFO` 等级、`info` 分类的日志\n\\EasySwoole\\EasySwoole\\Logger::getInstance()-&gt;info('record level:INFO-category:info log info');\nwaring 日志\n// 打印和记录 `WANING` 等级、`waring` 分类的日志\n\\EasySwoole\\EasySwoole\\Logger::getInstance()-&gt;waring('record level:WANING-category:waring log info');\nconsole 日志\n// 只在控制台打印 `INFO` 等级、`debug` 分类的日志 (不记录日志文件)\n\\EasySwoole\\EasySwoole\\Logger::getInstance()-&gt;console('console', \\EasySwoole\\Log\\LoggerInterface::LOG_LEVEL_INFO, 'debug');\nnotice 日志\n// 打印和记录 `NOTICE` 等级、`notice` 分类的日志\n\\EasySwoole\\EasySwoole\\Logger::getInstance()-&gt;notice('record level:NOTICE-category:notice log info');\nerror 日志\n// 打印和记录 `ERROR` 等级、`error` 分类的日志\n\\EasySwoole\\EasySwoole\\Logger::getInstance()-&gt;error('record level:ERROR-category:error log info');\nevent 日志写入后执行回调\n使用 event 时，请先注册 Event。\n// 日志写入之后执行\n\\EasySwoole\\EasySwoole\\Logger::getInstance()-&gt;onLog()-&gt;set('myHook', function ($msg, $logLevel, $category) {\n    // 增加日志写入之后的回调函数\n});\n自定义日志处理器\n需要实现 EasySwoole\\Log\\LoggerInterface 即可：\n自定义示例如下，新建 App\\Log\\LogHandler.php 文件，编辑内容如下：\n&lt;?php\n\nnamespace App\\Log;\n\nuse EasySwoole\\Log\\LoggerInterface;\n\nclass LogHandler implements LoggerInterface\n{\n\n    private $logDir;\n\n    function __construct(string $logDir = null)\n    {\n        if (empty($logDir)) {\n            $logDir = getcwd();\n        }\n        $this-&gt;logDir = $logDir;\n    }\n\n    function log(?string $msg, int $logLevel = self::LOG_LEVEL_INFO, string $category = 'debug'): string\n    {\n        $date = date('Y-m-d H:i:s');\n        $levelStr = $this-&gt;levelMap($logLevel);\n        $filePath = $this-&gt;logDir . \"/log_{$category}.log\";\n        $str = \"自定义日志:[{$date}][{$category}][{$levelStr}] : [{$msg}]\\n\";\n        file_put_contents($filePath, \"{$str}\", FILE_APPEND | LOCK_EX);\n        return $str;\n    }\n\n    function console(?string $msg, int $logLevel = self::LOG_LEVEL_INFO, string $category = 'console')\n    {\n        $date = date('Y-m-d H:i:s');\n        $levelStr = $this-&gt;levelMap($logLevel);\n        $temp = \"自定义日志:[{$date}][{$category}][{$levelStr}]:[{$msg}]\\n\";\n        fwrite(STDOUT, $temp);\n    }\n\n    private function levelMap(int $level)\n    {\n        switch ($level) {\n            case self::LOG_LEVEL_INFO:\n                return 'info';\n            case self::LOG_LEVEL_NOTICE:\n                return 'notice';\n            case self::LOG_LEVEL_WARNING:\n                return 'warning';\n            case self::LOG_LEVEL_ERROR:\n                return 'error';\n            default:\n                return 'unknown';\n        }\n    }\n}\n注册自定义日志处理器\n\n(EasySwoole 3.4.4 及以上版本可使用) 方法1. 在配置文件 (dev.php / produce.php)中注册自定义日志处理器 \n\n&lt;?php\n\nuse EasySwoole\\Log\\LoggerInterface;\n\nreturn [\n    // ... 这里省略\n    'MAIN_SERVER' =&gt; [\n        // ... 这里省略\n    ],\n    \"LOG\" =&gt; [\n        'dir' =&gt; null,\n        'level' =&gt; LoggerInterface::LOG_LEVEL_DEBUG,\n        // 注册日志处理器 `handler` (handler)\n        'handler' =&gt;  new \\App\\Log\\LogHandler(),\n        'logConsole' =&gt; true,\n        'displayConsole'=&gt;true,\n        'ignoreCategory' =&gt; []\n    ],\n    // ... 这里省略\n];\n\n(EasySwoole 3.4.x+ 版本可使用) 方法2. 在 initialize 事件 中注册自定义 logger 处理器 \n\n注册示例代码如下：\n&lt;?php\n\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\n\nclass EasySwooleEvent implements Event\n{\n    public static function initialize()\n    {\n        date_default_timezone_set('Asia/Shanghai');\n\n        // 注册自定义 `logger` 处理器\n        \\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::LOGGER_HANDLER, new \\App\\Log\\LogHandler());\n\n        // 或使用如下方式进行注册自定义 `logger` 处理器\n        // \\EasySwoole\\EasySwoole\\Logger::getInstance(new \\App\\Log\\LogHandler());\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n\n    }\n}\n注意：针对 EasySwoole 3.4.x 之前版本，请在 bootstrap 事件（即项目根目录的 bootstrap.php 文件）中，使用 \\EasySwoole\\EasySwoole\\Logger::getInstance(new \\App\\Log\\LogHandler()); 方式注册自定义日志处理器。\n日志中心\n通常在一些情况下，会把数据往日志中心推送进行数据分析，在 onLog 回调，把日志信息，推送到日志中心即可。","link":"/BaseUsage/log.html"},{"id":118,"title":"异常","content":"Trigger\nEasySwoole\\EasySwoole\\Trigger触发器，用于主动触发错误或者异常而不中断程序继续执行。\n使用\n拦截异常并记录\n比如：在控制器的OnException中：\nprotected function onException(\\Throwable $throwable): void\n{\n    //拦截错误进日志,使控制器继续运行\n    \\EasySwoole\\EasySwoole\\Trigger::getInstance()-&gt;throwable($throwable);\n    $this-&gt;writeJson(\\EasySwoole\\Http\\Message\\Status::CODE_INTERNAL_SERVER_ERROR, null, $throwable-&gt;getMessage());\n}\n直接记录\n\\EasySwoole\\EasySwoole\\Trigger::getInstance()-&gt;error('test error');\n回调接管注册\n通常出现重大异常（支付失败等）需要进行报警处理，在全局的mainServerCreate事件中进行注册：\n\\EasySwoole\\EasySwoole\\Trigger::getInstance()-&gt;onException()-&gt;set('notify',function (\\Throwable $throwable){\n    // 自行实现通知代码\n});\n\n\\EasySwoole\\EasySwoole\\Trigger::getInstance()-&gt;onError()-&gt;set('notify',function ($msg){\n    // 自行实现通知代码\n});\n自定义处理类\n需要开发者实现EasySwoole\\Trigger\\TriggerInterface：\n&lt;?php\n\nnamespace App\\Exception;\n\nuse EasySwoole\\EasySwoole\\Logger;\nuse EasySwoole\\Trigger\\Location;\nuse EasySwoole\\Trigger\\TriggerInterface;\n\nclass TriggerHandel implements TriggerInterface\n{\n    public function error($msg, int $errorCode = E_USER_ERROR, Location $location = null)\n    {\n        Logger::getInstance()-&gt;console('这是自定义输出的错误:'.$msg);\n        // TODO: Implement error() method.\n    }\n\n    public function throwable(\\Throwable $throwable)\n    {\n        Logger::getInstance()-&gt;console('这是自定义输出的异常:'.$throwable-&gt;getMessage());\n        // TODO: Implement throwable() method.\n    }\n}\n在initialize事件中注入自定义trigger处理器：\n\n\\EasySwoole\\EasySwoole\\Trigger::getInstance(new \\App\\Exception\\TriggerHandel());\n","link":"/BaseUsage/trigger.html"},{"id":119,"title":"自定义命令","content":"自定义命令\nEasySwoole 默认自带有 5 个命令，如下所示: \nphp easyswoole crontab  对定时任务进行管理\nphp easyswoole install  安装(需要在./vendor/easyswoole/easyswoole/bin/easyswoole 文件中调用)\nphp easyswoole phpunit  执行单元测试 \nphp easyswoole process  对自定义进程进行管理\nphp easyswoole server   启动、停止、重启服务等\nphp easyswoole task     查看 task 任务的运行状态\n默认命令详细内容可查看 基础管理命令\n旧版本(3.4.x 之前版本)框架自定义命令的实现可查看 自定义命令 3.3.x\n定义命令\n通过实现 \\EasySwoole\\EasySwoole\\Command\\CommandInterface 接口，用户可自定义命令：\n该接口定义的方法如下：\n&lt;?php\n\nnamespace EasySwoole\\Command\\AbstractInterface;\n\ninterface CommandInterface\n{\n    public function commandName(): string;\n\n    public function exec(): ?string;\n\n    public function help(CommandHelpInterface $commandHelp): CommandHelpInterface;\n\n    public function desc(): string;\n}\n自定义命令使用示例\n实现自定义命令接口(AbstractInterface)\n新建文件 App/Command/Test.php，内容如下：\n&lt;?php\n\nnamespace App\\Command;\n\nuse EasySwoole\\Command\\AbstractInterface\\CommandHelpInterface;\nuse EasySwoole\\Command\\AbstractInterface\\CommandInterface;\nuse EasySwoole\\Command\\CommandManager;\nuse EasySwoole\\EasySwoole\\Command\\Utility;\n\nclass Test implements CommandInterface\n{\n    public function commandName(): string\n    {\n        return 'test';\n    }\n\n    public function exec(): ?string\n    {\n        // 获取用户输入的命令参数\n        $argv = CommandManager::getInstance()-&gt;getOriginArgv();\n\n        if (count($argv) &lt; 3) {\n            echo \"please input the action param!\" . PHP_EOL;\n            return null;\n        }\n\n        // remove test\n        array_shift($argv);\n\n        // 获取 action 参数\n        $action = $argv[1];\n\n        // 下面就是对 自定义命令 的一些处理逻辑\n        if (!$action) {\n            echo \"please input the action param!\" . PHP_EOL;\n            return null;\n        }\n\n        // 获取 option 参数\n        $optionArr = $argv[2] ?? [];\n\n        switch ($action) {\n            case 'echo_string':\n                if ($optionArr) {\n                    $strValue = explode('=', $optionArr);\n                    echo $strValue[1] . PHP_EOL;\n                } else {\n                    echo 'this is test!' . PHP_EOL;\n                }\n                break;\n            case 'echo_date':\n                if ($optionArr) {\n                    $strValue = explode('=', $optionArr);\n                    echo \"now is \" . date('Y-m-d H:i:s') . ' ' . $strValue[1] . '!' . PHP_EOL;\n                } else {\n                    echo \"now is \" . date('Y-m-d H:i:s') . '!' . PHP_EOL;\n                }\n                break;\n            case 'echo_logo':\n                echo Utility::easySwooleLog();\n                break;\n            default:\n                echo \"the action {$action} is not existed!\" . PHP_EOL;\n        }\n        return null;\n    }\n\n    public function help(CommandHelpInterface $commandHelp): CommandHelpInterface\n    {\n        // 添加 自定义action(action 名称及描述)\n        $commandHelp-&gt;addAction('echo_string', 'print the string');\n        $commandHelp-&gt;addAction('echo_date', 'print the date');\n        $commandHelp-&gt;addAction('echo_logo', 'print the logo');\n        // 添加 自定义action 可选参数\n        $commandHelp-&gt;addActionOpt('--str=str_value', 'the string to be printed ');\n        return $commandHelp;\n    }\n\n    // 设置自定义命令描述\n    public function desc(): string\n    {\n        return 'this is test command!';\n    }\n}\n注册自定义命令\n在 bootstrap 事件 中注册自定义命令。\n修改项目根目录的 bootstrap.php 文件，添加如下内容实现注册自定义命令:\n&lt;?php\n//全局bootstrap事件\ndate_default_timezone_set('Asia/Shanghai');\n\n\\EasySwoole\\Command\\CommandManager::getInstance()-&gt;addCommand(new \\App\\Command\\Test());\nbootstrap 事件 是 3.2.5 新增的事件，它允许用户在框架初始化之前执行自定义事件。\n执行命令结果\n$ php easyswoole test\nplease input the action param!\n\n$ php easyswoole test -h\nThis is test command!\nUsage:\n  easyswoole test ACTION [--opts ...]\nActions:\n  echo_string  print the string\n  echo_date    print the date\n  echo_logo    print the logo\nOptions:\n  --str=str_value  the string to be printed \n\n$ php easyswoole test echo_string\nthis is test!\n\n$ php easyswoole test echo_date\nnow is 2021-02-23 19:23:19!\n\n$ php easyswoole test echo_logo\n  ______                          _____                              _\n |  ____|                        / ____|                            | |\n | |__      __ _   ___   _   _  | (___   __      __   ___     ___   | |   ___\n |  __|    / _` | / __| | | | |  \\___ \\  \\ \\ /\\ / /  / _ \\   / _ \\  | |  / _ \\\n | |____  | (_| | \\__ \\ | |_| |  ____) |  \\ V  V /  | (_) | | (_) | | | |  __/\n |______|  \\__,_| |___/  \\__, | |_____/    \\_/\\_/    \\___/   \\___/  |_|  \\___|\n                          __/ |\n                         |___/\n\n$ php easyswoole test echo_string --str=\"hello easyswoole\"\nhello easyswoole","link":"/BaseUsage/customCommand.html"},{"id":120,"title":"单元测试","content":"Phpunit 组件\nEasySwoole/Phpunit 是对 Phpunit 的协程定制化封装，主要为解决自动协程化入口的问题。并屏蔽了 Swoole ExitException。\n组件要求\n\nphp: &gt;= 7.3\next-swoole: ^4.4.0\nphpunit/phpunit: ^9.3\n\n安装方法\n\ncomposer require easyswoole/phpunit\n\n仓库地址\neasy-swoole/phpunit\n基本使用\n\n./vendor/bin/co-phpunit tests\n\n或者使用以下方式：\n\nphp easyswoole phpunit tests\n\n默认采用协程容器去执行测试用例，使用非协程采用以下方式：\n\nphp easyswoole phpunit --no-coroutine\n\n注：tests 为要的测试目录，用于放需要进行单元测试的文件。\n预处理\neasyswoole/phpunit 支持在项目目录下定义一个 phpunit.php，用户可以在该文件中，进行统一的测试前预处理，其他测试与 phpunit 一致。\n如何进行单元测试\n这里以 ORM 组件为测试演示：\n连接注册\n请在 EasySwoole 全局的 initialize 事件中注册。\n&lt;?php\n\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\nuse EasySwoole\\ORM\\Db\\Connection;\nuse EasySwoole\\ORM\\DbManager;\n\nclass EasySwooleEvent implements Event\n{\n    public static function initialize()\n    {\n        date_default_timezone_set('Asia/Shanghai');\n\n        $config = new \\EasySwoole\\ORM\\Db\\Config(Config::getInstance()-&gt;getConf(\"MYSQL\"));\n        DbManager::getInstance()-&gt;addConnection(new Connection($config));\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n\n    }\n}\n预处理\n请在 EasySwoole 项目根目录下创建 phpunit.php 文件。\n&lt;?php\n\nuse EasySwoole\\EasySwoole\\Core;\n\nrequire_once __DIR__ . '/vendor/autoload.php';\n\nCore::getInstance()-&gt;initialize();\n注：在 3.4.x 之前版本，initialize 事件调用为：EasySwoole\\EasySwoole\\Core::getInstance()-&gt;initialize()-&gt;globalInitialize();。\n编写测试用例\n新建 tests\\DbTest.php，编辑内容如下：\n&lt;?php\n\nnamespace Tests;\nuse EasySwoole\\Mysqli\\QueryBuilder;\nuse PHPUnit\\Framework\\TestCase;\nuse EasySwoole\\ORM\\DbManager;\n\nclass DbTest extends TestCase\n{\n    function testCon()\n    {\n        $builder = new QueryBuilder();\n        $builder-&gt;raw('select version()');\n        $ret = DbManager::getInstance()-&gt;query($builder,true)-&gt;getResult();\n        $this-&gt;assertArrayHasKey('version()',$ret[0]);\n    }\n}\n注：请注册 composer.json 下 Tests 命名空间与 tests 目录的映射关系。\n映射关系大致如下所示：\n{\n    \"require\": {\n        \"easyswoole/easyswoole\": \"3.4.4\",\n        \"easyswoole/phpunit\": \"^1.0\",\n        \"easyswoole/orm\": \"^1.4\"\n    },\n    \"autoload\": {\n        \"psr-4\": {\n            \"App\\\\\": \"App/\",\n            \"Tests\\\\\": \"tests/\"\n        }\n    }\n}\n然后执行 composer dumpautoload。\n执行\n\n./vendor/bin/co-phpunit tests\n\n或者执行\n\nphp easyswoole phpunit tests/DbTest.php\n","link":"/Components/phpunit.html"},{"id":121,"title":"异步任务","content":"Task\nEasySwoole 3.3.0+ 异步任务放弃了 Swoole 的原生 task，采用独立组件实现。\n相对于原生 Swoole Task，easyswoole/task 组件实现了以下功能：\n\n可以投递闭包任务\n可以在 TaskWorker 等其他自定义进程继续投递任务\n实现任务限流与状态监控  \n\n安装\n\ncomposer require easyswoole/task\n\n框架中使用\n同步调用：\n\\EasySwoole\\EasySwoole\\Task\\TaskManager::getInstance()-&gt;sync(function (){\n    echo 'sync';\n});\n异步调用：\n\\EasySwoole\\EasySwoole\\Task\\TaskManager::getInstance()-&gt;async(function () {\n    echo 'async';\n}, function ($reply, $taskId, $workerIndex) {\n    // $reply 返回的执行结果\n    // $taskId 任务id\n    echo 'async success';\n});\n由于 php 本身就不能序列化闭包，该闭包投递是通过反射该闭包函数，获取 php 代码直接序列化 php 代码，然后直接 eval 代码实现的。\n所以投递闭包无法使用外部的对象引用，以及资源句柄，复杂任务请使用任务模板方法。\n任务模版\n自定义一个任务模版\n&lt;?php\n\nnamespace App\\Task;\n\nuse EasySwoole\\Task\\AbstractInterface\\TaskInterface;\n\nclass CustomTask implements TaskInterface\n{\n    protected $data;\n\n    public function __construct($data)\n    {\n        // 保存投递过来的数据\n        $this-&gt;data = $data;\n    }\n\n    public function run(int $taskId, int $workerIndex)\n    {\n        // 执行逻辑\n    }\n\n    public function onException(\\Throwable $throwable, int $taskId, int $workerIndex)\n    {\n        // 异常处理\n    }\n}\n如何使用\n$task = \\EasySwoole\\EasySwoole\\Task\\TaskManager::getInstance();\n\n// 投递异步任务\n$task-&gt;async(new CustomTask(['user' =&gt; 'custom']));\n\n// 投递同步任务\n$data = $task-&gt;sync(new CustomTask(['user' =&gt; 'custom']));\n投递返回值\neasyswoole/task 组件在 1.0.8 及以前版本支持，如下 4 个投递返回值：\n\n\n&gt; 0 投递成功（异步任务专属，返回 taskId，同步任务直接返回 run() 方法运行之后返回的值)\n\n-1 task 进程繁忙，投递失败 (已经到达最大运行数量 maxRunningNum )\n\n-2 投递数据解包失败，当投递数据传输时数据异常时会报错，此错误为组件底层错误，一般不会出现\n\n-3 任务出错 (该任务执行时出现异常错误，被组件拦截并输出错误)\n\n在 1.0.9 ~ 1.1.1 版本，除了支持上述 4 个投递返回值，还新增支持了以下 2 个投递返回值：\n\n\n-4 投递的任务数据不合法，一般是投递了不能序列化的数据才会出现。\n\n-5 投递的任务在运行时出错\n\n在最新的版本及以后版本中，又新增支持了以下 2 个投递返回值：\n\n\n-6 投递的任务数据包已过期，一般是 Task 进程比较繁忙时才会出现。\n\n-7 投递任务时，任务运行完成后没有任何数据返回。一般是因为执行任务时间过长导致 UnixSocket 超时，才会出现。\n\n独立使用\n该组件可独立使用，代码如下：\n&lt;?php\n\nuse EasySwoole\\Task\\Config;\nuse EasySwoole\\Task\\Task;\n\nrequire_once __DIR__ . '/vendor/autoload.php';\n\n/**\n * 配置项中可以修改工作进程数、临时目录，进程名，最大并发执行任务数，异常回调等\n */\n$config = new Config();\n$task = new Task($config);\n\n// 添加 swoole 服务\n$http = new \\Swoole\\Http\\Server(\"0.0.0.0\", 9501);\n\n// 注入 swoole 服务，进行创建 task 进程\n$task-&gt;attachToServer($http);\n\n// 在 onrequest 事件中调用 task (其他地方也可以，这只是示例)\n$http-&gt;on(\"request\", function (\\Swoole\\Http\\Request $request, \\Swoole\\Http\\Response $response) use ($task) {\n    if (isset($request-&gt;get['sync'])) {\n        // 同步调用 task\n        $ret = $task-&gt;sync(function ($taskId, $workerIndex) {\n            return \"{$taskId}.{$workerIndex}\";\n        });\n        $response-&gt;end(\"sync result \" . $ret);\n    } else if (isset($request-&gt;get['status'])) {\n        var_dump($task-&gt;status());\n    } else {\n        // 异步调用 task\n        $id = $task-&gt;async(function ($taskId, $workerIndex) {\n            \\co::sleep(1);\n            var_dump(\"async id {$taskId} task run\");\n        });\n        $response-&gt;end(\"async id {$id} \");\n    }\n});\n// 启动服务\n$http-&gt;start();\n版本强调\n框架低版本升级为 EasySwoole 3.3.0+，需要手动进行配置修改。  \n需要删除 MAIN_SERVER.SETTING.task_worker_num，MAIN_SERVER.SETTING.task_enable_coroutine 配置项。       \n请在项目根目录的 dev.php/produce.php 的 MAIN_SERVER 配置项中，增加 TASK 子配置项：\n&lt;?php\n\n// 这里省略\n\nreturn [\n    // 这里省略 ...\n\n    'MAIN_SERVER' =&gt; [\n\n        // 这里省略 ...\n\n        'TASK' =&gt; [\n            'workerNum' =&gt; 4,\n            'maxRunningNum' =&gt; 128,\n            'timeout' =&gt; 15\n        ]\n    ],\n\n    // 这里省略 ...\n];\nTask管理\n查看所有Task进程的状态\n\nphp easyswoole task status\n","link":"/Components/Component/task.html"},{"id":122,"title":"自定义进程","content":"自定义进程\nPHP自带的pcntl存在许多不足，不支持重定向标准输入和输出及进程间通信的功能，且容易使用错误。\nEasySwoole基于Swoole的Process模块进行了封装，来创建工作进程，用于处理耗时任务，消息队列，等其它的特殊任务。\n在EasySwoole启动时，会自动创建注册的进程，并执行进程指定的逻辑代码，进程意外退出时，会被重新拉起。\n创建一个自定义进程\n需要定义一个进程类继承EasySwoole\\Component\\Process\\AbstractProcess。\n定义进程内执行逻辑回调\nprotected function run($arg)\n{\n    // TODO: Implement run() method.\n    $this-&gt;getProcessName(); // 获取注册进程名称\n\n    $this-&gt;getProcess(); // 获取进程实例 \\Swoole\\Process\n\n    $this-&gt;getPid(); // 获取当前进程Pid\n\n    $this-&gt;getArg(); // 获取注册时传递的参数\n}\n进程间通信Pipe回调\nprotected function onPipeReadable(Process $process)\n{\n    // 该回调可选\n    // 当主进程对子进程发送消息的时候 会触发\n    $process-&gt;read(); // 读取消息\n}\n进程间异常回调\nprotected function onException(\\Throwable $throwable, ...$args)\n{\n    // 该回调可选\n    // 捕获run方法内抛出的异常\n    // 这里可以通过记录异常信息来帮助更加方便的知道出现问题的代码\n}\n进程信号回调\nprotected function onSigTerm()\n{\n    // 当进程接收到 SIGTERM 信号触发该回调\n}\n进程意外退出回调\nprotected function onShutDown()\n{\n    // 该回调可选\n    // 进程意外退出 触发此回调\n    // 大部分用于清理工作\n}\n注册进程\n在 EasySwoole 全局的 mainServerCreate 事件中进行进程注册\n$processConfig = new \\EasySwoole\\Component\\Process\\Config([\n    'processName' =&gt; 'CustomProcess', // 设置 自定义进程名称\n    'processGroup' =&gt; 'Custom', // 设置 自定义进程组名称\n    'arg' =&gt; [\n        'arg1' =&gt; 'this is arg1!'\n    ], // 【可选参数】设置 注册进程时要传递给自定义进程的参数，可在自定义进程中通过 $this-&gt;getArg() 进行获取\n    'enableCoroutine' =&gt; true, // 设置 自定义进程自动开启协程\n]);\n\n\\EasySwoole\\Component\\Process\\Manager::getInstance()-&gt;addProcess(new CustomProcess($processConfig));\n推荐使用 \\EasySwoole\\Component\\Process\\Manager 类进行注册自定义进程，注册方式示例代码如上所示。如果您的框架版本过低，不支持 \\EasySwoole\\Component\\Process\\Manager 类，可使用如下方式进行注册自定义进程: \\EasySwoole\\EasySwoole\\ServerManager::getInstance()->getSwooleServer()->addProcess((new TickProcessnew CustomProcess($processConfig));\n完整示例代码\n1. 定义自定义进程类示例\n首先，我们定义一个自定义进程类继承 \\EasySwoole\\Component\\Process\\AbstractProcess 类，示例代码如下：\n&lt;?php\nnamespace App\\Process;\n\nuse EasySwoole\\Component\\Process\\AbstractProcess;\nuse Swoole\\Process;\n\nclass CustomProcess extends AbstractProcess\n{\n    protected function run($arg)\n    {\n        // TODO: Implement run() method.\n        $processName = $this-&gt;getProcessName(); // 获取 注册进程名称\n        $swooleProcess = $this-&gt;getProcess(); // 获取 注册进程的实例 \\Swoole\\Process\n        $processPid = $this-&gt;getPid(); // 获取 当前进程 Pid\n        $args = $this-&gt;getArg(); // 获取 注册进程时传递的参数\n\n        var_dump('### 开始运行自定义进程 start ###');\n        var_dump($processName, $swooleProcess, $processPid, $args);\n        var_dump('### 运行自定义进程结束 end ###');\n    }\n\n    protected function onPipeReadable(Process $process)\n    {\n        // 该回调可选\n        // 当主进程对子进程发送消息的时候 会触发\n        $recvMsgFromMain = $process-&gt;read(); // 用于获取主进程给当前进程发送的消息\n        var_dump('收到主进程发送的消息: ');\n        var_dump($recvMsgFromMain);\n    }\n\n    protected function onException(\\Throwable $throwable, ...$args)\n    {\n        // 该回调可选\n        // 捕获 run 方法内抛出的异常\n        // 这里可以通过记录异常信息来帮助更加方便地知道出现问题的代码\n    }\n\n    protected function onShutDown()\n    {\n        // 该回调可选\n        // 进程意外退出 触发此回调\n        // 大部分用于清理工作\n    }\n\n    protected function onSigTerm()\n    {\n        // 当进程接收到 SIGTERM 信号触发该回调\n    }\n}\n2. 注册进程示例\n然后在 mainServerCreate 事件中进行注册进程，示例代码如下：\n&lt;?php\n\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\n\nclass EasySwooleEvent implements Event\n{\n    public static function initialize()\n    {\n        date_default_timezone_set('Asia/Shanghai');\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        $processConfig = new \\EasySwoole\\Component\\Process\\Config([\n            'processName' =&gt; 'CustomProcess', // 设置 进程名称为 TickProcess\n            'processGroup' =&gt; 'Custom', // 设置 进程组名称为 Tick\n            'arg' =&gt; [\n                'arg1' =&gt; 'this is arg1!',\n            ], // 传递参数到自定义进程中\n            'enableCoroutine' =&gt; true, // 设置 自定义进程自动开启协程环境\n        ]);\n\n        // 【推荐】使用 \\EasySwoole\\Component\\Process\\Manager 类注册自定义进程\n        $customProcess = (new \\App\\Process\\CustomProcess($processConfig));\n        // 【可选操作】把 tickProcess 的 Swoole\\Process 注入到 Di 中，方便在后续控制器等业务中给自定义进程传输信息(即实现主进程与自定义进程间通信)\n        \\EasySwoole\\Component\\Di::getInstance()-&gt;set('customSwooleProcess', $customProcess-&gt;getProcess());\n        // 注册进程\n        \\EasySwoole\\Component\\Process\\Manager::getInstance()-&gt;addProcess($customProcess);\n\n        /*\n        #【针对于低版本不支持 \\EasySwoole\\Component\\Process\\Manager 类】可使用 \\EasySwoole\\EasySwoole\\ServerManager 类注册自定义进程\n        $customProcess = (new \\App\\Process\\CustomProcess($processConfig))-&gt;getProcess();\n        // 【可选操作】把 tickProcess 的 Swoole\\Process 注入到 Di 中，方便在后续控制器等业务中给自定义进程传输信息(即实现主进程与自定义进程间通信)\n        \\EasySwoole\\Component\\Di::getInstance()-&gt;set('customSwooleProcess', $customProcess);\n        // 注册进程\n        \\EasySwoole\\EasySwoole\\ServerManager::getInstance()-&gt;getSwooleServer()-&gt;addProcess($customProcess);\n        */\n    }\n}\n3. 向自定义进程中传递消息\n&lt;?php\n\nnamespace App\\HttpController;\n\nuse EasySwoole\\Component\\Di;\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\n\nclass Index extends Controller\n{\n    public function index()\n    {\n        // 获取 Di 中注入的 自定义进程\n        $customProcess = Di::getInstance()-&gt;get('customSwooleProcess');\n        // 向自定义进程中传输信息，会触发自定义进程的 onPipeReadable 回调\n        $customProcess-&gt;write('this is test!');\n    }\n}\n进程管理命令说明\nEasySwoole 内置了对于 Process 的命令行操作，方便开发者非常友好地去管理 Process。\n可执行 php easyswoole process -h 来查看具体操作。\n显示所有进程\n\nphp easyswoole process show\n\n如果想要以 MB 形式显示：\n\nphp easyswoole process show -d\n\n杀死指定进程(PID)\n\nphp easyswoole process kill --pid=PID\n\n杀死指定进程组(GROUP)\n\nphp easyswoole process kill --group=GROUP_NAME\n\n杀死所有进程\n\nphp easyswoole process killAll\n\n强制杀死进程\n需要带上 -f 参数，例如：\n\nphp easyswoole process kill --pid=PID -f\n","link":"/Components/Component/process.html"},{"id":123,"title":"ioc 容器","content":"依赖注入\nDependency Injection  依赖注入\nEasySwoole 实现了简单版的 IOC 容器，使用 IOC 容器 可以很方便地存储/获取资源，实现解耦。\n使用依赖注入，最重要的一点好处就是有效地分离了对象和它所需要的外部资源，使得它们松散耦合，有利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。\n在我们的日常开发中，创建对象的操作随处可见，以至于对其十分熟悉的同时又感觉十分繁琐，每次需要对象都需要亲手将其 new 出来，甚至某些情况下由于坏编程习惯还会造成对象无法被回收，这是相当糟糕的。但更为严重的是，我们一直倡导的松耦合、少入侵原则，这种情况下变得一无是处。于是前辈们开始谋求改变这种编程陋习，考虑如何使用编码更加解耦合，由此而来的解决方案是面向接口的编程。\n注意：在服务启动后，对 IOC容器 的获取/注入仅限当前进程有效。不对其他 worker 进程产生影响。\n方法列表\ngetInstance\n用于获取依赖注入组件 IoC 容器 对象。\n使用示例：\n$di = \\EasySwoole\\Component\\Di::getInstance();\nset\n用于向 IoC 容器 中注入内容。\n函数原型：set($key, $obj, ...$arg): void\n\n\n$key: 键名。\n\n\n$obj: 要注入的内容。支持注入对象名、对象实例、闭包、资源、字符串等各种常见变量。\n\n\n$arg: 若注入的内容为 is_callable 类型，则可以设置该参数以供 callable 执行时传入。\n\n\n使用示例：\n$di-&gt;set('test', new TestClass());\n$di-&gt;set('test', TestClass::class);\n\n// set 的时候储存的是[类名, 方法名]的数组，需要自己手动调用 call_user_func() 执行（不要被错误与异常章节的 demo 误解为会自动执行)\n$di-&gt;set('test', [TestClass::class,'testFunction']);\n\n// set 的时候传递了类名，get 的时候才去 new 对象，并且将可变变量传递进构造函数，返回实例化后的对象\n$di-&gt;set('test', TestClass::class, $arg_one, $arg_tow);\nDi 的 set 方法为懒惰加载模式，若 set 一个对象名或者闭包，则该对象不会马上被创建。\nget\n用户获取 IoC 容器 中某个注入的内容。\n函数原型：get($key)\n\n$key: 调用 set 方法时设置的键名。\n\n使用示例：\n$val = $di-&gt;get('test');\ndelete\n用户删除 IoC 容器 中某个注入的内容。\n函数原型：delete($key): void\n\n$key: 调用 set 方法时设置的键名。\n\n使用示例：\n$di-&gt;delete('test');\nclear\n用于清空 IoC 容器 的所有内容。\n函数原型：clear($key): void\n\n$key: 调用 set 方法时设置的键名。\n","link":"/Components/Component/ioc.html"},{"id":124,"title":"控制器","content":"控制器\n功能介绍\n毫无疑问，控制器层是负责处理客户端请求，转发给响应模型，并将结果返回给客户端。EasySwoole 使用了对象池复用模式，降低对象创建、销毁的开销，注入 request 和 response 对象来完成客户端与服务端之间的交互。\n示例\n\n在 App/HttpController/ 目录下增加文件 User.php\n\n代码\n&lt;?php\n/**\n * @CreateTime:   2020/8/19 12:30 上午\n * @Author:       huizhang  &lt;2788828128@qq.com&gt;\n * @Copyright:    copyright(2020) Easyswoole all rights reserved\n * @Description:  用户控制器\n */\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\n\nclass User extends Controller\n{\n\n    /**\n     * 用户信息\n     *\n     * @return string\n     * CreateTime: 2020/8/19 12:37 上午\n     */\n    public function userInfo()\n    {\n        // 获取 get 参数\n        $name = $this-&gt;request()-&gt;getQueryParam('name');\n\n        // 输出到终端\n        var_dump($name);\n\n        // 返回给客户端\n        $this-&gt;response()-&gt;write($name . PHP_EOL);\n\n        // return 返回的值会让框架在此进行控制器方法调度，将继续执行 User 控制器类的 requestTotal 方法 \n        return '/User/requestTotal';\n    }\n\n    /**\n     * 接口请求量\n     *\n     * CreateTime: 2020/8/19 12:37 上午\n     */\n    public function requestTotal()\n    {\n        $this-&gt;response()-&gt;write('请求数+1' . PHP_EOL);\n\n        // 还可以 return，但不要两个方法互相调用，会导致死循环\n    }\n\n    /**\n     * 此控制器抛异常时会执行此方法\n     *\n     * @param \\Throwable $throwable\n     * @throws \\Throwable\n     * CreateTime: 2020/8/19 12:48 上午\n     */\n    public function onException(\\Throwable $throwable): void\n    {\n        parent::onException($throwable); // TODO: Change the autogenerated stub\n    }\n\n    /**\n     * gc 方法将在执行完 afterAction 方法之后自动调用，可自行覆盖实现其他的 gc 回收逻辑\n     *\n     * CreateTime: 2020/8/19 12:52 上午\n     */\n    public function gc()\n    {\n        parent::gc(); // TODO: Change the autogenerated stub\n    }\n\n    /**\n     * 当控制器方法执行结束之后将调用该方法，可自行覆盖该方法实现数据回收等逻辑\n     *\n     * @param string|null $actionName\n     * CreateTime: 2020/8/19 12:51 上午\n     */\n    public function afterAction(?string $actionName): void\n    {\n        parent::afterAction($actionName); // TODO: Change the autogenerated stub\n    }\n\n    /**\n     * 当请求方法未找到时，自动调用该方法，可自行覆盖该方法实现自己的逻辑\n     *\n     * @param string|null $action\n     * CreateTime: 2020/8/19 12:51 上午\n     */\n    public function actionNotFound(?string $action)\n    {\n        parent::actionNotFound($action); // TODO: Change the autogenerated stub\n    }\n\n    /**\n     * 所有控制器请求都会先经过该方法，如果此方法返回 false 则请求不继续往下执行，可用于权限验证\n     *\n     * @param string|null $action\n     * @return bool|null\n     * CreateTime: 2020/8/19 12:52 上午\n     */\n    public function onRequest(?string $action): ?bool\n    {\n        return parent::onRequest($action); // TODO: Change the autogenerated stub\n    }\n\n}\n\n执行过程\n\n启动 easyswoole\n\nphp easyswoole server start\n\n访问\n\ncurl http://localhost:9501/user/userInfo?name=easyswoole\n执行结果\n\n服务端输出\n\n➜  doc-new git:(master) ✗ php easyswoole server start\n#!/usr/bin/env php\n  ______                          _____                              _\n |  ____|                        / ____|                            | |\n | |__      __ _   ___   _   _  | (___   __      __   ___     ___   | |   ___\n |  __|    / _` | / __| | | | |  \\___ \\  \\ \\ /\\ / /  / _ \\   / _ \\  | |  / _ \\\n | |____  | (_| | \\__ \\ | |_| |  ____) |  \\ V  V /  | (_) | | (_) | | | |  __/\n |______|  \\__,_| |___/  \\__, | |_____/    \\_/\\_/    \\___/   \\___/  |_|  \\___|\n                          __/ |\n                         |___/\n\nmain server                   SWOOLE_WEB\nlisten address                0.0.0.0\nlisten port                   9501\nworker_num                    8\nreload_async                  true\nmax_wait_time                 3\ndocument_root                 /Users/guoyuzhao/sites/doc-new/Static\nenable_static_handler         true\npid_file                      /Users/guoyuzhao/sites/doc-new/Temp/pid.pid\nlog_file                      /Users/guoyuzhao/sites/doc-new/Log/swoole.log\nuser                          guoyuzhao\nswoole version                4.5.2\nphp version                   7.4.8\neasyswoole version            3.4.0-dev\nrun mode                      dev\ntemp dir                      /Users/guoyuzhao/sites/doc-new/Temp\nlog dir                       /Users/guoyuzhao/sites/doc-new/Log\nstring(10) \"easyswoole\"\n客户端输出\n➜  ssh curl http://localhost:9501/user/userInfo\\?name\\=easyswoole\n\neasyswoole\n请求数+1\n控制器方法\n\neasyswoole 在控制器基类中实现了几个通用方法，当然用户也可根据需要进行方法重写实现自己的逻辑 \n\nonRequest\n\n所有控制器请求都会先经过该方法，如果此方法返回 false 则请求不继续往下执行，可用于权限验证\n\nprotected function onRequest(?string $action): ?bool\n{\n    return true;\n}\nonException\n\n当执行控制器方法抛异常时会调用该方法，可自行覆盖该方法实现异常捕获等逻辑\n\nprotected function onException(\\Throwable $throwable): void\n{\n    throw $throwable;\n}\nafterAction\n\n当 action 执行结束后调用该方法，可自行覆盖该方法实现数据回收等逻辑\n\nprotected function afterAction(?string $actionName): void\n{\n\n}\nactionNotFound\n\n当请求方法未找到时，自动调用此方法\n\nprotected function actionNotFound(?string $action)\n{\n    $class = static::class;\n    $this-&gt;writeJson(\\EasySwoole\\Http\\Message\\Status::CODE_NOT_FOUND,null,\"{$class} has not action for {$action}\");\n}\ngc\n\ngc 方法在 afterAction 方法执行完后调用\n\nprotected function gc()\n{\n    //恢复默认值\n    foreach ($this-&gt;defaultProperties as $property =&gt; $value) {\n        $this-&gt;{$property} = $value;\n    }\n}\n注意事项\n\n只有第一次请求时才会调用构造函数\n对象池模式只重置非静态 public 属性\n对象池复用模式只针对单一进程，多个 worker 进程不共享\n文件夹、文件、类名为大驼峰，变量与类方法小驼峰(规范)\naction 返回的字符串将会被 url 解析规则以及 route 路由规则解析\n两个 action 的 return 不能互相调用，否则将导致死循环\n","link":"/HttpServer/contorller.html"},{"id":125,"title":"请求对象","content":"Request 对象\n接收客户端的 HTTP 请求对象\n生命周期\nRequest 对象在系统中以单例模式存在，自收到客户端 HTTP 请求时自动创建，直至请求结束自动销毁。Request 对象完全符合 PSR-7 中的所有规范。\n核心方法\ngetRequestParam()\n用于获取用户通过 POST 或者 GET 提交的参数（注意：若 POST 与 GET 存在同键名参数，则以POST 为准）。\n示例：\n// 在控制器中 可以通过 $this-&gt;request() 获取到 Request 对象\n// $request = $this-&gt;request()；\n\n// 获取 `POST` 或者 `GET` 提交的所有参数\n$data = $request-&gt;getRequestParam();\nvar_dump($data);\n\n// 获取 `POST` 或者 `GET` 提交的单个参数\n$orderId = $request-&gt;getRequestParam('orderId');\nvar_dump($orderId);\n\n// 获取 `POST` 或者 `GET` 提交的多个参数\n$mixData = $request-&gt;getRequestParam(\"orderId\",\"type\");\nvar_dump($mixData);\ngetSwooleRequest()\n获取当前的 swoole_http_request 对象。\ngetCookieParams()\n获取 HTTP 请求中的 cookie 信息\n// 获取所有 `cookie` 信息\n$all = $request-&gt;getCookieParams();\nvar_dump($all);\n\n// 获取单个 `cookie` 信息\n$who = $request-&gt;getCookieParams('who');\nvar_dump($who);\ngetUploadedFiles()\n获取客户端上传的全部文件信息。\n// 获取一个上传文件，返回的是一个 \\EasySwoole\\Http\\Message\\UploadFile 的对象\n$img_file = $request-&gt;getUploadedFile('img');\n\n// 获取全部上传文件返回包含 \\EasySwoole\\Http\\Message\\UploadFile 对象的数组\n$data = $request-&gt;getUploadedFiles();\nvar_dump($data);\n点击查看 UploadFile对象\ngetBody()\n获取以非 form-data 或 x-www-form-urlenceded 编码格式 POST 提交的原始数据，相当于PHP中的 $HTTP_RAW_POST_DATA。\n获得 get 内容\n$get = $request-&gt;getQueryParams();\n获得 post 内容\n$post = $request-&gt;getParsedBody();\n获得 raw 内容\n\n例如在常用的 post 请求中，Content-Type 为 application/json 时就可用如下方法获取 json 请求体内容。\n\n$content = $request-&gt;getBody()-&gt;__toString();\n$raw_array = json_decode($content, true);\n获得头部\n$header = $request-&gt;getHeaders();\n获得 server\n$server = $request-&gt;getServerParams();\n获得 cookie\n$cookie = $request-&gt;getCookieParams();\n将数据挂载到当前请求对象 $request 上\n将某个需要的数据挂载到当前请求对象 $request 上，方便在本次请求生命周期内的后续其他方法中调用这个数据。\n支持链式调用。\n$this-&gt;request()-&gt;withAttribute($key, $value);\n\n// 链式调用\n$this-&gt;request()-&gt;withAttribute($key1, $value1)-&gt;withAttribute($key2, $value2);\n\n注意：挂载的数据只对每次请求当前请求生命周期有效。\n\n获取当前请求对象 $request 上的挂载数据\n// 获取单个数据\n$this-&gt;request()-&gt;getAttribute($key);\n\n// 获取所有 返回数组\n$this-&gt;request()-&gt;getAttributes(); // array\n\n注意：挂载的数据只对每次请求当前请求生命周期有效。\n\n丢弃挂载到当前请求对象 $request 上的某个数据\n$this-&gt;request()-&gt;withoutAttribute($uselessKey);\n使用示例：\n&lt;?php\n\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\n\nclass Index extends Controller\n{\n    public function onRequest(?string $action): ?bool\n    {\n        // 挂载数据 到 $request 对象上\n        $this-&gt;request()-&gt;withAttribute('name', 'easyswoole')\n            -&gt;withAttribute('age', 18);\n\n        return parent::onRequest($action); // TODO: Change the autogenerated stub\n    }\n\n    public function index()\n    {\n        // 获取挂载的单个数据\n        $ret = $this-&gt;request()-&gt;getAttribute('name'); // 'easyswoole'\n\n        // 获取挂载的全部数据\n        $rets = $this-&gt;request()-&gt;getAttributes();\n\n        // 删除某个挂载数据\n        $this-&gt;request()-&gt;withoutAttribute('name');\n\n        // 再次获取挂载的全部数据\n        $rets1 = $this-&gt;request()-&gt;getAttributes();\n\n        var_dump($ret, $rets, $rets1);\n\n        // 运行结果：\n        /*\n        string(10) \"easyswoole\"\n        array(2) {\n          [\"name\"]=&gt;\n          string(10) \"easyswoole\"\n          [\"age\"]=&gt;\n          int(18)\n        }\n        array(1) {\n          [\"age\"]=&gt;\n          int(18)\n        }\n        */\n    }\n}","link":"/HttpServer/request.html"},{"id":126,"title":"响应对象","content":"Response 对象\n响应客户端的请求\n生命周期\nResponse 对象在系统中以单例模式存在，自收到客户端 HTTP 请求时自动创建，直至请求结束自动销毁。Response 对象完全符合 PSR-7 中的所有规范。\n其他细节方法，有兴趣的同学可以在 IDE 中查看对应的代码。\n在控制器中可以通过 $this-&gt;response() 获取到 Response 对象。\n$response = $this-&gt;response();\n核心方法\nwrite\n向客户响应数据。\n// 向客户端响应 字符串数据\n$this-&gt;response()-&gt;write('hello world');\n\n注意：当向客户端响应中文字符串时，请务必设置响应头，并在 Content-Type 属性中指定编码，否则将显示乱码。\n\n示例：\n// 向客户端响应 中文字符串\n// 设置响应头，并在 `Content-Type` 属性中指定编码\n$this-&gt;response()-&gt;withHeader('Content-Type', 'text/html;charset=utf-8');\n$this-&gt;response()-&gt;write('你好! easyswoole!');\n\n// 向客户端响应 json 字符串\n$this-&gt;response()-&gt;withHeader('Content-Type', 'application/json;charset=utf-8');\n$this-&gt;response()-&gt;write(json_encode(['name' =&gt; 'easyswoole']));\n在控制器中可直接调用 $this->writeJson($statusCode = 200, $result = null, $msg = null) 方法向客户端响应 json 字符串\n示例：\n// 在 `easyswoole` 控制器中，向客户端响应 json 字符串\n$this-&gt;writeJson(200, ['name' =&gt; 'easyswoole'], 'success!');\nredirect\n将请求重定向至指定的 URL\n$this-&gt;response()-&gt;redirect(\"/newURL/index.html\");\nsetCookie\n向客户端设置一个 Cookie，用法与 PHP 原生的 setcookie 一致。\n$this-&gt;response()-&gt;setCookie(string $name, $value = null, $expire = null,string $path = '/', string $domain = '', bool $secure = false, bool $httponly = false, string $samesite = '')\ngetSwooleResponse\n获取原始的 swoole_http_response 实例。\n$swooleResponse = $this-&gt;response()-&gt;getSwooleResponse();\nend\n结束对该次 HTTP 请求响应，结束之后，无法再次向客户端响应数据。\n$this-&gt;response()-&gt;end();\n\n注意：和 Swoole 原生 swoole_http_response 实例的 end 方法有所区别。 \n\nisEndResponse\n判断该次 HTTP 请求是否结束响应，当你不知道是否已经结束响应时，可通过该方法判断是否能再次向客户端响应数据：\nif (!$this-&gt;response()-&gt;isEndResponse()) {\n    $this-&gt;response()-&gt;write('继续发送数据');\n}\nwithStatus\n向客户端发送 HTTP 状态码。\n$this-&gt;response()-&gt;withStatus($statusCode);\n注意：$statusCode 必须为标准的 HTTP 允许状态码，具体请见 Http Message 中 的 Status 对象。\nwithHeader\n用于向 HTTP 客户端发送一个 header。\n$this-&gt;response()-&gt;withHeader('Content-Type', 'application/json;charset=utf-8');\n其他方法\n用于获取响应内容，即需要响应给客户端的数据。一般用于在响应客户端之前记录响应日志之类的业务。具体使用可查看框架的 afterRequest 事件\n$this-&gt;response()-&gt;getBody()-&gt;__toString();\n其他响应\n向客户端响应文件流，实现文件下载\n\n实现 excel 文件自动下载\n\n示例如下：在控制器中响应客户端，实现 excel 文件自动下载\n&lt;?php\n\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\n\nclass Index extends Controller\n{\n    function index()\n    {\n        // 要下载 excel 文件的指定路径，例如这里是项目根目录下的 test.xlsx 文件\n        $this-&gt;response()-&gt;sendFile(EASYSWOOLE_ROOT . '/test.xlsx');\n        // 设置文件流内容类型，这里以 xlsx 为例\n        $this-&gt;response()-&gt;withHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');\n        // 设置要下载的文件名称，一定要带文件类型后缀\n        $this-&gt;response()-&gt;withHeader('Content-Disposition', 'attachment;filename=' . 'download_test.xlsx');\n        $this-&gt;response()-&gt;withHeader('Cache-Control', 'max-age=0');\n        $this-&gt;response()-&gt;end();\n    }\n}\n访问 http://localhost:9501/ 就会自动下载 download_test.xlsx 文件了。\n\n注意：这里必须使用 withHeader 设置响应头，一定不能使用 php-fpm 下的 header 函数设置。\n","link":"/HttpServer/response.html"},{"id":127,"title":"静态路由","content":"静态路由\n静态路由是直接通过 URl 映射，因此效率高，但作用也是有限的。\nURL解析规则\n仅支持 PATHINFO 模式的 URL 解析，且与控制器名称(方法)保持一致，控制器搜索规则为优先完整匹配模式\n解析规则\n在没有路由干预的情况下，内置的解析规则支持无限级嵌套目录，如下方两个例子所示\n\n\nhttp://serverName/api/auth/login\n对应执行的方法为 \\App\\HttpController\\Api\\Auth::login()\n\n\nhttp://serverName/a/b/c/d/f\n\n\n如果 f 为控制器名，则执行的方法为 \\App\\HttpController\\A\\B\\C\\D\\F::index()\n\n\n如果 f 为方法名，则执行的方法为 \\App\\HttpControllers\\A\\B\\C\\D::f()\n\n\n如果最后的路径为 index 时，底层会自动忽略，并直接调用控制器的默认方法(也就是 index)\n\n\n\n\n解析层级\n理论上 EasySwoole 支持无限层级的 URL -&gt; 控制器 映射，但出于系统效率和防止恶意 URL 访问， 系统默认为 3 级，若由于业务需求，需要更多层级的 URL 映射匹配，请在框架初始化事件中向 DI 注入常量 SysConst::HTTP_CONTROLLER_MAX_DEPTH，值为 URL 解析的最大层级，注入方式如下代码，允许 URL 最大解析至 5 层\npublic static function initialize()\n{\n    \\EasySwoole\\Component\\Di::getInstance()-&gt;set(SysConst::HTTP_CONTROLLER_MAX_DEPTH, 5);\n}\n特殊情况\n当控制器和方法都为 index 时，可直接忽略不写\n\n\n如果方法为 index，则可以忽略:\n如果对应执行方法名为 \\App\\HttpController\\Api\\User::index()\nurl 可直接写 http://serverName/api/User  \n\n\n如果控制器和方法都为 Index，则可以忽略\n如果对应执行方法名为 \\App\\HttpController\\Index::index()\nurl 可直接写 http://serverName/   \n\n\nindex 忽略规则理论支持无限层级，根据解析层级最大进行逐层查找\n\n\n注意，EasySwoole 的 URL 路径区分大小写，控制器首字母支持小写转换","link":"/HttpServer/staticRoute.html"},{"id":128,"title":"动态路由","content":"动态路由\n动态路由就是把 url 的请求优雅地对应到你想要执行的操作方法。\nEasySwoole 的动态路由是基于 FastRoute 实现，与其路由规则保持一致。 \n示例代码:\n新建文件 App\\HttpController\\Router.php，(从框架 3.4.x 版本开始，用户可能不需要新建此文件。如果用户在安装时选择了释放 Router.php 则不必新建，如果没有，请自行新建):  \n&lt;?php\nnamespace App\\HttpController;\n\nuse EasySwoole\\Component\\Context\\ContextManager;\nuse EasySwoole\\Http\\AbstractInterface\\AbstractRouter;\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\nuse FastRoute\\RouteCollector;\n\nclass Router extends AbstractRouter\n{\n    function initialize(RouteCollector $routeCollector)\n    {\n        // http://localhost:9501/user 将匹配执行 App\\HttpController\\Index 类的 user 方法\n        $routeCollector-&gt;get('/user', '/user');\n\n        // http://localhost:9501/user1 将匹配执行 App\\HttpController\\User 类的 user1 方法\n        $routeCollector-&gt;get('/user1', '/User/user1');\n\n        // http://localhost:9501/rpc 将匹配执行 App\\HttpController\\Rpc 类的 index 方法\n        $routeCollector-&gt;get('/rpc', '/Rpc/index');\n\n        // http://localhost:9501/ 将直接执行下面的回调\n        $routeCollector-&gt;get('/', function (Request $request, Response $response) {\n            $response-&gt;write('this router index');\n        });\n\n        # http://localhost:9501/ 将匹配执行 App\\HttpController\\Index 类的 index 方法\n        // $routeCollector-&gt;get('/', '/index');\n\n        // http://localhost:9501/test 将直接执行下面的回调，然后重新定位匹配执行 App\\HttpController\\Index 类的 child 方法\n        $routeCollector-&gt;get('/test', function (Request $request, Response $response) {\n            $response-&gt;write('this router test.');\n            return '/child';// 重新定位匹配执行 App\\HttpController\\Index 类的 child 方法\n        });\n\n        // 以下 2 个路由将匹配一样处理方法\n        // http://localhost:9501/mtest1 和 http://localhost:9501/mtest2 路由都将匹配执行 App\\HttpController\\A\\B\\C\\D\\Index 类的 index 方法 (EasySwoole 默认支持 5 个层级的控制器深度)\n        $routeCollector-&gt;get('/mtest1', '/a/b/c/d/index/index');\n        $routeCollector-&gt;get('/mtest2', '/A/B/C/D/Index/index');\n\n        // 从 `easyswoole/http 2.x 版本开始，绑定的参数将由框架内部进行组装到框架的 `Context(上下文)` 数据之中，具体使用请看下文。\n        $routeCollector-&gt;get('/user/{id:\\d+}', function (Request $request, Response $response) {\n            $response-&gt;write(json_encode([\n                'get' =&gt; $request-&gt;getQueryParams(),\n                'post' =&gt; $request-&gt;getParsedBody(),\n                // 在这里可以获取 id 参数\n                'context' =&gt; ContextManager::getInstance()-&gt;get(Router::PARSE_PARAMS_CONTEXT_KEY)\n            ]));\n            return false;// 不再往下请求,结束此次响应\n        });\n\n        /** `easyswoole/http 2.x` 之前版本请使用如下方式，获取绑定的 id 参数 ( $request-&gt;getQueryParam('id') */\n        /* \n        $routeCollector-&gt;get('/user/{id:\\d+}', function (Request $request, Response $response) {\n            // 获取到路由匹配的 id\n            $response-&gt;write(\"this is router user ,your id is {$request-&gt;getQueryParam('id')}\");\n            return false; // 不再往下请求,结束此次响应\n        });\n        */\n    }\n}\n访问 http://127.0.0.1:9501/rpc，对应执行方法为 App\\HttpController\\Rpc.php 的 index() 方法  \n用户在新建控制器类和文件夹时，请使用大驼峰法命名。这样更加规范。\n如果使用回调函数方式处理路由，return false; 代表不继续往下请求。\n针对 $routeCollector-&gt;get('route', 'handler');，特别说明下：\n\n当 handler 为 /xxx 时，则对应执行 App\\HttpController\\Index.php 类的 xxx() 方法。\n当 handler 为 /xxx/xxx/xxx/xxx 或者 /Xxx/Xxx/Xxx/xxx 时，二者其实等价，都对应执行 App\\HttpController\\Xxx\\Xxx\\Xxx.php 类的 xxx() 方法。\n当 handler 为 /xxx/xxx/xxx/Xxx 或者 /Xxx/Xxx/Xxx/Xxx 时，二者也等价，都对应执行 App\\HttpController\\Xxx\\Xxx\\Xxx.php 类的 Xxx() 方法。\n\n综上所述，其实 handler 中最后一个 / 后的一定为操作方法 (且不会转换大小写)，前面的则为对应控制器所在命名空间及路径，控制器名称及文件夹名称请务必以 大写字母 开头，否则路由将不能匹配到对应的执行方法（因为框架内部默认对每一级控制器名进行首字母转大写处理）。而对于 route 则没有特殊要求。\n路由分组\n&lt;?php\n\nclass Router extends \\EasySwoole\\Http\\AbstractInterface\\AbstractRouter\n{\n    function initialize(\\FastRoute\\RouteCollector $routeCollector)\n    {\n        $routeCollector-&gt;addGroup('/admin', function (\\FastRoute\\RouteCollector $collector) {\n            // 访问 http://localhost:9501/admin/test?version=x 将匹配如下路由，并且进行再次匹配执行\n            $collector-&gt;addRoute('GET', '/test', function (\\EasySwoole\\Http\\Request $request, \\EasySwoole\\Http\\Response $response) {\n                $version = $request-&gt;getQueryParam('version');\n                // 这里可以根据 version 参数判断返回新路径\n                if ($version == 1) {\n                    // http://localhost:9501/admin/test?version=1 将匹配路由 \"/V1/admin/test\"\n                    // 即执行对应的 App\\HttpController\\V1\\Admin.php 类的 test() 方法\n                    $path = '/V1' . $request-&gt;getUri()-&gt;getPath(); // \"/V1/admin/test\"\n                } else {\n                    // http://localhost:9501/admin/test?version=2 将匹配路由 \"/V2/admin/test\"\n                    // 即执行对应的 App\\HttpController\\V2\\Admin.php 类的 test() 方法\n                    $path = '/V2' . $request-&gt;getUri()-&gt;getPath(); // \"/V2/admin/test\"\n                }\n                // 返回新的构造的path\n                return $path;\n            });\n        });\n\n        // 注意：http://localhost:9501/admins/index?version=x 不能匹配到下面这个 action 路由配置参数\n        // 需要单独配置路由，如下所示：即执行对应的 App\\HttpController\\V1\\Admins.php 类的 index() 方法\n        // $collector-&gt;addRoute('GET', '/admins/index', '/V1/Admin/index');\n        $routeCollector-&gt;addGroup('/admins', function (\\FastRoute\\RouteCollector $collector) {\n            // 访问 http://localhost:9501/admins/test?version=x 将匹配如下路由，并且进行再次匹配执行\n            $collector-&gt;addRoute('GET', '/{action}', function (\\EasySwoole\\Http\\Request $request, Response $response) {\n                $version = $request-&gt;getQueryParam('version');\n                // 这里可以根据 version 参数判断返回新路径\n                if ($version == 1) {\n                    // http://localhost:9501/admins/test?version=1 将匹配路由 \"/V1/admins/test\"\n                    // 即执行对应的 App\\HttpController\\V1\\Admins.php 类的 test() 方法\n                    $path = '/V1' . $request-&gt;getUri()-&gt;getPath(); // \"/V1/admins/test\"\n                } else {\n                    // http://localhost:9501/admins/test?version=2 将匹配路由 \"/V2/admins/test\"\n                    // 即执行对应的 App\\HttpController\\V2\\Admins.php 类的 test() 方法\n                    $path = '/V2' . $request-&gt;getUri()-&gt;getPath(); // \"/V2/admins/test\"\n                }\n                // 返回新的构造的path\n                return $path;\n            });\n        });\n    }\n}\n全局模式拦截\n在 Router.php 加入以下代码，即可开启全局模式拦截\n$this-&gt;setGlobalMode(true);\n全局模式拦截下，路由将只匹配 Router.php 中的控制器方法进行响应，将不会执行框架的默认解析\n异常错误处理\n通过以下 2 个方法，可设置 路由匹配错误 以及 未找到方法的回调：\n在 Router.php 加入以下代码：\n&lt;?php\n$this-&gt;setMethodNotAllowCallBack(function (\\EasySwoole\\Http\\Request $request,\\EasySwoole\\Http\\Response $response){\n    $response-&gt;write('未找到处理方法');\n    return false; // 结束此次响应\n});\n$this-&gt;setRouterNotFoundCallBack(function (\\EasySwoole\\Http\\Request $request,\\EasySwoole\\Http\\Response $response){\n    $response-&gt;write('未找到路由匹配');\n    return 'index'; // 重定向到 index 路由\n});\n该回调函数只针对于 fastRoute 未匹配状况，如果回调里面不结束该请求响应，则该次请求将会继续进行Dispatch 并尝试寻找对应的控制器进行响应处理。  \nFastRoute 使用\naddRoute 方法\n定义路由的 addRoute 方法原型如下，该方法需要三个参数，下面围绕这三个参数我们对路由组件进行更深一步的了解\n$routeCollector-&gt;addRoute($httpMethod, $routePattern, $handler)\nhttpMethod\n该参数需要传入一个 大写 的 HTTP 方法字符串，指定路由可以拦截的方法，单个方法直接传入字符串，需要 拦截多个方法 可以传入一个 一维数组，如下面的例子：\n// 拦截GET方法\n$routeCollector-&gt;addRoute('GET', '/router', '/Index');\n\n// 拦截POST方法\n$routeCollector-&gt;addRoute('POST', '/router', '/Index');\n\n// 拦截多个方法\n$routeCollector-&gt;addRoute(['GET', 'POST'], '/router', '/Index');\n\nroutePattern\n传入一个路由匹配表达式，符合该表达式要求的路由才会被拦截并进行处理，表达式支持 {参数名称:匹配规则} 这样的占位符匹配，用于限定路由参数。\nhandler\n指定路由匹配成功后需要处理的方法，可以传入一个闭包，当传入闭包时一定要 注意处理完成之后要处理结束响应，否则请求会继续 Dispatch 寻找对应的控制器来处理，当然如果利用这一点，也可以对某些请求进行处理后再交给控制器执行逻辑。\n// 传入闭包的情况\n$routeCollector-&gt;addRoute('GET', '/router/{id:\\d+}', function (Request $request, Response $response) {\n    $id = $request-&gt;getQueryParam('id');\n    $response-&gt;write('Userid : ' . $id);\n    return false;\n});\n\n也可以直接传入控制器路径\n$routeCollector-&gt;addRoute('GET', '/router2/{id:\\d+}', '/Index');\n基本匹配\n下面的定义将会匹配 http://localhost:9501/users/info\n$routeCollector-&gt;addRoute('GET', '/users/info', 'handler');\n绑定参数\n下面的定义将 /users/ 后面的部分作为参数，并且限定参数只能是数字 [0-9]\n// 可以匹配: http://localhost:9501/users/12667\n// 不能匹配: http://localhost:9501/users/abcde\n\n$routeCollector-&gt;addRoute('GET', '/users/{id:\\d+}', 'handler');\n\n下面的定义不做任何限定，仅将匹配到的URL部分获取为参数\n// 可以匹配: http://localhost:9501/users/12667\n// 可以匹配: http://localhost:9501/users/abcde\n\n$routeCollector-&gt;addRoute('GET', '/users/{name}', 'handler');\n有时候路由的部分位置是可选的，可以像下面这样定义\n// 可以匹配: http://localhost:9501/users/to\n// 可以匹配: http://localhost:9501/users/to/username\n\n$routeCollector-&gt;addRoute('GET', '/users/to[/{name}]', 'handler');\n从 easyswoole/http 2.x 版本开始，绑定的参数将由框架内部进行组装到框架的 Context(上下文) 数据之中，具体调用方法请看下文，若想要在 get 数据中获得绑定的参数，请看下文进行设置。\n以下操作均在Router.php中initialize方法中操作.\nGET获取路由参数\n从 $this-&gt;request()-&gt;getQueryParams() 即在 get 数据中获取 路由匹配的参数，需进行如下设置：\n$this-&gt;parseParams(\\EasySwoole\\Http\\AbstractInterface\\AbstractRouter::PARSE_PARAMS_IN_GET);\nPOST获取路由参数\n从 $this-&gt;request()-&gt;getParsedBody() 中获取路由匹配的参数，需进行如下设置：\n$this-&gt;parseParams(\\EasySwoole\\Http\\AbstractInterface\\AbstractRouter::PARSE_PARAMS_IN_POST);\nContext获取路由参数\n从 \\EasySwoole\\Component\\Context\\ContextManager::getInstance()-&gt;get(Router::PARSE_PARAMS_CONTEXT_KEY) 中获取 路由匹配的参数，需进行如下设置：\n$this-&gt;parseParams(\\EasySwoole\\Http\\AbstractInterface\\AbstractRouter::PARSE_PARAMS_IN_CONTEXT);\n此配置项是easyswoole/http 2.x版本默认配置.\nNONE\n不获取路由匹配的参数，需进行如下设置:\n$this-&gt;parseParams(\\EasySwoole\\Http\\AbstractInterface\\AbstractRouter::PARSE_PARAMS_NONE);\n\n注意：以上 4 种设置，用户只能设置 1 种。Router 默认使用的设置是第 3 种。\n\n综合使用示例如下：\n&lt;?php\n\nuse EasySwoole\\Component\\Context\\ContextManager;\nuse EasySwoole\\Http\\AbstractInterface\\AbstractRouter;\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\nuse FastRoute\\RouteCollector;\n\nclass Router extends AbstractRouter\n{\n    function initialize(RouteCollector $routeCollector)\n    {\n        ######   针对从 easyswoole/http 2.x 开始的   ######\n        ### 获取路由中匹配的参数\n        // 可采取如下形式来获取 路由匹配的参数\n        # 1. 在 $this-&gt;request()-&gt;getQueryParams() 中获取 路由匹配的参数，需进行如下设置\n        // $this-&gt;parseParams(Router::PARSE_PARAMS_IN_GET);\n        /*\n        ## 使用示例\n        $this-&gt;parseParams(Router::PARSE_PARAMS_IN_GET);\n        $routeCollector-&gt;get('/user/{id:\\d+}', function (Request $request, Response $response) {\n            $response-&gt;write(json_encode([\n                'get' =&gt; $request-&gt;getQueryParams(), // 在这里可以获取 id 参数\n                'post' =&gt; $request-&gt;getParsedBody(),\n                'context' =&gt; ContextManager::getInstance()-&gt;get(Router::PARSE_PARAMS_CONTEXT_KEY)\n            ]));\n            return false;// 不再往下请求,结束此次响应\n        });\n        ## 访问: http://localhost:9501/user/100\n        ## 响应结果: {\"get\":{\"id\":\"100\"},\"post\":[],\"context\":null}\n        */\n\n        # 2. 在 $this-&gt;request()-&gt;getParsedBody() 中获取 路由匹配的参数，需进行如下设置\n        // $this-&gt;parseParams(Router::PARSE_PARAMS_IN_POST);\n        /*\n        ## 使用示例\n        $this-&gt;parseParams(Router::PARSE_PARAMS_IN_POST);\n        $routeCollector-&gt;get('/user/{id:\\d+}', function (Request $request, Response $response) {\n            $response-&gt;write(json_encode([\n                'get' =&gt; $request-&gt;getQueryParams(),\n                'post' =&gt; $request-&gt;getParsedBody(), // 在这里可以获取 id 参数\n                'context' =&gt; ContextManager::getInstance()-&gt;get(Router::PARSE_PARAMS_CONTEXT_KEY)\n            ]));\n            return false;// 不再往下请求,结束此次响应\n        });\n        ## 访问: http://localhost:9501/user/100\n        ## 响应结果: {\"get\":[],\"post\":{\"id\":\"100\"},\"context\":null}\n        */\n\n        # 3. (Router 默认采用的设置) 在 \\EasySwoole\\Component\\Context\\ContextManager::getInstance()-&gt;get(Router::PARSE_PARAMS_CONTEXT_KEY) 中获取 路由匹配的参数，需进行如下设置\n        // $this-&gt;parseParams(Router::PARSE_PARAMS_IN_CONTEXT);\n\n        ## 使用示例\n        # Router 默认使用此设置，可以不用进行设置，默认就可以 CONTEXT 中获取 路由匹配的参数\n        # (可选操作) $this-&gt;parseParams(Router::PARSE_PARAMS_IN_CONTEXT);\n        $routeCollector-&gt;get('/user/{id:\\d+}', function (Request $request, Response $response) {\n            $response-&gt;write(json_encode([\n                'get' =&gt; $request-&gt;getQueryParams(),\n                'post' =&gt; $request-&gt;getParsedBody(),\n                'context' =&gt; ContextManager::getInstance()-&gt;get(Router::PARSE_PARAMS_CONTEXT_KEY)   // 在这里可以获取 id 参数\n            ]));\n            return false;// 不再往下请求,结束此次响应\n        });\n        ## 访问: http://localhost:9501/user/100\n        ## 响应结果: {\"get\":[],\"post\":[],\"context\":{\"id\":\"100\"}}\n\n        # 4. 不获取 路由匹配的参数，需进行如下设置\n        // $this-&gt;parseParams(Router::PARSE_PARAMS_NONE);\n        /*\n        ## 使用示例\n        $this-&gt;parseParams(Router::PARSE_PARAMS_NONE);\n        $routeCollector-&gt;get('/user/{id:\\d+}', function (Request $request, Response $response) {\n            $response-&gt;write(json_encode([\n                'get' =&gt; $request-&gt;getQueryParams(),\n                'post' =&gt; $request-&gt;getParsedBody(),\n                'context' =&gt; ContextManager::getInstance()-&gt;get(Router::PARSE_PARAMS_CONTEXT_KEY)\n            ]));\n            return false;// 不再往下请求,结束此次响应\n        });\n        ## 访问: http://localhost:9501/user/100\n        ## 响应结果: {\"get\":[],\"post\":[],\"context\":null}\n        */\n    }\n}\neasyswoole/http 2.x 之前版本绑定的参数将由框架内部进行组装到框架的 get 数据之中，调用方式如下：\n&lt;?php\n\nuse EasySwoole\\Http\\AbstractInterface\\AbstractRouter;\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\nuse FastRoute\\RouteCollector;\n\nclass Router extends AbstractRouter\n{\n    function initialize(RouteCollector $routeCollector)\n    {\n        // easyswoole/http 2.x 版本之前的路由匹配采用如下方式即可获取 ( $request-&gt;getQueryParam('id') )\n        $routeCollector-&gt;get('/user/{id:\\d+}', function (Request $request, Response $response) {\n            // 获取到路由匹配的 id\n            $response-&gt;write(\"this is router user ,your id is {$request-&gt;getQueryParam('id')}\");\n            return false; // 不再往下请求,结束此次响应\n        });\n    }\n}","link":"/HttpServer/dynamicRoute.html"},{"id":129,"title":"权限与中间件","content":"请求拦截\nEasySwoole 的控制器并没有提供类似中间件的说法，而是提供了控制器中的 onRequest 事件进行验证。\n例如，我们需要对 /api/user/* 下的路径进行 cookie 验证。那么有以下两种方案：\n全局 Request 及 Response 事件\n在 全局 Initialize 事件 中注册.\npublic static function initialize()\n{\n    date_default_timezone_set('Asia/Shanghai');\n\n    // onRequest v3.4.x+\n    \\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::HTTP_GLOBAL_ON_REQUEST, function (\\EasySwoole\\Http\\Request $request, \\EasySwoole\\Http\\Response $response) {\n        $cookie = $request-&gt;getCookieParams('user_cookie');\n        // 对 cookie 进行判断，比如在数据库或者是 redis 缓存中，存在该 cookie 信息，说明用户登录成功\n        $isLogin = true;\n        if ($isLogin) {\n            // 返回 true 表示继续往下执行控制器 action\n            return true;\n        } else {\n            // 这一步可以给前端响应数据，告知前端未登录\n            $data = Array(\n                \"code\" =&gt; 200,\n                \"result\" =&gt; null,\n                \"msg\" =&gt; '请先登录'\n            );\n            $response-&gt;withHeader('Content-Type', 'application/json;charset=utf-8');\n            $response-&gt;withStatus(200);\n            $response-&gt;write(json_encode($data, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES));\n            // 返回 false 表示不继续往下执行控制器 action\n            return false;\n        }\n    });\n\n    // afterRequest v3.4.x+\n    \\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::HTTP_GLOBAL_AFTER_REQUEST, function (\\EasySwoole\\Http\\Request $request, \\EasySwoole\\Http\\Response $response) {\n\n    });\n}\nEasySwoole 3.4.x 版本之前：可在项目根目录的 EasySwooleEvent.php 中看到 onRequest 及 afterRequest 方法。\n定义 Base 控制器\n&lt;?php\n\nnamespace App\\HttpController\\Api\\User;\n\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\n\nabstract class Base extends Controller\n{\n    protected function onRequest(?string $action): ?bool\n    {\n        $cookie = $this-&gt;request()-&gt;getCookieParams('user_cookie');\n        // 对 cookie 进行判断，比如在数据库或者是 redis 缓存中，存在该 cookie 信息，说明用户登录成功\n        $isLogin = true;\n        if ($isLogin) {\n            // 返回 true 表示继续往下执行控制器 action\n            return true;\n        } else {\n            // 这一步可以给前端响应数据，告知前端未登录\n            $this-&gt;writeJson(401, null, '请先登录');\n            // 返回 false 表示不继续往下执行控制器 action\n            return false;\n        }\n    }\n}\n后续，只要 /api/user/* 路径下的控制器，都继承自 Base 控制器，都可以自动实现对 cookie 拦截了\n\n行为权限校验也是如此，可以判断某个用户是否对该控制器的 action 或者请求路径有没有权限\n","link":"/HttpServer/interception.html"},{"id":130,"title":"异常处理","content":"错误与异常拦截\nhttp 控制器错误异常\n在 http 控制器中出现错误，系统将使用默认异常处理进行输出至客户端，代码如下：\n&lt;?php\nprotected function onException(\\Throwable $throwable, Request $request, Response $response)\n{\n    if(is_callable($this-&gt;httpExceptionHandler)){\n        call_user_func($this-&gt;httpExceptionHandler,$throwable,$request,$response);\n    }else{\n        $response-&gt;withStatus(Status::CODE_INTERNAL_SERVER_ERROR);\n        $response-&gt;write(nl2br($throwable-&gt;getMessage().\"\\n\".$throwable-&gt;getTraceAsString()));\n    }\n}\n可直接在控制器重写 onException 方法：\n&lt;?php\nnamespace App\\HttpController;\n\nuse App\\ViewController;\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\nuse EasySwoole\\Http\\Message\\Status;\n\nclass Base extends ViewController\n{\n\n    function index()\n    {\n        // TODO: Implement index() method.\n        $this-&gt;actionNotFound('index');\n    }\n\n    function onException(\\Throwable $throwable): void\n    {\n        var_dump($throwable-&gt;getMessage());\n    }\n\n    protected function actionNotFound(?string $action): void\n    {\n        $this-&gt;response()-&gt;withStatus(Status::CODE_NOT_FOUND);\n        $this-&gt;response()-&gt;write('action not found');\n    }\n}\n自定义异常处理\n开发者可自定义异常处理文件：\n&lt;?php\nnamespace App;\n\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\n\nclass ExceptionHandler\n{\n    public static function handle(\\Throwable $exception, Request $request, Response $response)\n    {\n        var_dump($exception-&gt;getTraceAsString());\n    }\n}\n在 initialize 事件中使用 DI 注册异常处理:\n&lt;?php\n\npublic static function initialize()\n{\n    \\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::HTTP_EXCEPTION_HANDLER, [\\App\\ExceptionHandler::class, 'handle']);\n}","link":"/HttpServer/exception.html"},{"id":131,"title":"session","content":"EasySwoole Session 组件\n由于在 Swoole 协程下，php 自带的 session 函数是不能使用的。为此，EasySwoole 提供了独立的 session 组件，实现 php 的 session 功能。\nSession 组件目前最新稳定版本为 3.x。针对 2.x 版本的组件使用文档请看 Session 2.x，其他旧版本的组件使用文档请以 Github 为准。\n组件要求\n\nphp: &gt;=7.1.0\neasyswoole/spl: ^1.3\neasyswoole/utility: ^1.1\neasyswoole/component: ^2.1\n\n安装方法\n从框架 3.4.4 版本开始，框架默认自带该组件，不用再次再装，其他版本请使用 composer 安装，安装方法如下所示。\n\ncomposer require easyswoole/session=3.x\n\n仓库地址\neasyswoole/session=3.x\n基本使用\n注册 session handler\n使用 session 前，需要先注册 session handler。接下来的示例使用的 session handler 是 EasySwoole 内置的 session handler，开箱即用。\n注册步骤如下：\n\n首先我们定义一个 session 工具类继承自 session 组件的 \\EasySwoole\\EasySwoole\\Session 类。用户可以自行定义类继承并实现。下面为提供的一个参考工具类。\n\n新增 App\\Tools\\Session.php，内容如下：\n&lt;?php\n\nnamespace App\\Tools;\n\nuse EasySwoole\\Component\\Singleton;\n\nclass Session extends \\EasySwoole\\Session\\Session\n{\n    use Singleton;\n}\n\n注册 session handler。修改 EasySwoole 全局 event 文件(即框架根目录的 EasySwooleEvent.php 文件)，在 mainServerCreate 全局事件和 HTTP 的 全局 HTTP_GLOBAL_ON_REQUEST 事件中注册 session handler。\n\n具体实现代码如下:\n&lt;?php\n\nnamespace EasySwoole\\EasySwoole;\n\nuse App\\Tools\\Session;\nuse EasySwoole\\Component\\Di;\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\nuse EasySwoole\\Session\\FileSession;\nuse EasySwoole\\Utility\\Random;\n\nclass EasySwooleEvent implements Event\n{\n    public static function initialize()\n    {\n        date_default_timezone_set('Asia/Shanghai');\n\n        // 可以自己实现一个标准的 session handler，下面使用组件内置实现的 session handler\n        // 基于文件存储，传入 EASYSWOOLE_TEMP_DIR . '/Session' 目录作为 session 数据文件存储位置\n        Session::getInstance(new FileSession(EASYSWOOLE_TEMP_DIR . '/Session'));\n\n        Di::getInstance()-&gt;set(SysConst::HTTP_GLOBAL_ON_REQUEST, function (Request $request, Response $response) {\n            // TODO: 注册 HTTP_GLOBAL_ON_REQUEST 回调，相当于原来的 onRequest 事件\n\n            // 获取客户端 Cookie 中 easy_session 参数\n            $sessionId = $request-&gt;getCookieParams('easy_session');\n            if (!$sessionId) {\n                $sessionId = Random::character(32); // 生成 sessionId\n                // 设置向客户端响应 Cookie 中 easy_session 参数\n                $response-&gt;setCookie('easy_session', $sessionId);\n            }\n\n            // 存储 sessionId 方便调用，也可以通过其它方式存储\n            $request-&gt;withAttribute('easy_session', $sessionId);\n\n            Session::getInstance()-&gt;create($sessionId); // 创建并返回该 sessionId 的 context\n        });\n\n        Di::getInstance()-&gt;set(SysConst::HTTP_GLOBAL_AFTER_REQUEST, function (Request $request, Response $response) {\n            // TODO: 注册 HTTP_GLOBAL_AFTER_REQUEST 回调，相当于原来的 afterRequest 事件\n\n            // session 数据落地【必不可少这一步】\n            Session::getInstance()-&gt;close($request-&gt;getAttribute('easy_session'));\n\n            // gc 会清除所有 session，切勿操作\n            // Session::getInstance()-&gt;gc(time());\n        });\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n\n    }\n}\n在 EasySwoole 中使用 session\n\n注册 session handler 之后，我们就可以在 EasySwoole 控制器 的任意位置使用了。\n简单使用示例代码如下:\n&lt;?php\n\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\nuse EasySwoole\\Session\\Context;\n\nclass Session extends Controller\n{\n    protected function session(): ?Context\n    {\n        // 封装一个方法，方便我们快速获取 session context\n        $sessionId = $this-&gt;request()-&gt;getAttribute('easy_session');\n        return \\App\\Tools\\Session::getInstance()-&gt;create($sessionId);\n    }\n\n    // 将值保存在 session 中\n    public function set()\n    {\n        // $this-&gt;session()-&gt;set('key', 'value');\n        // 把 'test_session_key' 作为键，time() 的值作为值，保存在 session 中\n        $this-&gt;session()-&gt;set('test_session_key', time());\n\n        // 响应客户端\n        $this-&gt;writeJson(200, 'success!');\n    }\n\n    // 获取 session 中的值\n    public function get()\n    {\n        // $this-&gt;session()-&gt;get('key');\n        // 从 session 中获取 key 为 'test_session_key' 的值\n        $ret = $this-&gt;session()-&gt;get('test_session_key');\n\n        // 响应客户端\n        $this-&gt;writeJson(200, $ret);\n    }\n\n    // 获取 session 中所有数据\n    public function all()\n    {\n        // 获取 session 中所有数据\n        $ret = $this-&gt;session()-&gt;allContext();\n\n        // 响应客户端\n        $this-&gt;writeJson(200, $ret);\n    }\n\n    // 删除 session 中的值\n    public function del()\n    {\n        // $this-&gt;session()-&gt;del('key');\n        // 删除 session 中 key 为 'test_session_key' 的值\n        $this-&gt;session()-&gt;del('test_session_key');\n\n        // 再次获取 session 中所有数据并响应客户端\n        $this-&gt;writeJson(200, $this-&gt;session()-&gt;allContext());\n    }\n\n    // 清空 session 中所有数据\n    public function flush()\n    {\n        // 清空 session 中所有数据\n        $this-&gt;session()-&gt;flush();\n\n        // 再次获取 session 中所有数据并响应客户端\n        $this-&gt;writeJson(200, $this-&gt;session()-&gt;allContext());\n    }\n\n    // 重新设置(覆盖) session 中的数据\n    public function setData()\n    {\n        // 重新设置(覆盖) session 中的数据\n        $ret = $this-&gt;session()-&gt;setData([\n            'test_session_key' =&gt; 1,\n            'test_session_key1' =&gt; 2\n        ]);\n\n        // 再次获取 session 中所有数据并响应给客户端\n        $this-&gt;writeJson(200, $ret-&gt;allContext());\n    }\n}\n然后访问 http://127.0.0.1:9501/session/set (示例请求地址)就可以进行测试设置 session，访问 http://127.0.0.1:9501/session/flush (示例请求地址)就可以清空所有 session 数据。其他示例请用户自行测试。","link":"/HttpServer/session.html"},{"id":132,"title":"视图","content":"模板引擎\n渲染驱动\nEasySwoole 引入模板渲染驱动的形式，把需要渲染的数据，通过协程客户端投递到自定义的同步进程中进行渲染并返回结果。为何要如此处理，原因在于，市面上的一些模板引擎在 Swoole 协程下存在变量安全问题。例如以下流程：\n\nrequest A reached, static A assign requestA-data\ncompiled template \nwrite compiled template (yield current coroutine)\nrequest B reached，static A assign requestB-data\nrender static A data into complied template file\n\n以上流程我们可以发现，A 请求的数据，被 B 请求给污染了。为了解决该问题，EasySwoole 引入模板渲染驱动模式。\n组件要求\n\neasyswoole/spl: ^1.0\neasyswoole/component: ^2.0\n\n安装方法\n\ncomposer require easyswoole/template\n\n仓库地址\neasyswoole/template\n基础实现原理讲解\n实现渲染引擎\n&lt;?php\nclass R implements \\EasySwoole\\Template\\RenderInterface\n{\n    public function render(string $template, ?array $data = null, ?array $options = null): ?string\n    {\n        return 'todo some thing';\n    }\n\n    public function onException(\\Throwable $throwable, $arg): string\n    {\n        return $throwable-&gt;getMessage();\n    }\n}\n旧版本 Template (1.1.0 之前版本) 实现渲染引擎如下：\n&lt;?php\nclass R implements \\EasySwoole\\Template\\RenderInterface\n{\n    public function render(string $template, ?array $data = [], ?array $options = []):?string\n    {\n        return 'todo some thing';\n    }\n\n    public function afterRender(?string $result, string $template, array $data = [], array $options = [])\n    {\n        // TODO: Implement afterRender() method.\n    }\n\n    public function onException(Throwable $throwable, $arg):string\n    {\n        return $throwable-&gt;getMessage();\n    }\n}\n在自定义 HTTP 服务中调用渲染引擎\n&lt;?php\nrequire_once __DIR__ . '/vendor/autoload.php';\n\nclass MyRender implements \\EasySwoole\\Template\\RenderInterface\n{\n\n    public function render(string $template, ?array $data = null, ?array $options = null): ?string\n    {\n        return \"your template is {$template} and data is \" . json_encode($data);\n    }\n\n    public function onException(\\Throwable $throwable, $arg): string\n    {\n        return $throwable-&gt;getTraceAsString();\n    }\n}\n\n$renderConfig = \\EasySwoole\\Template\\Render::getInstance()-&gt;getConfig();\n\n/*\n * 可选配置\n$renderConfig-&gt;setTempDir(getcwd()); // 设置 渲染引擎驱动 Socket 存放目录，默认为 getcwd()\n$renderConfig-&gt;setTimeout(3); // 设置 超时时间，默认为 3s，不建议修改\n$renderConfig-&gt;setServerName('EasySwoole'); // 设置 渲染引擎驱动服务名称，不建议修改\n$renderConfig-&gt;setWorkerNum(3); // 设置 渲染引擎服务工作进程数，默认为 3，不建议修改\n */\n\n$renderConfig-&gt;setRender(new MyRender()); // 设置 渲染引擎\n\n$http = new swoole_http_server(\"0.0.0.0\", 9501);\n$http-&gt;on(\"request\", function ($request, $response) {\n    $ret = \\EasySwoole\\Template\\Render::getInstance()-&gt;render('index.html', ['easyswoole' =&gt; 'hello']);\n    $response-&gt;end($ret);\n});\n\n// 调用渲染引擎\n\\EasySwoole\\Template\\Render::getInstance()-&gt;attachServer($http);\n\n$http-&gt;start();\n旧版本 Template 组件(1.1.0 之前)在自定义 HTTP 服务中调用渲染引擎时，实现渲染引擎接口的方法有些许不同，详细请看上文实现渲染引擎。\n重启渲染引擎\n由于某些模板引擎会缓存模板文件，导致可能出现以下情况：\n\n用户 A 请求 1.tpl 返回 'a'\n开发者修改了 1.tpl 的数据，改成了 'b'\n用户 B、C、D 在之后的请求中，可能会出现 'a'、'b'两种不同的值\n\n那是因为模板引擎已经缓存了 A 所在进程的文件，导致后面的请求如果也分配到了 A 的进程，就会获取到缓存的值\n解决方案如下：\n\n1: 重启 EasySwoole 服务，即可解决\n2: 模板渲染引擎实现了重启方法 restartWorker，直接调用即可\n\nRender::getInstance()-&gt;restartWorker();\n用户可以根据自己的逻辑，自行调用 restartWorker 方法进行重启。\n重启渲染引擎使用示例\n例如：用户可以在控制器中新增 reload 方法重启渲染引擎：\n1、实现自定义渲染引擎，新建 App\\RenderDriver\\MyRender.php 文件\n&lt;?php\n\nnamespace App\\RenderDriver;\n\nclass MyRender implements \\EasySwoole\\Template\\RenderInterface\n{\n    public function render(string $template, ?array $data = null, ?array $options = null): ?string\n    {\n        return \"your template is {$template} and data is \" . json_encode($data);\n    }\n\n    public function onException(\\Throwable $throwable, $arg): string\n    {\n        return $throwable-&gt;getTraceAsString();\n    }\n}\n旧版本 Template 组件(1.1.0 之前)实现自定义渲染引擎接口的方法和最新稳定版本有些许不同，详细请看上文。\n2、注册渲染引擎服务\n&lt;?php\n\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\nuse EasySwoole\\Template\\Render;\n\nclass EasySwooleEvent implements Event\n{\n    public static function initialize()\n    {\n        date_default_timezone_set('Asia/Shanghai');\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        $renderConfig = \\EasySwoole\\Template\\Render::getInstance()-&gt;getConfig();\n\n        /*\n         * 可选配置\n        $renderConfig-&gt;setTempDir(getcwd()); // 设置 渲染引擎驱动 Socket 存放目录，默认为 getcwd()\n        $renderConfig-&gt;setTimeout(3); // 设置 超时时间，默认为 3s，不建议修改\n        $renderConfig-&gt;setServerName('EasySwoole'); // 设置 渲染引擎驱动服务名称，不建议修改\n        $renderConfig-&gt;setWorkerNum(3); // 设置 渲染引擎服务工作进程数，默认为 3，不建议修改\n         */\n\n        $renderConfig-&gt;setRender(new \\App\\RenderDriver\\MyRender());\n        Render::getInstance()-&gt;attachServer(ServerManager::getInstance()-&gt;getSwooleServer());\n    }\n}\n3、在控制器中新增 reload 方法重启渲染引擎\n&lt;?php\n\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\nuse EasySwoole\\Template\\Render;\n\nclass Index extends Controller\n{\n    public function index()\n    {\n        $this-&gt;response()-&gt;write(Render::getInstance()-&gt;render('index.tpl', [\n            'user' =&gt; 'easyswoole',\n            'time' =&gt; time()\n        ]));\n    }\n\n    public function reload()\n    {\n        Render::getInstance()-&gt;restartWorker();\n        $this-&gt;response()-&gt;write('restart worker success!');\n    }\n}\n运行结果：访问 http://127.0.0.1:9501/ (示例请求地址) 即可看到运行结果: your template is index.tpl and data is {\"user\":\"easyswoole\",\"time\":1613659221}，然后访问 http://127.0.0.1:9501/reload (示例请求地址) 即可重启渲染引擎，看到运行结果 restart worker success!\n使用示例(在 EasySwoole 中使用)\n使用 Smarty 渲染\n引入Smarty\n\ncomposer require smarty/smarty\n\n实现渲染引擎\n新建 \\App\\RenderDriver\\Smarty.php，内容如下：\n&lt;?php\n\nnamespace App\\RenderDriver;\n\nuse EasySwoole\\Template\\RenderInterface;\n\nclass Smarty implements RenderInterface\n{\n    private $smarty;\n\n    function __construct()\n    {\n        $temp = sys_get_temp_dir();\n        $this-&gt;smarty = new \\Smarty();\n        $this-&gt;smarty-&gt;setTemplateDir(EASYSWOOLE_ROOT . '/App/View/');\n        $this-&gt;smarty-&gt;setCacheDir(\"{$temp}/smarty/cache/\");\n        $this-&gt;smarty-&gt;setCompileDir(\"{$temp}/smarty/compile/\");\n    }\n\n    public function render(string $template, ?array $data = null, ?array $options = null): ?string\n    {\n        foreach ($data as $key =&gt; $item) {\n            $this-&gt;smarty-&gt;assign($key, $item);\n        }\n        return $this-&gt;smarty-&gt;fetch($template, $cache_id = null, $compile_id = null, $parent = null, $display = false,\n            $merge_tpl_vars = true, $no_output_filter = false);\n    }\n\n    public function onException(\\Throwable $throwable, $arg): string\n    {\n        $msg = \"{$throwable-&gt;getMessage()} at file:{$throwable-&gt;getFile()} line:{$throwable-&gt;getLine()}\";\n        trigger_error($msg);\n        return $msg;\n    }\n}\n旧版本 Template 组件(1.1.0 之前)实现渲染引擎接口的方法和最新稳定版本有些许不同，详细请看上文。Template 1.1.0 之前版本实现如下:\n&lt;?php\nnamespace App\\RenderDriver;\n\nuse EasySwoole\\Template\\RenderInterface;\n\nclass Smarty implements RenderInterface\n{\n    private $smarty;\n\n    function __construct()\n    {\n        $temp = sys_get_temp_dir();\n        $this-&gt;smarty = new \\Smarty();\n        $this-&gt;smarty-&gt;setTemplateDir(EASYSWOOLE_ROOT . '/App/View/');\n        $this-&gt;smarty-&gt;setCacheDir(\"{$temp}/smarty/cache/\");\n        $this-&gt;smarty-&gt;setCompileDir(\"{$temp}/smarty/compile/\");\n    }\n\n    public function render(string $template, ?array $data = [], ?array $options = []): ?string\n    {\n        foreach ($data as $key =&gt; $item) {\n            $this-&gt;smarty-&gt;assign($key, $item);\n        }\n        return $this-&gt;smarty-&gt;fetch($template, $cache_id = null, $compile_id = null, $parent = null, $display = false,\n            $merge_tpl_vars = true, $no_output_filter = false);\n    }\n\n    public function afterRender(?string $result, string $template, array $data = [], array $options = [])\n    {\n\n    }\n\n    public function onException(\\Throwable $throwable, $arg): string\n    {\n        $msg = \"{$throwable-&gt;getMessage()} at file:{$throwable-&gt;getFile()} line:{$throwable-&gt;getLine()}\";\n        trigger_error($msg);\n        return $msg;\n    }\n}\n在 EasySwoole 的 HTTP 服务中调用\n首先在 EasySwoole 全局事件 EasySwooleEvent.php 的 mainServerCreate 事件中注册渲染引擎服务，注册示例代码如下：\n&lt;?php\n\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\n\nclass EasySwooleEvent implements Event\n{\n    public static function initialize()\n    {\n        date_default_timezone_set('Asia/Shanghai');\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        // 获取 Render 配置\n        $renderConfig = \\EasySwoole\\Template\\Render::getInstance()-&gt;getConfig();\n\n        // [可选配置]\n        /*\n        $renderConfig-&gt;setTimeout(3); // 设置 超时时间，默认为 3s，不建议修改\n        $renderConfig-&gt;setServerName('EasySwoole'); // 设置 渲染引擎驱动服务名称，不建议修改\n        $renderConfig-&gt;setWorkerNum(3); // 设置 渲染引擎服务工作进程数，默认为 3，不建议修改\n         */\n\n        // 设置 渲染引擎模板驱动\n        $renderConfig-&gt;setRender(new \\App\\RenderDriver\\Smarty());\n\n        // 设置 渲染引擎进程 Socket 存放目录，默认为 getcwd()\n        $renderConfig-&gt;setTempDir(EASYSWOOLE_TEMP_DIR);\n\n        // 注册进程到 EasySwoole 主服务\n        \\EasySwoole\\Template\\Render::getInstance()-&gt;attachServer(\\EasySwoole\\EasySwoole\\ServerManager::getInstance()-&gt;getSwooleServer());\n    }\n}\n在控制器层响应(使用示例代码如下)：\n首先新建 App\\View\\custom.html，内容如下：\n{$name}\n在控制器中进行调用：\n&lt;?php\n\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\n\nclass Index extends Controller\n{\n    public function index()\n    {\n        $this-&gt;response()-&gt;write(\\EasySwoole\\Template\\Render::getInstance()-&gt;render('custom.html', ['name' =&gt; 'Welcome To Use EasySwoole ^_^!']));\n    }\n}\n运行结果：启动服务，访问 http://127.0.0.1:9501，即可看到运行结果：Welcome To Use EasySwoole ^_^! \n支持常用的模板引擎\n下面列举一些常用的模板引擎包方便引入使用:\nsmarty/smarty\nSmarty 是一个使用 PHP 写出来的模板引擎，是目前业界最著名的 PHP 模板引擎之一。\n引入方法\ncomposer require smarty/smarty=~3.1\nleague/plates\n使用原生 PHP 语法的非编译型模板引擎，更低的学习成本和更高的自由度。\n引入方法\ncomposer require league/plates=3.*\nduncan3dc/blade\nLaravel 框架使用的模板引擎\n引入方法\ncomposer require duncan3dc/blade=^4.5\ntopthink/think-template\nThinkPHP 框架使用的模板引擎\n引入方法\ncomposer require topthink/think-template\n如果用户想要在 EasySwoole 框架中使用以上模板引擎，具体使用示例可以查看Template 使用示例 或者 Template 组件单元测试用例。上文中讲述了使用 Smarty 模板引擎的使用示例，其他模板引擎的使用方法大致类似。\n常见问题\n注册渲染引擎失败，出现 UnixSocket bind 失败\n\n报错结果类似如下：\n\nPHP Fatal error:  Uncaught EasySwoole\\Component\\Process\\Exception: EasySwoole\\Template\\RenderWorker bind /work/EasySwoole.Render.Worker.0.sock fail case Operation not permitted in /work/vendor/easyswoole/component/src/Process/Socket/AbstractUnixProcess.php:32\n\n失败原因：部分 vargrant 服务器或 Docker 服务器没有权限创建 UnixSocket，导致注册渲染引擎失败。\n解决方案：注册渲染引擎时，设置渲染引擎驱动进程 Socket 存放目录为 '/Tmp'。示例代码如下:\n\n&lt;?php\n\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\n\nclass EasySwooleEvent implements Event\n{\n    public static function initialize()\n    {\n        date_default_timezone_set('Asia/Shanghai');\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        // 获取 Render 配置\n        $renderConfig = \\EasySwoole\\Template\\Render::getInstance()-&gt;getConfig();\n        // 设置 渲染引擎模板驱动\n        $renderConfig-&gt;setRender(new \\App\\RenderDriver\\Smarty());\n\n        ###  设置 渲染引擎进程 Socket 存放目录为 '/Tmp'  ###\n        $renderConfig-&gt;setTempDir('/Tmp');\n\n        // 注册进程到 EasySwoole 主服务\n        \\EasySwoole\\Template\\Render::getInstance()-&gt;attachServer(\\EasySwoole\\EasySwoole\\ServerManager::getInstance()-&gt;getSwooleServer());\n    }\n}","link":"/Components/Component/template.html"},{"id":133,"title":"验证码","content":"EasySwoole 验证码组件\nEasySwoole 提供了独立的 验证码组件 ，几行代码即可实现输出一个验证码，支持用户自定义验证码字体\n组件要求\n\nphp: &gt;=7.1\next-gd: *\neasyswoole/spl: ^1.0\n\n安装方法\n\ncomposer require easyswoole/verifycode=3.x\n\n仓库地址\neasyswoole/verifycode=3.x\n基本使用\n配置\n生成验证码前需要传入 \\EasySwoole\\VerifyCode\\Conf 的对象实例，\\EasySwoole\\VerifyCode\\Conf 类实例化后会有默认配置，无需配置也可生成验证码图片。\n下面是 \\EasySwoole\\VerifyCode\\Conf 类提供的相关配置方法。\n&lt;?php\n// +----------------------------------------------------------------------\n// | easySwoole [ use swoole easily just like echo \"hello world\" ]\n// +----------------------------------------------------------------------\n// | WebSite: https://www.easyswoole.com\n// +----------------------------------------------------------------------\n// | Welcome Join QQGroup 853946743\n// +----------------------------------------------------------------------\n\nnamespace EasySwoole\\VerifyCode;\n\nuse EasySwoole\\Spl\\SplBean;\n\n/**\n * 验证码配置文件\n * Class VerifyCodeConf\n * @author  : evalor &lt;master@evalor.cn&gt;\n * @package Vendor\\VerifyCode\n */\nclass Conf extends SplBean\n{\n\n    public $charset   = '1234567890AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz'; // 字母表\n    public $useCurve  = false;         // 混淆曲线\n    public $useNoise  = false;         // 随机噪点\n    public $useFont   = null;          // 指定字体\n    public $fontColor = null;          // 字体颜色\n    public $backColor = null;          // 背景颜色\n    public $imageL    = null;          // 图片宽度\n    public $imageH    = null;          // 图片高度\n    public $fonts     = [];            // 额外字体\n    public $fontSize  = 25;            // 字体大小\n    public $length    = 4;             // 生成位数\n    public $mime      = MIME::PNG;     // 设置类型\n    public $temp      = '/tmp';  // 设置缓存目录\n\n    public function setTemp($temp){\n        if (!is_dir($temp)) mkdir($temp,0755) &amp;&amp; chmod($temp,0755);\n        $this-&gt;temp = $temp;\n    }\n\n    /**\n     * 设置图片格式\n     * @param $MimeType\n     * @author : evalor &lt;master@evalor.cn&gt;\n     * @return Conf\n     */\n    public function setMimeType($MimeType)\n    {\n        $allowMime = [ MIME::PNG, MIME::GIF, MIME::JPG ];\n        if (in_array($MimeType, $allowMime)) $this-&gt;mime = $MimeType;\n        return $this;\n    }\n\n    /**\n     * 设置字符集\n     * @param string $charset\n     * @return Conf\n     */\n    public function setCharset($charset)\n    {\n        is_string($charset) &amp;&amp; $this-&gt;charset = $charset;\n        return $this;\n    }\n\n    /**\n     * 开启混淆曲线\n     * @param bool $useCurve\n     * @return Conf\n     */\n    public function setUseCurve($useCurve = true)\n    {\n        is_bool($useCurve) &amp;&amp; $this-&gt;useCurve = $useCurve;\n        return $this;\n    }\n\n    /**\n     * 开启噪点生成\n     * @param bool $useNoise\n     * @return Conf\n     */\n    public function setUseNoise($useNoise = true)\n    {\n        is_bool($useNoise) &amp;&amp; $this-&gt;useNoise = $useNoise;\n        return $this;\n    }\n\n    /**\n     * 使用自定义字体\n     * @param string $useFont\n     * @return Conf\n     */\n    public function setUseFont($useFont)\n    {\n        is_string($useFont) &amp;&amp; $this-&gt;useFont = $useFont;\n        return $this;\n    }\n\n    /**\n     * 设置文字颜色\n     * @param array|string $fontColor\n     * @return Conf\n     */\n    public function setFontColor($fontColor)\n    {\n        if (is_string($fontColor)) $this-&gt;fontColor = $this-&gt;HEXToRGB($fontColor);\n        if (is_array($fontColor)) $this-&gt;fontColor = $fontColor;\n        return $this;\n    }\n\n    /**\n     * 设置背景颜色\n     * @param null $backColor\n     * @return Conf\n     */\n    public function setBackColor($backColor)\n    {\n        if (is_string($backColor)) $this-&gt;backColor = $this-&gt;HEXToRGB($backColor);\n        if (is_array($backColor)) $this-&gt;backColor = $backColor;\n        return $this;\n    }\n\n    /**\n     * 设置图片宽度\n     * @param int|string $imageL\n     * @return Conf\n     */\n    public function setImageWidth($imageL)\n    {\n        $this-&gt;imageL = intval($imageL);\n        return $this;\n    }\n\n    /**\n     * 设置图片高度\n     * @param null $imageH\n     * @return Conf\n     */\n    public function setImageHeight($imageH)\n    {\n        $this-&gt;imageH = intval($imageH);\n        return $this;\n    }\n\n    /**\n     * 设置字体集\n     * @param array|string $fonts\n     * @return Conf\n     */\n    public function setFonts($fonts)\n    {\n        if (is_string($fonts)) array_push($this-&gt;fonts, $fonts);\n        if (is_array($fonts) &amp;&amp; !empty($fonts)) {\n            if (empty($this-&gt;fonts)) {\n                $this-&gt;fonts = $fonts;\n            } else {\n                array_merge($this-&gt;fonts, $fonts);\n            }\n        }\n        return $this;\n    }\n\n    /**\n     * 设置字体尺寸\n     * @param int $fontSize\n     * @return Conf\n     */\n    public function setFontSize($fontSize)\n    {\n        $this-&gt;fontSize = intval($fontSize);\n        return $this;\n    }\n\n    /**\n     * 设置验证码长度\n     * @param int $length\n     * @return Conf\n     */\n    public function setLength($length)\n    {\n        $this-&gt;length = intval($length);\n        return $this;\n    }\n\n    /**\n     * 获取配置值\n     * @param $name\n     * @author : evalor &lt;master@evalor.cn&gt;\n     * @return mixed\n     */\n    public function __get($name)\n    {\n        return $this-&gt;$name;\n    }\n\n    /**\n     * 十六进制转RGB\n     * @param $hexColor\n     * @author : evalor &lt;master@evalor.cn&gt;\n     * @return array\n     */\n    function HEXToRGB($hexColor)\n    {\n        $color = str_replace('#', '', $hexColor);\n        if (strlen($color) &gt; 3) {\n            $rgb = array(\n                hexdec(substr($color, 0, 2)),\n                hexdec(substr($color, 2, 2)),\n                hexdec(substr($color, 4, 2))\n            );\n        } else {\n            $color = $hexColor;\n            $r = substr($color, 0, 1) . substr($color, 0, 1);\n            $g = substr($color, 1, 1) . substr($color, 1, 1);\n            $b = substr($color, 2, 1) . substr($color, 2, 1);\n            $rgb = array(\n                hexdec($r),\n                hexdec($g),\n                hexdec($b)\n            );\n        }\n        return $rgb;\n    }\n}\n配置方法\n需要对验证码进行自定义配置可以使用上文提到的组件提供的 \\EasySwoole\\VerifyCode\\Conf 类进行动态配置。\nuse EasySwoole\\VerifyCode\\Conf;\n$Conf = new Conf();\n设置字符集合\n可以自定义验证码生成时使用的字符集合，设置后从集合中随机选取，不设置则从 [0-9A-Za-z] 中随机选取\n$Conf-&gt;setCharset('123456ABCD');\n设置背景色\n设置验证码的背景颜色，不设置则默认使用白色，支持使用完整 HEX、缩写 HEX 和 RGB 值设置\n$Conf-&gt;setBackColor('#3A5FCD');\n$Conf-&gt;setBackColor('CCC');\n$Conf-&gt;setBackColor([30, 144, 255]);\n设置文字颜色\n设置验证码的文字颜色，不设置则随机生成一个颜色，支持使用完整 HEX、缩写 HEX 和 RGB 值设置\n$Conf-&gt;setFontColor('#3A5FCD');\n$Conf-&gt;setFontColor('CCC');\n$Conf-&gt;setFontColor([30, 144, 255]);\n设置混淆\n支持两种混淆方式，默认两种混淆都是关闭的，需要手动开启\n// 开启或关闭混淆曲线\n$Conf-&gt;setUseCurve();\n// 开启或关闭混淆噪点\n$Conf-&gt;setUseNoise();\n设置字体\n默认验证码类已经带有 6 种字体，如果需要增加自己的字体库来提高识别难度，或者指定使用的字体，可以进行如下设置，注意字体路径需要使用绝对路径，即文件的完整路径\n// 增加单个字体传入路径字符串\n$Conf-&gt;setFonts('path/to/file.ttf');\n// 增加多个字体传入路径的数组\n$Conf-&gt;setFonts(['path/to/file1.ttf', 'path/to/file2.ttf']);\n// 指定生成使用的字体文件\n$Conf-&gt;setUseFont('path/to/file.ttf');\n其他设置\n可以指定验证码图片宽高，字体大小，随机生成的验证码位数等\n// 设置验证码图片的宽度\n$Conf-&gt;setImageWidth(400);\n// 设置验证码图片的高度\n$Conf-&gt;setImageHeight(200);\n// 设置生成字体大小\n$Conf-&gt;setFontSize(30);\n// 设置生成验证码位数\n$Conf-&gt;setLength(4);\n链式调用\n为了更流畅的进行设置，所有的配置项均支持链式调用\n$Conf = new Conf();\n$Conf-&gt;setUseNoise()-&gt;setUseCurve()-&gt;setFontSize(30);\n可以使用上方的动态配置，将设置好的配置类传入给验证码类。\n$Conf = new \\EasySwoole\\VerifyCode\\Conf();\n$Conf-&gt;setFontSize(30);\n$VCode = new \\EasySwoole\\VerifyCode\\VerifyCode($Conf);\n\n如果配置比较多，也需要全站统一验证码配置，可以将验证码的配置放入配置文件，在生成时读取配置，验证码的配置类继承自 \\EasySwoole\\Spl\\SplBean，可以在设置好后使用配置类的 toArray 方法直接获得配置数组，实例化验证码时，读取数组重新生成 \\EasySwoole\\VerifyCode\\Conf 类即可。\n\n验证码生成\n\\EasySwoole\\VerifyCode\\VerifyCode 验证码操作类，如果不传入 \\EasySwoole\\VerifyCode\\Conf 实例，则自动实例化一个 \\EasySwoole\\VerifyCode\\Conf 实例。\n&lt;?php\n$config = new \\EasySwoole\\VerifyCode\\Conf([\n    // 以下配置均为可选配置，用户可根据需求自行配置\n    # 'charset'  =&gt; '1234567890AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz', # 设置验证码字符集合，默认为 数字 + 大小写字母\n    # 'useCurve'  =&gt; false, # 设置不开启 混淆曲线，默认不开启\n    # 'useNoise'  =&gt; false, # 设置不开启 随机噪点，默认不开启\n    # 'useFont'   =&gt; null,  # 设置验证码使用的字体，默认随机获取内置字体\n    # 'fontColor' =&gt; null,  # 设置 字体颜色，默认随机获取，支持使用完整 HEX，缩写 HEX 和 RGB 值设置\n    # 'backColor' =&gt; null,  # 设置 背景颜色，默认白色，支持使用完整 HEX，缩写 HEX 和 RGB 值设置\n    # 'imageL'    =&gt; null,  # 设置 验证码宽度，默认 162.5px\n    # 'imageH'    =&gt; null,  # 设置 验证码高度，默认 50px\n    # 'fonts'     =&gt; [],    # 设置 验证码可能使用的字体集合，默认组件内置支持 5 种\n    # 'fontSize'  =&gt; 25,    # 设置 验证码字体大小，默认 25px\n    # 'length'    =&gt; 4,     # 设置 验证码位数，默认 4 位\n]);\n\n# 使用方法单独配置 和 上述在构造函数中配置 等价\n// 设置验证码长度为 4 【其他配置方法请看上文 \\EasySwoole\\VerifyCode\\Conf 类】\n# $config-&gt;setLength(4);\n\n$code = new \\EasySwoole\\VerifyCode\\VerifyCode($config);\n$code-&gt;DrawCode();// 生成验证码，返回一个 \\EasySwoole\\VerifyCode\\Result 对象\n验证码结果类\n验证码结果类，由 VerifyCode 验证码操作类调用 DrawCode() 方法时创建并返回。\n下面是 \\EasySwoole\\VerifyCode\\Result 类的具体实现，可获取创建验证码之后得到相关结果。\n&lt;?php\n// +----------------------------------------------------------------------\n// | easySwoole [ use swoole easily just like echo \"hello world\" ]\n// +----------------------------------------------------------------------\n// | WebSite: https://www.easyswoole.com\n// +----------------------------------------------------------------------\n// | Welcome Join QQGroup 853946743\n// +----------------------------------------------------------------------\n\nnamespace EasySwoole\\VerifyCode;\n\n/**\n * 验证码结果类\n * Class Result\n * @author : evalor &lt;master@evalor.cn&gt;\n * @package easySwoole\\VerifyCode\n */\nclass Result\n{\n    private $captchaByte;  // 验证码图片\n    private $captchaMime;  // 验证码类型\n    private $captchaCode;  // 验证码内容\n    private $createTime;\n\n    function __construct($Byte, $Code, $Mime)\n    {\n        $this-&gt;captchaByte = $Byte;\n        $this-&gt;captchaMime = $Mime;\n        $this-&gt;captchaCode = $Code;\n        $this-&gt;createTime = time();\n    }\n\n    function getCreateTime():int\n    {\n        return $this-&gt;createTime;\n    }\n\n    function getCodeHash($code = null,$time = null)\n    {\n        if(!$code){\n            $code = $this-&gt;captchaCode;\n        }\n        if(!$time){\n            $time = $this-&gt;createTime;\n        }\n        return substr(md5($code.$time),8,16);\n    }\n\n    /**\n     * 获取验证码图片\n     * @author : evalor &lt;master@evalor.cn&gt;\n     * @return mixed\n     */\n    function getImageByte()\n    {\n        return $this-&gt;captchaByte;\n    }\n\n    /**\n     * 返回图片Base64字符串\n     * @author : evalor &lt;master@evalor.cn&gt;\n     * @return string\n     */\n    function getImageBase64()\n    {\n        $base64Data = base64_encode($this-&gt;captchaByte);\n        $Mime = $this-&gt;captchaMime;\n        return \"data:{$Mime};base64,{$base64Data}\";\n    }\n\n    /**\n     * 获取验证码内容\n     * @author : evalor &lt;master@evalor.cn&gt;\n     * @return mixed\n     */\n    function getImageCode()\n    {\n        return $this-&gt;captchaCode;\n    }\n\n    /**\n     * 获取Mime信息\n     * @author : evalor &lt;master@evalor.cn&gt;\n     */\n    function getImageMime()\n    {\n        return $this-&gt;captchaMime;\n    }\n}\n使用示例\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: Apple\n * Date: 2018/11/12 0012\n * Time: 16:30\n */\n\nnamespace App\\HttpController;\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\nuse EasySwoole\\VerifyCode\\Conf;\n\nclass VerifyCode extends Controller\n{\n    function index()\n    {\n        // 配置验证码\n        $config = new Conf();\n        $code = new \\EasySwoole\\VerifyCode\\VerifyCode($config);\n\n        // 生成验证码\n        $drawCode = $code-&gt;DrawCode();\n\n        // 获取生成的验证码内容字符串 string(4) \"0rnh\"\n        // 可存储起来和用户输入的验证码比对\n        $codeStr = $drawCode-&gt;getImageCode();\n\n        // 设置响应文件内容类型\n        $this-&gt;response()-&gt;withHeader('Content-Type','image/png');\n\n        // 向客户端输出验证码图片\n        $this-&gt;response()-&gt;write($drawCode-&gt;getImageByte());\n    }\n\n    function getBase64()\n    {\n        // 配置验证码\n        $config = new Conf();\n        $code = new \\EasySwoole\\VerifyCode\\VerifyCode($config);\n\n        // 生成验证码\n        $drawCode = $code-&gt;DrawCode();\n\n        // 获取生成的验证码内容字符串 string(4) \"0rnh\"\n        // 可存储起来和用户输入的验证码比对\n        $codeStr = $drawCode-&gt;getImageCode();\n\n        // 向客户端输出验证码的 base64 编码，前端可用来生成图片\n        $this-&gt;response()-&gt;write($drawCode-&gt;getImageBase64());\n    }\n}\n访问 http://localhost:9501/VerifyCode/index (示例请求地址) 即可看到验证码图片，访问 http://localhost:9501/VerifyCode/getBase64 (示例请求地址) 即可得到验证码图片的 base64 编码结果。\n进阶使用\n生成二维码图片并返回，然后进行校验。\n首先新建一个验证码工具类 \\App\\Utility\\VerifyCodeTools，内容如下所示：\n&lt;?php\n/**\n * User: luffyQAQ\n * Date: 2019/9/5 15:29\n * Email: &lt;1769360227@qq.com&gt;\n */\n\nnamespace App\\Utility;\n\nclass VerifyCodeTools\n{\n    const DURATION = 5 * 60;\n\n    // 校验验证码\n    public static function checkVerifyCode($code, $time, $hash)\n    {\n        if ($time + self::DURATION &lt; time()) {\n            return false;\n        }\n        $code = strtolower($code);\n        return self::getVerifyCodeHash($code, $time) == $hash;\n    }\n\n    // 生成验证码 hash 字符串\n    public static function getVerifyCodeHash($code, $time)\n    {\n        return md5($code . $time);\n    }\n}\n生成验证码及对验证码进行校验。\n&lt;?php\n/**\n * User: luffyQAQ\n * Date: 2019/9/5 15:29\n * Email: &lt;1769360227@qq.com&gt;\n */\n\nnamespace App\\HttpController;\n\nuse App\\Utility\\VerifyCodeTools;\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\nuse EasySwoole\\Http\\Message\\Status;\nuse EasySwoole\\Utility\\Random;\nuse EasySwoole\\VerifyCode\\Conf;\n\nclass VerifyCode extends Controller\n{\n    static $VERIFY_CODE_TTL = 120;\n    static $VERIFY_CODE_LENGTH = 4;\n\n    // 生成验证码\n    public function verifyCode()\n    {\n        // 配置验证码\n        $config = new Conf();\n        $code = new \\EasySwoole\\VerifyCode\\VerifyCode($config);\n\n        // 获取随机数(即验证码的具体值)\n        $random = Random::character(self::$VERIFY_CODE_LENGTH, '1234567890abcdefghijklmnopqrstuvwxyz');\n        // var_dump($random);    string(4) \"m02t\"\n\n        // 绘制验证码\n        $code = $code-&gt;DrawCode($random);\n\n        // 获取验证码的 base64 编码及设置验证码有效时间\n        $time = time();\n        $result = [\n            'verifyCode' =&gt; $code-&gt;getImageBase64(), // 得到绘制验证码的 base64 编码字符串\n            'verifyCodeTime' =&gt; $time,\n        ];\n\n        // 将验证码加密存储在 Cookie 中，方便进行后续验证。用户也可以把验证码保存在 Session 或者 Redis中，方便后续验证。\n        $this-&gt;response()-&gt;setCookie(\"verifyCodeHash\", VerifyCodeTools::getVerifyCodeHash($random, $time), $time + self::$VERIFY_CODE_TTL, '/');\n        $this-&gt;response()-&gt;setCookie('verifyCodeTime', $time, $time + self::$VERIFY_CODE_TTL, '/');\n        $this-&gt;writeJson(Status::CODE_OK, $result, 'success');\n    }\n\n    // 校验验证码\n    public function checkVerifyCode()\n    {\n        $code = $this-&gt;request()-&gt;getRequestParam('code');\n        $verifyCodeHash = $this-&gt;request()-&gt;getRequestParam('verifyCodeHash');\n        $verifyCodeTime = $this-&gt;request()-&gt;getRequestParam('verifyCodeTime');\n        if (!VerifyCodeTools::checkVerifyCode($code, $verifyCodeTime, $verifyCodeHash)) {\n            $this-&gt;writeJson(Status::CODE_OK, '验证码错误!', []);\n            return false;\n        }\n        $this-&gt;writeJson(Status::CODE_OK, '验证码正确!', []);\n    }\n}\n\n调用对应的路径接口(即访问 http://localhost:9501/VerifyCode/verifyCode [示例请求地址])，即可实现前台验证码显示。在 http://localhost:9501/VerifyCode/checkVerifyCode [示例请求地址] 接口中传递参数即可校验验证码是否正确。","link":"/Components/verifyCode.html"},{"id":134,"title":"验证器","content":"EasySwoole 验证器组件\nEasySwoole 提供了独立的 验证器组件，几行代码即可实现对请求参数进行验证。常用于对 HTTP 等请求中的请求参数的验证。\n验证器 Validate 组件当前最新版本为 2.0.0，相比旧版本 1.3.0 及之前版本支持了更强的验证规则，也允许用户使用更多的自定义操作，更加方便用户对请求参数进行验证。关于组件旧版本 1.3.0 及更早版本的使用文档请查看 Validate 1.3.x 文档\n另外框架还提供了在注解中对 HTTP 请求参数进行校验的组件，可以很方便地对 HTTP 请求参数的合法性进行校验。在注解中就可以设置请求参数的验证规则，使得代码更简洁，详细使用见 参数注解校验。\n组件要求\n\nphp: &gt;= 7.1.0\neasyswoole/spl: ^1.0\npsr/http-message: ^1.0\next-json: *\next-mbstring: *\n\n安装方法\n框架 3.4.x 及以上版本自带 validate 组件，所以不需要单独安装。3.4.x 之前的版本请单独安装，安装方法如下：\n\ncomposer require easyswoole/validate\n\n仓库地址\neasyswoole/validate\n基本使用\n普通验证\n支持的验证方法\n普通验证支持的验证方法有如下：activeUrl、allDigital、allowFile、allowFileType、alpha、alphaDash、alphaNum、between、betweenLen、bool、dateAfter、dateBefore、decimal、different、differentWithColumn、equal、equalWithColumn、float、func、greaterThanWithColumn、inArray、integer、isArray、isIp、length、lengthMax、lengthMin、lessThanWithColumn、max、min、url、money、notEmpty、notInArray、numeric、optional、regex、required、timestampAfter、timestampAfterDate、timestampBefore、timestampBeforeDate、url。\n验证方法的具体使用可查看 方法列表\n使用组件提供的默认的验证错误信息提示\nvalidate 验证器提供了默认验证错误信息的规则，点击查看 默认验证错误信息的规则。\n使用示例如下：\n&lt;?php\nrequire_once __DIR__ . \"/vendor/autoload.php\";\n\n// 要验证的数据\n$data = [\n    'name' =&gt; 'easyswoole',\n    'age' =&gt; 19\n];\n\n// 初始化验证器对象\n$validate = new \\EasySwoole\\Validate\\Validate();\n\n// 给字段加上验证规则 (验证数据中 name 字段不能没有)\n$validate-&gt;addColumn('name')-&gt;required();\n\n// 给字段加上验证规则 (验证数据中 age 字段不能没有且值不能大于18)\n$validate-&gt;addColumn('age')-&gt;required()-&gt;max(18);\n\n// 验证结果：验证通过返回 true 反之返回 false\n$bool = $validate-&gt;validate($data);\nif ($bool) {\n    var_dump(\"验证通过\");\n} else {\n    var_dump($validate-&gt;getError()-&gt;__toString());\n}\n/*\n * 输出结果：string(23) \"age的值不能大于18\"\n */\n\n注意：验证器组件的验证顺序是按照添加验证规则时的 添加字段的先后顺序 和 验证规则的先后顺序 逐个进行验证的，先添加的验证规则不通过则直接返回验证失败，然后就可以获取对应的验证错误信息。例如上述示例中，会优先验证 name 字段是否存在。下面示例也是一样的原理。\n\n使用自定义的验证错误信息提示\n使用示例如下：\n&lt;?php\nrequire_once __DIR__ . \"/vendor/autoload.php\";\n\n// 要验证的数据\n$data = [\n    'name' =&gt; 'easyswoole',\n    'age' =&gt; 16\n];\n\n// 初始化验证器对象\n$validate = new \\EasySwoole\\Validate\\Validate();\n\n// 给字段加上验证规则 (验证数据中 name 字段不能没有)\n$validate-&gt;addColumn('name')-&gt;required('名字不为空');\n\n// 给字段加上验证规则\n$validate-&gt;addColumn('age')-&gt;required('年龄不为空')-&gt;func(function ($itemData, $column, \\EasySwoole\\Validate\\Validate $validate) {\n\n    // 获取要验证的数据，为 1 个 \\EasySwoole\\Spl\\SplArray 对象\n    var_dump($validate-&gt;getVerifyData());\n\n    // 判断要验证的数据是否属于 \\EasySwoole\\Spl\\SplArray\n    var_dump($validate-&gt;getVerifyData() instanceof \\EasySwoole\\Spl\\SplArray);\n\n    // 获取验证的字段名，为 'age'，即 addColumn() 中设置的字段名\n    var_dump($column);\n\n    // 获取验证的字段名的值，为 18\n    var_dump($itemData);\n\n    return ($validate-&gt;getVerifyData() instanceof \\EasySwoole\\Spl\\SplArray) &amp;&amp; $column === 'age' &amp;&amp; $itemData === 0.001;\n}, '只允许18岁的进入');\n\n// 验证结果：验证通过返回 true 反之返回 false\n$bool = $validate-&gt;validate($data);\nif ($bool) {\n    var_dump(\"验证通过\");\n} else {\n    var_dump($validate-&gt;getError()-&gt;__toString());\n}\n/*\n * 输出结果：string(23) \"只允许18岁的进入\"\n */\n自定义验证\n使用自定义验证器类的自定义验证规则\n使用示例如下：\n&lt;?php\nrequire_once __DIR__ . \"/vendor/autoload.php\";\n\nclass CustomValidator extends \\EasySwoole\\Validate\\Functions\\AbstractValidateFunction\n{\n    /**\n     * 返回当前校验规则的名字\n     */\n    public function name(): string\n    {\n        return 'mobile';\n    }\n\n    /**\n     * 验证失败返回 false，或者用户可以抛出异常，验证成功返回 true\n     * @param $itemData\n     * @param $arg\n     * @param $column\n     * @return bool\n     */\n    public function validate($itemData, $arg, $column, \\EasySwoole\\Validate\\Validate $validate): bool\n    {\n        $regular = '/^((13[0-9])|(14[5,7,9])|(15[^4])|(18[0-9])|(17[0,1,3,5,6,7,8]))\\\\d{8}$/';\n        if (!preg_match($regular, $itemData)) {\n            return false;\n        }\n\n        return true;\n    }\n}\n\n// 待验证数据\n$data = [\n    'mobile' =&gt; '12312345678'\n];\n\n$validate = new \\EasySwoole\\Validate\\Validate();\n\n// 先添加 function 第一个参数为类，第二个参数设置是否覆盖 (当存在相同名字的验证规则，传参数 true 会替换掉前面设置的同名的验证规则)\n$validate-&gt;addFunction(new CustomValidator(), false);\n\n// 自定义错误消息示例\n$validate-&gt;addColumn('mobile')-&gt;required('手机号不能为空')-&gt;callUserRule(new CustomValidator(), '手机号格式不正确');\n\n// 验证结果\n$bool = $validate-&gt;validate($data);\nif ($bool) {\n    var_dump(\"验证通过\");\n} else {\n    var_dump($validate-&gt;getError()-&gt;__toString());\n}\n/*\n * 输出结果：string(24) \"手机号格式不正确\"\n */\n特殊验证\n使用带 * 号的匹配规则进行验证\n使用示例如下：\n&lt;?php\nrequire_once __DIR__ . \"/vendor/autoload.php\";\n\n$validate = new \\EasySwoole\\Validate\\Validate();\n\n// * 可以放在任意位置 且有多个\n$validate-&gt;addColumn('*.a')-&gt;required()-&gt;notEmpty()-&gt;between(1, 10);\n\n// 验证结果\n$bool = $validate-&gt;validate([\n    'a' =&gt; ['a' =&gt; 1],\n    'b' =&gt; ['a' =&gt; 11]\n]);\nif ($bool) {\n    var_dump(\"验证通过\");\n} else {\n    var_dump($validate-&gt;getError()-&gt;__toString());\n}\n/*\n * 输出结果：*.a只能在 1 - 10 之间\n */\n快速验证\n我们还提供了数组快速验证方式。\n函数原型：EasySwoole\\Validate\\Validate::make():\n参数：\n\n\n$rules 验证规则.\n\n$message 自定义错误信息.\n\n$alias 字段别名.\n\n返回值：\n\n\n\\EasySwoole\\Validate\\Validate::class实例.\n\n使用示例如下：\n&lt;?php\nrequire_once __DIR__ . \"/vendor/autoload.php\";\n\n// 验证规则\n$rules = [\n    'name' =&gt; 'required|notEmpty',\n    'age' =&gt; 'required|integer|between:20,30',\n    'weight' =&gt; 'required|max:50'\n];\n\n// 验证错误消息提示\n$messages = [\n    'name.required' =&gt; '名字不能为空！',\n    'age' =&gt; '年龄输入有误！',\n    'weight.max' =&gt; '体重最大不能超过50！'\n];\n\n// 验证字段的别名\n$alias = [\n    'name' =&gt; '名字',\n    'age' =&gt; '年龄',\n    'weight' =&gt; '体重'\n];\n\n// 组装快速验证\n$validate = \\EasySwoole\\Validate\\Validate::make($rules, $messages, $alias);\n\n// 验证结果\n$bool = $validate-&gt;validate([\n    'name' =&gt; '史迪仔',\n    'age' =&gt; 20,\n    'weight' =&gt; 70\n]);\nif ($bool) {\n    var_dump(\"验证通过\");\n} else {\n    var_dump($validate-&gt;getError()-&gt;__toString());\n}\n/*\n * 输出结果：weight的值不能大于'50'\n */\n\n暂不支持 inArray、notInArray、func、callUserRule、allowFile、allowFileType 等规则。\n\n其他的具体的验证规则，可查看 验证规则列表","link":"/Components/Validate/validate.html"},{"id":135,"title":"文件上传","content":"UploadFile 对象\n基于 PSR-7 规范封装的 UploadFile。\n注意，当上传大于 2M 的文件时请调整配置文件 MAIN_SERVER.SETTING.package_max_length 参数，详细请看 配置文件。\n在控制器内获取上传的文件：\n&lt;?php\n\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\n\nclass Index extends Controller\n{\n    function index()\n    {\n        $request = $this-&gt;request();\n\n        // 获取一个上传文件，客户端上传的文件字段名为 'file'\n        // 返回的是一个 \\EasySwoole\\Http\\Message\\UploadFile 的对象\n        /** @var \\EasySwoole\\Http\\Message\\UploadFile $file */\n        $file = $request-&gt;getUploadedFile('file');\n\n        // 获取所有上传的文件\n        // 返回的是一个包含多个 \\EasySwoole\\Http\\Message\\UploadFile 对象的对象数组\n        $files = $request-&gt;getUploadedFiles();\n    }\n}\n获取临时文件名\n/** @var \\EasySwoole\\Http\\Message\\UploadFile $file */\n$file-&gt;getTempName();\n获取 Stream\n/** @var \\EasySwoole\\Http\\Message\\UploadFile $file */\n$file-&gt;getStream();\n移动到指定位置\n/** @var \\EasySwoole\\Http\\Message\\UploadFile $file */\n$file-&gt;moveTo('/xxx/xxx/xxx.png'); // 失败这里会抛出异常 \\EasySwoole\\Http\\Exception\\FileException\n获取文件大小\n/** @var \\EasySwoole\\Http\\Message\\UploadFile $file */\n$file-&gt;getSize();\n获取错误码\n/** @var \\EasySwoole\\Http\\Message\\UploadFile $file */\n$file-&gt;getError();\n获取客户端文件名\n/** @var \\EasySwoole\\Http\\Message\\UploadFile $file */\n$file-&gt;getClientFilename();\n获取文件类型\n/** @var \\EasySwoole\\Http\\Message\\UploadFile $file */\n$file-&gt;getClientMediaType();","link":"/HttpServer/uploadFile.html"},{"id":136,"title":"全局变量","content":"全局变量\n在 swoole 协程当中，我们都知道类似 $_GET、$_SESSION 这样的全局变量是不能安全使用的。原因是协程切换下会带来数据污染问题。\n惊喜\nEasySwoole 在 spl 包中，实现了一个 SplContextArray，并在主进程的位置，替换了这些全局变量，使得这些数据的访问是安全的，并在请求结束后自动清理。从而我们可以在使用一些 FPM 环境下的组件包时没有影响。\n注意：该特性下面的注册和使用示例需要你的框架 easyswoole/http 组件版本大于等于 2.0.0。如果用户easyswoole/http 组件版本在 1.6 ~ 1.7.19 之间请查看 全局变量旧版本用法\n注册\n&lt;?php\n\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\nuse EasySwoole\\Http\\GlobalParam\\Hook;\nuse EasySwoole\\Session\\FileSession;\nuse EasySwoole\\Session\\Session;\n\nclass EasySwooleEvent implements Event\n{\n    public static function initialize()\n    {\n        date_default_timezone_set('Asia/Shanghai');\n\n        // 配置 session，设置 session 数据文件存储目录为 EASYSWOOLE_TEMP_DIR\n        # $sesionHandler = new FileSession(EASYSWOOLE_TEMP_DIR . '/Session');\n\n        $globalParamHook = new Hook();\n\n        // 如果不需要使用 session 请勿注册\n        // 使用时请先参考 session 章节 https://www.easyswoole.com/HttpServer/session.html，新增 \\App\\Tools\\Session 类文件。\n        # \\App\\Tools\\Session::getInstance($sesionHandler);\n        # $globalParamHook-&gt;enableSession(Session::getInstance());\n\n        $globalParamHook-&gt;register();\n\n        // onRequest v3.4.x+\n        \\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::HTTP_GLOBAL_ON_REQUEST, function (\\EasySwoole\\Http\\Request $request, \\EasySwoole\\Http\\Response $response) use ($globalParamHook) {\n            // 替换全局变量\n            $globalParamHook-&gt;onRequest($request, $response);\n        });\n\n        // afterRequest v3.4.x+\n        \\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::HTTP_GLOBAL_AFTER_REQUEST, function (\\EasySwoole\\Http\\Request $request, \\EasySwoole\\Http\\Response $response) {\n\n        });\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n\n    }\n}\n\n事件注册完毕后，即可使用 $_GET、$_COOKIE、$_POST、$_FILES、$_SERVER、$_SESSION。\n\n使用\n&lt;?php\n\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\n\nclass Index extends Controller\n{\n    function index()\n    {\n        var_dump($_GET['a']);\n        var_dump($_SERVER);\n    }\n}\n注意\n该特性需要 2.0.0 版本以上的 http 组件库\n\"easyswoole/http\": \"^2.0.0\"","link":"/HttpServer/global.html"},{"id":137,"title":"i18n多语言","content":"I18N 组件\nI18N 国际多语言，允许让您的项目支持多种语言\n组件要求\n\neasyswoole/component: ^2.2\n\n安装方法\n\ncomposer require easyswoole/i18n\n\n仓库地址\neasyswoole/i18n\n基本使用\n在 swoole 中单独使用\n&lt;?php\n\nrequire_once __DIR__ . '/vendor/autoload.php';\n\nuse EasySwoole\\I18N\\AbstractDictionary;\nuse EasySwoole\\I18N\\I18N;\n\n// 定义一个词典。const 值请务必于 const 变量名一致，这样是避免用户手敲词条名称出错\nclass Dictionary extends AbstractDictionary\n{\n    const HELLO = 'HELLO';\n    const GOOD_MORNING = 'GOOD_MORNING';\n    const HOME = 'HOME';\n\n}\n\n// 定义一个中文语言包\nclass Chinese extends Dictionary\n{\n    const HELLO = '你好';\n    const HOME = '主页';\n}\n\n// 定义一个英文语言包\nclass English extends Dictionary\n{\n    const HELLO = 'hello';\n    const GOOD_MORNING = 'Hi,good morning';\n    const HOME = 'home page';\n}\n\n// 注册语言包\nI18N::getInstance()-&gt;addLanguage(new Chinese(), 'Cn');\nI18N::getInstance()-&gt;addLanguage(new English(), 'En');\n// 设置默认语言包\nI18N::getInstance()-&gt;setDefaultLanguage('Cn');\n\n$http = new swoole_http_server('0.0.0.0', 9501);\n\n$http-&gt;on('request', function (\\Swoole\\Http\\Request $request, \\Swoole\\Http\\Response $response) {\n    // 使用\n    $res = [];\n    $ret = I18N::getInstance()-&gt;translate(Dictionary::HELLO);\n    $res[] = $ret;\n    var_dump($ret); // string(6) \"你好\"\n\n    $ret = I18N::getInstance()-&gt;translate(Dictionary::GOOD_MORNING);\n    $res[] = $ret;\n    var_dump($ret); // string(12) \"GOOD_MORNING\"\n\n    $ret = I18N::getInstance()-&gt;sprintf('%s ! 欢迎到 %s !!!!',Dictionary::HELLO,Dictionary::HOME);\n    $res[] = $ret;\n    var_dump($ret); // string(30) \"你好 ! 欢迎到 主页 !!!!\"\n\n    // setLanguage 仅仅会影响当前协程的语言\n    $ret = I18N::getInstance()-&gt;setLanguage('En')-&gt;translate(Dictionary::GOOD_MORNING);\n    $res[] = $ret;\n    var_dump($ret); // string(15) \"Hi,good morning\"\n\n    $response-&gt;header('Content-Type', 'text/html;charset=utf-8');\n    $response-&gt;end(json_encode($res, JSON_UNESCAPED_UNICODE));\n});\n\n$http-&gt;start();\n访问 http://localhost:9501/ (示例访问请求地址) 即可看到如下结果：[\"你好\",\"GOOD_MORNING\",\"你好 ! 欢迎到 主页 !!!!\",\"Hi,good morning\"]\n在 EasySwoole 中使用\n1. 定义语言包\n新增如下文件：App\\Languages\\Dictionary.php、App\\Languages\\Chinese.php、App\\Languages\\English.php\n内容如下：\n&lt;?php\n\nnamespace App\\Languages;\n\nuse EasySwoole\\I18N\\AbstractDictionary;\n\n// 定义一个词典。\n// const 值请务必于 const 变量名一致，这样是避免用户手敲词条名称出错\nclass Dictionary extends AbstractDictionary\n{\n    const HELLO = 'HELLO';\n    const GOOD_MORNING = 'GOOD_MORNING';\n    const HOME = 'HOME';\n}\n&lt;?php\n\nnamespace App\\Languages;\n\n// 定义一个中文语言包\nclass Chinese extends Dictionary\n{\n    const HELLO = '你好';\n    const GOOD_MORNING = '早上好';\n    const HOME = '主页';\n}\n&lt;?php\n\nnamespace App\\Languages;\n\n// 定义一个英文语言包\nclass English extends Dictionary\n{\n    const HELLO = 'hello';\n    const GOOD_MORNING = 'Hi,good morning';\n    const HOME = 'home page';\n}\n2. 注册语言包和注册默认语言\n在项目根目录的 EasySwooleEvent.php 的 initialize 事件函数中进行注册。\n调用示例代码如下： \n&lt;?php\n\nnamespace EasySwoole\\EasySwoole;\n\nuse App\\Languages\\Chinese;\nuse App\\Languages\\English;\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\nuse EasySwoole\\I18N\\I18N;\n\nclass EasySwooleEvent implements Event\n{\n    public static function initialize()\n    {\n        date_default_timezone_set('Asia/Shanghai');\n\n        // 注册语言包\n        I18N::getInstance()-&gt;addLanguage(new Chinese(), 'Cn');\n        I18N::getInstance()-&gt;addLanguage(new English(), 'En');\n\n        \\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::HTTP_GLOBAL_ON_REQUEST, function (Request $request, Response $response) {\n            // 获取 header 中 language 参数\n            $lang = $request-&gt;getHeader('language');\n            if (empty($lang)) {\n                $lang = 'Cn';\n            }\n            // 设置默认语言包\n            I18N::getInstance()-&gt;setDefaultLanguage($lang);\n            return true;\n        });\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n\n    }\n}\n3. 在控制器中进行调用\n&lt;?php\n\nnamespace App\\HttpController;\n\nuse App\\Languages\\Dictionary;\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\nuse EasySwoole\\I18N\\I18N;\n\nclass Index extends Controller\n{\n    function index()\n    {\n        // 使用\n        $rets = [];\n        $ret = I18N::getInstance()-&gt;translate(Dictionary::HELLO);\n        $rets[] = $ret;\n        var_dump($ret); // 你好\n\n        $ret = I18N::getInstance()-&gt;translate(Dictionary::GOOD_MORNING);\n        $rets[] = $ret;\n        var_dump($ret); // GOOD_MORNING\n\n        $ret = I18N::getInstance()-&gt;sprintf('%s ! 欢迎到 %s !!!!', Dictionary::HELLO, Dictionary::HOME);\n        $rets[] = $ret;\n        var_dump($ret); // \"你好 ! 欢迎到 主页 !!!!\n\n        // setLanguage 仅仅会影响当前协程的语言\n        $ret = I18N::getInstance()-&gt;setLanguage('En')-&gt;translate(Dictionary::GOOD_MORNING);\n        $rets[] = $ret;\n        var_dump($ret); // Hi,good morning\n\n        $this-&gt;writeJson(200, $rets, 'success!');\n    }\n}\n运行结果：访问 http://localhost:9501/(示例访问地址) 即可看到如下结果：{\"code\":200,\"result\":[\"你好\",\"早上好\",\"你好 ! 欢迎到 主页 !!!!\",\"Hi,good morning\"],\"msg\":\"success!\"}\n提示\n\n可以在 EasySwoole 的 initialize 初始化事件 中做好语言包的注册和默认语言的注册。\n可以在全局的 onRequest 事件，根据 header 或者是其他参数，调用 setLanguage 方法修改当次请求的语言\n","link":"/Components/i18n.html"},{"id":138,"title":"常见问题","content":"常见问题\n如何处理静态资源\nApache URl rewrite\n&lt;IfModule mod_rewrite.c&gt;\n  Options +FollowSymlinks\n  RewriteEngine On\n  RewriteCond %{REQUEST_FILENAME} !-d\n  RewriteCond %{REQUEST_FILENAME} !-f\n  # RewriteRule ^(.*)$ index.php/$1 [QSA,PT,L]  fcgi下无效\n  RewriteRule ^(.*)$  http://127.0.0.1:9501/$1 [QSA,P,L]\n   # 请开启 proxy_mod proxy_http_mod request_mod\n&lt;/IfModule&gt;\nNginx URl rewrite\nserver {\n    root /data/wwwroot/;\n    server_name local.swoole.com;\n    location / {\n        proxy_http_version 1.1;\n        proxy_set_header Connection \"keep-alive\";\n        proxy_set_header X-Real-IP $remote_addr;\n        if (!-f $request_filename) {\n             proxy_pass http://127.0.0.1:9501;\n        }\n    }\n}\nSwoole 静态文件处理器\n详细请可查看 配置文件 章节\n修改配置文件的 dev.php 或者 produce.php，实现 Swoole 对静态文件进行处理。\n&lt;?php\n\nreturn [\n    // ...... 这里省略\n    'MAIN_SERVER' =&gt; [\n        // ...... 这里省略\n        'SETTING' =&gt; [\n            // ...... 这里省略\n\n            # 设置处理 Swoole 静态文件\n            'document_root' =&gt; EASYSWOOLE_ROOT . '/Static/',\n            'enable_static_handler' =&gt; true,\n        ],\n        // ...... 这里省略\n    ],\n    // ...... 这里省略\n];\n\n上述配置是假设你的项目根目录有个 Static 目录是用来放置静态文件的。具体的使用可查看 https://wiki.swoole.com/#/http_server?id=document_root\n\n关于跨域处理\n在框架的初始化事件 initialize 事件 中进行注册。\n注册示例代码如下：\npublic static function initialize()\n{\n    date_default_timezone_set('Asia/Shanghai');\n\n    // onRequest v3.4.x+\n    \\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::HTTP_GLOBAL_ON_REQUEST, function (\\EasySwoole\\Http\\Request $request, \\EasySwoole\\Http\\Response $response) {\n        $origin = $request-&gt;getHeader('origin')[0] ?? '*';\n        $response-&gt;withHeader('Access-Control-Allow-Origin', $origin);\n        $response-&gt;withHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\n        $response-&gt;withHeader('Access-Control-Allow-Credentials', 'true');\n        $response-&gt;withHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Requested-With, token');\n        if ($request-&gt;getMethod() === 'OPTIONS') {\n             $response-&gt;withStatus(\\EasySwoole\\Http\\Message\\Status::CODE_OK);\n             return false;\n        }\n        return true;\n    });\n}\nEasySwoole 3.4.x 版本之前：可在项目根目录的 EasySwooleEvent.php 中看到 onRequest 及 afterRequest 方法.\n如何获取 $HTTP_RAW_POST_DATA\n$content = $this-&gt;request()-&gt;getBody()-&gt;__toString();\n$raw_array = json_decode($content, true);\n如何获取客户端 IP\n举例，如何在控制器中获取客户端 IP\n// 真实地址\n// 获取连接的文件描述符\n$fd = $this-&gt;request()-&gt;getSwooleRequest()-&gt;fd;\n$ip = \\EasySwoole\\EasySwoole\\ServerManager::getInstance()-&gt;getSwooleServer()-&gt;connection_info($fd);\nvar_dump($ip);\n\n// header 地址，例如经过 nginx proxy 后\n$ip2 = $this-&gt;request()-&gt;getHeaders();\nvar_dump($ip2);\nHTTP 状态码总为500\n自 swoole 1.10.x 和 2.1.x 版本起，执行 http server 回调中，若未执行 response-&gt;end()，则全部返回 500 状态码\n如何 setCookie\n调用 response 对象的 setCookie 方法即可设置 cookie。setCookie 方法和原生 setcookie 用法一致。\n$this-&gt;response()-&gt;setCookie('name', 'value');\n更多操作可看 Response 对象\n如何自定义 App 命名空间对应目录\n只需要修改项目根目录的 composer.json 的自动加载的 App 命名空间对应的目录即可，然后执行 composer dumpautolaod -o 注册就行。\n{\n    // ... 这里省略\n    \"autoload\": {\n        \"psr-4\": {\n            \"App\\\\\": \"Application/\"\n        }\n    }\n}\n如何启用 Https\n通常建议使用 Nginx 或者 Lb 来配置证书，将 https 请求解析为 http 反代到 swoole \n如果你仅是测试使用，可以在配置文件 (dev.php 或者 produce.php) 中添加和修改以下配置来启用https。\n&lt;?php\n\nreturn [\n    // ...... 这里省略\n    'MAIN_SERVER' =&gt; [\n        // ...... 这里省略\n        'SOCK_TYPE' =&gt; SWOOLE_TCP | SWOOLE_SSL, // 默认是 SWOOLE_TCP\n        'SETTING' =&gt; [\n            'ssl_cert_file' =&gt; '证书路径，仅支持.pem格式',\n            'ssl_key_file' =&gt; '私钥路径',\n        ]\n        // ...... 这里省略\n    ],\n    // ...... 这里省略\n];\n详细请可查看 配置文件 章节\nDNS Lookup resolve timeout 错误\n该错误一般存在于 http 客户端并发调用时产生，原因是 dns 效率慢，导致多线程获取 dns 时超时，包括不限于以下场景:  \n\nmysql host 设置为域名形式，并且设置最小连接高于 2(很难看到，一般是 10 才会偶尔报错)\nHTTPClient 多个协程同时并发\ncsp 并发编程\n等\n\n解决方法为:\n在并发之前，预先使用 Swoole\\Coroutine::gethostbyname('www.baidu.com'); 去查询一次dns ip，swoole 底层才会自动缓存该 ip。\n例如:\nSwoole\\Coroutine::gethostbyname('www.baidu.com');\nfor ($j = 0; $j &lt; 100; $j++) {\n    go(function () use ($j) {\n        for ($i = 0; $i &lt; 1000; $i++) {\n            $client = new Swoole\\Coroutine\\Http\\Client('www.baidu.com', 443, true);\n            $client-&gt;get('/');\n            if (empty($client-&gt;errMsg)) {\n//var_dump($client-&gt;getBody());\n            } else {\n                var_dump($client-&gt;errMsg);\n            }\n        }\n    });\n}\nCURL 发送 POST请求 EasySwoole 服务器端超时\n\n出现原因：CURL 在发送较大的 POST 请求(例如: 上传文件)时会先发一个 100-continue 的请求，如果收到服务器的回应才会发送实际的 POST 数据。而 swoole_http_server(即 EasySwoole 的 Http 主服务) 不支持 100-continue，就会导致 CURL 请求超时。\n解决方法：\n\n\n方法1：关闭 CURL 的 100-continue，在 CURL 的 Header 中配置关闭 100-continue 选项。\n\n示例代码(php):\n&lt;?php\n// 创建一个新cURL资源\n$ch = curl_init();\n// 设置URL和相应的选项\ncurl_setopt($ch, CURLOPT_URL, \"http://127.0.0.1:9501\");\ncurl_setopt($ch, CURLOPT_HEADER, 0);\ncurl_setopt($ch, CURLOPT_POST, 1); // 设置为POST方式\ncurl_setopt($ch, CURLOPT_HTTPHEADER, array('Expect:')); // 关闭 `CURL` 的 `100-continue`\ncurl_setopt($ch, CURLOPT_POSTFIELDS, array('test' =&gt; str_repeat('a', 800000)));// POST 数据\ncurl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n\n\n方法2：使用 Nginx 做前端代理，由 Nginx 处理 100-Continue(针对无法关闭 100-continue时)\n\nhttp 服务中公共函数如何引入\n很多开发小伙伴在开发过程中可能遇到疑惑，在 EasySwoole 怎么像 ThinkPHP 框架那样引入自定义的公共函数，接下来简单说明下引入方法，这边推荐借助 composer 的自动加载机制 （Files）实现。\n修改项目根目录的 composer.json 文件的 autoload.files 选项，示例如下：\n{\n    // ... 这里省略\n    \"autoload\": {\n        // ... 这里省略\n        \"files\": [\"App/Common/functions.php\"]\n    }\n}\n然后新建文件 App\\Common\\functions.php，在 functions.php 中编写自己的自定义函数，再在项目根目录执行 composer dumpautoload 完成自动加载，就可以在框架的任意位置进行调用函数了。\n示例如下：\n&lt;?php\n// functions.php\nif (!function_exists('helloEasySwoole')) {\n    function helloEasySwoole()\n    {\n        echo 'Hello EasySwoole!';\n    }\n}\n\n// ... 更多自定义函数\n调用示例：\n&lt;?php\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\n\nclass Index extends Controller\n{\n    function index()\n    {\n        \\helloEasySwoole();\n    }\n}\n\n自定义函数都可以放在这个文件中。\n","link":"/HttpServer/problem.html"},{"id":139,"title":"安装","content":"安装\ncomposer require easyswoole/http-annotation\n注意：用户在使用 EasySwoole 注解组件 进行 EasySwoole 开发时，仍需要 use 注解相对应的命名空间。这显然不是一个高效的做法。我们推荐在 PhpStorm 环境下进行开发，并且在 PhpStorm 中安装 Jetbrain 自带的 PHP Annotation 组件，可以提供注解命名空间自动补全、注解属性代码提醒、注解类跳转等非常有帮助的。(PhpStorm 2019 以上版本的 IDE，该组件可能不能正常使用。)\n组件优势\n在使用 EasySwoole Http 注解组件进行开发时，可以很方便地生成 API 接口文档，可以极大地提高了我们 phper 的开发效率。具体如何使用请看 自动注解文档 章节\n实现原理\n注解控制器，完整命名空间为EasySwoole\\HttpAnnotation\\AnnotationController，是继承自\nuse EasySwoole\\Http\\AbstractInterface\\Controller的子类。它重写了父类的__construct和__exec方法，从而实现的注解支持。\n__construct\n在构造方法中。默认实例化了自带的注解解析器EasySwoole\\HttpAnnotation\\Annotation\\Parser，并解析了当前class的注解标签。\n__exec\n该方法是承接Dispatcher与控制器实体逻辑的桥梁。在该方法中，注解控制器做了以下事情\n\n检查并执行成员变量注解逻辑\n检查onRequest函数注解参数并执行注解参数逻辑校验\n检查目的action所注解标签并进行参数校验与逻辑校验\n\n基础例子\nnamespace App\\HttpController;\n\nuse EasySwoole\\EasySwoole\\Trigger;\nuse EasySwoole\\HttpAnnotation\\AnnotationController;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\Param;\nuse EasySwoole\\HttpAnnotation\\Exception\\Annotation\\ParamValidateError;\n\nclass Index extends AnnotationController\n{\n    /**\n     * @Param(name=\"name\",required=\"\")\n     * @Param(name=\"age\",integer=\"\")\n     */\n    function index()\n    {\n        $data = $this-&gt;request()-&gt;getRequestParam();\n        $this-&gt;response()-&gt;write(\"your name is {$data['name']} and age {$data['age']}\");\n    }\n\n    function onException(\\Throwable $throwable): void\n    {\n        if($throwable instanceof ParamValidateError){\n            $this-&gt;response()-&gt;withHeader('Content-type','text/html;charset=utf-8');\n            $this-&gt;response()-&gt;write(\"字段【{$throwable-&gt;getValidate()-&gt;getError()-&gt;getField()}】校验错误\");\n        }else{\n            Trigger::getInstance()-&gt;throwable($throwable);\n        }\n    }\n}\n在以上代码中，会自动对name和age字段进行校验，当校验失败时，抛出一个异常，校验成功则进入action逻辑。具体请看参数注解章节。","link":"/HttpServer/Annotation/install.html"},{"id":140,"title":"参数注解","content":"参数注解校验\nEasyswoole控制器总共有三个参数注解标签，分别是：\n\n@Param EasySwoole\\HttpAnnotation\\AnnotationTag\\Param\n\n@ApiAuth EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiAuth\n\n@ApiGroupAuth EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiGroupAuth\n\n\nApiAuth与ApiGroupAuth均继承自Param，对于任意一个参数注解，都要求填写注解的name字段。\nParam对象实际上是对Easyswoole/Validate参数验证组件验证规则的封装，底层是调用该组件进行参数校验。\n当校验失败的时候，则会抛出一个EasySwoole\\HttpAnnotation\\Exception\\Annotation\\ParamValidateError异常，可以在控制器的onExcepion中进行处理。\n@Param\n基础参数注解，作用域在控制器的actionMethod与onRequest均为有效。例如在以下代码中：\n/**\n* @Param(name=\"name\",required=\"\",lengthMax=\"25\")\n* @Param(name=\"age\",integer=\"\")\n*/\nfunction index()\n{\n    $data = $this-&gt;request()-&gt;getRequestParam();\n    $this-&gt;response()-&gt;write(\"your name is {$data['name']} and age {$data['age']}\");\n}\n那么则规定了index这个action需要name与age这两个参数，且校验规则分别为required=\"\",lengthMax=\"25\"与integer=\"\"\n参数的接收\n在控制器的Request对象中得到的参数值，为客户端提交的原始值，参数的注解校验或者预处理，并不会影响原始值。但是通过控制器自动传参或者是上下文注解标签得到的参数，则为经过预处理后的参数。\n自动传参\n/**\n* @Param(name=\"name\",required=\"\",lengthMax=\"25\",from={GET,POST})\n* @Param(name=\"age\",type=\"int\")\n*/\nfunction index($age,$name)\n{\n   $data = $this-&gt;request()-&gt;getRequestParam();\n   $this-&gt;response()-&gt;write(\"your name is {$name} and age {$age}\");\n}\n当某个action定义了参数，且有注解的时候，那么控制器会利用反射机制，根据函数定义的参数名，去取对应的参数。\n注解传参数\n/**\n* @Param(name=\"name\",required=\"\",lengthMax=\"25\",from={GET,POST})\n* @Param(name=\"age\",type=\"int\")\n* @InjectParamsContext(key=\"data\")\n*/\nfunction index()\n{\n    $data = ContextManager::getInstance()-&gt;get('data');\n    $this-&gt;response()-&gt;write(\"your name is {$data['name']} and age {$data['age']}\");\n}\n通过@InjectParamsContext标签，完整命名空间是EasySwoole\\HttpAnnotation\\AnnotationTag\\InjectParamsContext，我们可以把通过验证的参数，设置到指定的协成上下文中，并通过上下文管理器EasySwoole\\Component\\Context\\ContextManager得到对应的参数。其中，除了必填的key字段，还有如下几个字段：\n\n\nonlyParamTag\n忽略@ApiAuth与@ApiGroupAuth定义的参数\n\n\nfilterNull\n忽略值为null的参数\n\n\nfilterEmpty\n忽略值被empty()判定为true的参数，注意数字0或者是字符串0与空字符串等问题\n\n\n附加字段\n@Param注解除了name字段为必填项，还有以下几个辅助字段。\nfrom\n例如在以下注解中：\n* @Param(name=\"name\",required=\"\",lengthMax=\"25\",from={GET,POST})\n* @Param(name=\"age\",integer=\"\",from={POST})\n则规定了name字段允许的取参顺序为：GET =&gt; POST，而age参数就仅仅允许为 POST 传参。目前from的允许值为：\nPOST，GET，COOKIE,HEADER,FILE,DI,CONTEXT,RAW,JSON,SESSION,ROUTER_PARAMS。在无规定from字段时，默认以$request-&gt;getRequestParam($paramName)方法获得参数值。具体实现可以在EasySwoole\\HttpAnnotation\\AnnotationController的__handleMethodAnnotation方法中查看。\ntype\n例如以下注解中：\n* @Param(name=\"age\",type=\"int\")\n通过函数自动传参，或者是@InjectParamsContext得到的参数时，会对age这个参数进行intval()处理。type字段可选值为：string，int,double,real,float，bool，json，array，具体可以在EasySwoole\\HttpAnnotation\\AnnotationTag\\Param的typeCast方法中查看。\ndefaultValue\n在客户端没有传递该参数的值时，可以用该字段进行默认值的定义。\npreHandler\n该字段是用于对某个参数值不为null时进行预处理。preHandler需要是一个callable，例如\n* @Param(name=\"password\",preHandler=\"md5\")\n则通过函数自动传参，或者是@InjectParamsContext得到的参数时，password会被自动执行md5()\ndescription\n该字段主要用户自动生成文档时，参数的描述说明。\n@ApiAuth\n@ApiAuth注解标签，完整的命名空间是EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiAuth，作用域在控制器的actionMethod与onRequest均为有效，本质与@Param标签并无区别，仅仅是在自动生成文档的时候，@Param被描述为请求参数，而@ApiAuth则会被描述为权限参数。\n控制器全局参数\n全局注解标签是@ApiGroupAuth，完整的命名空间是EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiGroupAuth,作用域在整个控制器。\nnamespace App\\HttpController;\n\nuse EasySwoole\\HttpAnnotation\\AnnotationController;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiGroupAuth;\n\n/**\n * Class Index\n * @ApiGroupAuth(name=\"token\",required=\"\")\n * @package App\\HttpController\n */\nclass Index extends AnnotationController\n{\n\n}\n这样的注解表示，Index控制器下的任何请求，都需要token这个参数。\n参数覆盖优先顺序\n@Param &gt; @ApiAuth &gt; @ApiGroupAuth","link":"/HttpServer/Annotation/param.html"},{"id":141,"title":"行为注解","content":"Action注解\n@Api\n标记这个method为api.\n\n\nname 注解文档的api标题.\n\npath 路由（可注册到fast-route）\n\nversion api版本号（暂时没用）\n\ndescription api描述（新版本建议使用@ApiDescription）\n\ndeprecated 注解文档标注此api为废弃（将会不可访问,返回423状态）\n\n@ApiDescription\n\n\nvalue api描述\n\n@Method\n\n\nallow 验证请求方法\n\n注入fast-route\n&lt;?php\n\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\AbstractRouter;\nuse EasySwoole\\HttpAnnotation\\Utility\\Scanner;\nuse FastRoute\\RouteCollector;\n\nclass Router extends AbstractRouter\n{\n    function initialize(RouteCollector $routeCollector)\n    {\n        $scanner = new Scanner();\n        $scanner-&gt;mappingRouter($routeCollector, EASYSWOOLE_ROOT . '/App/HttpController', 'App\\HttpController');\n    }\n}\n\n这样就可以把@Api注解中的path注入到fast-route,具体用法查看动态路由\n\nexample\n&lt;?php\n\nnamespace App\\HttpController;\n\nuse EasySwoole\\HttpAnnotation\\AnnotationController;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\Api;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiDescription;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\Method;\n\n/**\n * Class Test\n * @package App\\HttpController\n */\nclass Test extends AnnotationController\n{\n\n    /**\n     * @Api(name=\"test-index\",path=\"/test/index\",version=\"1.0\")\n     * @ApiDescription(\"test-index-action\")\n     */\n    public function index()\n    {\n\n    }\n\n    /**\n     * @Api(name=\"test-deprecated\",path=\"/test/index\",version=\"1.0\",deprecated=true)\n     */\n    public function deprecated()\n    {\n\n    }\n\n    /**\n     * @Api(name=\"test-post\")\n     * @Method(allow={POST,PUT})\n     */\n    public function post(){\n\n    }\n}","link":"/HttpServer/Annotation/action.html"},{"id":142,"title":"成员属性注解","content":"成员属性注解\n我们直接查看以下例子：\nnamespace App\\HttpController;\n\nuse EasySwoole\\HttpAnnotation\\AnnotationController;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\Context;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\Di;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\Inject;\n\nclass Test\n{\n    public function __construct($a, $b)\n    {\n    }\n}\n\nclass Index extends AnnotationController\n{\n    /**\n     * @Di(key=\"di\")\n     */\n    public $di;\n    /**\n     * @Context(key=\"context\")\n     */\n    public $context;\n\n    /**\n     * @var \\EasySwoole\\HttpAnnotation\\Tests\\TestController\\Test $inject\n     * @Inject(className=\"\\EasySwoole\\HttpAnnotation\\Tests\\TestController\\Test\", args={1,{1,2}})\n     */\n    public $inject;\n\n}\n@Di\n@Di标签，完整命名空间是EasySwoole\\HttpAnnotation\\AnnotationTag\\Di，用于在每次请求进来的时候，从IOC中取数据，并赋值到对应的属性中，以上等价于:\n$this-&gt;di = EasySwoole\\Component\\Di::getInstance()-&gt;get(di)\n@Context\n@Context标签，完整命名空间是EasySwoole\\HttpAnnotation\\AnnotationTag\\Context，用于在每次请求进来的时候，从上下文管理器中取数据，并赋值到对应的属性中，以上等价于:\n$this-&gt;context = EasySwoole\\Component\\ContextManager::getInstance()-&gt;get(context)\n@Inject\n@Inject标签，完整命令空间是EasySwoole\\HttpAnnotation\\AnnotationTag\\Inject，可注入类并且传入构造函数参数，以上等价于: \nnew className(...$args)","link":"/HttpServer/Annotation/property.html"},{"id":144,"title":"自动注解文档","content":"注解文档\nEasyswoole允许通过注解控制器的注解标签，生成文档。\n控制器输出文档\nnamespace App\\HttpController;\n\nuse EasySwoole\\HttpAnnotation\\AnnotationController;\nuse EasySwoole\\HttpAnnotation\\Utility\\AnnotationDoc;\n\nclass Index extends AnnotationController\n{\n    function index()\n    {\n        $doc = new AnnotationDoc();\n        $string = $doc-&gt;scan2Html(EASYSWOOLE_ROOT.'/App/HttpController');\n        $this-&gt;response()-&gt;withAddedHeader('Content-type',\"text/html;charset=utf-8\");\n        $this-&gt;response()-&gt;write($string);\n    }\n}\n例如在以上的代码中，我们就是直接扫描Easyswoole默认的控制器目录下的全部注解并输出对应文档，用户可以自己去做文档权限控制，或者是对应的目录限制。\n生成离线文档\n在项目根目录下执行如下命令：\nphp easyswoole doc --dir=App/HttpController\n\n// 或者执行如下命令\nphp vendor/bin/annotation-doc --dir=App/HttpController\n即可生成对应的离线文档。具体使用可查看 基础命令章节 - 生成 API 文档\n\n注意，仅当有@Api标记的控制器方法才会被渲染到文档中。\n\n注意事项\n有的同学在注解@ApiSuccess中,写入了plainText和jsonArray,会导致注解失败.有以下注意事项:\n执行composer info需保证\neasyswoole/annotation版本&gt;=2.0.3\nplaintText用法为：\nMyAnnotation(myProperty=r\"{\"code\":200}\")\n也就是格式为\nr\"{RAW}\"\n字母r+双引号。\njson Array用法为：\n@PropertyTag(input={\"code\":2,\"result\":[{\"name\":1}]})\n可以直接解析为完整的数组。\n注解示例1\nnamespace App\\HttpController;\n\nuse EasySwoole\\HttpAnnotation\\AnnotationController;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\Api;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiDescription;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiFail;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiGroup;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiGroupAuth;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiGroupDescription;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiRequestExample;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiSuccess;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\Param;\n\n/**\n * Class Api\n * @package App\\HttpController\n * @ApiGroup(groupName=\"Api\")\n * @ApiGroupDescription(\"这是我的API全局描述\")\n * @ApiGroupAuth(name=\"userToken\",from={POST},required=\"\",description=\"用户登录后，服务端返回的token,用于API鉴权\")\n */\nclass UserApi extends AnnotationController\n{\n    /**\n     * @Api(name=\"update\",path=\"/userApi/update\")\n     * @ApiDescription(\"更新用户基础资料\")\n     * @ApiRequestExample(\"curl http://127.0.0.1:9501/userApi/update?name=es&amp;age=11\")\n     * @Param(name=\"userId\",description=\"用户id\")\n     * @Param(name=\"account\",description=\"用户account\")\n     * @ApiSuccess({\"code\":200,\"result\":{\"userId\":2,\"account\":\"zyf\",\"username\":\"es\",\"phone\":\"xxxx\",\"avatar\":null,\"createTime\":1595837009,\"isDelete\":null,\"deleteTime\":null,\"user_token\":\"2-bc429ab40a7a2ebc-1596008468\"},\"msg\":\"登录成功\"})\n     * @ApiFail({\"code\":400,\"result\":null,\"msg\":\"字段非法\"})\n     */\n    function update()\n    {\n\n    }\n}\n注解示例2\n\nuse EasySwoole\\Component\\Context\\ContextManager;\nuse EasySwoole\\HttpAnnotation\\AnnotationController;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\Api;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiAuth;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiDescription;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiFail;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiFailParam;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiGroup as ApiGroupTag;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiGroupAuth;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiGroupDescription;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiRequestExample;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiSuccess;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\ApiSuccessParam;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\CircuitBreaker;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\Context;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\Di;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\InjectParamsContext;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\Method;\nuse EasySwoole\\HttpAnnotation\\AnnotationTag\\Param;\nuse EasySwoole\\HttpAnnotation\\Exception\\Annotation\\ParamValidateError;\n\n/**\n * Class ControllerA\n * @package EasySwoole\\HttpAnnotation\\Tests\\TestController\n * @ApiGroupTag(groupName=\"GroupA\")\n * @ApiGroupDescription(\"GroupA desc\")\n * @ApiGroupAuth(name=\"groupParamA\",required=\"\")\n * @ApiGroupAuth(name=\"groupParamB\",required=\"\")\n */\nclass Annotation extends AnnotationController\n{\n\n    /**\n     * @Di(key=\"di\")\n     */\n    public $di;\n    /**\n     * @Context(key=\"context\")\n     */\n    public $context;\n\n    /**\n     * @Api(path=\"/apiGroup/func\",name=\"func\")\n     * @ApiAuth(name=\"apiAuth1\")\n     * @ApiAuth(name=\"apiAuth2\")\n     * @ApiDescription(\"func desc\")\n     * @ApiFail(\"func fail example1\")\n     * @ApiFail(\"func fail example2\")\n     * @ApiFailParam(name=\"failParam1\")\n     * @ApiFailParam(name=\"failParam2\")\n     * @ApiRequestExample(\"func request example1\")\n     * @ApiRequestExample(\"func request example2\")\n     * @ApiSuccess(\"func success example1\")\n     * @ApiSuccess(\"func success example2\")\n     * @ApiSuccessParam(name=\"successParam1\")\n     * @ApiSuccessParam(name=\"successParam2\")\n     * @CircuitBreaker(timeout=5.0)\n     * @InjectParamsContext(key=\"requestData\")\n     * @Method(allow={POST,GET})\n     * @Param(name=\"param1\")\n     * @Param(name=\"param2\")\n     */\n    function func()\n    {\n\n    }\n}","link":"/HttpServer/Annotation/doc.html"},{"id":145,"title":"ddl定义","content":"DDL\n数据库模式定义语言DDL(Data Definition Language)，是用于描述数据库中要存储的现实世界实体的语言。Easyswoole提供了一个DDL库，方便用户用于定义一个数据库表结构。\n组件要求\n\neasyswoole / spl：^ 1.2\n\n安装方法\n\ncomposer require easyswoole/ddl\n\n仓库地址\neasyswoole/ddl\n基本使用\n创建表(CreateTable)\nuse EasySwoole\\DDL\\Blueprint\\Create\\Table as CreateTable;\nuse EasySwoole\\DDL\\DDLBuilder;\nuse EasySwoole\\DDL\\Enum\\Character;\nuse EasySwoole\\DDL\\Enum\\Engine;\n\n$scoreSql = DDLBuilder::create('score', function (CreateTable $table) {\n    $table-&gt;setIfNotExists()-&gt;setTableComment('成绩表');          //设置表名称\n    $table-&gt;setTableCharset(Character::UTF8MB4_GENERAL_CI);     //设置表字符集\n    $table-&gt;setTableEngine(Engine::INNODB);                     //设置表引擎\n    $table-&gt;int('id')-&gt;setIsUnsigned()-&gt;setIsAutoIncrement()-&gt;setIsPrimaryKey()-&gt;setColumnComment('自增ID');\n    $table-&gt;int('stu_id')-&gt;setIsUnsigned()-&gt;setColumnComment('学生id');\n    $table-&gt;int('course_id')-&gt;setIsUnsigned()-&gt;setZeroFill()-&gt;setColumnComment('课程id');\n    $table-&gt;float('score', 3, 1)-&gt;setColumnComment('成绩');\n    $table-&gt;int('created_at', 10)-&gt;setColumnComment('创建时间');\n    $table-&gt;foreign(null,'stu_id','student','stu_id')\n        -&gt;setOnDelete(Foreign::CASCADE)-&gt;setOnUpdate(Foreign::CASCADE);\n});\necho $scoreSql;\n\n//结果如下：\n\nCREATE TABLE IF NOT EXISTS `score` (\n  `id` int UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT '自增ID',\n  `stu_id` int UNSIGNED NOT NULL COMMENT '学生id',\n  `course_id` int UNSIGNED ZEROFILL NOT NULL COMMENT '课程id',\n  `score` float(3,1) NOT NULL COMMENT '成绩',\n  `created_at` int(10) NOT NULL COMMENT '创建时间',\n  FOREIGN KEY (`stu_id`) REFERENCES `student` (`stu_id`) ON DELETE CASCADE ON UPDATE CASCADE\n)\nENGINE = INNODB DEFAULT COLLATE = 'utf8mb4_general_ci' COMMENT = '成绩表';\n\n修改表(AlterTable)\nuse EasySwoole\\DDL\\Blueprint\\Alter\\Table as AlterTable;\nuse EasySwoole\\DDL\\DDLBuilder;\n\n$alterStuScoreSql = DDLBuilder::alter('score', function (AlterTable $table) {\n    $table-&gt;setRenameTable('student_score')-&gt;setTableComment('学生成绩表');\n    $table-&gt;modifyIndex('ind_score')-&gt;normal('ind_score', 'score')-&gt;setIndexComment('学生成绩--普通索引');\n    $table-&gt;modifyForeign('fk_stu_id')-&gt;foreign('fk_stu_id', 'stu_id', 'student_info', 'stu_id');\n});\necho $alterStuScoreSql;\n\n//结果如下：\n\nALTER TABLE `score` RENAME TO `student_score`;\nALTER TABLE `student_score` \nCOMMENT = '学生成绩表',\nDROP INDEX `ind_score`,\nADD INDEX `ind_score` (`score`) COMMENT '学生成绩--普通索引';\nALTER TABLE `student_score` DROP FOREIGN KEY `fk_stu_id`;\nALTER TABLE `student_score` ADD CONSTRAINT `fk_stu_id` FOREIGN KEY (`stu_id`) REFERENCES `student_info` (`stu_id`);\n\n删除表(DropTable)\nuse EasySwoole\\DDL\\DDLBuilder;\n\n$dropStuScoreSql = DDLBuilder::drop('student_score');\necho $dropStuScoreSql;\n\n//结果如下：\n\nDROP TABLE `student`;","link":"/Components/ddl.html"},{"id":146,"title":"安装和使用","content":"Mysqli\n安装\ncomposer require easyswoole/mysqli\nClient 用法\n$config = new \\EasySwoole\\Mysqli\\Config([\n    'host'          =&gt; '',\n    'port'          =&gt; 3300,\n    'user'          =&gt; '',\n    'password'      =&gt; '',\n    'database'      =&gt; '',\n    'timeout'       =&gt; 5,\n    'charset'       =&gt; 'utf8mb4',\n]);\n\n$client = new \\EasySwoole\\Mysqli\\Client($config);\n\ngo(function ()use($client){\n    //构建sql\n    $client-&gt;queryBuilder()-&gt;get('user_list');\n    //执行sql\n    var_dump($client-&gt;execBuilder());\n});\n需要调用execBuilder()才会执行","link":"/Components/Mysqli/install.html"},{"id":147,"title":"基础示例","content":"GET\nuse EasySwoole\\Mysqli\\QueryBuilder;\n\n$builder = new QueryBuilder();\n\n// 获取全表\n$builder-&gt;get('getTable');\n\n// 表前缀\n$builder-&gt;setPrefix('easyswoole_')-&gt;get('getTable');\n\n// 获取总数。下面两个结果相同\n$builder-&gt;withTotalCount()-&gt;where('col1', 1, '&gt;')-&gt;get('getTable');\n$builder-&gt;setQueryOption('SQL_CALC_FOUND_ROWS')-&gt;where('col1', 1, '&gt;')-&gt;get('getTable');\n\n// fields。支持一维数组或字符串\n$builder-&gt;fields('col1, col2')-&gt;get('getTable');\n$builder-&gt;get('getTable', null, ['col1','col2']);\n\n// limit 1。下面两个结果相同\n$builder-&gt;get('getTable', 1)\n$builder-&gt;getOne('getTable')\n\n// offset 1, limit 10\n$builder-&gt;get('getTable',[1, 10])\n\n// 去重查询。\n$builder-&gt;get('getTable', [2,10], ['distinct col1','col2']);\n\n// where查询\n$builder-&gt;where('col1', 2)-&gt;get('getTable');\n\n// where查询2\n$builder-&gt;where('col1', 2, '&gt;')-&gt;get('getTable');\n\n// 多条件where\n$builder-&gt;where('col1', 2)-&gt;where('col2', 'str')-&gt;get('getTable');\n\n// whereIn, whereNotIn, whereLike，修改相应的operator(IN, NOT IN, LIKE)\n$builder-&gt;where('col3', [1,2,3], 'IN')-&gt;get('getTable');\n\n// orWhere\n$builder-&gt;where('col1', 2)-&gt;orWhere('col2', 'str')-&gt;get('getTable');\n\n// 复杂where\n// 生成大概语句：where status = 1 AND (id &gt; 10 or id &lt; 2)\n$builder-&gt;where('status', 1)-&gt;where(' (id &gt; 10 or id &lt;2) ')-&gt;get('getTable');\nJOIN\nuse EasySwoole\\Mysqli\\QueryBuilder;\n\n$builder = new QueryBuilder();\n\n// join。默认INNER JOIN\n$builder-&gt;join('table2', 'table2.col1 = getTable.col2')-&gt;get('getTable');\n$builder-&gt;join('table2', 'table2.col1 = getTable.col2', 'LEFT')-&gt;get('getTable');\n\n// join Where\n$builder-&gt;join('table2','table2.col1 = getTable.col2')-&gt;where('table2.col1', 2)-&gt;get('getTable');\nGROUPBY HAVING\nuse EasySwoole\\Mysqli\\QueryBuilder;\n\n$builder = new QueryBuilder();\n\n// groupBy. \n$builder-&gt;groupBy('col1')-&gt;get('getTable');\n$builder-&gt;where('col1',2)-&gt;groupBy('col1')-&gt;get('getTable');\n\n// having\n$builder-&gt;groupBy('col1')-&gt;having('col1')-&gt;get('getTable');\n$builder-&gt;groupBy('col1')-&gt;having('col1', 1, '&gt;')-&gt;get('whereGet');\n\n// and having. having第4个参数默认是 `AND`，默认多having是`且`关系\n$builder-&gt;groupBy('col1')-&gt;having('col1', 1, '&gt;')-&gt;having('col2', 1, '&gt;')-&gt;get('whereGet');\n\n// or having. 下面两种方法效果相等\n$builder-&gt;groupBy('col1')-&gt;having('col1', 1, '&gt;')-&gt;orHaving('col2', 1, '&gt;')-&gt;get('whereGet');\n$builder-&gt;groupBy('col1')-&gt;having('col1', 1, '&gt;')-&gt;having('col2', 1, '&gt;', 'OR')-&gt;get('whereGet');\nORDERBY\nuse EasySwoole\\Mysqli\\QueryBuilder;\n\n$builder = new QueryBuilder();\n\n// orderBy. 默认DESC\n$builder-&gt;orderBy('col1', 'ASC')-&gt;get('getTable');\n$builder-&gt;where('col1',2)-&gt;orderBy('col1', 'ASC')-&gt;get('getTable');\n\nUNION\nuse EasySwoole\\Mysqli\\QueryBuilder;\n\n$builder = new QueryBuilder();\n\n// union. 相当于 adminTable UNION userTable\n$builder-&gt;union((new QueryBuilder)-&gt;where('userName', 'user')-&gt;get('userTable'))\n    -&gt;where('adminUserName', 'admin')-&gt;get('adminTable');\nUPDATE\nuse EasySwoole\\Mysqli\\QueryBuilder;\n\n$builder = new QueryBuilder();\n\n// update \n$builder-&gt;update('updateTable', ['a' =&gt; 1]);\n\n// limit update\n$builder-&gt;update('updateTable', ['a' =&gt; 1], 5);\n\n// where update\n$builder-&gt;where('whereUpdate', 'whereValue')-&gt;update('updateTable', ['a' =&gt; 1]);\nDELETE\nuse EasySwoole\\Mysqli\\QueryBuilder;\n\n$builder = new QueryBuilder();\n\n// delete all\n$builder-&gt;delete('deleteTable');\n\n// limit delete\n$builder-&gt;delete('deleteTable', 1);\n\n// where delete\n$builder-&gt;where('whereDelete', 'whereValue')-&gt;delete('deleteTable');\n\nINSERT\nuse EasySwoole\\Mysqli\\QueryBuilder;\n\n$builder = new QueryBuilder();\n\n// insert into\n$builder-&gt;insert('insertTable', ['a' =&gt; 1, 'b' =&gt; \"b\"]);\n\n// replace into\n$builder-&gt;replace('replaceTable', ['a' =&gt; 1]);\n\nSUBQUERY\nuse EasySwoole\\Mysqli\\QueryBuilder;\n\n$builder = new QueryBuilder();\n\n// 单一where条件子查询\n// 等同于 SELECT * FROM users WHERE id in ((SELECT userId FROM products WHERE  qty &gt; 2))\n$sub = $this-&gt;builder::subQuery();\n$sub-&gt;where(\"qty\", 2, \"&gt;\");\n$sub-&gt;get(\"products\", null, \"userId\");\n$builder-&gt;where(\"id\", $sub, 'in')-&gt;get('users');\n\n// 多where条件子查询\n// 等同于 SELECT * FROM users WHERE col2 = 1 AND id in ((SELECT userId FROM products WHERE  qty &gt; 2))\n$sub = $this-&gt;builder::subQuery();\n$sub-&gt;where (\"qty\", 2, \"&gt;\");\n$sub-&gt;get (\"products\", null, \"userId\");\n$this-&gt;builder-&gt;where('col2',1)-&gt;where (\"id\", $sub, 'in')-&gt;get('users');\n\n// INSERT 包含子结果集\n// 等同于 INSERT INTO products (`productName`, `userId`, `lastUpdated`) VALUES ('test product', (SELECT name FROM users WHERE  id = 6  LIMIT 1), NOW())\n$userIdQ = $this-&gt;builder::subQuery();\n$userIdQ-&gt;where (\"id\", 6);\n$userIdQ-&gt;getOne (\"users\", \"name\");\n$data = Array (\n    \"productName\" =&gt; \"test product\",\n    \"userId\" =&gt; $userIdQ,\n    \"lastUpdated\" =&gt; $this-&gt;builder-&gt;now()\n);\n$this-&gt;builder-&gt;insert (\"products\", $data);\nLOCK\nuse EasySwoole\\Mysqli\\QueryBuilder;\n\n$builder = new QueryBuilder();\n\n// FOR UPDATE 排它锁。下面两个方法效果相同\n$builder-&gt;setQueryOption(\"FOR UPDATE\")-&gt;get('getTable');\n$builder-&gt;selectForUpdate(true)-&gt;get('getTable');\n\n//  LOCK IN SHARE MODE。共享锁\n$builder-&gt;lockInShareMode()-&gt;get('getTable');\n$builder-&gt;setQueryOption(['LOCK IN SHARE MODE'])-&gt;get('getTable');\n\n// LOCK TABLES 获取表锁\n$builder-&gt;lockTable('table');\n\n// UNLOCK TABLES 释放表锁\n$builder-&gt;unlockTable('table');\n","link":"/Components/Mysqli/mysqli.html"},{"id":148,"title":"基本使用","content":"查询构造器\nQueryBuilder是一个SQL构造器，用来构造prepare sql。例如：\nuse EasySwoole\\Mysqli\\QueryBuilder;\n\n$builder = new QueryBuilder();\n\n//执行条件构造逻辑\n$builder-&gt;where('col1',2)-&gt;get('my_table');\n\n//获取最后的查询参数\necho $builder-&gt;getLastQueryOptions();\n\n//获取子查询\necho $builder-&gt;getSubQuery();\n\n//获取上次条件构造的预处理sql语句\necho $builder-&gt;getLastPrepareQuery();\n// SELECT  * FROM whereGet WHERE  col1 = ? \n\n//获取上次条件构造的预处理sql语句所以需要的绑定参数\necho $builder-&gt;getLastBindParams();\n//[2]\n\n//获取上次条件构造的sql语句\necho $builder-&gt;getLastQuery();\n//SELECT  * FROM whereGet WHERE  col1 = 2 \n\n// 获取最后插入的insert_id 使用客户端从swoole mysql获取\n$client-&gt;mysqlClient()-&gt;insert_id","link":"/Components/Mysqli/builder.html"},{"id":149,"title":"查询数据","content":"查询数据\n基本查询\n用id查询一条用户数据：\n$client-&gt;queryBuilder()-&gt;where('id', 1)-&gt;getOne('user_list');\n查询多条数据：\n$client-&gt;queryBuilder()-&gt;where('is_vip', 1)-&gt;get('user_list');\nget/getOne返回值查看链式操作里的详细文档\n在使用 get 和 getOne 等操作方法前可以任意使用链式操作方法","link":"/Components/Mysqli/query.html"},{"id":150,"title":"添加数据","content":"添加数据\nINSERT INTO\n$client-&gt;queryBuilder()-&gt;insert('insertTable', ['a' =&gt; 1, 'b' =&gt; \"b\"]);\nREPLACE INTO\n$builder-&gt;replace('replaceTable', ['a' =&gt; 1]);","link":"/Components/Mysqli/insert.html"},{"id":151,"title":"更新数据","content":"更新数据\nWHERE UPDATE\n$client-&gt;queryBuilder()-&gt;where('whereUpdate', 'whereValue')-&gt;update('updateTable', ['a' =&gt; 1]);\nLIMIT UPDATE\n$client-&gt;queryBuilder()-&gt;update('updateTable', ['a' =&gt; 1], 5);\n快捷更新\n$client-&gt;queryBuilder()\n    -&gt;where('whereUpdate', 'whereValue')\n    -&gt;update('updateTable', [\n        'age'    =&gt; QueryBuilder::inc(1),\n        'number' =&gt; QueryBuilder::dec(3),\n    ]);","link":"/Components/Mysqli/update.html"},{"id":152,"title":"删除数据","content":"删除数据\nLIMIT DELETE\n$client-&gt;queryBuilder()-&gt;delete('user_list', 3);\nWHERE DELETE\n$client-&gt;queryBuilder()-&gt;where('whereUpdate', 'whereValue')-&gt;delete('user_list');","link":"/Components/Mysqli/delete.html"},{"id":153,"title":"limit","content":"limit\nlimit方法主要用于指定查询和操作的数量，特别在分页查询的时候使用较多。\n查询数量\n查询10个用户数据：\n$builder-&gt;limit(10)-&gt;get('user_list');\n传参说明\n方法原型\nfunction limit(int $one, ?int $two = null)\n\n$one 若第二个参数不传，则代表取多少条数据；若第二个参数传递，则代表从第几行开始\n$two 可不传，若传递，则代表从$one开始，取$two行数据\n","link":"/Components/Mysqli/Chain/limitMethod.html"},{"id":154,"title":"fields","content":"fields\n主要目的是查询时标识要返回的字段值\n指定字段\n$builder-&gt;fields(['id','title'])-&gt;get('user_list');\n设置别名\n$builder-&gt;fields(['id','title as notice'])-&gt;get('user_list');\n使用SQL函数\n$builder-&gt;fields(['id','SUM(score)'])-&gt;get('user_list');\n传参说明\n方法原型\nfunction fields($fields)\n\n$fields array|string 如果非数组时，只可传入一个字段名\n","link":"/Components/Mysqli/Chain/fieldsMethod.html"},{"id":155,"title":"where","content":"where\n快速完成条件语句构建。where方法的参数支持字符串和数组。\n普通查询+\n$builder-&gt;where('col1', 2)-&gt;get('getTable');\n字符串语句\n可以使用字符串语句构建比较复杂的条件\n// 生成大概语句：where status = 1 AND (id &gt; 10 or id &lt; 2)\n$builder-&gt;where('status', 1)-&gt;where(' (id &gt; 10 or id &lt;2) ')-&gt;get('getTable');\nnull 条件\n\n$builder = new \\EasySwoole\\Mysqli\\QueryBuilder();\n$builder-&gt;where('status', null,'is')-&gt;get('getTable');\n$builder-&gt;where('status is null')-&gt;get('getTable');\n$builder-&gt;where('status', null,'is not')-&gt;get('getTable');\n特殊操作符\n$builder-&gt;where('id', [1,2,3], 'IN')-&gt;get('getTable');\n$builder-&gt;where('age', 12, '&gt;')-&gt;get('getTable');\n连接条件\norWhere\n$builder-&gt;where('is_vip', 1)-&gt;where('id', [1,2], '=', 'OR')-&gt;get('getTable');\n$builder-&gt;where('is_vip', 1)-&gt;orWhere('id', [1,2])-&gt;get('getTable');\n传参说明\n方法原型\nfunction where($whereProp, $whereValue = 'DBNULL', $operator = '=', $cond = 'AND')\n\n$whereProp string 支持索引数组、kv数组、或直接传递字符串\n$whereValue string 条件值\n$operator string 操作符\n$cond string 连接条件\n","link":"/Components/Mysqli/Chain/whereMethod.html"},{"id":156,"title":"orwhere","content":"orWhere\n快速完成条件语句构建\n下面两种方法等价\n$builder-&gt;where('is_vip', 1)-&gt;where('id', 1, '=', 'OR')-&gt;get('getTable');\n$builder-&gt;where('is_vip', 1)-&gt;orWhere('id', 1)-&gt;get('getTable');\n传参说明\n方法原型\nfunction orWhere($whereProp, $whereValue = 'DBNULL', $operator = '=')\n\n$whereProp string 支持索引数组、kv数组、或直接传递字符串\n$whereValue string 条件值\n$operator string 操作符\n","link":"/Components/Mysqli/Chain/orWhereMethod.html"},{"id":157,"title":"orderby","content":"orderBy\n用于对操作的结果排序。\n基本用法\n默认DESC排序规则\n$builder-&gt;orderBy('col1', 'ASC')-&gt;get('getTable');\n$builder-&gt;where('col1',2)-&gt;orderBy('col1', 'ASC')-&gt;get('getTable');\nORDER BY FIELD\n可以通过第三个参数实现\n$array = [\n    'a',\n    'b'\n];\n$builder-&gt;orderBy('', 'DESC', $array)-&gt;get('getTable');\n实现原理\nif (is_array($customFieldsOrRegExp)) {\n    foreach ($customFieldsOrRegExp as $key =&gt; $value) {\n        $customFieldsOrRegExp[$key] = preg_replace(\"/[^\\x80-\\xff-a-z0-9\\.\\(\\),_` ]+/i\", '', $value);\n    }\n    $orderByField = 'FIELD (' . $orderByField . ', \"' . implode('\",\"', $customFieldsOrRegExp) . '\")';\n}\nORDER BY REGEXP\n可以通过第三个参数实现\n实现原理\nif (is_string($customFieldsOrRegExp)) {\n    $orderByField = $orderByField . \" REGEXP '\" . $customFieldsOrRegExp . \"'\";\n}\n传参说明\n方法原型\nfunction orderBy($orderByField, $orderbyDirection = \"DESC\", $customFieldsOrRegExp = null)\n\n$orderByField 排序字段\n$orderbyDirection 排序规则\n$customFieldsOrRegExp 其他条件\n","link":"/Components/Mysqli/Chain/orderbyMethod.html"},{"id":158,"title":"groupby","content":"groupBy\n通常用于结合合计函数，根据一个或多个列对结果集进行分组 。\ngroup方法只有一个参数，并且只能使用字符串。\n使用\n$builder-&gt;groupBy('is_vip')-&gt;get('getTable');\n$builder-&gt;groupBy('is_vip,level')-&gt;get('getTable');\n传参说明\n方法原型\nfunction groupBy($groupByField)\n\n$groupByField string 分组字段\n","link":"/Components/Mysqli/Chain/groupbyMethod.html"},{"id":159,"title":"having","content":"having\n用于配合group方法完成从分组的结果中筛选（通常是聚合条件）数据。\n使用\n$builder-&gt;groupBy('user_id')-&gt;having('times', 3,'&gt;')-&gt;get('getTable');\n传参说明\n方法原型\nfunction having($havingProp, $havingValue = 'DBNULL', $operator = '=', $cond = 'AND')\n\n$havingProp 条件\n$havingValue 值\n$operator string 操作符\n$cond string 连接条件\n","link":"/Components/Mysqli/Chain/havingMethod.html"},{"id":160,"title":"orhaving","content":"orHaving\n用于配合group方法完成从分组的结果中筛选（通常是聚合条件）数据。\n使用\n$builder-&gt;groupBy('user_id')-&gt;orHaving('times', 3,'&gt;')-&gt;get('getTable');\n等同于\n$builder-&gt;groupBy('user_id')-&gt;having('times', 3,'&gt;'，'OR')-&gt;get('getTable');\n传参说明\n方法原型\nfunction orHaving($havingProp, $havingValue = 'DBNULL', $operator = '=')\n\n$havingProp 条件\n$havingValue 值\n$operator string 操作符\n","link":"/Components/Mysqli/Chain/orHavingMethod.html"},{"id":161,"title":"join","content":"Join\njoin通常有下面几种类型，不同类型的join操作会影响返回的数据结果。\n\nINNER JOIN: 等同于 JOIN（默认的JOIN类型）,如果表中有至少一个匹配，则返回行\nLEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行\nRIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行\nFULL JOIN: 只要其中一个表中存在匹配，就返回行\n\n基本使用\n$builder-&gt;join('table2','table2.col1 = getTable.col2')-&gt;get('getTable');\n指定类型\n$builder-&gt;join('table2','table2.col1 = getTable.col2','LEFT')-&gt;get('getTable');\n传参说明\n方法原型\nfunction join($joinTable, $joinCondition, $joinType = '')\n\n$joinTable 表名\n$joinCondition 条件\n$joinType 类型\n","link":"/Components/Mysqli/Chain/joinMethod.html"},{"id":162,"title":"joinwhere","content":"joinWhere\n传参说明\n方法原型\nfunction joinWhere($whereJoin, $whereProp, $whereValue = 'DBNULL', $operator = '=', $cond = 'AND')","link":"/Components/Mysqli/Chain/joinWhereMethod.html"},{"id":163,"title":"joinorwhere","content":"joinOrWhere\n传参说明\n方法原型\nfunction joinOrWhere($whereJoin, $whereProp, $whereValue = 'DBNULL', $operator = '=')","link":"/Components/Mysqli/Chain/joinOrWhereMethod.html"},{"id":164,"title":"union","content":"union\n构建UNION语句\n传参说明\n方法原型\nfunction union($cond, $isUnionAll = false)\n\n$cond   条件\n$isUnionAll\n","link":"/Components/Mysqli/Chain/unionMethod.html"},{"id":165,"title":"lockinsharemode","content":"LockInShareModel\nLockInShareModel锁定(InnoDb)\n传参说明\n方法原型\nfunction lockInShareMode($isLock = true)\n\n$isLock   \n","link":"/Components/Mysqli/Chain/lockInShareModeMethod.html"},{"id":166,"title":"selectforupdate","content":"selectForUpdate\nSELECT FOR UPDATE锁定(InnoDb)\n传参说明\n方法原型\nfunction selectForUpdate($isLock = true, string $option = null)\n\n$isLock   \n$option NOWAIT,WAIT 5,SKIP LOCKED\n","link":"/Components/Mysqli/Chain/selectForUpdateMethod.html"},{"id":167,"title":"setlocktablemode","content":"setLockTableMode\n锁表模式(读/写)\n传参说明\n方法原型\nfunction  setLockTableMode($method)\n\n$method  读/写\n","link":"/Components/Mysqli/Chain/setLockTableModeMethod.html"},{"id":168,"title":"locktable","content":"lockTable\n获得表锁\n传参说明\n方法原型\nfunction lockTable($table)\n\n$table  表名称\n","link":"/Components/Mysqli/Chain/lockTableMethod.html"},{"id":169,"title":"unlocktable","content":"unlockTable\n释放表锁\n传参说明\n方法原型\nfunction unlockTable()","link":"/Components/Mysqli/Chain/unlockTableMethod.html"},{"id":170,"title":"setqueryoption","content":"setQueryOption\n设置查询条件\n用法\n$builder-&gt;setQueryOption(\"FOR UPDATE\")-&gt;where('whereUpdate', 'whereValue')-&gt;update('updateTable', ['a' =&gt; 1], 2);\n传参说明\n方法原型\nfunction setQueryOption($options)","link":"/Components/Mysqli/Chain/setQueryOptionMethod.html"},{"id":171,"title":"setprefix","content":"setPrefix\n设置表前缀\n传参说明\n方法原型\nfunction setPrefix($prefix = '')","link":"/Components/Mysqli/Chain/setPrefixMethod.html"},{"id":172,"title":"withtotalcount","content":"withTotalCount\n统计结果行数\n查询用法\n查询用户行数：\n$builder-&gt;withTotalCount()-&gt;get(\"user\",null,\"*\");\n传参说明\n方法原型\nfunction withTotalCount(): QueryBuilder","link":"/Components/Mysqli/Chain/withTotalCountMethod.html"},{"id":173,"title":"replace","content":"replace\nreplace插入\n传参说明\n方法原型\nfunction replace($tableName, $insertData)\n\n$tableName 表名\n$insertData 需要插入的数据\n","link":"/Components/Mysqli/Chain/replaceMethod.html"},{"id":174,"title":"onduplicate","content":"onDuplicate\nonDuplicate插入\n传参说明\n方法原型\nfunction onDuplicate($updateColumns, $lastInsertId = null)\n\n$updateColumns 更新的列\n$lastInsertId 可不传，若传入，更新$lastInsertId行数据\n","link":"/Components/Mysqli/Chain/onDuplicateMethod.html"},{"id":175,"title":"安装","content":"ORM\nEasyswoole提供的一个全新协程安全的ORM封装。\n安装\n依赖关系\n\nswoole &gt;= 4.4.8\n\nEasyswoole  &gt;=3.3.2 \nmysqli &gt; 2.x\n\n\n\ncomposer require easyswoole/orm\n\n配置信息注册\nORM 的连接配置信息（数据库连接信息）需要注册到连接管理器中。\n数据库连接管理器\nORM的连接管理由EasySwoole\\ORM\\DbManager类完成，它是一个单例类。\nuse EasySwoole\\ORM\\DbManager;\n\nDbManager::getInstance();\n注册数据库连接配置\n你可以在框架 initialize 主服务创建事件中注册连接\nuse EasySwoole\\ORM\\DbManager;\nuse EasySwoole\\ORM\\Db\\Connection;\nuse EasySwoole\\ORM\\Db\\Config;\n\npublic static function initialize()\n{\n    $config = new Config();\n    $config-&gt;setDatabase('easyswoole_orm');\n    $config-&gt;setUser('root');\n    $config-&gt;setPassword('');\n    $config-&gt;setHost('127.0.0.1');\n    $config-&gt;setTimeout(15); // 超时时间\n\n    DbManager::getInstance()-&gt;addConnection(new Connection($config));\n\n    // 设置指定连接名称 后期可通过连接名称操作不同的数据库\n    DbManager::getInstance()-&gt;addConnection(new Connection($config),'write');\n}\n数据库连接自带连接池说明\n在默认实现中，ORM自带了一个基于连接池实现的连接类\nEasySwoole\\ORM\\Db\\Connection 实现了连接池的使用\nuse EasySwoole\\ORM\\DbManager;\nuse EasySwoole\\ORM\\Db\\Connection;\nuse EasySwoole\\ORM\\Db\\Config;\n\npublic static function initialize()\n{\n    $config = new Config();\n    $config-&gt;setDatabase('easyswoole_orm');\n    $config-&gt;setUser('root');\n    $config-&gt;setPassword('');\n    $config-&gt;setHost('127.0.0.1');\n    $config-&gt;setTimeout(15); // 超时时间\n    //连接池配置\n    $config-&gt;setGetObjectTimeout(3.0); //设置获取连接池对象超时时间\n    $config-&gt;setIntervalCheckTime(30*1000); //设置检测连接存活执行回收和创建的周期\n    $config-&gt;setMaxIdleTime(15); //连接池对象最大闲置时间(秒)\n    $config-&gt;setMinObjectNum(5); //设置最小连接池存在连接对象数量\n    $config-&gt;setMaxObjectNum(20); //设置最大连接池存在连接对象数量\n    $config-&gt;setAutoPing(5); //设置自动ping客户端链接的间隔\n\n    DbManager::getInstance()-&gt;addConnection(new Connection($config));\n}","link":"/Components/Orm/install.html"},{"id":176,"title":"必看章节，不看勿提问","content":"开发者必读\n此部分对于 ORM 的学习和使用非常重要。遇到使用问题时，请先确保自己认真看完了 ORM 文档，在对问题进行排查后，实在不能解决再进行提问和反馈。\n设计思想\nORM 全称：object relational mapping，目的是想像操作对象一样去操作数据库，是符合面向对象开发思想的。\n如将一条数据的插入，映射成一个对象的实例化。伪代码如下所示：\n&lt;?php\n$user = UserModel::create();\n$user-&gt;data([\n    'attr' =&gt; 'value'\n]);\n$user-&gt;save();\n常见问题汇总\n重复使用 Model 对象\n一个对象映射一条数据，此时会有很多用习惯了 db 封装组件的小伙伴把 Model 当成了 db 封装使用，重复调用一个 Model 对象，如下所示：\n&lt;?php\n// 错误使用\n\n// 假设id自增\n$user = UserModel::create();\n\n// 插入一条新用户\n$user-&gt;data([\n    'attr' =&gt; 'value'\n]);\n$user-&gt;save();\n\n// 插入第二条新用户，此时由于重复调用同一个对象，产生报错，自增 id 主键重复\n$user-&gt;data([\n    'attr' =&gt; 'value2'\n]);\n$user-&gt;save();\n\nORM 生成复杂 sql\n\n\n\nORM 是基于 mysqli 2.x 组件实现，内部引用 mysqli 组件中的 QueryBuilder 类 完成 sql 的构造，并且在 查询 章节 注明了闭包函数使用方式（可直接使用 mysqli 组件中的绝大部分连贯操作，如 having 等特殊条件）\n\n\n如果 mysqli 组件的连贯操作也无法满足您的需求，您有以下几种方式解决该问题：\n\n使用自定义 sql 执行\n尝试给组件贡献代码，新增功能特性\n提出反馈，我们会在精力允许和大众所需时，对组件进行维护升级\n\n\n\n优雅删除数据\n在 ORM 设计思想中，对数据的操作映射为对对象的操作，如果按照此原则，那么需要我们先查询出对象，然后再调用对象的 destroy() 方法进行删除。\n但是对于执行效率的消耗来说，此次查询在部分业务场景下是无用的。\n那么我们到底是否需要遵守设计原则？一般情况下是在 操作前需要校验数据是否存在 时遵守，无需校验则直接根据删除条件传参删除即可。\n设计原则代表思想，在某些场景下遵守它需要付出一定代价，开发者可以根据喜好去决定是否遵守。\n删除数据伪代码如下所示：\n&lt;?php\n$user = User::create()-&gt;get($param['id']);\n\nif (!$user){\n    return '操作数据不存在，请检查再试';\n}\n\n$res = $user-&gt;destroy();\n连接预热\n为了避免连接空档期突如其来的高并发，我们可以对数据库连接预热，也就是 Worker 进程启动的时候，提前准备好数据库连接。\n对连接进行预热使用实例如下所示：\n&lt;?php\n\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\nuse EasySwoole\\ORM\\DbManager;\nuse EasySwoole\\ORM\\Db\\Connection;\nuse EasySwoole\\ORM\\Db\\Config;\nuse EasySwoole\\EasySwoole\\Config as GlobalConfig;\n\nclass EasySwooleEvent implements Event\n{\n    public static function initialize()\n    {\n        // TODO: Implement initialize() method.\n        date_default_timezone_set('Asia/Shanghai');\n        $config = new Config(GlobalConfig::getInstance()-&gt;getConf(\"MYSQL\"));\n        DbManager::getInstance()-&gt;addConnection(new Connection($config));\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        $register-&gt;add($register::onWorkerStart,function (){\n            // 链接预热\n            // ORM 1.4.31 版本之前请使用 getClientPool() \n            // DbManager::getInstance()-&gt;getConnection()-&gt;getClientPool()-&gt;keepMin();\n\n            DbManager::getInstance()-&gt;getConnection()-&gt;__getClientPool()-&gt;keepMin();\n        });\n    }\n}\n断线问题\n为什么会断线？\n在连接池模式下，一个连接创建后，并不会因为因为请求结束而断开，就好比 php-fpm 下的 pconnect 特性一样。而一个连接建立后，可能会因为太久没有使用(执行 sql )，而被mysql 服务端主动断开了连接，或者是因为链路问题，切断了连接。而连接被切断的时候。我们并不知道这件事。因此就导致了我们用了一个断线的数据库连接去执行 sql，从而出现断线错误或者异常。\n如何解决短线问题？\n与 java 全家桶的原理一致，我们需要做的事情就是：\n\n定时检查连接是否可用\n定时检查连接的最后一次使用状态\n\n因此在 EasySwoole 的 ORM 中，ORM 组件提供了 IntervalCheckTime 配置项，它指定的就是多久做一次周期检查，MaxIdleTime 配置项指的是如果一个连接超过这个时间没有使用，则会被回收。AutoPing 配置项指的是多久执行一个 select 1 用来触发这个连接，让这个连接被 mysql 服务端标记为活跃而不会被回收。如果经常出现断线，可以适当缩短 周期性检查 和 AutoPing 的时间（即调整 IntervalCheckTime、AutoPing 配置项的值）。\n百分百不会断线了？\n理论上，做了上面的步骤，出现使用断线连接的概率是非常低的，但是并不是真的就百分百稳了，比如极端情况：mysql 服务重启，或者是链路断线了。因此，我们一定要做类似如下这样的处理措施：\n&lt;?php\ntry {\n    $client = $pool-&gt;getClient();\n    $cilient-&gt;query(xxxxxx);\n} catch (\\Throwable $t) {}\n也就是说，任何 orm 的使用，一定要 try。至于为何，请参考 java 为何强制对任何数据库 io 做 try 处理。\n为何不能做自动重连\n我们可以看到，在某些自以为很聪明的框架中，有下面这样的操作：\n&lt;?php\n$client = $pool-&gt;getClient();\ntry {\n    return $client-&gt;query();\n} catch(\\Throwable $t) {\n    // 2006 2002 为断线\n    if ($client-&gt;getError() == '2006') {\n        $client-&gt;connect();\n        return $client-&gt;query();\n    } else {\n        throw $t;\n    }\n}\n乍一看，没有什么问题。实际上，按照上面的重连，我们来看看下面的伪代码：\n&lt;?php\n$client = $pool-&gt;getClient();\n$client-&gt;startTransaction();\n$client-&gt;query(query one);\n// client disconnect case network\n$client-&gt;reconnect();\n$client-&gt;query(query two);\n$client-&gt;commit();\n这样，在极端情况下，会导致 query one 结果丢失，但是 query two 却执行了，这对于事务来说，是不可原谅的。此刻又会有人说，那我判断下链接是不是在事务中不就好了。实际上，远远没这么简单。为此，最好的方式就是我们养成良好的习惯。任何的数据库 io，都做 try 操作，与 java 一致。","link":"/Components/Orm/readme.html"},{"id":177,"title":"核心文件","content":"核心文件\n本章节对核心Config、Connection、DbManager源码分析，方便开发者快速上手。\nConfig\nOrm自带连接池，因此继承了EasySwoole\\Pool\\Config，并且父级继承了EasySwoole\\Spl\\SplBean具有对类属性快速赋值的操作。\n实例\n$config = new \\EasySwoole\\ORM\\Db\\Config();\n基本配置\n设置host\n/** @var \\EasySwoole\\ORM\\Db\\Config  $config **/\n$config-&gt;setHost('127.0.0.1');\n$config-&gt;setHost('127.0.0.1:3306');\n设置port\n/** @var \\EasySwoole\\ORM\\Db\\Config  $config **/\n$config-&gt;setPort(3306);\n设置用户名\n/** @var \\EasySwoole\\ORM\\Db\\Config  $config **/\n$config-&gt;setUser('root');\n设置密码\n/** @var \\EasySwoole\\ORM\\Db\\Config  $config **/\n$config-&gt;setPassword('easyswoole');\n设置数据库\n/** @var \\EasySwoole\\ORM\\Db\\Config  $config **/\n$config-&gt;setDatabase('easyswoole');\n设置charset\n/** @var \\EasySwoole\\ORM\\Db\\Config  $config **/\n$config-&gt;setCharset('utf8');\n设置严格模式\n/** @var \\EasySwoole\\ORM\\Db\\Config  $config **/\n$config-&gt;setStrictType(true);\n设置fetchMode\n/** @var \\EasySwoole\\ORM\\Db\\Config  $config **/\n$config-&gt;setFetchMode(true);\n设置超时时间\n/** @var \\EasySwoole\\ORM\\Db\\Config  $config **/\n$config-&gt;setTimeout(15);\n设置返回结果为结果集\n可以快速all()-&gt;toArray()\n/** @var \\EasySwoole\\ORM\\Db\\Config  $config **/\n$config-&gt;setReturnCollection(true);\n连接池配置\n设置获取连接池对象超时时间\n/** @var \\EasySwoole\\ORM\\Db\\Config  $config **/\n$config-&gt;setGetObjectTimeout(3.0);\n设置检测连接存活执行回收和创建的周期\n/** @var \\EasySwoole\\ORM\\Db\\Config  $config **/\n$config-&gt;setIntervalCheckTime(30*1000);\n连接池对象最大闲置时间(秒)\n/** @var \\EasySwoole\\ORM\\Db\\Config  $config **/\n$config-&gt;setMaxIdleTime(15);\n设置最小连接池存在连接对象数量\n/** @var \\EasySwoole\\ORM\\Db\\Config  $config **/\n$config-&gt;setMinObjectNum(5);\n设置最大连接池存在连接对象数量\n/** @var \\EasySwoole\\ORM\\Db\\Config  $config **/\n$config-&gt;setMaxObjectNum(15);\n设置自动ping客户端链接的间隔\n/** @var \\EasySwoole\\ORM\\Db\\Config  $config **/\n$config-&gt;setAutoPing(5);\n快速设置\n$config = new \\EasySwoole\\ORM\\Db\\Config([\n    'host' =&gt; '127.0.0.1',\n    'autoPing' =&gt; 5\n]);\nConnection\n实例\n/** @var \\EasySwoole\\ORM\\Db\\Config  $config **/\n$connection = new \\EasySwoole\\ORM\\Db\\Connection($config);\n获取池\n/** @var \\EasySwoole\\ORM\\Db\\Connection $connection **/\n$connection-&gt;getClientPool();\ndefer\ntimeout参数为空 默认获取config的timeout，此方法会自动回收对象，用户无需关心。\n/** @var \\EasySwoole\\ORM\\Db\\Connection $connection **/\n$connection-&gt;defer();\n$connection-&gt;defer(3.0);\n获取注入的config\n/** @var \\EasySwoole\\ORM\\Db\\Connection $connection **/\n$connection-&gt;getConfig();\nDbManager\nDbManager采用单例，注意：进程间数据是隔离的。\n实例\n\\EasySwoole\\ORM\\DbManager::getInstance();\n回调事件\n具体注入参数请看回调事件\n\\EasySwoole\\ORM\\DbManager::getInstance()-&gt;onQuery(function (){\n\n});\n注入连接池\n参数：\n\n\n$connection 连接池对象\n\n$connectionName 连接池名称 默认default 可进行读写分离配置\n\n/** @var \\EasySwoole\\ORM\\Db\\Config  $config **/\n$connection = new \\EasySwoole\\ORM\\Db\\Connection($config);\n\\EasySwoole\\ORM\\DbManager::getInstance()-&gt;addConnection($connection);\n\n\\EasySwoole\\ORM\\DbManager::getInstance()-&gt;addConnection($connection,'write');\n获取连接池\n参数：\n\n\n$connectionName 连接池名称\n\n\\EasySwoole\\ORM\\DbManager::getInstance()-&gt;getConnection();\nquery\n参数：\n\n\n$builder QueryBuilder\n\n$raw 是否raw执行，否则预处理\n\n$connection 指定连接池名称 或者 连接\n\n$timeout 超时时间\n\n\\EasySwoole\\ORM\\DbManager::getInstance()-&gt;query(new \\EasySwoole\\Mysqli\\QueryBuilder());\n事务\n注意事务协程上下文。\n参数：\n\n\n$con 指定连接池名称 或者 连接\n\n$timeout 超时时间\n\n\\EasySwoole\\ORM\\DbManager::getInstance()-&gt;startTransaction();\n\\EasySwoole\\ORM\\DbManager::getInstance()-&gt;commit();\n\\EasySwoole\\ORM\\DbManager::getInstance()-&gt;rollback();\ninvoke\n使用invoke方式，让ORM查询结束后马上归还资源，可以提高资源的利用率。\n参数：\n\n\n$call 回调函数\n\n$connectionName 指定连接池名称\n\n$timeout 超时时间\n\n\\EasySwoole\\ORM\\DbManager::getInstance()-&gt;invoke(function (\\EasySwoole\\ORM\\Db\\ClientInterface $client){\n\n    \\EasySwoole\\ORM\\DbManager::getInstance()-&gt;startTransaction($client);\n    \\EasySwoole\\ORM\\DbManager::getInstance()-&gt;commit($client);\n    \\EasySwoole\\ORM\\DbManager::getInstance()-&gt;rollback($client);\n\n});\n查询该连接是否处于事务上下文\n/** @var \\EasySwoole\\ORM\\Db\\ClientInterface $client **/\n\\EasySwoole\\ORM\\DbManager::isInTransaction($client);","link":"/Components/Orm/core.html"},{"id":178,"title":"定义模型","content":"Model\n基础定义\n基本模型\n定义一个模型基础的模型，必须继承EasySwoole\\ORM\\AbstractModel类\nnamespace App\\Models;\n\nuse EasySwoole\\ORM\\AbstractModel;\n\n/**\n * 用户商品模型\n * Class UserShop\n */\nclass UserShop extends AbstractModel\n{\n\n}\n数据表名称\n必须在Model中定义 $tableName 属性，指定完整表名，否则将会产生错误Table name is require for model\nnamespace App\\Models;\n\nuse EasySwoole\\ORM\\AbstractModel;\n\n/**\n * 用户商品模型\n * Class UserShop\n */\nclass UserShop extends AbstractModel\n{\n     /**\n      * @var string \n      */\n     protected $tableName = 'user_shop';\n}\n定义表结构\n自动生成表结构\n$model = new User();\n$table = $model-&gt;schemaInfo();\n使用模型中的schemaInfo()方法可以获取当前模型指定数据表的结构返回一个EasySwoole\\ORM\\Utility\\Schema\\Table对象\n模型本身会自动生成表结构,但每次启动Easyswoole,都会去重新获取一次表结构信息,并且在这次服务中缓存,直到Easyswoole服务停止或者重启\n如果不希望每次重启都去请求一次数据库,可自行定义该方法,返回Table对象\n自定义表结构\n在模型类中，我们实现一个getSchemaInfo方法，要求返回一个EasySwoole\\ORM\\Utility\\Schema\\Table实例化对象\nuse EasySwoole\\ORM\\Utility\\Schema\\Table;\nuse EasySwoole\\ORM\\AbstractModel;\n\nclass User extends AbstractModel\n{\n    protected $tableName = 'user';\n\n    /**\n     * 表的获取\n     * 此处需要返回一个 EasySwoole\\ORM\\Utility\\Schema\\Table\n     * @return Table\n     */\n    public function schemaInfo(bool $isCache = true): Table\n    {\n        $table = new Table($this-&gt;tableName);\n        $table-&gt;colInt('id')-&gt;setIsPrimaryKey(true);\n        $table-&gt;colChar('name', 255);\n        $table-&gt;colInt('age');\n        return $table;\n    }\n}\n\n表字段\n在Table中，有colX系列方法，用于表示表字段的类型，如以上示例的Int,Char\n$table-&gt;colInt('id');\n$table-&gt;colChar('name', 255);\n表主键\n如果需要将某个字段指定为主键 则用连贯操作方式，在后续继续指定即可。\n$table-&gt;colInt('id')-&gt;setIsPrimaryKey(true);\n指定连接名\n从 安装 章节，我们已经知道了，在注册配置信息的时候，可以给这份配置指定一个连接名\n可以通过模型类自定义属性 connectionName 来指定使用的连接配置，默认为 default\n假设已经通过 配置信息注册 章节注册了一个 read 连接名的配置\n那么我们可以在Model中定义指定read连接名\nClass AdminModel extends \\EasySwoole\\ORM\\AbstractModel \n{\n    protected $connectionName = 'read';\n}\n可以继续查看 读写分离 章节，进一步查看如何使用不同数据库配置。\n时间戳\n在ORM组件版本 &gt;= 1.0.18 后，增加自动时间戳特性支持。\n用于：自动写入创建和更新的时间字段。\n\n在插入数据的时候，自动设置插入时间为当前，\n在更新数据的时候，自动设置更新时间为当前。\n\n使用方式\nuse \\EasySwoole\\ORM\\AbstractModel ;\n\nClass AdminModel extends AbstractModel\n{\n    // 都是非必选的，默认值看文档下面说明\n    protected $autoTimeStamp = true;\n    protected $createTime = 'create_at';\n    protected $updateTime = 'update_at';\n}\nautoTimeStamp\n是否开启自动时间戳，默认值 false\n可选值： \n\ntrue 字段默认为int类型 储存时间戳\nint  字段为int类型 储存时间戳\ndatetime  字段为datetime类型  Y-m-d H:i:s\n\ncreateTime\n数据创建时间 字段名，默认值 create_time \n可选值\n\n任意字符串，对应为表中要储存创建时间的字段名\nfalse，不处理创建时间字段\n\nupdateTime\n数据更新时间 字段名，默认值 update_time \n可选值\n\n任意字符串，对应为表中要储存创建时间的字段名\nfalse，不处理更新时间字段\n\n字段预定义属性\n版本要求：orm &gt;= 1.4.9\n利用cast定义可以实现：在取出时自动转换为数组、在存储时自动转换为json字符\n数据库储存一般是以文本格式，php擅长的是数组、对象等，达到灵活使用的目的。\n也可以定义字段为int、小数、时间戳等\n定义方式\n\nclass TestCastsModel extends AbstractModel\n{\n    protected $casts = [\n        'age'           =&gt; 'int',\n        'id'            =&gt; 'float',\n        'addTime'       =&gt; 'timestamp',\n        'state'         =&gt; 'bool',\n        // 在join中自定义的\n        'test_json'     =&gt; 'json',\n        'test_array'    =&gt; 'array',\n        'test_date'     =&gt; 'date',\n        'test_datetime' =&gt; 'datetime',\n        'test_string'   =&gt; 'string',\n    ];\n}\n支持类型\n\n\n\n类型\n设置值\n\n\n\n\n整数\nint、 integer\n\n\n浮点\nreal、float、double\n\n\n字符串\nstring\n\n\n布尔值\nbool、boolean\n\n\n数组\narray  相当于json_decode($data, true)\n\n\n对象\njson、object   相当于json_decode($data)\n\n\n日期 Y-m-d\ndate\n\n\n日期 Y-m-d H:i:s\ndatetime\n\n\n时间戳\ntimestamp\n\n\n自定义日期格式\n未完成\n\n\n自定义小数类型\n未完成\n\n\n\n示例代码\n以下代码为orm组件的单元测试脚本 \n\n    public function testFloat()\n    {\n        $test = TestCastsModel::create([\n            'id' =&gt; 1\n        ]);\n        $this-&gt;assertIsFloat($test-&gt;id);\n    }\n\n    public function testInt()\n    {\n        $test = TestCastsModel::create([\n            'age' =&gt; \"21\"\n        ]);\n        $this-&gt;assertIsInt($test-&gt;age);\n    }\n\n    public function testTimestamp()\n    {\n        $test = TestCastsModel::create([\n            'addTime' =&gt; \"2020-6-4 16:45:04\"\n        ]);\n        $this-&gt;assertIsInt($test-&gt;addTime);\n    }\n\n    public function testBool()\n    {\n        $test = TestCastsModel::create([\n            'state' =&gt; 0\n        ]);\n        $this-&gt;assertIsBool($test-&gt;state);\n    }\n\n    public function testString()\n    {\n        $test = TestCastsModel::create();\n        $test-&gt;setAttr('test_string', 1);\n        $this-&gt;assertIsString($test-&gt;test_string);\n    }\n\n    public function testJson()\n    {\n        $test = TestCastsModel::create();\n        $test-&gt;setAttr('test_json', [\n            'name' =&gt; 'siam'\n        ]);\n\n        $this-&gt;assertInstanceOf(\\stdClass::class, $test-&gt;test_json);\n    }\n\n    public function testArray()\n    {\n        $test = TestCastsModel::create();\n        $test-&gt;setAttr('test_array', [\n            'name' =&gt; 'siam'\n        ]);\n\n        $this-&gt;assertIsArray($test-&gt;test_array);\n    }\n\n    public function testDate()\n    {\n        $test = TestCastsModel::create();\n        $test-&gt;setAttr('test_date', time());\n        $this-&gt;assertEquals(date(\"Y-m-d\"), $test-&gt;test_date);\n    }\n    public function testDateTime()\n    {\n        $test = TestCastsModel::create();\n        $test-&gt;setAttr('test_datetime', time());\n        $this-&gt;assertEquals(date(\"Y-m-d H:i:s\"), $test-&gt;test_datetime);\n    }\n","link":"/Components/Orm/definitionModel.html"},{"id":179,"title":"invoke执行","content":"orm invoke\n在高并发情况下，资源浪费的占用时间越短越好，可以提高程序的服务效率。\n在ORM默认情况下是使用defer方法获取pool内的连接资源，并在协程退出时自动归还，在此情况下，在带来便利的同时，会造成不必要资源的浪费。\n我们可以使用invoke方式，让ORM查询结束后马上归还资源，可以提高资源的利用率。\n$value = DbManager::getInstance()-&gt;invoke(function ($client){\n    $testUserModel = Model::invoke($client);\n    $testUserModel-&gt;state = 1;\n    $testUserModel-&gt;name = 'Siam';\n    $testUserModel-&gt;age = 18;\n    $testUserModel-&gt;addTime = date('Y-m-d H:i:s');\n    $data = $testUserModel-&gt;save();\n    return $data;\n});\nvar_dump($value);\n旧版本的invoke没有return值，请更新orm版本。\n方法支持\n在此种模式下，主要有两个方法需要讲解。\n\nDbManager下的invoke方法 （从连接池内获取一个连接，并在闭包完成时归还连接）\nModel的invoke方法 （注入客户端连接，不再从连接池内defer获取）\n\ninvoke中调试sql\n版本&gt;=1.2.12提供特性\n关于lastQueryResult、lastQuery返回内容，请查看章节模型执行结果、最后执行语句\n$client-&gt;lastQueryResult();\n$client-&gt;lastQuery();\n指定连接名和超时时间\nDbManager的invoke方法可以有3个传参\n\n第一个参数为闭包，在以上示例中已经体现\n第二个参数为连接名，非必选，可以指定要从哪个池中拿出链接\n第三个参数为超时时间，非必选，默认为3秒\n","link":"/Components/Orm/invoke.html"},{"id":180,"title":"自定义sql执行","content":"自定义SQL执行\n有时候你可能需要在查询中使用原生表达式。你可以使用 QueryBuilder 构造一个原生 SQL 表达式\nORM 内部依赖的是 mysqli 组件的QueryBuilder\nuse EasySwoole\\Mysqli\\QueryBuilder;\n\n$queryBuild = new QueryBuilder();\n// 支持参数绑定 第二个参数非必传\n$queryBuild-&gt;raw(\"select * from test where name = ?\", ['siam']);\n// $queryBuild-&gt;raw(\"select * from test where name = 'siam'\");\n\n// 第二个参数 raw  指定true，表示执行原生sql\n// 第三个参数 connectionName 指定使用的连接名，默认 default\n$data = DbManager::getInstance()-&gt;query($queryBuild, true, 'default');\n\n通过Model执行\nuse EasySwoole\\Mysqli\\QueryBuilder;\n// 需要注意的是，这里的sql语句仅仅是示例\n// 正确推荐的做法应该仍然是查询Model类对应的表，得到表结构字段的数据\n$data = Model::create()-&gt;func(function ($builder){\n    $builder-&gt;where('userId',1)-&gt;get('user_list');\n});\n\n注意，func可以返回bool类型，当返回 true的时候，表示该builder 需要以raw 模式执行。\n\nuse EasySwoole\\Mysqli\\QueryBuilder;\n// 需要注意的是，这里的sql语句仅仅是示例\n// 正确推荐的做法应该仍然是查询Model类对应的表，得到表结构字段的数据\n$data = Model::create()-&gt;func(function ($builder){\n    $builder-&gt;raw('select * from user_list where userId = ?',[1]);\n    return true;\n});\n原生 SQL 表达式将会被当做字符串注入到查询中，因此你应该小心使用，避免创建 SQL 注入的漏洞。","link":"/Components/Orm/customSqlExecution.html"},{"id":181,"title":"模型执行结果","content":"执行结果\n当model执行一个语句之后,会将该次执行的结果保存到$model-&gt;lastQueryResult()中,该方法将返回一个EasySwoole\\ORM\\Db\\Result对象\n&lt;?php\n$model = new AdminModel();\n$model-&gt;all();\n//获取查询结果对象\n$lastResult = $model-&gt;lastQueryResult();\n//获取查询数据总数,查询时需要调用`withTotalCount`才可以使用该方法\nvar_dump($lastResult-&gt;getTotalCount());\n//获得最后插入的id\nvar_dump($lastResult-&gt;getLastInsertId());\n//获取执行影响的数据条数  update,delete等方法使用\nvar_dump($lastResult-&gt;getAffectedRows());\n//获取错误code\nvar_dump($lastResult-&gt;getLastErrorNo());\n//获取错误消息\nvar_dump($lastResult-&gt;getLastError());\n//获取执行mysql返回的结果\nvar_dump($lastResult-&gt;getResult());\n\n// 以下内容在版本&gt;=1.2.2后提供\n\n// 获取结果中的第一条\nvar_dump($lastResult-&gt;getResultOne());\n// 获取结果中某列\nvar_dump($lastResult-&gt;getResultColumn(string $column));\n// 获取结果中某列的第一条数据\nvar_dump($lastResult-&gt;getResultScalar(string $column));\n// 以某一个字段名为key 返回结果数组\nvar_dump($lastResult-&gt;getResultIndexBy(string $column));\n\n// 以下快速获取方式在版本&gt;=1.2.12后提供\nDbManager::getInstance()-&gt;getConnection()-&gt;defer()-&gt;lastQueryResult();\nAdminModel::defer()-&gt;lastQueryResult();\n当$model执行get,all,save等类似方法出错时,可通过调用getLastError方法获取错误消息用于调试","link":"/Components/Orm/lastResult.html"},{"id":182,"title":"最后执行语句","content":"最后执行语句\n当model执行一个语句之后,会将该次执行的语句对象保存到$model-&gt;lastQuery()中:\n&lt;?php\n$model = new AdminModel();\n//执行all查询\nvar_dump($model-&gt;all());\n//打印最后执行的`EasySwoole\\Mysqli\\QueryBuilder` 对象\nvar_dump($model-&gt;lastQuery());\n//打印最后执行的sql语句\nvar_dump($model-&gt;lastQuery()-&gt;getLastQuery());\n\n// 新版本orm提供\n$lastQuery = DbManager::getInstance()-&gt;getLastQuery()-&gt;getLastQuery(); // 第一个lastQuery是对象，第二次是从对象中取出语句\n$model->lastQuery() 返回的是query对象,具体文档可查看:查询构造器 文档","link":"/Components/Orm/lastQuery.html"},{"id":183,"title":"事务操作","content":"事务操作\n\nDbManager 连接管理器提供\n\nDbManager 操作事务\n传参说明（代码示例看下文）\n\n\n\n参数类型\n参数说明\n\n\n\n\nstring 或 array\n值为 $connectionName (即连接名)，代表使用当前协程下连接名为 $connectionName 的 mysql 连接执行事务\n\n\nClientInterface\n在 invoke 闭包中直接传入 client，代表直接操作指定 mysql 客户端\n\n\n\n返回值说明：bool。开启成功则返回 true，开启失败则返回 false。\n\n开启事务\n\n// $connection 参数默认为 'default'，表示使用当前协程下连接名为 $connectionName 的 mysql 连接开启事务\n\\EasySwoole\\ORM\\DbManager::getInstance()-&gt;startTransaction($connection = 'default');\n\n提交事务\n\n// 如果不传 'default'，则提交当前协程下连接名称为 default 的事务\n\\EasySwoole\\ORM\\DbManager::getInstance()-&gt;commit($connection = 'default');\n\n回滚事务\n\n// 如果不传 'default'，则回滚当前协程下连接名称为 default 的事务\n\\EasySwoole\\ORM\\DbManager::getInstance()-&gt;rollback($connection = 'default');\nClient 直接管理\n无需传参\n返回值说明：bool。开启成功则返回 true，开启失败则返回 false。\n\nClientInterface-&gt;startTransaction();\nClientInterface-&gt;commit();\nClientInterface-&gt;rollback();\n\n代码示例1\nDbManager 管理事务 ，可以开启多个连接名下的客户端事务，进行多连接事务管理\ntry {\n    // 开启事务\n    \\EasySwoole\\ORM\\DbManager::getInstance()-&gt;startTransaction();\n\n    // 执行更新 $model 的更新操作\n    $model = new UserModel();\n    $res = $model-&gt;update(['is_vip' =&gt; 1]);\n\n    // 提交事务\n    \\EasySwoole\\ORM\\DbManager::getInstance()-&gt;commit();\n} catch(\\Throwable  $e){\n    // 回滚事务\n    \\EasySwoole\\ORM\\DbManager::getInstance()-&gt;rollback();\n}\n代码示例2\nDbManager 管理事务，传递参数为 ClientInterface 类型，指定操作客户端\n效果等同于上文代码示例3，直接操作客户端\n// 指定取出 write 连接名下的客户端，并且执行开启事务\n\\EasySwoole\\ORM\\DbManager::getInstance()-&gt;invoke(function (EasySwoole\\ORM\\Db\\ClientInterface $client){\n    // 开启事务\n    \\EasySwoole\\ORM\\DbManager::getInstance()-&gt;startTransaction($client);\n\n    // ...\n}, 'write');","link":"/Components/Orm/transactionOperations.html"},{"id":184,"title":"读写分离","content":"读写分离\n注册读写链接配置信息\n首先，我们需要按照 安装 注册 读 / 写 两个链接的信息\n主要代码大概如下\nDbManager::getInstance()-&gt;addConnection($con, 'read');\nDbManager::getInstance()-&gt;addConnection($con2, 'write');\n指定使用链接\n有两种方式可以使用 可以根据自己的需求选择\n主要利用AbstractModel提供的connection()方法\nfunction connection(string $name, bool $isTemp = false)\n第二个参数需要传入为true，表示临时使用，否则该认定为固定使用 建议只在临时使用时设置该方式，如果要固定使用则从Model类文件中定义。\nModel继承定义\nclass Test extends AbstractModel{\n    /** 这里因为不是使用默认的配置链接名 所以需要指定 */\n    protected $connectionName = 'write';\n\n    /** get 方法使用读链接 */\n    public function get($where = null, bool $returnAsArray)\n    {\n        $this-&gt;connection('read', true);\n        return parent::get($where, $returnAsArray);\n    } \n}\n外部使用\nTest::create()-&gt;connection('read',true)-&gt;all();","link":"/Components/Orm/readWriteSeparation.html"},{"id":185,"title":"查询","content":"查询\n查询一行\n\nget($where)\n\n查询多行\n\nall($where)\n\n返回值说明\n\n\nget返回的是一个 EasySwoole\\ORM\\AbstractModel 实例，可以复用进行模型的其他操作 当没有查询结果时返回 null \n\nall返回的是一个数组，里面的每一个元素都是  EasySwoole\\ORM\\AbstractModel 实例\n\n多种传参方式\n在以上方法列表中，最重要的是$where参数，可以实现多种使用方式\n// 通过主键\n$res = UserModel::create()-&gt;get(1);\n// 通过key=&gt;value 数组\n$res = UserModel::create()-&gt;get([\n  'u_id'    =&gt; 1,\n  'u_state' =&gt; 0,\n  'is_vip'  =&gt; 1\n]);\n// 通过闭包方式，构造复杂的sql\n// 这是一种很强大灵活的方式，闭包的参数是一个mysqli组件的查询构造器，可以调用所有连贯操作\n// http://www.easyswoole.com/Components/Mysqli/builder.html\n$res = UserModel::create()-&gt;get(function(QueryBuilder $queryBuilder){\n    $queryBuilder-&gt;where('u_state', 1);\n    $queryBuilder-&gt;where('age', 12, '&gt;');// 各种特殊操作符  between like != 等等都可以完成\n    $queryBuilder-&gt;order('u_id');\n});\n// 连贯操作，继续可以往下查看ORM的文档\n$res = UserModel::create()-&gt;where('u_id', 1)-&gt;get();\n分页\nlimit和withTotalCount，获取分页列表数据以及总条数。\n下面模拟获取分页列表数据，page为页码，limit为每页显示多少条数。\n$page = 1;          // 当前页码\n$limit = 10;        // 每页多少条数据\n\n$model = AdminModel::create()-&gt;limit($limit * ($page - 1), $limit)-&gt;withTotalCount();\n\n// 列表数据\n$list = $model-&gt;all(null);\n\n$result = $model-&gt;lastQueryResult();\n\n// 总条数\n$total = $result-&gt;getTotalCount();\n快速查询\n获取查询结果某一列的值，如果 $column 为空，则会返回查询结果的第一列\n\ncolumn(?string $column = null): ?array\n\n获取查询结果某一列第一行的值，如果 $column 为空，则会返回查询结果的第一列第一行的值\n\nscalar(?string $column = null): ?array\n\n获取结果并使用某一列的作为索引\n\nindexBy(string $column): ?array\n\n$nameList = UserListModel::create()-&gt;column('name');\n/*\n会返回类似这样的数组\n[\n  'tom',\n  'tony',\n  'alex'\n  'ben'\n]\n */\n\n$name = UserListModel::create()-&gt;scalar('name');\n$age = UserListModel::create()-&gt;limit(1)-&gt;scalar('age');\n/*\n会返回单个值\n$name = 'tom';\n$age = 12;\n*/\n\n$userList = UserListModel::create()-&gt;indexBy('age');\n/*\n会返回类似这样的数组\n[\n  '12' =&gt; [\n    'tom',\n    'tony'\n  ],\n  '13' =&gt; [\n    'alex',\n  ]\n  '14' =&gt; [\n    'ben',\n  ]\n]\n */\n\ncolumn，scalar，indexBy 这三个方法都是对 all 方法的封装。\nscalar 方法只是返回查询结果当中的某一列第一行的值， 条件语句中不会自动加上 LIMIT 1 条件。\ncolumn，scalar，indexBy 这三个方法在获取数据失败时会返回 null ，获取数据失败时不一定查询失败，也可能返回的数据里没有对应的列名\n\nnull条件查询\n如果需要查询 为null/不为null 的数据.\n$model = new \\App\\Model\\RequestLogModel();\n$model-&gt;where('a',null,'is')-&gt;get();\n$model-&gt;where('a',null,'is not')-&gt;get();","link":"/Components/Orm/query.html"},{"id":186,"title":"转换数组","content":"结果转换数组\n查询后将对象转为数组\n传参\ntoArray和toRawArray传参一致\n\n\n\n参数名\n参数说明\n\n\n\n\nnotNull\n是否过滤空，bool类型 默认false，当为true时，只返回非空字段\n\n\nstrict\n严格模式，bool类型 默认true，当为true时，只返回当前模型对应数据表的字段，其他field别名等不返回。\n\n\n\n示例\n经过获取器\n$model = Model::create()-&gt;get(1);\n$array = $model-&gt;toArray();\n\n$model = Model::create()-&gt;all();\nforeach($model as $one){\n    var_dump($one-&gt;toArray());\n}\n不经过获取器\n$model = Model::create()-&gt;get(1);\n$array = $model-&gt;toRawArray();\n\n$model = Model::create()-&gt;all();\nforeach($model as $one){\n    var_dump($one-&gt;toRawArray());\n}\n筛选\norm &gt; 1.4.4\n在调用toArray或toRawArray之前。可以通过调用field()和hidden()方法进行返回数据的筛选\n两个方法的传参为array|string,string代表只过滤一个字段\n$field = $model-&gt;field(['user_list'])-&gt;toArray(false, false); // 返回的数组里只有user_list一个元素\n$hidden = $model-&gt;hidden('user_list')-&gt;toArray(false, false); // 返回的数组里过滤了user_list元素\n\n追加\n追加非模型字段的属性，必须设置获取器。\n\\EasySwoole\\ORM\\Tests\\models\\TestUserListModel::create()-&gt;all()-&gt;append(['append_one'])-&gt;toArray();\n显示\n显示指定字段。\n\\EasySwoole\\ORM\\Tests\\models\\TestUserModel::create()-&gt;all()-&gt;visible(['username','password'])-&gt;toArray();\n隐藏\n隐藏指定字段。\n\\EasySwoole\\ORM\\Tests\\models\\TestUserModel::create()-&gt;all()-&gt;hidden(['password'])-&gt;toArray();\n注意事项\n模型层all方法,默认是不返回Collection的,需要通过foreach进行:\n$results = \\EasySwoole\\ORM\\Tests\\models\\TestUserModel::create()-&gt;all();\n/** @var \\EasySwoole\\ORM\\AbstractModel $result */\nforeach($results as $result) {\n    $result-&gt;toArray();\n}\n\n可以通过配置项returnCollection进行配置,即可快速调用：\n\\EasySwoole\\ORM\\Tests\\models\\TestUserModel::create()-&gt;all()-&gt;toArray();\n\nget方法不受此配置项影响。\n\n如果不想修改此配置项，兼容以前代码可以通过以下代码快速实现toArray.\n$ret = \\EasySwoole\\ORM\\Tests\\models\\TestUserModel::create()-&gt;all();\nif (!$ret instanceof \\EasySwoole\\ORM\\Collection\\Collection) {\n    $ret = new \\EasySwoole\\ORM\\Collection\\Collection($ret);\n}\n$ret-&gt;toArray();\n\n以上代码自己去做封装.\n","link":"/Components/Orm/toArray.html"},{"id":187,"title":"快捷查询","content":"快捷查询\n依赖关系\n\nmysqli &gt;=2.1.2\nORM &gt;= 1.2.5\n\n查询单行指定字段值\n\nval(string $column)\nscalar(?string $column = null)\n\n查询多行指定字段值\n\ncolumn(?string $column = null)\nindexBy(string $column)\n\n返回值说明\n\n\nval 当存在该行数据并字段存在时，返回该字段值。\n字段不存在时，返回该行数据数组。\n该行不存在时，返回null\n\n\nscalar 当符合条件数据存在时，返回首条数据字段值。\n当符合条件不存在时，返回空数组。\n当不传参数时，默认返回主键值。\n\n\ncolumn 返回该字段值的数组。\n当参数不传时，默认返回主键数组。\n\n\nindexBy返回以指定字段为Key的数据数组。\n\n\n示例\n\n// val 直接返回某一行的某一列\n$res = UserModel::create()-&gt;val('loginName');\nvar_dump($res);\n\n// column 快速查询结果的某一列\n$res = UserModel::create()-&gt;column('loginName');\nvar_dump($res);\n\n// scalar 快速查询结果的某一列的第一条数据\n$res = UserModel::create()-&gt;scalar('loginName');\nvar_dump($res);\n\n// indexBy 以某个字段名的数据返回结果数组\n$res = UserModel::create()-&gt;indexBy('loginName');\nvar_dump($res);\n","link":"/Components/Orm/quickQuery.html"},{"id":188,"title":"特殊条件查询","content":"特殊条件查询\nfind_in_set\n生成条件  find_in_set(1, name)\n? 代表参数绑定，可以直接写明条件，第二个参数不传递即可，但需要注意防范注入风险\n$data = Model::create()-&gt;where(\"find_in_set(?, name)\", [1])-&gt;get();\n复杂where or\n// 生成大概语句：where status = 1 AND (id &gt; 10 or id &lt; 2)\nModel::create()-&gt;where('status', 1)-&gt;where(' (id &gt; 10 or id &lt;2) ')-&gt;get();\nlock table\nModel::create()-&gt;func(function ($builder){\n  // ...\n  $builder-&gt;lockTable(\"tableName\");\n  // ...\n});\n释放表锁\nModel::create()-&gt;func(function ($builder){\n  // ...\n  $builder-&gt;unlockTable();\n  // ...\n});\nselect for update\nModel::create()-&gt;get(function ($builder){\n  // ...\n  $builder-&gt;selectForUpdate();\n  // ...\n});","link":"/Components/Orm/specialQuery.html"},{"id":189,"title":"新增","content":"新增\n要往数据库新增一条记录，先创建新模型实例，给实例设置属性，然后调用 save 方法：\n$model = new UserModel();\n// 不同设置值的方式\n$model-&gt;setAttr('id', 7);\n$model-&gt;name = 'name';\n$model['name'] = 'name';\n\n$res = $model-&gt;save();\nvar_dump($res); // 返回自增id 或者主键的值  失败则返回null\n在这个示例中，我们将 id 和 name 赋值给了 UserModel 模型实例的 id 和 name 属性。当调用 save 方法时，将会插入一条新记录\n数组赋值\n可以传入数组[字段名=&gt;字段值] 再调用 save 方法保存\n$model = UserModel::create([\n    'name' =&gt; 'siam',\n    'age'  =&gt; 21,\n]);\n\n$res = $model-&gt;save();\n// data($data, $setter = true)  \n// 第二个参数 可以决定是否要调用修改器（如果要设置的话   下面的文档有说明）\n$user = UserModel::create()-&gt;data([\n    'name' =&gt; 'siam',\n    'age'  =&gt; 21,\n], false)-&gt;save();\n批量插入\nsaveAll可以传递二维数组，批量插入数据，但由于ORM的工作职责，他需要将数据映射为对象，所以在内部处理中还是通过遍历处理，而非一条sql插入\n（如果有此需求的用户请自行自定义执行sql语句）（mysqli组件中提供了 insertMulti `方法，ORM可以使用func方式调用）\nfunction saveAll($data, $replace = true, $transaction = true)\n参数说明\n\n数据，二维数组\n是否覆盖，意思为：如果在数组中包含了pk主键的值，那么则操作为更新 if ( $replace &amp;&amp; isset($row[$pk]) )\n\n是否开启事务，默认为true，如果是已经手动开启过事务，并在中间调用saveAll，则需要关闭这里的事务，否则因为内部代码的开启事务，导致你的程序执行逻辑异常。\n","link":"/Components/Orm/add.html"},{"id":190,"title":"删除","content":"删除\n删除记录使用 destroy 方法, 方法可以传入多种表达类型参数. 执行后返回影响的记录数\n通过 已有Model\n这种方式是我们最推荐的，也是ORM这种组件的核心思想，把数据的操作映射为对对象的操作。\n$user = UserModel::create()-&gt;get(1);\n$user-&gt;destroy();\n通过 主键\n$res = UserModel::create()-&gt;destroy(1); //通过直接指定主键(如果存在)\n$res = UserModel::create()-&gt;destroy('2,4,5');//指定多个参数每个参数为不同主键\n$res = UserModel::create()-&gt;destroy([3, 7]);//数组指定多个主键\n通过 where 条件\n$res = UserModel::create()-&gt;destroy(['age' =&gt; 21]);//数组指定 where 条件结果来删除\n$res = UserModel::create()-&gt;destroy(function (QueryBuilder $builder) {\n    $builder-&gt;where('id', 1);\n});\n删除全表数据\n如果你需要清空表，你可以使用 destroy 方法传入 (null,true)，它将删除所有行\n$res = UserModel::create()-&gt;destroy(null,true);","link":"/Components/Orm/delete.html"},{"id":191,"title":"更新","content":"更新\n\nOrm的功能是依赖于mysqli 2.x组件的，update的$data参数将会传递给mysqli构造sql。\n所以我们可以直接使用大部分mysqli的功能\n\n通过 已有Model\n这种方式是我们最推荐的，也是ORM这种组件的核心思想，把数据的操作映射为对对象的操作。\n$user = UserModel::create()-&gt;get(1);\n$user-&gt;update([\n  'is_vip' =&gt; 1\n]);\n\n$user = UserModel::create()-&gt;get(1);\n//获取后指定字段赋值\n$user-&gt;is_vip = 1;\n$user-&gt;update();\n通过 where 更新\nupdate 参数1传入更新数组[字段名=&gt;字段值],参数2传递 where 条件数组\n$res = UserModel::create()-&gt;update([\n    'name' =&gt; 'new'\n], ['id' =&gt; 1]);\n实际更新影响的行数\nupdate返回的是执行语句是否成功,只有mysql语句出错时才会返回false,否则都为true\n,所以需要getAffectedRows来判断是否更新成功\n$user = UserModel::create()-&gt;get(1);\n$user-&gt;update([\n  'is_vip' =&gt; 1\n]);\nvar_dump($user-&gt;lastQueryResult()-&gt;getAffectedRows());\n获取具体语法错误\nupdate如果返回了false,那么代表你的语句有错误,可通过getLastError获取具体错误信息\n$user = UserModel::create()-&gt;get(1);\n$suc = $user-&gt;update([\n  'is_vip' =&gt; 1\n]);\nif($suc=== false){\n    var_dump($user-&gt;lastQueryResult()-&gt;getLastError());\n}\n生效字段说明\n模型内数据分为正常数据、附属数据两种。\n如果是表结构拥有字段的数据，则属于正常数据，其他则属于附属数据。\n推荐更新用法\n先通过model映射出正确的数据对象，然后再改变值，更新。\n将会自动生效表结构内的字段。其他附属数据不会组成update sql。\n$user = UserModel::create()-&gt;get(1);\n$user-&gt;is_vip = 1;\n$user['vip_time'] = 15;\n$res = $user-&gt;update();\n批量更新\n通过这种方式，不会过滤非表结构字段的数据，全部组成sql，可能造成mysql错误。\n$res = UserModel::create()-&gt;update([\n  'is_vip' =&gt; 0,\n  'test' =&gt; 3333,// 表结构不存在的字段\n], [\n  'vip_time' =&gt; 0\n]);\n快捷更新\nTestUserModel::create()-&gt;update([\n    'age' =&gt; QueryBuilder::inc(3), // 自增3\n    'test' =&gt; QueryBuilder::dec(4), // 自降4\n], [\n    'name' =&gt; 'Siam222'\n]);","link":"/Components/Orm/update.html"},{"id":192,"title":"连贯操作","content":"连贯操作\nORM提供的链式操作方法，可以有效的提高数据存取的代码清晰度和开发效率。\nwhere\n你可以使用 where 方法。调用 where 最基本的方式是需要传递一个参数\n这个参数可以传递多种不同表现:\n主键\n// 主键\n$user = UserListModel::create()-&gt;where(1)-&gt;get();\n\n// 多个主键\n$user = UserListModel::create()-&gt;where([1,2,3])-&gt;all();\n数组\n// [字段名=&gt; 字段值]数组方式\n$user = UserListModel::create()-&gt;where(['state' =&gt; 1])-&gt;get();\n\n// 复杂条件数组\n$user = UserListModel::create()-&gt;where([\n    'age'  =&gt; [[18,23], 'between'],\n    'name' =&gt; ['siam', 'like', 'or'],\n])\n原生sql\n$user = UserListModel::create()-&gt;where(\"sql 语句 需要自己注意注入风险\")-&gt;get();\n其他Mysqli链式操作里的where传参\nORM where 操作也可以实现 EasySwoole\\Mysqli\\QueryBuilder 中的 where 操作\n更多操作还可以查阅Mysqli链式操作里的where章节\n// 走builder原生的where\n$getCoherent5 = UserListModel::create()-&gt;where('id', 1, '=')-&gt;get();\n$getCoherent6 = UserListModel::create()-&gt;where('id', 1, '!=')-&gt;get();\n$getCoherent6 = UserListModel::create()-&gt;where('id', 1, 'like')-&gt;get();\nalias\nalias用于设置当前数据表的别名\n$res = TestUserListModel::create()-&gt;alias('siam')-&gt;where(['siam.name' =&gt; 'test'])-&gt;all();\ngroup\ngroup 方法可以将结果分组。\n$group = TestUserListModel::create()-&gt;field('sum(age) as age, `name`')-&gt;group('name')-&gt;all(null);\norder\norder 方法可用于将原生字符串设置为 order by 子句的值：\n$order = TestUserListModel::create()-&gt;order('id', 'DESC')-&gt;get();\njoin\njoin通常有下面几种类型，不同类型的join操作会影响返回的数据结果。\n\nINNER JOIN: 等同于 JOIN（默认的JOIN类型）,如果表中有至少一个匹配，则返回行\nLEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行\nRIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行\nFULL JOIN: 只要其中一个表中存在匹配，就返回行\n\nobject join ( mixed $joinTable , string $joinCondition = null [, string $type = 'INNER'] )\n$joinTable 要关联的（完整）表名以及别名\n$joinCondition 关联条件.\n$type 关联类型。可以为:'LEFT', 'RIGHT', 'OUTER', 'INNER', 'LEFT OUTER', 'RIGHT OUTER', 'NATURAL'，不区分大小写，默认为INNER(数据库软件 默认)。\n$join = TestUserListModel::create()-&gt;join('table2','table2.col1 = user_list.col2')-&gt;get();\n\n$join2 = TestUserListModel::create()-&gt;alias('list')-&gt;join('table2 as t2','t2.col1 = list.col2')-&gt;get();","link":"/Components/Orm/coherentOperation.html"},{"id":193,"title":"聚合","content":"聚合\nORM 还提供了各种聚合方法，比如 count, max，min， avg，还有 sum。你可以在构造查询后调用任何方法：\nmax\n$max = TestUserListModel::create()-&gt;max('age');\nmin\n$min = TestUserListModel::create()-&gt;min('age');\ncount\n// count 不必传字段名\n$count = TestUserListModel::create()-&gt;count();\navg\n$avg = TestUserListModel::create()-&gt;avg('age');\nsum\n$sum = TestUserListModel::create()-&gt;sum('age');","link":"/Components/Orm/aggregation.html"},{"id":194,"title":"获取器","content":"获取器\n获取器的作用是在获取数据的字段值后自动进行处理\n若要定义一个获取器，则须在你的模型上创建一个 「get 字段名 Attr」 方法。\n要访问的字段的获取器方法需使用「小驼峰」来命名。在这个例子中，我们将为 status 属性定义一个访问器。\n数据表的字段会在使用获取器时自动转换为驼峰法访问\n当 ORM实例 尝试获取 status 的值时，将会自动调用此访问器：\nclass UserModel extends AbstractModel\n{ \n    /**\n     * $value mixed 是原值\n     * $data  array 是当前model所有的值 \n     */\n    protected function getStatusAttr($value, $data)\n    {\n        $status = [-1=&gt;'删除',0=&gt;'禁用',1=&gt;'正常',2=&gt;'待审核'];\n        return $status[$value];\n    }\n}\n获取器还可以定义数据表中不存在的字段，例如：\nprotected function getEasyswooleAttr($value,$data)\n{\n  return 'Easyswoole用户-'.$data['id'];\n}\n那么在外部我们就可以使用这个easyswoole字段了\n$res = UserModel::create()-&gt;get(4);\nvar_dump($res-&gt;easyswoole);","link":"/Components/Orm/getter.html"},{"id":195,"title":"修改器","content":"修改器\n修改器的作用是在模型实例修改字段赋值时自动进行处理\n若要定义一个修改器，则须在你的模型上创建一个 「set 字段名 Attr」 方法。\n要定义的修改器方法需使用「小驼峰」来命名。在这个例子中，我们将为 name 属性定义一个修改器。\n数据表的字段会在使用获取器时自动转换为驼峰法访问\n当 模型实例 尝试修改 name字段的值时，将会自动调用此修改器：\nclass UserModel extends AbstractModel\n{\n    /**\n     * $value mixed 是原值\n     * $data  array 是当前model所有的值 \n     */\n    protected function setNameAttr($value, $data)\n    {\n        return $value.\"_加一个统一后缀\";\n    }\n}\n如下代码在设置保存的时候将会被修改器处理后保存\n$model = new UserModel([\n    'name' =&gt; 'siam',\n    'age'  =&gt; 21,\n]);\n$model-&gt;save();\n//name 存入后值为: siam_加一个统一后缀","link":"/Components/Orm/modifier.html"},{"id":196,"title":"示例","content":"ORM关联查询示例\n简单介绍一下关联查询的使用场景和方法\n表结构和数据准备\nusers 用户表\n| user_id | user_name  |\n| ------- | ---------- |\n| 1       | Siam(宣言) |\nphones 手机信息表\n| phone_id | can_use | user_id | phone_name |\n| -------- | ------- | ------- | ---------- |\n| 1        | 1       | 1       | 诺基亚A1   |\n| 2        | 0       | 1       | 苹果11     |\n| 3        | 1       | 2       | 三星ZD     |\n定义模型的步骤就不说了，这是ORM的基础使用。\n应用场景\n我们现在需要提供一个接口，根据user_id来查询用户的信息，以及这个用户名下的所有手机信息\n正常我们需要new两个模型、手动传参来获取手机信息，但是使用关联查询，可以简化这个过程\n定义关联关系\n首先我们需要在模型文件中定义两者的关系（用于查询时自动构建条件语句）\n\nclass Users extends AbstractModel\n{\n    protected $tableName = 'users';\n\n    public function phones(){\n        // users的phones方法，指向Phones模型，也就是phones表\n        // 第二个参数用于更灵活的筛选目标数据，不修改则传递null\n        // 第三个参数代表：根据Users模型的user_id字段的值去获取目标数据\n        // 第四个参数代表：Phones表上当做条件语句的字段名\n        // 构建的语句大概为  select * from phones where user_id(第四个参数) = $Users.user_id (第三个参数)\n        return $this-&gt;hasMany(Phones::class, function ($builder){\n        }, 'user_id', 'user_id');\n    }\n}\n使用，返回的数据就是拥有手机信息列表的\n$user   = Users::create()-&gt;get(1);\n$phones = $user-&gt;phones(); // 这一步可以用预查询完成 简化语句\n\n$this-&gt;response()-&gt;write(json_encode($user));\n更灵活的筛选数据方式\n第二个参数是一个闭包，可以很灵活地调用mysqli中的QueryBuilder方法\n//状态正常的手机信息\npublic function phones(){\n    return $this-&gt;hasMany(Phones::class, function ($builder){\n        $builder-&gt;where('can_use', 1);\n    }, 'user_id', 'user_id'); // 这里填写主表字段的值储存在附表的哪个字段上\n}\n// 排序\npublic function phones_desc(){\n    return $this-&gt;hasMany(Phones::class, function ($builder){\n        $builder-&gt;orderBy('phone_id', \"DESC\");\n    }, 'user_id', 'user_id'); // 这里填写主表字段的值储存在附表的哪个字段上\n}\n// 返回部分数据\npublic function phones_limit(){\n    return $this-&gt;hasMany(Phones::class, function ($builder){\n        $builder-&gt;limit(1);\n    }, 'user_id', 'user_id'); // 这里填写主表字段的值储存在附表的哪个字段上\n}\n\n// where筛选\npublic function iphone(){\n    return $this-&gt;hasOne(Phones::class, function($builder){\n        $builder-&gt;where('phone_name', \"苹果11\");\n    }, 'user_id', 'user_id');\n}\n\n// 返回指定字段\npublic function iphone_field(){\n    return $this-&gt;hasOne(Phones::class, function($builder){\n        $builder-&gt;where('phone_name', \"苹果11\");\n        $builder-&gt;fields(\"phone_name, user_id\");\n    }, 'user_id', 'user_id');\n}","link":"/Components/Orm/Associat/example.html"},{"id":197,"title":"一对一关联","content":"一对一关联\n定义\n例如，一个 User 模型可能关联一个 Relation 模型。\n为了定义这个关联，我们要在 User 模型中写一个 relation 方法。在 relation 方法内部调用 hasOne 方法并返回其结果:\nhasOne 方法的第一个参数是关联模型的类名。\npublic function relation()\n{\n    return $this-&gt;hasOne(Relation::class);\n}\n模型关联方法允许你向关联加入自定义限制\n以下案例表示：Relation表中的u_id等于当前模型(假设为User)的id值\nuse EasySwoole\\Mysqli\\QueryBuilder;\n\npublic function settingWhere()\n{\n    return $this-&gt;hasOne(Relation::class, function(QueryBuilder $query){\n        $query-&gt;where('u_id', $this-&gt;id);\n        $query-&gt;where('status', 1);\n        return $query;\n    });\n}\nORM 会自动基于关联模型的主键列进行关联。\n在这种情况下，会自动使用 Relation id 主键。如果你想覆盖这个约定，可以传递第三个参数和第四个参数给 hasOne 方法：\n第三个参数为当前模型的 column, 第四个参数为关联模型的对应 column\npublic function settingWhere()\n{\n    return $this-&gt;hasOne(Relation::class, null, 'id', 'user_id');\n}\n使用\n一旦定义了模型关联，我们就可以使用 ORM 动态属性获得相关的记录。动态属性允许你访问关系方法就像访问模型中定义的属性一样：\n如果查询不到则为null  查询得到则为一个模型类的实例 可以继续调用ORM的方式 快速更新 删除等\n$res = User::create()-&gt;get(1);\n$hasOneRelation = $res-&gt;relation; //访问实际是 relation 方法处理后的结果; 返回的是Relation模型对象\n\n$userid = $hasOneRelation-&gt;user_id;","link":"/Components/Orm/Associat/oneToOneAssociations.html"},{"id":198,"title":"一对多关联","content":"一对多关联\n定义\n例如，一个 User 模型可能关联多个 Relation 模型。\n为了定义这个关联，我们要在 User 模型中写一个 relation 方法。在 relation 方法内部调用 hasMany 方法并返回其结果:\nhasMany 方法的第一个参数是关联模型的类名。\npublic function relation()\n{\n    return $this-&gt;hasMany(Relation::class);\n}\n模型关联方法允许你向关联加入自定义限制\nuse EasySwoole\\Mysqli\\QueryBuilder;\n\npublic function settingWhere()\n{\n    return $this-&gt;hasMany(Relation::class, function(QueryBuilder $query){\n        $query-&gt;where('u_id', $this-&gt;id);\n        $query-&gt;where('status', 1);\n        return $query;\n    });\n}\nORM 会自动基于关联模型的主键列进行关联。\n在这种情况下，会自动使用 Relation id 主键。如果你想覆盖这个约定，可以传递第三个参数和第四个参数给 hasMany 方法：\n第三个参数为当前模型的 column, 第四个参数为关联模型的对应 column\npublic function settingWhere()\n{\n    return $this-&gt;hasMany(Relation::class, null, 'id', 'user_id');\n}\n使用\n一旦定义了模型关联，我们就可以使用 ORM 动态属性获得相关的记录。动态属性允许你访问关系方法就像访问模型中定义的属性一样：\n如果查询不到则为null  查询得到则为一个数组, 每个数组元素都是模型类的实例 可以继续调用ORM的方式 快速更新 删除等\n$userModel = User::create()-&gt;get(1);\n$hasManyRelation = $userModel-&gt;relation; //访问实际是 relation 方法处理后的结果; 返回的是数组 每个数组元素都是 Relation 模型对象\n\n$userId = [];\nforeach($res-&gt;relation as $relationModel) {\n    $userId[] = $relationModel-&gt;user_id;\n}","link":"/Components/Orm/Associat/oneToManyAssociations.html"},{"id":199,"title":"关联预查询","content":"关联预查询\n在普通关联中，我们在Model类文件中定义了关系后，即可快速关联查询数据。\n但在此时仍然需要我们手动获取该关联名才会执行。\n预查询提供了一种主数据查询后，马上自动查询关联数据的用法。\norm版本需要&gt;= 1.2.0\nwith方法\nwith方法传入一个数组，内容为已经在类文件中定义好的关联名\n$res = Model::create()-&gt;with(['user_list', 'user_store'])-&gt;get(1);\n\nvar_dump($res); // 此时已经有user_list,user_sotre两个关联字段的数据，不再需要先手动调用一次。\n支持传参数操作：\norm &gt;= 1.4.25\n\n$res = Model::create()-&gt;with(['user_list' =&gt; ['a' =&gt; 1, 'b' =&gt; 2]])-&gt;get(1);\n$res = Model::create()-&gt;with(['user_list' =&gt; 'test'])-&gt;get(1);\n\n// 伪代码\nfunction user_list($data){\n    var_dump($data); // a =&gt; 1 b=&gt; 2 or test\n}","link":"/Components/Orm/Associat/preWithQuery.html"},{"id":200,"title":"回调事件","content":"回调事件\n针对全局 onQuery\n针对全局设置回调事件方式如下:\n// 注册ORM时, 调用回调函数\npublic static function mainServerCreate(EventRegister $register)\n{\n    ...\n\n    DbManager::getInstance()-&gt;addConnection(new Connection($config));\n    DbManager::getInstance()-&gt;onQuery(function ($res, $builder, $start) {\n        // 打印参数 OR 写入日志\n    });\n}\nonQuery回调会注入三个参数\n\n\nres查询结果对象, 类名为EasySwoole\\ORM\\Db\\Result\n\n\n可以参考 执行结果 文档, 以获取更多的结果内容\n\n\nbuilder查询语句对象, 类名为EasySwoole\\Mysqli\\QueryBuilder\n\n\nstart开始查询时间戳, 单位为s, 类型为float\n\n\n如果查询过程中调用withTotalCount()方法, 那么还会产生第二个回调结果\n需要注意的是, 此回调方法务必在注册ORM时调用, 否则不会产生任何结果\n针对特定模型 onQuery\n如果不想使用全局性的onQuery, 我们可以在执行操作的时候调用onQuery方法, 以此来实现针对特定模型的回调\n$res = User::create()-&gt;onQuery(function ($res, $builder, $start) {\n    // 打印参数 OR 写入日志\n})-&gt;get(1);\n回调注入的三个参数与全局性onQuery相同\n记录慢日志\n我们可以通过手动判断执行时间, 来实现一个记录慢日志的功能\npublic static function mainServerCreate(EventRegister $register)\n{\n    ...\n\n    DbManager::getInstance()-&gt;addConnection(new Connection($config));\n    DbManager::getInstance()-&gt;onQuery(function ($res, $builder, $start) {\n        $queryTime = 查询时间阈值;\n        if (bcsub(time(), $start, 3) &gt; $queryTime) {\n            // 写入日志\n        }\n    });\n}","link":"/Components/Orm/Event/onQuery.html"},{"id":201,"title":"模型事件","content":"模型事件\n模型事件是指模型在执行写入, 修改, 删除操作的时候触发的行为事件\n方法列表\n\n\n\n事件名称\n事件说明\n参数\n\n\n\n\nonBeforeInsert\n插入前事件\n$model\n\n\nonAfterInsert\n插入后事件\n$model, $res\n\n\nonBeforeUpdate\n更新前事件\n$model\n\n\nonAfterUpdate\n更新后事件\n$model, $res\n\n\nonBeforeDelete\n删除前事件\n$model\n\n\nonAfterDelete\n删除后事件\n$model, $res\n\n\n\n\n$model 当前模型实例\n$res 当前行为执行结果, 当执行失败时类型统一为bool型false, 当执行成功时有两种情况:\n执行onAfterDelete事件: int型 影响记录数, 其他事件: bool型 true\n\n如果ORM版本低于1.1.19将无法使用模型事件\nclass User extends AbstractModel\n{\n    /**\n     * @var string\n     */\n    protected $tableName = 'users';\n\n    public static $insert = false;\n    public static $update = false;\n    public static $delete = false;\n\n    protected static function onBeforeInsert($model)\n    {\n        return self::$insert;\n    }\n\n    protected static function onAfterInsert($model, $res)\n    {\n\n    }\n\n    protected static function onBeforeUpdate($model)\n    {\n        return self::$update;\n    }\n\n    protected static function onAfterUpdate($model, $res)\n    {\n\n    }\n\n    protected static function onBeforeDelete($model)\n    {\n        return self::$delete;\n    }\n\n    public static function onAfterDelete($model, $res)\n    {\n\n    }\n}","link":"/Components/Orm/Event/model.html"},{"id":202,"title":"常见问题","content":"ORM 使用中常见问题\n在 MySQL 中调用存储过程时报错\n\n报错原因：在使用 ORM 连接接池或者 MySQLi 连接池时, 在 invoke 里用 queryBuilder()-&gt;raw() 方式执行 call 存储过程，并发时会报错\n解决方法示例代码如下：\n\n请把 MySQL 连接配置中配置修改成 fetch_mode=true，控制器代码需编写如下调用存储过程:\n$db-&gt;rawQuery(\"call add_account_proc_v1('002c3d76f952f5bf1271be1bf33771d8', '102', 'huawei', 'tmp', '002c3d76f952f5bf1271be1bf33771d8', 1, '2020-08-14 17:29:36')\");\nvar_dump($db-&gt;mysqlClient()-&gt;fetchAll());\n$db-&gt;mysqlClient()-&gt;nextResult();","link":"/Components/Orm/problem.html"},{"id":203,"title":"tcp服务","content":"TCP\nEasySwoole创建TCP服务器，有两种以下方式：\n主服务\n修改配置文件MAIN_SERVER.SERVER_TYPE为EASYSWOOLE_SERVER。\nEasySwooleEvent中mainServerCreate事件进行回调注册：\npublic static function mainServerCreate(\\EasySwoole\\EasySwoole\\Swoole\\EventRegister $register)\n{\n    $register-&gt;add($register::onConnect, function (\\Swoole\\Server $server, int $fd, int $reactor_id) {\n        echo \"fd {$fd} connected\";\n    });\n\n    $register-&gt;add($register::onReceive, function (\\Swoole\\Server  $server, int $fd, int $reactor_id, string $data) {\n        echo \"fd:{$fd} send:{$data}\\n\";\n    });\n\n    $register-&gt;add($register::onClose, function (\\Swoole\\Server  $server, int $fd, int $reactor_id) {\n            echo \"fd {$fd} closed\";\n    });\n}\n子服务\n顾名思义：另开一个端口进行tcp监听。\nEasySwooleEvent中mainServerCreate事件，进行子服务监听：\npublic static function mainServerCreate(\\EasySwoole\\EasySwoole\\Swoole\\EventRegister $register)\n{\n    $server = \\EasySwoole\\EasySwoole\\ServerManager::getInstance()-&gt;getSwooleServer();\n\n    $subPort = $server-&gt;addlistener('0.0.0.0', 9502, SWOOLE_TCP);\n    $subPort-&gt;set([\n        // swoole 相关配置\n        'open_length_check' =&gt; false,\n    ]);\n    $subPort-&gt;on($register::onConnect, function (\\Swoole\\Server $server, int $fd, int $reactor_id) {\n            echo \"fd {$fd} connected\";\n    });\n\n    $subPort-&gt;on($register::onReceive, function (\\Swoole\\Server  $server, int $fd, int $reactor_id, string $data) {\n        echo \"fd:{$fd} send:{$data}\\n\";\n    });\n\n    $subPort-&gt;on($register::onClose, function (\\Swoole\\Server  $server, int $fd, int $reactor_id) {\n            echo \"fd {$fd} closed\";\n    });\n}","link":"/Socket/tcp.html"},{"id":204,"title":"tcp服务器处理粘包","content":"TCP 服务器处理粘包\n粘包问题\n由于tcp的特性,可能会出现数据粘包情况,例如   \n\nA连接Server\nA发送 hello \nA又发送了一条 hello\nServer可能会一次性收到一条&quot;hellohello&quot;的数据\nServer也可能收到&quot;he&quot; ,&quot;llohello&quot;类似这样的中断数据\n\n粘包解决\n\n通过标识EOF,例如http协议,通过\\r\\n\\r\\n 的方式去表示该数据已经完结,我们可以自定义一个协议,例如当接收到 &quot;结尾666&quot; 字符串时,代表该字符串已经结束,如果没有获取到,则存入缓冲区,等待结尾字符串,或者如果获取到多条,则通过该字符串剪切出其他数据\n定义消息头,通过特定长度的消息头进行获取,例如我们定义一个协议,前面10位字符串都代表着之后数据主体的长度,那么我们传输数据时,只需要000000000512346(前10位为协议头,表示了这条数据的大小,后面的为数据),每次我们读取只先读取10位,获取到消息长度,再读取消息长度那么多的数据,这样就可以保证数据的完整性了.(但是为了不被混淆,协议头也得像EOF一样标识)\n通过pack二进制处理,相当于于方法2,将数据通过二进制封装拼接进消息中,通过验证二进制数据去读取信息,sw采用的就是这种方式\n\n可查看swoole官方文档:https://wiki.swoole.com/wiki/page/287.html\n实现粘包处理\n服务端:\n&lt;?php\n$subPort2 = $server-&gt;addlistener('0.0.0.0', 9503, SWOOLE_TCP);\n$subPort2-&gt;set(\n    [\n        'open_length_check'     =&gt; true,\n        'package_max_length'    =&gt; 81920,\n        'package_length_type'   =&gt; 'N',\n        'package_length_offset' =&gt; 0,\n        'package_body_offset'   =&gt; 4,\n    ]\n);\n$subPort2-&gt;on('connect', function (\\swoole_server $server, int $fd, int $reactor_id) {\n    echo \"tcp服务2  fd:{$fd} 已连接\\n\";\n    $str = '恭喜你连接成功服务器2';\n    $server-&gt;send($fd, pack('N', strlen($str)) . $str);\n});\n$subPort2-&gt;on('close', function (\\swoole_server $server, int $fd, int $reactor_id) {\n    echo \"tcp服务2  fd:{$fd} 已关闭\\n\";\n});\n$subPort2-&gt;on('receive', function (\\swoole_server $server, int $fd, int $reactor_id, string $data) {\n    echo \"tcp服务2  fd:{$fd} 发送原始消息:{$data}\\n\";\n    echo \"tcp服务2  fd:{$fd} 发送消息:\" . substr($data, '4') . \"\\n\";\n});\n客户端:\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: Tioncico\n * Date: 2019/3/6 0006\n * Time: 16:22\n */\ninclude \"../vendor/autoload.php\";\ndefine('EASYSWOOLE_ROOT', realpath(dirname(getcwd())));\n\\EasySwoole\\EasySwoole\\Core::getInstance()-&gt;initialize();\n//::: warning \n//在3.3.7版本后,initialize事件调用改为:`EasySwoole\\EasySwoole\\Core::getInstance()-&gt;initialize()-&gt;globalInitialize();`\n//:::\n/**\n * tcp 客户端2,验证数据包,并处理粘包\n */\ngo(function () {\n    $client = new \\Swoole\\Client(SWOOLE_SOCK_TCP);\n    $client-&gt;set(\n        [\n            'open_length_check'     =&gt; true,\n            'package_max_length'    =&gt; 81920,\n            'package_length_type'   =&gt; 'N',\n            'package_length_offset' =&gt; 0,\n            'package_body_offset'   =&gt; 4,\n        ]\n    );\n    if (!$client-&gt;connect('127.0.0.1', 9503, 0.5)) {\n        exit(\"connect failed. Error: {$client-&gt;errCode}\\n\");\n    }\n    $str = 'hello world';\n    $client-&gt;send(encode($str));\n    $data = $client-&gt;recv();//服务器已经做了pack处理\n    var_dump($data);//未处理数据,前面有4 (因为pack 类型为N)个字节的pack\n    $data = decode($data);//需要自己剪切解析数据\n    var_dump($data);\n//    $client-&gt;close();\n});\n\n/**\n * 数据包 pack处理\n * encode\n * @param $str\n * @return string\n * @author Tioncico\n * Time: 9:50\n */\nfunction encode($str)\n{\n    return pack('N', strlen($str)) . $str;\n}\n\nfunction decode($str)\n{\n    $data = substr($str, '4');\n    return $data;\n}","link":"/Socket/tcpSticky.html"},{"id":205,"title":"websocket服务","content":"WebSocket\nWebSocket是一种在单个TCP连接上进行全双工通信的协议。WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。\n修改配置文件MAIN_SERVER.SERVER_TYPE为EASYSWOOLE_WEB_SOCKET_SERVER。\nEasySwooleEvent中mainServerCreate事件进行回调注册：\npublic static function mainServerCreate(\\EasySwoole\\EasySwoole\\Swoole\\EventRegister $register)\n{\n    $register-&gt;set($register::onOpen, function ($ws, $request) {\n        var_dump($request-&gt;fd, $request-&gt;server);\n        $ws-&gt;push($request-&gt;fd, \"hello, welcome\\n\");\n    });\n\n    $register-&gt;set($register::onMessage, function (\\Swoole\\WebSocket\\Server $server, \\Swoole\\WebSocket\\Frame $frame) {\n        echo \"Message: {$frame-&gt;data}\\n\";\n        $server-&gt;push($frame-&gt;fd, \"server: {$frame-&gt;data}\");\n    });\n\n    $register-&gt;set($register::onClose, function ($ws, $fd) {\n        echo \"client-{$fd} is closed\\n\";\n    });\n}","link":"/Socket/webSocket.html"},{"id":206,"title":"udp服务","content":"UDP\nUDP为应用程序提供了一种无需建立连接就可以发送封装的IP数据包的方法。\nEasySwooleEvent中mainServerCreate事件，进行子服务监听：\npublic static function mainServerCreate(\\EasySwoole\\EasySwoole\\Swoole\\EventRegister $register)\n{\n    $server = \\EasySwoole\\EasySwoole\\ServerManager::getInstance()-&gt;getSwooleServer();\n\n    $subPort = $server-&gt;addlistener('0.0.0.0', 9503, SWOOLE_UDP);\n    $subPort-&gt;on($register::onPacket, function (\\Swoole\\Server $server, string $data, array $clientInfo) {\n           $server-&gt;sendto($clientInfo['address'], $clientInfo['port'], 'Server：' . $data);\n    });\n}","link":"/Socket/udp.html"},{"id":207,"title":"常见问题","content":"如何遍历全部链接\nuse EasySwoole\\EasySwoole\\ServerManager;\n$server = ServerManager::getInstance()-&gt;getSwooleServer();\n$start_fd = 0;\nwhile(true)\n{\n    $conn_list = $server-&gt;getClientList($start_fd, 10);\n    if ($conn_list===false or count($conn_list) === 0)\n    {\n        echo \"finish\\n\";\n        break;\n    }\n    $start_fd = end($conn_list);\n    var_dump($conn_list);\n    foreach($conn_list as $fd)\n    {\n        $server-&gt;send($fd, \"broadcast\");\n    }\n}\nhttps://wiki.swoole.com/wiki/page/p-connection_list.html\n如何获取链接信息\nuse EasySwoole\\EasySwoole\\ServerManager;\n$server = ServerManager::getInstance()-&gt;getSwooleServer();\n$fdinfo = $server-&gt;getClientInfo($fd);\nhttps://wiki.swoole.com/wiki/page/p-connection_info.html\nSocket有哪些开发场景?\nh5即时游戏\n网页聊天室\n物联网开发\n服务器udp广播\n车联网\n智能家居\nweb网页服务器","link":"/Socket/problem.html"},{"id":208,"title":"websocket协议","content":"websocket\nwebsocket是html5中提出的一个协议规范,它允许浏览器与服务器中相互主动通信.  \nhttp\n在讲websocket之前,我们必须先了解http协议\nhttp协议是基于tcp实现的协议,它的请求步骤为: \n\n浏览器与服务器建立tcp协议\n浏览器发送请求\n服务端接收请求,回复消息\n浏览器接收消息\ntcp连接关闭\n\nhttp协议的特点就是即连即关,每次接收到消息就关闭连接,并且需要浏览器主动请求服务器才能获取到消息\nhttp痛点\n在平常需求中,http协议并没有什么问题,用户输入链接,浏览器请求服务器,服务器返回数据,浏览器获得消息,用户查看网页.是一个很正常的步骤.\n但是,http协议限制了,用户获得数据必须主动去请求服务器,才能获取到数据,在聊天室,网页对战游戏中,并不是只有用户与服务器的交互,还存在了用户与用户之间的交互.\n那么,在websocket之前,http是怎么实现用户与用户之间的交互的呢?\n举个例子,在聊天室需求中,A和B互相通信的实现:  \n\nA不断的请求服务器,B有没有给我发送消息(主动请求服务器,询问有没有新消息)\nB不断的请求服务器,A有没有给我发送消息(主动请求服务器,询问有没有新消息)\nA请求服务器,发送数据:&quot;向B发送一条消息XXXX&quot;\nB不断的请求服务器,服务器返回:&quot;A向你发送了一条消息&quot;\n...\n\n在这个例子中,我们发现,A和B如果需要获取到对方是否有没有发送消息,必须不断的请求服务器,主动询问服务器是否有消息.\n那么,不断的间隔是多少呢?1秒10次?10秒一次?1秒10次不断的请求服务器,服务器能承受住吗?10秒一次?那A发送一条消息,B就得10秒后才能收到,消息延时太过于厉害.\n那么,有没有办法,使得服务器主动给浏览器发消息呢?这就是websocket了\nwebsocket\nwebsocket作为全双工通信协议,只要连接成功之后,浏览器和服务器就可以互相主动发送消息,那么,刚刚的聊天室需求就会变成:  \n\nA与服务器建立连接\nB与服务器建立连接\nA请求服务器,发送数据:&quot;向B发送一条消息XXXX&quot;\n服务器接收到消息,主动向B推送:&quot;A向你发送了一条消息&quot;\nB收到服务器推送\n\nwebsocket 的应用场景就是如此,在需要即时返回消息/频繁请求 的需求中,\nwebsocket协议可以长连接保持当前连接,不用像http一样每次请求都得重新发起一次消息.\n双方可以相互主动推送消息,消息可以即时送达,避免了消息延迟  \nwebsocket协议\n前面讲到了websocket的应用场景,那么为什么websocket可以做即时消息呢?那websocket为什么可以做即时消息,http却不能呢?\nwebsocket协议实现步骤为:  \n\n先使用http协议连接服务端(没错,websocket是基于http协议的)\n第一个步骤额外补充,在使用http协议时,附带了(我要升级websocket协议)的数据\n服务端如果支持websocket,将会给客户端返回(升级成功),如果不支持,则会输出正常的http数据\n客户端接收服务端返回的消息,如果支持,则连接保持,不支持则报错并断开\n连接保持,这时候,客户端和服务端即可互相发消息  \n\nwebsocket详细协议了解可查看: http://noobcourse.php20.cn/NoobCourse/NetworkrPotocol/tcp/websocket.html \nwebsocket示例\n前端示例\nwebsocket代码该怎么写呢?以下是前端的简单例子实现:  \n//先new 一个websocket对象,地址是localhost+端口9501 ws是前面的协议声明,类似于http://xx.cn\nvar ws = new WebSocket(\"ws://localhost:9501\");\n//定义 打开事件 的回调,当连接ws成功后,会调用执行这个回调函数\nws.onopen = function() {\n  console.log(\"client：打开连接\");\n  ws.send(\"client：hello，服务端\");\n};\n//定义 服务器发送消息 的回调,当服务器主动发送消息到客户端时,会调用执行这个回调函数\nws.onmessage = function(e) {\n  console.log(\"client：接收到服务端的消息 \" + e.data);\n  setTimeout(() =&gt; {\n    ws.close();\n  }, 5000);\n};\n//定义 关闭连接 的回调,当连接关闭(服务端关闭,客户端关闭,网络断开等原因),会调用执行这个回调函数 \nws.onclose = function(params) {\n  console.log(\"client：关闭连接\");\n};\nphp实现websocket服务端\n本文采用swoole扩展,实现websocket服务端:\n&lt;?php\n$server = new Swoole\\WebSocket\\Server(\"0.0.0.0\", 9501);\n\n$server-&gt;on('open', function (Swoole\\WebSocket\\Server $server, $request) {\n    echo \"握手成功 fd{$request-&gt;fd}\\n\";\n});\n\n$server-&gt;on('message', function (Swoole\\WebSocket\\Server $server, $frame) {\n    echo \"接收客户端消息: {$frame-&gt;fd}:{$frame-&gt;data},opcode:{$frame-&gt;opcode},fin:{$frame-&gt;finish}\\n\";\n    $server-&gt;push($frame-&gt;fd, \"this is server\");\n});\n\n$server-&gt;on('close', function ($ser, $fd) {\n    echo \"客户端 {$fd} 关闭\\n\";\n});\necho  \"websocket服务器启动成功\\n\";\n\n$server-&gt;start();\n测试情况\nphp cli模式执行php代码,启动服务器\n[root@localhost IM]# php websocket.php \nwebsocket服务器启动成功\n在浏览器中运行js代码,将输出:   \nclient：打开连接\nVM93:10 client：接收到服务端的消息 this is server\nVM93:17 client：关闭连接\n服务端将输出:   \n[root@localhost IM]# php websocket.php \nwebsocket服务器启动成功\n握手成功 fd1\n接收客户端消息: 1:client：hello，服务端,opcode:1,fin:1\n客户端 1 关闭","link":"/Socket/websocketProtocol.html"},{"id":209,"title":"安装与使用示例","content":"Socket\n关于 Socket 控制器使用的具体示例，请查看 demo\n安装\n\ncomposer require easyswoole/socket\n\n独立使用\n此组件可脱离主框架使用，方便开发者自行创建服务进行调度，属于socket事件调度器。\nuse EasySwoole\\Socket\\AbstractInterface\\Controller;\nuse EasySwoole\\Socket\\AbstractInterface\\ParserInterface;\nuse EasySwoole\\Socket\\Bean\\Response;\nuse EasySwoole\\Socket\\Bean\\Caller;\n\nclass C extends Controller{\n\n    private $hit = 0;\n    protected $hitTime = 0;\n\n    function __construct()\n    {\n        var_dump('controller create  '.spl_object_hash($this));\n        parent::__construct();\n    }\n\n    protected function onRequest(?string $actionName): bool\n    {\n\n        $this-&gt;hit++;\n        $this-&gt;hitTime = time();\n        return true;\n    }\n\n    function test()\n    {\n        var_dump($this-&gt;hit,$this-&gt;hitTime);\n//        co::sleep(10);\n        $this-&gt;response()-&gt;setMessage('time:'.time());\n    }\n\n    protected function gc()\n    {\n        parent::gc(); // TODO: Change the autogenerated stub\n        var_dump('controller has ben gc');\n    }\n}\n\nclass Parser implements ParserInterface{\n\n    public function decode($raw, $client): ?Caller\n    {\n        // TODO: Implement decode() method.\n        $ret =  new Caller();\n        $ret-&gt;setControllerClass(C::class);\n        $ret-&gt;setAction('test');\n        return $ret;\n    }\n\n    /*\n     * 如果这里返回null，则不给客户端任何数据\n     */\n    public function encode(Response $response, $client): ?string\n    {\n        // TODO: Implement encode() method.\n        return $response-&gt;__toString();\n    }\n\n}\n\n$server = new \\Swoole\\Server(\"127.0.0.1\", 9501);\n$server-&gt;set([\n    'worker_num'=&gt;1\n]);\n\n$conf = new \\EasySwoole\\Socket\\Config();\n$conf-&gt;setType($conf::TCP);\n$conf-&gt;setParser(new Parser());\n$conf-&gt;setMaxPoolNum(2);\n$conf-&gt;setOnExceptionHandler(function (\\swoole_server $server,\\Throwable $throwable,string $raw,$client,Response $response){\n    $response-&gt;setStatus('error');\n    $response-&gt;setStatus($response::STATUS_RESPONSE_AND_CLOSE);\n});\n\n$dispatch = new \\EasySwoole\\Socket\\Dispatcher($conf);\n$server-&gt;on('receive', function ($server, $fd, $reactor_id, $data)use($dispatch) {\n    $dispatch-&gt;dispatch($server,$data,$fd,$reactor_id);\n});\n$server-&gt;on('close', function ($server, $fd) {\n    echo \"connection close: {$fd}\\n\";\n});\n$server-&gt;start();\n框架内使用\nTcp\n控制器\n&lt;?php\n\nnamespace App\\TcpController;\n\nuse EasySwoole\\Socket\\AbstractInterface\\Controller;\n\nclass Index extends Controller\n{\n    public function index()\n    {\n        $this-&gt;response()-&gt;setMessage('this is index');\n    }\n}\n解析器\n&lt;?php\n\nnamespace App\\Parser;\n\nuse EasySwoole\\Socket\\AbstractInterface\\ParserInterface;\nuse EasySwoole\\Socket\\Bean\\Caller;\nuse EasySwoole\\Socket\\Bean\\Response;\n\nclass TcpParser implements ParserInterface\n{\n    public function decode($raw, $client): ?Caller\n    {\n        $data = substr($raw, '4');\n        $data = json_decode($data, true);\n        $caller = new Caller();\n        $controller = !empty($data['controller']) ? $data['controller'] : 'Index';\n        $action = !empty($data['action']) ? $data['action'] : 'index';\n        $param = !empty($data['param']) ? $data['param'] : [];\n        $controller = \"App\\\\TcpController\\\\{$controller}\";\n        $caller-&gt;setControllerClass($controller);\n        $caller-&gt;setAction($action);\n        $caller-&gt;setArgs($param);\n        return $caller;\n    }\n\n    public function encode(Response $response, $client): ?string\n    {\n        return pack('N', strlen($response-&gt;getMessage())) . $response-&gt;getMessage();\n    }\n}\n注册\nmainServerCreate\n$config = new \\EasySwoole\\Socket\\Config();\n$config-&gt;setType($config::TCP);\n$config-&gt;setParser(TcpParser::class);\n$dispatcher = new \\EasySwoole\\Socket\\Dispatcher($config);\n$config-&gt;setOnExceptionHandler(function (\\Swoole\\Server $server, \\Throwable $throwable, string $raw, \\EasySwoole\\Socket\\Client\\Tcp $client, \\EasySwoole\\Socket\\Bean\\Response $response) {\n    $response-&gt;setMessage('system error!');\n    $response-&gt;setStatus($response::STATUS_RESPONSE_AND_CLOSE);\n});\n$register-&gt;set($register::onReceive, function (\\Swoole\\Server $server, int $fd, int $reactorId, string $data) use ($dispatcher) {\n    $dispatcher-&gt;dispatch($server, $data, $fd, $reactorId);\n});\nUdp\n控制器\n&lt;?php\n\nnamespace App\\UdpController;\n\nuse EasySwoole\\Socket\\AbstractInterface\\Controller;\n\nclass Index extends Controller\n{\n    public function index()\n    {\n        $this-&gt;response()-&gt;setMessage('this is index');\n    }\n}\n解析器\n&lt;?php\n\nnamespace App\\Parser;\n\nuse EasySwoole\\Socket\\AbstractInterface\\ParserInterface;\nuse EasySwoole\\Socket\\Bean\\Caller;\nuse EasySwoole\\Socket\\Bean\\Response;\n\nclass UdpParser implements ParserInterface\n{\n    public function decode($raw, $client): ?Caller\n    {\n        $data = json_decode($raw, true);\n        $caller = new Caller();\n        $controller = !empty($data['controller']) ? $data['controller'] : 'Index';\n        $action = !empty($data['action']) ? $data['action'] : 'index';\n        $param = !empty($data['param']) ? $data['param'] : [];\n        $controller = \"App\\\\UdpController\\\\{$controller}\";\n        $caller-&gt;setControllerClass($controller);\n        $caller-&gt;setAction($action);\n        $caller-&gt;setArgs($param);\n        return $caller;\n    }\n\n    public function encode(Response $response, $client): ?string\n    {\n        return json_encode($response-&gt;getMessage());\n    }\n}\n注册\nmainServerCreate\n$config = new \\EasySwoole\\Socket\\Config();\n$config-&gt;setType($config::UDP);\n$config-&gt;setParser(UdpParser::class);\n$dispatcher = new \\EasySwoole\\Socket\\Dispatcher($config);\n$config-&gt;setOnExceptionHandler(function (\\Swoole\\Server $server, \\Throwable $throwable, string $raw, \\EasySwoole\\Socket\\Client\\Udp $client, \\EasySwoole\\Socket\\Bean\\Response $response) {\n    $response-&gt;setMessage('system error!');\n    $response-&gt;setStatus($response::STATUS_RESPONSE_AND_CLOSE);\n});\n$server = \\EasySwoole\\EasySwoole\\ServerManager::getInstance()-&gt;getSwooleServer();\n$udpServer = $server-&gt;addListener('0.0.0.0', '9511', SWOOLE_UDP);\n$udpServer-&gt;on($register::onPacket, function (\\Swoole\\Server $server, string $data, array $clientInfo) use ($dispatcher) {\n    $dispatcher-&gt;dispatch($server, $data, $clientInfo['server_socket'], $clientInfo['address'], $clientInfo['port']);\n});\nWebsocket\n控制器\n&lt;?php\n\nnamespace App\\WebSocketController;\n\nuse EasySwoole\\Socket\\AbstractInterface\\Controller;\n\nclass Index extends Controller\n{\n    public function index()\n    {\n        $this-&gt;response()-&gt;setMessage('this is index');\n    }\n}\n解析器\n&lt;?php\n\nnamespace App\\Parser;\n\nuse EasySwoole\\Socket\\AbstractInterface\\ParserInterface;\nuse EasySwoole\\Socket\\Bean\\Caller;\nuse EasySwoole\\Socket\\Bean\\Response;\n\nclass WebSocketParser implements ParserInterface\n{\n    public function decode($raw, $client): ?Caller\n    {\n        $data = json_decode($raw, true);\n        $caller = new Caller();\n        $controller = !empty($data['controller']) ? $data['controller'] : 'Index';\n        $action = !empty($data['action']) ? $data['action'] : 'index';\n        $param = !empty($data['param']) ? $data['param'] : [];\n        $controller = \"App\\\\WebSocketController\\\\{$controller}\";\n        $caller-&gt;setControllerClass($controller);\n        $caller-&gt;setAction($action);\n        $caller-&gt;setArgs($param);\n        return $caller;\n    }\n\n    public function encode(Response $response, $client): ?string\n    {\n        return json_encode($response-&gt;getMessage());\n    }\n}\n自定义握手\n&lt;?php\n\nnamespace App;\n\nclass WebSocketEvent\n{\n    /**\n     * @param \\Swoole\\Http\\Request $request\n     * @param \\Swoole\\Http\\Response $response\n     * @return bool\n     */\n    public function onHandShake(\\Swoole\\Http\\Request $request, \\Swoole\\Http\\Response $response)\n    {\n        /** 此处自定义握手规则 返回 false 时中止握手 */\n        if (!$this-&gt;customHandShake($request, $response)) {\n            $response-&gt;end();\n            return false;\n        }\n\n        /** 此处是  RFC规范中的WebSocket握手验证过程 必须执行 否则无法正确握手 */\n        if ($this-&gt;secWebsocketAccept($request, $response)) {\n            $response-&gt;end();\n            return true;\n        }\n\n        $response-&gt;end();\n        return false;\n    }\n\n    /**\n     * @param \\Swoole\\Http\\Request $request\n     * @param \\Swoole\\Http\\Response $response\n     * @return bool\n     */\n    protected function customHandShake(\\Swoole\\Http\\Request $request, \\Swoole\\Http\\Response $response): bool\n    {\n        /**\n         * 这里可以通过 http request 获取到相应的数据\n         * 进行自定义验证后即可\n         * (注) 浏览器中 JavaScript 并不支持自定义握手请求头 只能选择别的方式 如get参数\n         */\n        $headers = $request-&gt;header;\n        $cookie = $request-&gt;cookie;\n\n        // if (如果不满足我某些自定义的需求条件，返回false，握手失败) {\n        //    return false;\n        // }\n        return true;\n    }\n\n    /**\n     * RFC规范中的WebSocket握手验证过程\n     * 以下内容必须强制使用\n     *\n     * @param \\Swoole\\Http\\Request $request\n     * @param \\Swoole\\Http\\Response $response\n     * @return bool\n     */\n    protected function secWebsocketAccept(\\Swoole\\Http\\Request $request, \\Swoole\\Http\\Response $response): bool\n    {\n        // ws rfc 规范中约定的验证过程\n        if (!isset($request-&gt;header['sec-websocket-key'])) {\n            // 需要 Sec-WebSocket-Key 如果没有拒绝握手\n            var_dump('shake fai1 3');\n            return false;\n        }\n        if (0 === preg_match('#^[+/0-9A-Za-z]{21}[AQgw]==$#', $request-&gt;header['sec-websocket-key'])\n            || 16 !== strlen(base64_decode($request-&gt;header['sec-websocket-key']))\n        ) {\n            //不接受握手\n            var_dump('shake fai1 4');\n            return false;\n        }\n\n        $key = base64_encode(sha1($request-&gt;header['sec-websocket-key'] . '258EAFA5-E914-47DA-95CA-C5AB0DC85B11', true));\n        $headers = array(\n            'Upgrade' =&gt; 'websocket',\n            'Connection' =&gt; 'Upgrade',\n            'Sec-WebSocket-Accept' =&gt; $key,\n            'Sec-WebSocket-Version' =&gt; '13',\n            'KeepAlive' =&gt; 'off',\n        );\n\n        if (isset($request-&gt;header['sec-websocket-protocol'])) {\n            $headers['Sec-WebSocket-Protocol'] = $request-&gt;header['sec-websocket-protocol'];\n        }\n\n        // 发送验证后的header\n        foreach ($headers as $key =&gt; $val) {\n            $response-&gt;header($key, $val);\n        }\n\n        // 接受握手 还需要101状态码以切换状态\n        $response-&gt;status(101);\n        var_dump('shake success at fd :' . $request-&gt;fd);\n        return true;\n    }\n}\n注册\nmainServerCreate\n&lt;?php\n$config = new \\EasySwoole\\Socket\\Config();\n$config-&gt;setType($config::WEB_SOCKET);\n$config-&gt;setParser(WebSocketParser::class);\n$dispatcher = new \\EasySwoole\\Socket\\Dispatcher($config);\n$config-&gt;setOnExceptionHandler(function (\\Swoole\\Server $server, \\Throwable $throwable, string $raw, \\EasySwoole\\Socket\\Client\\WebSocket $client, \\EasySwoole\\Socket\\Bean\\Response $response) {\n    $response-&gt;setMessage('system error!');\n    $response-&gt;setStatus($response::STATUS_RESPONSE_AND_CLOSE);\n});\n\n// 自定义握手\n/*$websocketEvent = new WebSocketEvent();\n$register-&gt;set(EventRegister::onHandShake, function (\\Swoole\\Http\\Request $request, \\Swoole\\Http\\Response $response) use ($websocketEvent) {\n    $websocketEvent-&gt;onHandShake($request, $response);\n});*/\n\n$register-&gt;set($register::onMessage, function (\\Swoole\\Websocket\\Server $server, \\Swoole\\Websocket\\Frame $frame) use ($dispatcher) {\n    $dispatcher-&gt;dispatch($server, $frame-&gt;data, $frame);\n});","link":"/Socket/install.html"},{"id":210,"title":"控制器对象","content":"Socket-Controller\n创建\n继承EasySwoole\\Socket\\AbstractInterface\\Controller\nclass Test extends \\EasySwoole\\Socket\\AbstractInterface\\Controller\n{\n\n}\n自定义解析器\nclass TestParser implements \\EasySwoole\\Socket\\AbstractInterface\\ParserInterface \n{\n    public function decode($raw,$client) : ?\\EasySwoole\\Socket\\Bean\\Caller\n    {\n\n    }\n\n    public function encode(\\EasySwoole\\Socket\\Bean\\Response $response,$client) : ?string\n    {\n\n    }\n}\n调度器注册\n子服务举例\nEasySwooleEvent中mainServerCreate事件进行回调注册：\npublic static function mainServerCreate(\\EasySwoole\\EasySwoole\\Swoole\\EventRegister $register)\n{\n    $server = \\EasySwoole\\EasySwoole\\ServerManager::getInstance()-&gt;getSwooleServer();\n\n    $subPort = $server-&gt;addlistener('0.0.0.0', 9502, SWOOLE_TCP);\n    $subPort-&gt;set(\n        // swoole 相关配置\n    );\n\n    $socketConfig = new \\EasySwoole\\Socket\\Config();\n    $socketConfig-&gt;setType($socketConfig::TCP);\n    $socketConfig-&gt;setParser(new TestParser());\n    //设置解析异常时的回调,默认将抛出异常到服务器\n    $socketConfig-&gt;setOnExceptionHandler(function ($server, $throwable, $raw, $client, \\EasySwoole\\Socket\\Bean\\Response $response) {\n        $response-&gt;setMessage(\"服务器异常（客户端fd:{$client-&gt;getFd()}）\");\n        $response-&gt;setStatus($response::STATUS_RESPONSE_AND_CLOSE); // 发送完主动关闭该连接\n    });\n    $dispatch = new \\EasySwoole\\Socket\\Dispatcher($socketConfig);\n\n    $subPort-&gt;on($register::onConnect, function (\\Swoole\\Server $server, int $fd, int $reactor_id) {\n            echo \"fd {$fd} connected\";\n    });\n\n    $subPort-&gt;on($register::onReceive, function (\\Swoole\\Server  $server, int $fd, int $reactor_id, string $data) use ($dispatch) {\n        $dispatch-&gt;dispatch($server, $data, $fd, $reactor_id);\n    });\n\n    $subPort-&gt;on($register::onClose, function (\\Swoole\\Server  $server, int $fd, int $reactor_id) {\n            echo \"fd {$fd} closed\";\n    });\n}","link":"/Socket/controller.html"},{"id":211,"title":"响应对象","content":"Socket-Response\n响应状态分析\nEasySwoole\\Socket\\Bean\\Response\n此响应类主要用于此调度结束或者调度出现异常，对连接后续的操作。\n正常响应(保持连接，服务端不主动关闭)(Response默认响应状态)\n\n\\EasySwoole\\Socket\\Bean\\Response::STATUS_OK;\n\n响应后服务端主动关闭连接\n\n\\EasySwoole\\Socket\\Bean\\Response::STATUS_RESPONSE_AND_CLOSE;\n\n服务端直接关闭连接\n\n\\EasySwoole\\Socket\\Bean\\Response::STATUS_CLOSE;\n\n设置响应信息\n响应信息会经过解析器的encode。\nclass Test extends \\EasySwoole\\Socket\\AbstractInterface\\Controller\n{\n    public function testMessage()\n    {   \n        $this-&gt;response()-&gt;setMessage('test message');\n    }\n}\n设置响应状态\n当响应信息为空的时候，并不会发送给客户端信息。\n异常\n自定义了异常处理器，可进行响应状态控制:\nclass TestParser implements \\EasySwoole\\Socket\\AbstractInterface\\ParserInterface \n{\n    public function decode($raw,$client) : ?\\EasySwoole\\Socket\\Bean\\Caller\n    {\n\n    }\n\n    public function encode(\\EasySwoole\\Socket\\Bean\\Response $response,$client) : ?string\n    {\n\n    }\n}\n// 伪代码 需要开发者在mainServerCreate中进行注册，或者脱离主框架使用\n$conf = new \\EasySwoole\\Socket\\Config();\n$conf-&gt;setType($conf::TCP);\n$conf-&gt;setParser(new TestParser());\n$conf-&gt;setMaxPoolNum(2);\n$conf-&gt;setOnExceptionHandler(function (\\swoole_server $server,\\Throwable $throwable,string $raw,$client,\\EasySwoole\\Socket\\Bean\\Response $response){\n    $response-&gt;setMessage('system error');\n    $response-&gt;setStatus($response::STATUS_RESPONSE_AND_CLOSE);\n});\n控制器内方法\nclass Test extends \\EasySwoole\\Socket\\AbstractInterface\\Controller\n{\n    public function testStatus()\n    {   \n        $this-&gt;response()-&gt;setMessage('test status');\n        $this-&gt;response()-&gt;setStatus($this-&gt;response()::STATUS_RESPONSE_OK);\n    }\n}","link":"/Socket/response.html"},{"id":212,"title":"安装","content":"redis协程客户端\n虽然swoole有着自带的协程客户端,但是在生产环境中我们发现了一些问题:\nswoole的redis客户端并没有完全支持redis的全部命令，比如geo搜索，还有事务，特别是集群模式的redis，swoole客户端并不支持。为此，我们决定用swoole的tcp客户端实现一个完整版的redis客户端。\n目前,该redis客户端组件,已经支持除去脚本外的所有方法(目前支持了178个方法):  \n\n连接方法(connection)\n集群方法(cluster)\ngeohash\n哈希(hash)\n键(keys)\n列表(lists)\n订阅/发布(pub/sub)\n服务器(server)\n字符串(string)\n有序集合(sorted sets)\n集合 (sets)\n事务 (transaction)\n管道实现 (pipe)  \n\n\n由于redis的命令较多,可能漏掉1,2个命令\n\n组件要求\n\nphp: &gt;=7.1.0\next-swoole: ^4.4.0\neasyswoole/spl: ^1.2\n\n安装方法\n\ncomposer require easyswoole/redis\n\n仓库地址\neasyswoole/redis\n基本使用\nredis 单机配置\nredis 在实例化时,需要传入\\EasySwoole\\Redis\\Config\\RedisConfig实例:\n\n\n\n配置名\n默认参数\n说明\n备注\n\n\n\n\nhost\n127.0.0.1\nredis ip\n\n\n\nport\n6379\nredis端口\n\n\n\nunixSocket\nnull\nunixSocket文件路径\n此参数配置后,将忽略host,port参数,直接通过UnixSocket连接.(&gt;=1.3.0才可使用)\n\n\nauth\n\nauth密码\n\n\n\ndb\nnull\nredis数据库\n当db配置不等于null时,在connect的时候会自动select该配置\n\n\ntimeout\n3.0\n超时时间\n\n\n\nreconnectTimes\n3\n客户端异常重连次数\n\n\n\nserialize\nSERIALIZE_NONE\n数据是否序列化\n序列化参数有:SERIALIZE_NONE,SERIALIZE_PHP,SERIALIZE_JSON\n\n\n\nredis 单机配置示例\n$config = new \\EasySwoole\\Redis\\Config\\RedisConfig([\n    'host'      =&gt; '127.0.0.1',\n    'port'      =&gt; '6379',\n    'auth'      =&gt; 'easyswoole',\n    'db'        =&gt; null,\n    'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n]);\nredis集群配置\nredis 集群在实例化时，需要传入\\EasySwoole\\Redis\\Config\\RedisConfig实例:\n$config = new \\EasySwoole\\Redis\\Config\\RedisClusterConfig([\n    ['172.16.253.156', 9001],\n    ['172.16.253.156', 9002],\n    ['172.16.253.156', 9003],\n    ['172.16.253.156', 9004],\n], [\n    'auth' =&gt; '',\n    'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_PHP\n]);\n集群配置先传入一个ip,port的多维数组,再传入其他配置项,其他配置项和redis单机配置一致  \n需要注意,auth密码需要集群所有节点相同,只支持一个密码\nredis单机使用示例\n使用redis客户端(需要协程环境)\n&lt;?php\ninclude \"../vendor/autoload.php\";\ngo(function (){\n    $redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host' =&gt; '127.0.0.1',\n        'port' =&gt; '6379',\n        'auth' =&gt; 'easyswoole',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]));\n    var_dump($redis-&gt;set('a',1));\n    var_dump($redis-&gt;get('a'));\n});\nredis集群使用示例\n&lt;?php\ninclude \"../vendor/autoload.php\";\ngo(function () {\n    $redis = new \\EasySwoole\\Redis\\RedisCluster(new \\EasySwoole\\Redis\\Config\\RedisClusterConfig([\n        ['172.16.253.156', 9001],\n        ['172.16.253.156', 9002],\n        ['172.16.253.156', 9003],\n        ['172.16.253.156', 9004],\n    ], [\n        'auth' =&gt; '',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_PHP\n    ]));\n    var_dump($redis-&gt;set('a',1));\n    var_dump($redis-&gt;get('a'));\n    var_dump($redis-&gt;clusterKeySlot('a'));\n\n});\n回调事件\n在redis组件中,自定义了2个回调事件,用于代码跟踪调试,可在config中设置:\n&lt;?php\n$redisConfig = new RedisConfig([\n   'host' =&gt; REDIS_HOST,\n   'port' =&gt; REDIS_PORT,\n   'auth' =&gt; REDIS_AUTH,\n]);\n// 命令执行之前将调用\n$redisConfig-&gt;onBeforeEvent(function ($commandName,$commandData){\n   var_dump ($commandName,$commandData);\n});\n//命令获取到结果后将调用\n$redisConfig-&gt;onAfterEvent(function ($commandName,$commandData,$result){\n   var_dump ($commandName,$commandData,$result);\n});\n回调事件支持事务,pipe.\n在pipe模式中,只有最后excePipe时才会调用回调事件.\n异常处理\nredis组件根据错误的级别,区分了2种错误信息\n异常\n当redis连接失败,无法和redis服务通信时,将会抛出EasySwoole\\Redis\\Exception\\RedisException 异常,例如配置错误:\nPHP Fatal error:  Uncaught EasySwoole\\Redis\\Exception\\RedisException: connect to redis host 127.0.0.1:6379 fail after retry 4 times in /www/easyswoole/tioncico_redis/src/Redis.php:2866\nStack trace:\n#0 /www/easyswoole/tioncico_redis/src/Redis.php(579): EasySwoole\\Redis\\Redis-&gt;sendCommand(Array)\n#1 /www/easyswoole/tioncico_redis/tests/test.php(17): EasySwoole\\Redis\\Redis-&gt;get('a')\n#2 {main}\n  thrown in /www/easyswoole/tioncico_redis/src/Redis.php on line 2866\n\n接管异常\ngo(function () {\n\n    $redisConfig = new \\EasySwoole\\Redis\\Config\\RedisConfig();\n    $redisConfig-&gt;setAuth('easyswoole');\n    $redis = new \\EasySwoole\\Redis\\Redis($redisConfig);\n    try{\n\n        $data = $redis-&gt;rawCommand(['set','a','1','1']);//多了一个参数,redis将会报语法错误\n         var_dump($data);\n\n    }catch (\\EasySwoole\\Redis\\Exception\\RedisException $exception){\n\n        var_dump($exception-&gt;getMessage());\n        var_dump($exception-&gt;getRedisErrorCode());\n        var_dump($exception-&gt;getRedisErrorMsg());\n    }\n});","link":"/Components/Redis/introduction.html"},{"id":213,"title":"集群","content":"redis集群使用\n请查看安装章节的redis集群相关配置使用\n集群兼容方法\n在正常情况下,有些方法是不能直接被集群客户端调用成功的,比如mSet方法,它涉及了多个键名的操作,而多个键名是会分配给其他节点的\n目前redis集群客户端,实现了部分多键名操作方法的兼容,实现原理如下:\n对多键名操作方法,进行拆分成单键名,然后通过键名去获取槽节点,再通过槽节点分配的client去执行,每次只会执行一个键名\n已经实现了兼容的方法:\n\n\n\n方法名称\n参数\n说明\n备注\n\n\n\n\nmSet\n$data\n设置多个键值对\n\n\n\nmGet\n$keys\n获取多个键名的值\n\n\n\nmSetNx\n$data\n设置多个键值对\n该方法将不能准确的判断&quot;当所有key不存在时,设置多个key值&quot;\n\n\n\n集群禁用方法\n由于集群的特性,不同的key分配到了不同的槽位,当你调用sUnion,sUnIonStore等涉及多个key操作的命令时,将会返回false,同时错误信息会在$redis->getErrorMsg()中显示:\n$redis = new \\EasySwoole\\Redis\\RedisCluster(new \\EasySwoole\\Redis\\Config\\RedisClusterConfig([\n    ['172.16.253.156', 9001],\n    ['172.16.253.156', 9002],\n    ['172.16.253.156', 9003],\n    ['172.16.253.156', 9004],\n], [\n    'auth'      =&gt; '',\n    'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_PHP\n]));\n\n$data = $redis-&gt;sUnIonStore('a','v','c');\nvar_dump($data,$redis-&gt;getErrorMsg());\n将输出:\nbool(false)\nstring(53) \"CROSSSLOT Keys in request don't hash to the same slot\"\n集群客户端调度逻辑\n客户端默认调度\n集群客户端在调用redis方法的时候,自动默认一个客户端进行发送接收命令:\nfunction sendCommand(array $com, ?ClusterClient $client = null): bool\n{\n    $client = $client ?? $this-&gt;getDefaultClient();\n    $this-&gt;setDefaultClient($client);\n    return $this-&gt;sendCommandByClient($com, $client);\n}\n\nfunction recv($timeout = null, ?ClusterClient $client = null): ?Response\n{\n    $client = $client ?? $this-&gt;getDefaultClient();\n    $this-&gt;setDefaultClient($client);\n    return $this-&gt;recvByClient($client, $timeout);\n}\n当get,或者set的key值槽位不一致时,会自动切换客户端进行发送接收命令:\n //节点转移客户端处理\nif ($result-&gt;getErrorType() == 'MOVED') {\n    $nodeId = $this-&gt;getMoveNodeId($result);\n    $client = $this-&gt;getClient($nodeId);\n    $this-&gt;clientConnect($client);\n    //只处理一次moved,如果出错则不再处理\n    $client-&gt;sendCommand($command);\n    $result = $client-&gt;recv($timeout ?? $this-&gt;config-&gt;getTimeout());\n}\n切换完成之后,下一次命令,依旧是默认客户端.  \n获取集群的客户端\n集群操作方法列表:\n\n\n\n方法名称\n参数\n说明\n备注\n\n\n\n\ngetNodeClientList\n\n获取集群客户端列表\n\n\n\ngetNodeList\n\n获取集群节点信息数组\n\n\n\nclientAuth\nClusterClient $client, $password\n集群客户端auth验证\n\n\n\nsetDefaultClient\nClusterClient $defaultClient\n设置一个默认的客户端\n\n\n\ngetDefaultClient\n\n获取一个默认的客户端(初始化会自动默认一个)\n\n\n\ntryConnectServerList\n\n尝试重新获取客户端列表\n当调用命令返回false,可尝试重新获取\n\n\ngetClient\n$nodeKey = null\n根据nodeKey获取一个客户端\n\n\n\ngetMoveNodeId\nResponse $response\n根据recv返回的Move消息获取一个nodeKey\n\n\n\ngetSlotNodeId\n$slotId\n根据槽id获取 nodeKey\n\n\n\n\n这些方法用于用户自定义发送命令给redis服务端,或者是自己定义默认客户端进行发送\n集群兼容管道方法\n由于管道的特性,开启管道后,之后执行的命令将会保存不会直接发送,直到最后执行execPipe才会一次性发送\n在集群中,只能选择一个客户端,进行一次性发送命令:\n\n\n\n方法名称\n参数\n说明\n备注\n\n\n\n\nexecPipe\n?ClusterClient $client = null\n一次性执行管道中保存的方法\n可通过获取客户端列表,自定义选择一个客户端进行发送\n\n\ndiscardPipe\n\n取消管道\n\n\n\nstartPipe\n\n管道开始记录\n\n\n\n","link":"/Components/Redis/cluster.html"},{"id":214,"title":"单机迁移集群","content":"场景\n在业务量小的情况下，我们使用Redis单机连接池就可以满足业务需求。因此，redis单机连接池就可以满足我们的业务。因此我们会这样写：\n示例\n注册连接池\nuse EasySwoole\\Redis\\Config\\RedisConfig;\nuse EasySwoole\\RedisPool\\Redis;\nRedis::getInstance()-&gt;register('redis',new RedisConfig());\n使用\nuse EasySwoole\\RedisPool\\Redis;\nuse EasySwoole\\Redis\\Redis as RedisClient\nRedis::invoke('redis', function (RedisClient $redis) {\n    var_dump($redis-&gt;set('a', 1));\n});\n当业务量上来后，我们需要切换成集群模式的时候怎么办。因此我们做的应该是：\n注册集群连接池\nuse EasySwoole\\RedisPool\\Redis;\nuse EasySwoole\\Redis\\Config\\RedisClusterConfig;\nRedis::getInstance()-&gt;register('redis',new RedisClusterConfig([\n        ['172.16.253.156', 9001],\n        ['172.16.253.156', 9002],\n        ['172.16.253.156', 9003],\n        ['172.16.253.156', 9004],\n    ]\n));\n老业务代码\nuse EasySwoole\\RedisPool\\Redis;\nuse EasySwoole\\Redis\\Redis as RedisClient\nRedis::invoke('redis', function (RedisClient $redis) {\n    var_dump($redis-&gt;set('a', 1));\n});\n对于之前的老业务代码，就会出现、、、、此事，我的invoker回调参数是一个EasySwoole\\Redis\\RedisCluster实例，而非EasySwoole\\Redis\\Redis,\n因此就会导致业务代码报错。\n解决方案\nEasyswoole Redis Pool组件，在2.1.1版本开始，基于easyswoole的magic pool 引入一个cask机制。可以指定实例化的class。\n定义一个class\nnamespace App\\Utility;\n\nuse EasySwoole\\Redis\\Redis;\n\nclass RedisClient extends Redis\n{\n    function fuck()\n    {\n        var_dump('waf');\n    }\n}\n\n该class继承自EasySwoole\\Redis\\Redis\n\n注册redis\nuse EasySwoole\\Redis\\Config\\RedisConfig;\nuse EasySwoole\\RedisPool\\Redis;\nuse App\\Utility\\RedisClient\nRedis::getInstance()-&gt;register('redis',$config,RedisClient::class);\n使用redis\nuse EasySwoole\\RedisPool\\Redis;\nuse App\\Utility\\RedisClient\nRedis::invoke('redis', function (RedisClient $redis) {\n    var_dump($redis-&gt;set('a', 1));\n});\n迁移集群\n修改注册配置\nuse EasySwoole\\RedisPool\\Redis;\nuse EasySwoole\\Redis\\Config\\RedisClusterConfig;\nRedis::getInstance()-&gt;register('redis',new RedisClusterConfig([\n        ['172.16.253.156', 9001],\n        ['172.16.253.156', 9002],\n        ['172.16.253.156', 9003],\n        ['172.16.253.156', 9004],\n    ]\n),RedisClient::class);\n继承修改\n修改App\\Utility\\RedisClient，让它继承EasySwoole\\Redis\\RedisCluster即可\n而由于redis单机客户端与集群客户端的方法几乎一致，因此可以不修改任何业务代码，就是实现单机到集群的迁移","link":"/Components/Redis/single2Cluster.html"},{"id":215,"title":"自定义命令","content":"自定义命令\nRedis 客户端提供了 rawCommand 方法以供使用自定义命令，可以实现 eval 等脚本命令执行的支持\n脚本命令\n可用于执行 Redis 脚本等。\n1. EVAL 执行 Lua 脚本\n调用形式：\n$res = $redis-&gt;rawCommand([\n    'EVAL', \n    \"lua script\", # lua 脚本\n    'keyNums',    # 指定脚本中键名参数的个数\n    // 在脚本中所用到的那些 Redis 键(key) 值\n    'key1',       # 第 1 个 key 对应的值\n    'key2',       # 第 2 个 key 对应的值\n    'key3',       # 第 3 个 key 对应的值\n    ...           # 多个 key 依次添加即可\n    // 在 Lua 中通过全局变量 ARGV 数组访问，\n    'arg1',       # 第 1 个附加 arg 参数对应的值\n    'arg2',       # 第 2 个附加 arg 参数对应的值\n    'arg3',       # 第 3 个附加 arg 参数对应的值\n    ...           # 多个 arg 参数依次添加即可\n]);\n\n// 获取执行 `Lua` 脚本的调用结果\nvar_dump($res-&gt;getData());\n使用示例：\n$res = $redis-&gt;rawCommand([\n    'EVAL', \n    \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\",\n    '2',\n    'key1',\n    'key2',\n    'first',\n    'second'\n]);\n\n// 获取执行 `Lua` 脚本的调用结果\nvar_dump($res-&gt;getData());\n2. EVALSHA 执行 Lua 脚本\n$res = $redis-&gt;rawCommand([\n    'SCRIPT',\n    'LOAD',\n    \"return 'hello moto'\" # lua 脚本\n]);\n\n$sha1 = $res-&gt;getData(); # SHA1 校验和\nvar_dump($sha1);\n\n$res = $redis-&gt;rawCommand([\n    'EVALSHA',\n    $sha1,\n    '0'\n]);\nvar_dump($res-&gt;getData());\n3. SCRIPT 查看脚本是否被缓存\n// 载入一个脚本\n$res = $redis-&gt;rawCommand([\n    'SCRIPT',\n    'LOAD',\n    \"return 'hello moto'\" # lua 脚本\n]);\n$sha1 = $res-&gt;getData(); # SHA1 校验和\nvar_dump($sha1);\n\n// 查看脚本是否被缓存\n$res = $redis-&gt;rawCommand([\n    'SCRIPT',\n    'EXISTS',\n    $sha1,\n    '0'\n]);\nvar_dump($res-&gt;getData()[0]);\n\n// 清空缓存\n$res = $redis-&gt;rawCommand([\n    'SCRIPT',\n    'FLUSH'\n]);\nvar_dump($res-&gt;getData());\n\n// 再次查看脚本是否被缓存\n$res = $redis-&gt;rawCommand([\n    'SCRIPT',\n    'EXISTS',\n    $sha1\n]);\nvar_dump($res-&gt;getData()[0]);\n4. EVAL 从缓存中移除所有脚本\n// 清空缓存\n$res = $redis-&gt;rawCommand([\n    'SCRIPT',\n    'FLUSH'\n]);\nvar_dump($res-&gt;getData());\n5. EVAL 杀死当前正在运行的 Lua 脚本\n// 杀死当前正在运行的 `Lua` 脚本\n$res = $redis-&gt;rawCommand([\n    'SCRIPT',\n    'KILL'\n]);\nvar_dump($res-&gt;getData());\n6. EVAL 将脚本 script 添加到脚本缓存中，但并不立即执行这个脚本。\n// 将脚本 `script` 添加到脚本缓存中，但并不立即执行这个脚本\n$res = $redis-&gt;rawCommand([\n    'SCRIPT',\n    'LOAD',\n    \"return 'hello moto'\" # lua 脚本\n]);\n$sha1 = $res-&gt;getData(); # SHA1 校验和\nvar_dump($sha1);\n基本使用\n$data = $redis-&gt;rawCommand(['set', 'a', '1']);\nvar_dump($data);\n\n$data = $redis-&gt;rawCommand(['get', 'a']);\nvar_dump($data);\n\n$redis-&gt;del('a');\nrawCommand将返回一个EasySwoole\\Redis\\Response对象\nobject(EasySwoole\\Redis\\Response)#8 (4) {\n  [\"status\":protected]=&gt;\n  int(0)\n  [\"data\":protected]=&gt;\n  string(2) \"OK\"\n  [\"msg\":protected]=&gt;\n  NULL\n  [\"errorType\":protected]=&gt;\n  NULL\n}\nobject(EasySwoole\\Redis\\Response)#9 (4) {\n  [\"status\":protected]=&gt;\n  int(0)\n  [\"data\":protected]=&gt;\n  string(1) \"1\"\n  [\"msg\":protected]=&gt;\n  NULL\n  [\"errorType\":protected]=&gt;\n  NULL\n}","link":"/Components/Redis/rawCommand.html"},{"id":216,"title":"连接池","content":"Redis-Pool\nRedis-Pool 基于 pool连接池管理,redis协程客户端 封装的组件\n安装\ncomposer require easyswoole/redis-pool\n连接池注册\n使用连接之前注册redis连接池:\n//redis连接池注册(config默认为127.0.0.1,端口6379)\n\\EasySwoole\\RedisPool\\RedisPool::getInstance()-&gt;register(new \\EasySwoole\\Redis\\Config\\RedisConfig(),'redis');\n// config是空配置,用户需手动配置. \n\n//redis集群连接池注册\n\\EasySwoole\\RedisPool\\RedisPool::getInstance()-&gt;register(new \\EasySwoole\\Redis\\Config\\RedisClusterConfig([\n        ['172.16.253.156', 9001],\n        ['172.16.253.156', 9002],\n        ['172.16.253.156', 9003],\n        ['172.16.253.156', 9004],\n    ]\n),'redisCluster');\n连接池配置\n当注册好时,将返回连接池的poolConf用于配置连接池:\n$redisPoolConfig = \\EasySwoole\\RedisPool\\RedisPool::getInstance()-&gt;register(new \\EasySwoole\\Redis\\Config\\RedisConfig());\n//配置连接池连接数\n$redisPoolConfig-&gt;setMinObjectNum(5);\n$redisPoolConfig-&gt;setMaxObjectNum(20);\n\n$redisClusterPoolConfig = \\EasySwoole\\RedisPool\\RedisPool::getInstance()-&gt;register(new \\EasySwoole\\Redis\\Config\\RedisClusterConfig([\n        ['172.16.253.156', 9001],\n        ['172.16.253.156', 9002],\n        ['172.16.253.156', 9003],\n        ['172.16.253.156', 9004],\n    ]\n));\n//配置连接池连接数\n$redisPoolConfig-&gt;setMinObjectNum(5);\n$redisPoolConfig-&gt;setMaxObjectNum(20);\n使用连接池\n//defer方式获取连接\n$redis = \\EasySwoole\\RedisPool\\RedisPool::defer();\n$redisCluster = \\EasySwoole\\RedisPool\\RedisPool::defer();\n$redis-&gt;set('a', 1);\n$redisCluster-&gt;set('a', 1);\n\n//invoke方式获取连接\n\\EasySwoole\\RedisPool\\RedisPool::invoke(function (\\EasySwoole\\Redis\\Redis $redis) {\n    var_dump($redis-&gt;set('a', 1));\n});\n\\EasySwoole\\RedisPool\\RedisPool::invoke(function (\\EasySwoole\\Redis\\Redis $redis) {\n    var_dump($redis-&gt;set('a', 1));\n});\n\n//获取连接池对象\n$redisPool = \\EasySwoole\\RedisPool\\RedisPool::getInstance()-&gt;getPool();\n$redisClusterPool = \\EasySwoole\\RedisPool\\RedisPool::getInstance()-&gt;getPool();\n\n$redis = $redisPool-&gt;getObj();\n$redisPool-&gt;recycleObj($redis);\n！！！注意，在未指定连接池名称是，注册的连接池名称为默认的default\n方法\nregister\n\\EasySwoole\\RedisPool\\RedisPool::getInstance()-&gt;register();\n参数：\n\n$config new \\EasySwoole\\Redis\\Config\\RedisConfig() || new \\EasySwoole\\Redis\\Config\\RedisClusterConfig()\n\n$name 连接池名称 默认default\n\n$cask 用户自定义redis-client 可忽略\n\n返回：\n\n注册成功返回EasySwoole\\Pool\\Config,可设置连接池的配置.\n\ndefer\n\\EasySwoole\\RedisPool\\RedisPool::defer();\n参数：\n\n$name 连接池名称 默认default\n\n$timeout 取出连接超时时间\n\n返回：\n\n成功返回连接池内对象 失败为null \n\ninvoke\n\\EasySwoole\\RedisPool\\RedisPool::invoke(function (\\EasySwoole\\Redis\\Redis $redis) {\n    var_dump($redis-&gt;set('a', 1));\n});\n参数：\n\n$call 执行的闭包函数，闭包函数参数为连接池对象\n$name 连接池名称 默认default\n\n$timeout 取出连接超时时间\n\n返回：\n\n成功返回闭包函数内返回的结果，失败返回null\n\n\ngetPool\n\\EasySwoole\\RedisPool\\RedisPool::getInstance()-&gt;getPool();\n参数：\n\n$name 连接池名称 默认default\n\n\n返回：\n\n成功返回EasySwoole\\RedisPool\\Pool,失败返回null.\n","link":"/Components/Redis/pool.html"},{"id":217,"title":"连接(connection)","content":"Redis 连接\nRedis 连接命令主要是用于连接 redis 服务\n操作方法\n连接方法包括一些auth,echo,ping,类似的方法,列表如下:    \n\n\n\n方法名称\n参数\n说明\n备注\n\n\n\n\nconnect\n$timeout\n连接\n\n\n\ndisconnect\n\n断开连接\n\n\n\nauth\n$password\nauth认证\n\n\n\necho\n$str\necho\n\n\n\nping\n\nping\n\n\n\nselect\n$db\n选择数据库\n\n\n\n\n基本使用\ngo(function () {\n    $redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host'      =&gt; '127.0.0.1',\n        'port'      =&gt; '6379',\n        'auth'      =&gt; 'easyswoole',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]));\n    $data = $redis-&gt;connect();\n    var_dump($data);\n    $data = $redis-&gt;auth('easyswoole');\n    var_dump($data);\n    $data = $redis-&gt;echo('test echo');\n    var_dump($data);\n    $data = $redis-&gt;ping();\n    var_dump($data);\n    $data = $redis-&gt;select(1);\n    var_dump($data);\n    $redis-&gt;disconnect();\n});","link":"/Components/Redis/connection.html"},{"id":218,"title":"键(keys)","content":"Redis 键(Keys)\nRedis 键命令用于管理 redis 的键。\n操作方法\n方法列表\n\n\n\n方法名称\n参数\n说明\n备注\n\n\n\n\ndel\n...$keys\n删除一个键\n$key可传一个array,也可以传多个可变参数\n\n\nunlink\n...$keys\n非阻塞删除一个键\n$key可传一个array,也可以传多个可变参数\n\n\ndump\n$key\n序列化\n\n\n\nexists\n$key\n查询是否存在\n\n\n\nexpire\n$key, $expireTime = 60\n给key设定过期时间(秒)\n\n\n\nexpireAt\n$key, $expireTime\n以UNIX时间戳格式设置key的过期时间\nexpireAt的作用和expire类似，都用于为key设置过期时间。 不同在于expireAt命令接受的时间参数是UNIX时间戳(unix timestamp)。At,顾名思义，在未来的某个时间点过期\n\n\npExpire\n$key, $expireTime = 60000\n给key设定过期时间(毫秒)\n\n\n\nkeys\n$pattern\n匹配key\n\n\n\nmove\n$key, $db\n移动key\n集群模式不能使用\n\n\npersist\n$key\n移除key的过期时间\n\n\n\npTTL\n$key\n返回毫秒过期时间\n\n\n\nttl\n$key\n返回过期时间\n\n\n\nrandomKey\n\n随机返回一个key\n\n\n\nrename\n$key, $new_key\n修改key的名字\n集群模式不能使用\n\n\nrenameNx\n$key, $new_key\nnewkey不存在时,修改key名字\n集群模式不能使用\n\n\ntype\n$key\n返回key储存的数据类型\n\n\n\n\ndel和unlink都可以传一个数组,或者传 ...数组(可变参数),如果第一个参数为数组,则后面的参数全部将忽略\n在集群中,del和unlink都是拆分key,判断key的solt进行一个个执行\n基本使用\ngo(function () {\n    $redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host'      =&gt; '127.0.0.1',\n        'port'      =&gt; '6379',\n        'auth'      =&gt; 'easyswoole',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]));\n    $key = 'test123213Key';\n    $redis-&gt;select(0);\n    $redis-&gt;set($key, 123);\n    $data = $redis-&gt;dump($key);\n    var_dump($data);\n    $data = $redis-&gt;dump($key . 'x');\n    var_dump($data);\n\n    $data = $redis-&gt;exists($key);\n    var_dump($data);\n\n    $data = $redis-&gt;expire($key, 1);\n    var_dump($data);\n    \\Swoole\\Coroutine::sleep(2);\n    var_dump($redis-&gt;exists($key));\n\n    $redis-&gt;expireAt($key, 1593570849);\n    \\Swoole\\Coroutine::sleep(1);\n    var_dump($redis-&gt;exists($key));\n\n    $redis-&gt;pExpire($key, 1 * 100);\n    \\Swoole\\Coroutine::sleep(0.1);\n    var_dump($redis-&gt;exists($key));\n\n    $redis-&gt;set($key, 123);\n    $data = $redis-&gt;keys(\"{$key}\");\n    var_dump($data);\n\n    $redis-&gt;select(1);\n    $redis-&gt;del($key);\n    $redis-&gt;select(0);\n    $data = $redis-&gt;move($key, 1);\n    var_dump($data);\n    $data = $redis-&gt;exists($key);\n    var_dump($data);\n    $redis-&gt;select(0);\n\n    $redis-&gt;set($key, 123);\n    $data = $redis-&gt;expire($key, 1);\n    var_dump($data);\n    $data = $redis-&gt;persist($key);\n    var_dump($data);\n\n    $redis-&gt;expire($key, 1);\n    $data = $redis-&gt;pTTL($key);\n    var_dump($data);\n\n    $data = $redis-&gt;ttl($key);\n    var_dump($data);\n\n    $data = $redis-&gt;randomKey();\n    var_dump($data);\n    $data = $redis-&gt;rename($key, $key . 'new');\n    var_dump($data);\n    var_dump($redis-&gt;expire($key . 'new'));\n    var_dump($redis-&gt;expire($key));\n\n    $data = $redis-&gt;renameNx($key, $key . 'new');\n    var_dump($data);\n    $redis-&gt;renameNx($key . 'new', $key);\n    $data = $redis-&gt;renameNx($key, $key . 'new');\n    var_dump($data);\n    $data = $redis-&gt;type($key);\n    var_dump($data);\n    $data = $redis-&gt;type($key . 'new');\n    var_dump($data);\n\n    $data = $redis-&gt;del($key);\n    var_dump($data);\n    $data = $redis-&gt;del('a','b','c');\n    var_dump($data);\n    $data = $redis-&gt;del(['a','b','c']);\n    var_dump($data);\n\n    $data = $redis-&gt;unlink($key);\n    var_dump($data);\n    $data = $redis-&gt;unlink('a','b','c');\n    var_dump($data);\n    $data = $redis-&gt;unlink(['a','b','c']);\n    var_dump($data);\n\n});","link":"/Components/Redis/keys.html"},{"id":219,"title":"字符串(string)","content":"Redis 字符串(String)\nRedis 字符串数据类型的相关命令用于管理 redis 字符串值\n操作方法\n方法列表\n\n\n\n方法名称\n参数\n说明\n备注\n\n\n\n\nset\n$key, $val, $timeout = 0\n设置一个键,以及设置过期时间,单位秒\n$timeout值可为int(过期时间秒),可为string(&quot;NX&quot;,&quot;XX&quot;),也可为array['NX','EX'=&gt;10]\n\n\nget\n$key\n获取一个键\n\n\n\ngetRange\n$key, $start, $end\n返回子字符串\n\n\n\ngetSet\n$key, $value\n返回key旧值并设置新值\n\n\n\ngetBit\n$key, $offset\n获取指定偏移量上的bit值\n\n\n\nmGet\n$keys\n获取多个key的值(参数可为string或者数组)\n在集群中,将会分开处理\n\n\nsetBit\n$key, $offset, $value\n设置偏移量的bit值\n\n\n\nsetEx\n$key, $expireTime, $value\n设置值以及过期时间(秒)\n\n\n\nsetNx\n$key, $value\nkey不存在时设置 key 的值。\n\n\n\nsetRange\n$key, $offset, $value\n设置偏移量的值\n\n\n\nstrLen\n$key\n返回 key 所储存的字符串值的长度\n\n\n\nmSet\n$data\n设置多个key的值,参数为关联数组\n\n\n\nmSetNx\n$data\n当所有key不存在时,设置多个key值,参数和mSet一样\n在集群中,key将会分开处理\n\n\npSetEx\n$key, $expireTime, $value\n同setEx,过期时间为毫秒\n\n\n\nincr\n$key\n自增1\n\n\n\nincrBy\n$key, $value\n自增$value数值\n\n\n\nincrByFloat\n$key, $value\n自增$value浮点值\n\n\n\ndecr\n$key\n自减1\n\n\n\ndecrBy\n$key, $value\n自减$value数值\n\n\n\nappEnd\n$key, $value\n追加字符串\n\n\n\nscan\n&amp;$cursor, $pattern=null, $count=null\n迭代string键名\n集群模式不能使用\n\n\n\n如果开启序列化配置,getRange,setRange,getBit,setBit,strLen,自增自减命令,append等都会失效\n在集群中,批量设置,批量获取都是拆数组一个个处理的,所以mSetNx 的特性将失效\n基本使用\n\ngo(function () {\n    $redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host'      =&gt; '127.0.0.1',\n        'port'      =&gt; '6379',\n        'auth'      =&gt; 'easyswoole',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]));\n    $key = 'test';\n    $value = 1;\n    $data = $redis-&gt;del($key);\n    var_dump($data);\n    $data = $redis-&gt;set($key, $value);\n    var_dump($data);\n    $data = $redis-&gt;set($key, $value,'XX');\n    var_dump($data);\n    $data = $redis-&gt;set($key, $value,'NX');\n    var_dump($data);\n    $data = $redis-&gt;set($key, $value,['NX','EX'=&gt;20]);\n    var_dump($data);\n    $data = $redis-&gt;set($key, $value,['NX','PX'=&gt;20000]);\n    var_dump($data);\n\n    $data = $redis-&gt;get($key);\n    var_dump($data);\n\n    $data = $redis-&gt;exists($key);\n    var_dump($data);\n\n    $data = $redis-&gt;set($key, $value);\n    var_dump($data);\n    $value += 1;\n    $data = $redis-&gt;incr($key);\n    var_dump($data);\n\n    $value += 10;\n    $data = $redis-&gt;incrBy($key, 10);\n    var_dump($data);\n\n    $value -= 1;\n    $data = $redis-&gt;decr($key);\n    var_dump($data);\n\n    $value -= 10;\n    $data = $redis-&gt;decrBy($key, 10);\n    var_dump($data);\n\n    $key = 'stringTest';\n    $value = 'tioncico';\n    $redis-&gt;set($key, $value);\n    $data = $redis-&gt;getRange($key, 1, 2);\n    var_dump($data);\n\n    $data = $redis-&gt;getSet($key, $value . 'a');\n    var_dump($data);\n    $redis-&gt;set($key, $value);\n\n    $bitKey = 'testBit';\n    $bitValue = 10000;\n    $redis-&gt;set($bitKey, $bitValue);\n    $data = $redis-&gt;setBit($bitKey, 1, 0);\n    var_dump($data);\n    $data = $redis-&gt;getBit($key, 1);\n    var_dump($data);\n\n    $field = [\n        'stringField1',\n        'stringField2',\n        'stringField3',\n        'stringField4',\n        'stringField5',\n    ];\n    $value = [\n        1,\n        2,\n        3,\n        4,\n        5,\n    ];\n    $data = $redis-&gt;mSet([\n        \"{$field[0]}\" =&gt; $value[0],\n        \"{$field[1]}\" =&gt; $value[1],\n        \"{$field[2]}\" =&gt; $value[2],\n        \"{$field[3]}\" =&gt; $value[3],\n        \"{$field[4]}\" =&gt; $value[4],\n    ]);\n    var_dump($data);\n    $data = $redis-&gt;mGet([$field[3], $field[2], $field[1]]);\n    var_dump($data);\n\n    $data = $redis-&gt;setEx($key, 1, $value[0] . $value[0]);\n    var_dump($data);\n    var_dump($redis-&gt;get($key));\n\n    $data = $redis-&gt;pSetEx($key, 1, $value[0]);\n    var_dump($data);\n    var_dump($redis-&gt;get($key));\n\n    $redis-&gt;del($key);\n    $data = $redis-&gt;setNx($key, 1);\n    var_dump($data);\n\n    $redis-&gt;del($field[0]);\n    $data = $redis-&gt;mSetNx([\n        \"{$field[0]}\" =&gt; $value[0],\n        \"{$field[1]}\" =&gt; $value[1],\n    ]);\n    var_dump($data);\n    var_dump( $redis-&gt;get($field[1]));\n    $redis-&gt;del($field[1]);\n    $data = $redis-&gt;mSetNx([\n        \"{$field[0]}\" =&gt; $value[0] + 1,\n        \"{$field[1]}\" =&gt; $value[1] + 1,\n    ]);\n    var_dump($data);\n    var_dump($redis-&gt;get($field[0]));\n\n    $data = $redis-&gt;setRange($field[0], 1, 1);\n    var_dump($data);\n    var_dump($redis-&gt;get($field[0]));\n\n    $data = $redis-&gt;strLen($field[0]);\n    var_dump($data);\n\n    $redis-&gt;set($key, 1);\n    $data = $redis-&gt;incrByFloat($key, 0.1);\n    var_dump($data);\n    $data = $redis-&gt;appEnd($field[0], '1');\n    var_dump($data);\n    var_dump($redis-&gt;get($field[0]));\n\n    //迭代测试\n    $cursor = 0;//迭代初始值0\n    $redis-&gt;flushAll();\n    $redis-&gt;set('xxxa', '仙士可');\n    $redis-&gt;set('xxxb', '仙士可');\n    $redis-&gt;set('xxxc', '仙士可');\n    $redis-&gt;set('xxxd', '仙士可');\n    $data = [];\n    do {\n        //每次迭代都会设置一次$cursor,为0代表迭代完成\n        $keys = $redis-&gt;scan($cursor, 'xxx*', 1);\n        $data = array_merge($data,$keys);\n    } while ($cursor);\n    var_dump($data);\n});","link":"/Components/Redis/string.html"},{"id":220,"title":"哈希(hash)","content":"Redis 哈希(Hash)\nRedis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。\nRedis 中每个 hash 可以存储 1 ~ 2 的 32 次方个键值对 (40多亿)。\n操作方法\n方法列表\n\n\n\n方法名称\n参数\n说明\n备注\n\n\n\n\nhDel\n$key, ...$field\n删除键,可多个\n\n\n\nhExists\n$key, $field\n查询字段是否存在\n\n\n\nhGet\n$key, $field\n获取一个字段值\n\n\n\nhGetAll\n$key\n获取这个key的全部字段值\n\n\n\nhSet\n$key, $field, $value\n设置key的字段值\n\n\n\nhValS\n$key\n获取哈希表中所有值\n\n\n\nhKeys\n$key\n获取所有哈希表中的字段\n\n\n\nhLen\n$key\n获取哈希表中字段的数量\n\n\n\nhMGet\n$key, $hashKeys\n获取所有给定字段$hashKeys数组的值\n\n\n\nhMSet\n$key, $data\n同时将多个$data键值对设置到$key中\n\n\n\nhIncrBy\n$key, $field, $increment\n给指定字段增加$increment\n\n\n\nhIncrByFloat\n$key, $field, $increment\n给指定字段增加浮点数$increment\n\n\n\nhSetNx\n$key, $field, $value\n只有在$filed不存在时,设置$field的值\n\n\n\nhScan\n$key,&amp;$cursor, $pattern=null, $count=null\n迭代哈希表中的键值对。\n\n\n\n\n基本使用\ngo(function () {\n    $redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host'      =&gt; '127.0.0.1',\n        'port'      =&gt; '6379',\n        'auth'      =&gt; 'easyswoole',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]));\n\n    $key = 'hKey';\n    $field = [\n        'hField1',\n        'hField2',\n        'hField3',\n        'hField4',\n        'hField5',\n    ];\n    $value = [\n        1,\n        2,\n        3,\n        4,\n        5,\n    ];\n\n    $redis-&gt;del($key);\n    $data = $redis-&gt;hSet($key, $field[0], $value[0]);\n    var_dump($data);\n\n    $data = $redis-&gt;hGet($key, $field[0]);\n    var_dump($data);\n\n    $data = $redis-&gt;hExists($key, $field[0]);\n    var_dump($data);\n\n    $data = $redis-&gt;hDel($key, $field[0]);\n    var_dump($data);\n\n    $data = $redis-&gt;hExists($key, $field[0]);\n    var_dump($data);\n\n    $data = $redis-&gt;hMSet($key, [\n        \"{$field[0]}\" =&gt; $value[0],\n        \"{$field[1]}\" =&gt; $value[1],\n        \"{$field[2]}\" =&gt; $value[2],\n        \"{$field[3]}\" =&gt; $value[3],\n        \"{$field[4]}\" =&gt; $value[4],\n    ]);\n    var_dump($data);\n    $data = $redis-&gt;hValS($key);\n    var_dump($data);\n\n    $data = $redis-&gt;hGetAll($key);\n    var_dump($data);\n\n    $data = $redis-&gt;hKeys($key);\n    var_dump($data);\n\n    $data = $redis-&gt;hLen($key);\n    var_dump($data);\n\n   $data = $redis-&gt;hMGet($key, [$field[0], $field[1], $field[2]]);\n    var_dump($data);\n\n    $data = $redis-&gt;hIncrBy($key, $field[4], 1);\n    var_dump($data);\n\n    $data = $redis-&gt;hIncrByFloat($key, $field[1], 1.1);\n    var_dump($data);\n\n    $data = $redis-&gt;hSetNx($key, $field[0], 1);\n    var_dump($data);\n\n    $data = $redis-&gt;hSetNx($key, $field[0] . 'a', 1);\n    var_dump($data);\n    var_dump($redis-&gt;hGet($key, $field[0] . 'a'));\n\n    $cursor = 0;\n    $redis-&gt;del('a');\n    $redis-&gt;hMSet('a',[\n        'a'=&gt;'tioncico',\n        'b'=&gt;'tioncico',\n        'c'=&gt;'tioncico',\n        'd'=&gt;'tioncico',\n        'e'=&gt;'tioncico',\n        'f'=&gt;'tioncico',\n        'g'=&gt;'tioncico',\n        'h'=&gt;'tioncico',\n    ]);\n\n    $data = [];\n    do {\n        $keys = $redis-&gt;hScan('a',$cursor);\n        $data = array_merge($data,$keys);\n        var_dump($keys);\n    } while ($cursor);\n\n});\n","link":"/Components/Redis/hash.html"},{"id":221,"title":"列表(lists)","content":"Redis 列表(List)\nRedis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）\n一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。\n操作方法\n方法列表\n\n\n\n方法名称\n参数\n说明\n备注\n\n\n\n\nlPush\n$key, ...$data\n将一个或多个值插入到列表头部\n\n\n\nbLPop\n$keys,$timeout\n移出并获取$keys列表的第一个元素， 如果$keys列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止\n$keys可为string,也可以为一个数组\n\n\nbRPop\n$keys,$timeout\n移出并获取$keys列表的最后一个元素， 如果$keys列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\n$keys可为string,也可以为一个数组\n\n\nbRPopLPush\n$source, $destination, $timeout\n从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\n\n\n\nrPopLPush\n$source, $destination\n移除列表的最后一个元素，并将该元素添加到另一个列表并返回\n\n\n\nlIndex\n$key,$index\n通过索引获取列表中的元素\n\n\n\nlLen\n$key\n获取列表长度\n\n\n\nlInsert\n$key,$bool,$pivot,$value\n在列表的元素前或者后插入元素\n\n\n\nrPush\n$key, ...$data\n在列表中添加一个或多个值\n\n\n\nlRange\n$key,$start,$stop\n获取列表指定范围内的元素\n\n\n\nlPop\n$key\n移出并获取列表的第一个元素\n\n\n\nrPop\n$key\n移出并获取列表的最后一个元素\n\n\n\nlPuShx\n$key,$value\n将一个值插入到已存在的列表头部\n\n\n\nrPuShx\n$key,$value\n为已存在的列表添加值\n\n\n\nlRem\n$key,$count,$value\n移除列表元素\n\n\n\nlSet\n$key,$index,$value\n通过索引设置列表元素的值\n\n\n\nlTrim\n$key,$start,$stop\n对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。\n\n\n\n\n基本使用\n\ngo(function () {\n    $redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host'      =&gt; '127.0.0.1',\n        'port'      =&gt; '6379',\n        'auth'      =&gt; 'easyswoole',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]));;\n\n    $key = [\n        'listKey1',\n        'listKey2',\n        'listKey3',\n    ];\n    $value = [\n        'a', 'b', 'c', 'd'\n    ];\n\n    $redis-&gt;flushAll();\n\n    //测试null的时候\n    $data = $redis-&gt;bLPop([$key[0],$key[1]], 1);\n    var_dump($data);\n    $data = $redis-&gt;lPush($key[0], $value[0], $value[1]);\n    var_dump($data);\n\n    //测试null的时候\n    $data = $redis-&gt;bLPop([$key[1]], 1);\n    var_dump($data);\n    $data = $redis-&gt;bRPop([$key[1]], 1);\n    var_dump($data);\n\n    $data = $redis-&gt;bLPop([$key[0],$key[1]], 1);\n    var_dump($data);\n\n    $data = $redis-&gt;bRPop([$key[0],$key[1]], 1);\n    var_dump($data);\n\n    $redis-&gt;del($key[0]);\n    $redis-&gt;lPush($key[0], $value[0], $value[1]);\n    $data = $redis-&gt;bRPopLPush($key[0], $key[1], 1);\n    var_dump($data);\n\n    $redis-&gt;del($key[0]);\n    $redis-&gt;lPush($key[0], $value[0], $value[1]);\n    $data = $redis-&gt;rPopLPush($key[0], $key[1]);\n    var_dump($data);\n\n    $redis-&gt;del($key[0]);\n    $redis-&gt;lPush($key[0], $value[0], $value[1]);\n    $data = $redis-&gt;lIndex($key[0], 1);\n    var_dump($data);\n    $data = $redis-&gt;lLen($key[0]);\n    var_dump($data);\n\n    $data = $redis-&gt;lInsert($key[0], true, 'b', 'c');\n    var_dump($data);\n    $data = $redis-&gt;lInsert($key[0], true, 'd', 'c');\n    var_dump($data);\n\n    $redis-&gt;del($key[1]);\n    $data = $redis-&gt;rPush($key[1], $value[0], $value[2], $value[1]);\n    var_dump($data);\n\n    $data = $redis-&gt;lRange($key[1], 0, 3);\n    var_dump($data);\n\n    $data = $redis-&gt;lPop($key[1]);\n    var_dump($data);\n\n    $data = $redis-&gt;rPop($key[1]);\n    var_dump($data);\n\n    $data = $redis-&gt;lPuShx($key[1], 'x');\n    var_dump($data);\n\n    $data = $redis-&gt;rPuShx($key[1], 'z');\n    var_dump($data);\n\n    $redis-&gt;del($key[1]);\n    $redis-&gt;rPush($key[1], $value[0], $value[0], $value[0]);\n    $data = $redis-&gt;lRem($key[1], 1, $value[0]);\n    var_dump($data);\n\n    $data = $redis-&gt;lSet($key[1], 0, 'xx');\n    var_dump($data);\n\n    $data = $redis-&gt;lTrim($key[1], 0, 2);\n    var_dump($data);\n});\n","link":"/Components/Redis/lists.html"},{"id":222,"title":"集合(sets)","content":"Redis 集合(Set)\nRedis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。\nRedis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。\n集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。\n操作方法\n方法列表\n\n\n\n方法名称\n参数\n说明\n备注\n\n\n\n\nsAdd\n$key, ...$data\n向集合添加一个或多个成员\n\n\n\nsCard\n$key\n获取集合的成员数\n\n\n\nsDiff\n$key1, ...$keys\n返回给定所有集合的差集\n\n\n\nsMembers\n$destination, ...$keys\n返回集合中的所有成员\n\n\n\nsDiffStore\n$key1, ...$keys\n返回给定所有集合的差集并存储在 destination 中\n\n\n\nsInter\n$destination, ...$keys\n返回给定所有集合的交集\n\n\n\nsInterStore\n$key, $member\n返回给定所有集合的交集并存储在 destination 中\n\n\n\nsIsMember\n$key\n判断 member 元素是否是集合 key 的成员\n\n\n\nsMove\n$source, $destination, $member\n将 member 元素从 source 集合移动到 destination 集合\n\n\n\nsPop\n$key\n移除并返回集合中的一个随机元素\n\n\n\nsRandMemBer\n$key, $count = null\n返回集合中一个或多个随机数\n\n\n\nsRem\n$key, $member1, ...$members\n移除集合中一个或多个成员\n\n\n\nsUnion\n$key1, ...$keys\n返回所有给定集合的并集\n\n\n\nsUnIonStore\n$destination, $key1, ...$keys\n所有给定集合的并集存储在 destination 集合中\n\n\n\nsScan\n$key,&amp;$cursor, $pattern=null, $count=null\n迭代集合中的元素\n\n\n\n\n在集群模式中,sDiff,sDiffStore,sInter,sMove,sUnion,sUnIonStore等方法不能使用\n基本使用\ngo(function () {\n     $redis =  new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host'      =&gt; '127.0.0.1',\n        'port'      =&gt; '6379',\n        'auth'      =&gt; 'easyswoole',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]));\n    $key = [\n            'muster1',\n            'muster2',\n            'muster3',\n            'muster4',\n            'muster5',\n        ];\n        $value = [\n            '1',\n            '2',\n            '3',\n            '4',\n        ];\n    $redis-&gt;del($key[0]);\n    $redis-&gt;del($key[1]);\n    $data = $redis-&gt;sAdd($key[0], $value[0], $value[1]);\n    var_dump($data);\n\n    $data = $redis-&gt;sCard($key[0]);\n    var_dump($data);\n\n    $redis-&gt;sAdd($key[1], $value[0], $value[2]);\n    $data = $redis-&gt;sDiff($key[0], $key[1]);\n    var_dump($data);\n\n    $data = $redis-&gt;sDiff($key[1], $key[0]);\n    var_dump($data);\n\n    $data = $redis-&gt;sMembers($key[0]);\n    var_dump($data);\n\n    $data = $redis-&gt;sMembers($key[1]);\n    var_dump($data);\n\n    $data = $redis-&gt;sDiffStore($key[2], $key[0], $key[1]);\n    var_dump($data);\n\n    $data = $redis-&gt;sInter($key[0], $key[1]);\n    var_dump($data);\n\n    $data = $redis-&gt;sInterStore($key[3], $key[0], $key[1]);\n    var_dump($data);\n\n    $data = $redis-&gt;sIsMember($key[0], $value[0]);\n    var_dump($data);\n\n    $data = $redis-&gt;sMove($key[0], $key[1], $value[1]);\n    var_dump($data);\n\n    $data = $redis-&gt;sPop($key[0]);\n    var_dump($data);\n\n    $redis-&gt;del($key[3]);\n    $redis-&gt;sAdd($key[3], $value[0], $value[1], $value[2], $value[3]);\n    $data = $redis-&gt;sRandMemBer($key[3], 4);\n    var_dump($data);\n\n    $data = $redis-&gt;sRem($key[3], $value[0], $value[1], $value[2], $value[3]);\n    var_dump($data);\n\n    $data = $redis-&gt;sUnion($key[0], $key[1]);\n    var_dump($data);\n\n    $redis-&gt;del($key[1]);\n    $redis-&gt;del($key[2]);\n    $redis-&gt;del($key[3]);\n    $redis-&gt;del($key[4]);\n    $redis-&gt;sAdd($key[1], 1, 2, 3, 4);\n    $redis-&gt;sAdd($key[2], 5);\n    $redis-&gt;sAdd($key[3], 6, 7);\n    $data = $redis-&gt;sUnIonStore($key[4], $key[1], $key[2], $key[3]);\n    var_dump($data);\n\n    $cursor = 0;\n    $redis-&gt;del('a');\n    $redis-&gt;sAdd('a','a1','a2','a3','a4','a5');\n    $data= [];\n    do {\n        $keys = $redis-&gt;sScan('a',$cursor,'*',1);\n        $data = array_merge($data,$keys);\n    } while ($cursor);\n    var_dump($data);\n});","link":"/Components/Redis/sets.html"},{"id":223,"title":"有序集合(sortedsets)","content":"Redis 有序集合(sorted set)\nRedis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。\n不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。\n有序集合的成员是唯一的,但分数(score)却可以重复。\n集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。\n操作方法\n方法列表\n\n\n\n方法名称\n参数\n说明\n备注\n\n\n\n\nzAdd\n$key, $score1, $member1, ...$data\n向有序集合添加一个或多个成员，或者更新已存在成员的分数\n\n\n\nzCard\n$key\n获取有序集合的成员数\n\n\n\nzCount\n$key, $min, $max\n计算在有序集合中指定区间分数的成员数\n\n\n\nzInCrBy\n$key, $increment, $member\n有序集合中对指定成员的分数加上增量 increment\n\n\n\nzInTerStore\n$destination, array $keys, array $weights = [], $aggregate = 'SUM'\n计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中\n\n\n\nzLexCount\n$key, $min, $max\n在有序集合中计算指定字典区间内成员数量\n\n\n\nzRange\n$key, $start, $stop, $withScores = false\n通过索引区间返回有序集合指定区间内的成员\n\n\n\nzRangeByLex\n$key, $min, $max, ...$data\n通过字典区间返回有序集合的成员\n\n\n\nzRangeByScore\n$key, $min, $max, array $options\n通过分数返回有序集合指定区间内的成员\n\n\n\nzRank\n$key, $member\n返回有序集合中指定成员的索引\n\n\n\nzRem\n$key, $member, ...$members\n移除有序集合中的一个或多个成员\n\n\n\nzRemRangeByLex\n$key, $min, $max\n移除有序集合中给定的字典区间的所有成员\n\n\n\nzRemRangeByRank\n$key, $start, $stop\n移除有序集合中给定的排名区间的所有成员\n\n\n\nzRemRangeByScore\n$key, $min, $max\n移除有序集合中给定的分数区间的所有成员\n\n\n\nzRevRange\n$key, $start, $stop, $withScores = false\n返回有序集中指定区间内的成员，通过索引，分数从高到低\n\n\n\nzRevRangeByScore\n$key, $max, $min, array $options\n返回有序集中指定分数区间内的成员，分数从高到低排序\n\n\n\nzRevRank\n$key, $member\n返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序\n\n\n\nzScore\n$key, $member\n返回有序集中，成员的分数值\n\n\n\nzUnionStore\n$destination, array $keys, array $weights = [], $aggregate = 'SUM'\n计算给定的一个或多个有序集的并集，并存储在新的 key 中\n\n\n\nzScan\n$key,&amp;$cursor, $pattern=null, $count=null\n迭代有序集合中的元素（包括元素成员和元素分值）\n\n\n\n\n在集群模式中,zInTerStore,zUnionStore 等方法不能使用\n基本使用\ngo(function (){\n    $redis =  new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host'      =&gt; '127.0.0.1',\n        'port'      =&gt; '6379',\n        'auth'      =&gt; 'easyswoole',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]));\n    $key = [\n            'sortMuster1',\n            'sortMuster2',\n            'sortMuster3',\n            'sortMuster4',\n            'sortMuster5',\n        ];\n    $member = [\n        'member1',\n        'member2',\n        'member3',\n        'member4',\n        'member5',\n    ];\n    $score = [\n        1,\n        2,\n        3,\n        4,\n    ];\n    $redis-&gt;del($key[0]);\n    $data = $redis-&gt;zAdd($key[0], $score[0], $member[0], $score[1], $member[1]);\n    var_dump($data);\n\n    $data = $redis-&gt;zCard($key[0]);\n    var_dump($data);\n\n    $data = $redis-&gt;zCount($key[0], 0, 3);\n    var_dump($data);\n\n    $data = $redis-&gt;zInCrBy($key[0], 1, $member[1]);\n    var_dump($data);\n\n    $redis-&gt;del($key[0]);\n    $redis-&gt;del($key[1]);\n    $redis-&gt;zAdd($key[0], $score[0], $member[0], $score[1], $member[1]);\n    $redis-&gt;zAdd($key[1], $score[0], $member[0], $score[3], $member[3]);\n    $data = $redis-&gt;zInTerStore($key[2], [$key[0], $key[1]], [1, 2]);\n    var_dump($data);\n\n    $data = $redis-&gt;zLexCount($key[0], '-', '+');\n    var_dump($data);\n\n    $redis-&gt;del($key[0]);\n    $redis-&gt;zAdd($key[0], $score[0], $member[0], $score[1], $member[1], $score[2], $member[2]);\n    $data = $redis-&gt;zRange($key[0], 0, -1, true);\n    var_dump($data);\n\n    $data = $redis-&gt;zRangeByLex($key[0], '-', '+');\n    var_dump($data);\n\n    $data = $redis-&gt;zRangeByScore($key[0], 2, 3, ['withScores' =&gt; true, 'limit' =&gt; array(0, 2)]);\n    var_dump($data);\n\n    $data = $redis-&gt;zRank($key[0], $member[1]);\n    var_dump($data);\n\n    $data = $redis-&gt;zRem($key[0], $member[1], $member[2]);\n    var_dump($data);\n\n    $redis-&gt;del($key[0]);\n    $redis-&gt;zAdd($key[0], $score[0], $member[0], $score[1], $member[1], $score[2], $member[2]);\n    $data = $redis-&gt;zRemRangeByLex($key[0], '-', '+');\n    var_dump($data);\n\n    $redis-&gt;del($key[0]);\n    $redis-&gt;zAdd($key[0], $score[0], $member[0], $score[1], $member[1], $score[2], $member[2]);\n    $data = $redis-&gt;zRemRangeByRank($key[0], 0, 2);\n    var_dump($data);\n\n    $redis-&gt;del($key[0]);\n    $redis-&gt;zAdd($key[0], $score[0], $member[0], $score[1], $member[1], $score[2], $member[2]);\n    $data = $redis-&gt;zRemRangeByScore($key[0], 0, 3);\n    var_dump($data);\n\n    $redis-&gt;del($key[0]);\n    $redis-&gt;zAdd($key[0], $score[0], $member[0], $score[1], $member[1], $score[2], $member[2]);\n    $data = $redis-&gt;zRevRange($key[0], 0, 3, true);\n    var_dump($data);\n\n    $redis-&gt;del($key[0]);\n    $redis-&gt;zAdd($key[0], $score[0], $member[0], $score[1], $member[1], $score[2], $member[2]);\n    $data = $redis-&gt;zRevRangeByScore($key[0], 3, 0, ['withScores' =&gt; true, 'limit' =&gt; array(0, 3)]);\n    var_dump($data);\n\n    $data = $redis-&gt;zRevRank($key[0], $member[0]);\n    var_dump($data);\n\n    $data = $redis-&gt;zScore($key[0], $member[0]);\n    var_dump($data);\n\n    $redis-&gt;del($key[0]);\n    $redis-&gt;del($key[1]);\n    $redis-&gt;del($key[2]);\n    $redis-&gt;zAdd($key[0], $score[0], $member[0], $score[1], $member[1]);\n    $redis-&gt;zAdd($key[1], $score[0], $member[0], $score[3], $member[3]);\n    $data = $redis-&gt;zUnionStore($key[2], [$key[1], $key[0]]);\n    var_dump($data);\n\n    $cursor = 0;\n    $redis-&gt;del('a');\n    $redis-&gt;zAdd('a',1,'a1',2,'a2',3,'a3',4,'a4',5,'a5');\n    $data = [];\n    do {\n        $keys = $redis-&gt;zScan('a',$cursor,'*',1);\n        $data = array_merge($data,$keys);\n    } while ($cursor);\n    var_dump($data);\n\n})","link":"/Components/Redis/sortedSets.html"},{"id":224,"title":"hyperloglog","content":"Redis HyperLogLog\nRedis 在 2.8.9 版本添加了 HyperLogLog 结构。\nRedis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。\n在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。\n但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。\n操作方法\n\n\n\n方法名称\n参数\n说明\n备注\n\n\n\n\npfAdd\n$key, $elements\n添加指定元素到 HyperLogLog 中。\n传入一个索引数组\n\n\npfCount\n$key\n返回给定 HyperLogLog 的基数估算值。\n\n\n\npfMerge\n$deStKey, array $sourceKeys\n将多个 HyperLogLog 合并为一个 HyperLogLog\n传入一个索引数组\n\n\n\n基本使用\n\ngo(function () {\n    $redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host'      =&gt; '127.0.0.1',\n        'port'      =&gt; '6379',\n        'auth'      =&gt; 'easyswoole',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]));;\n\n    $key = [\n        'hp1',\n        'hp2',\n        'hp3',\n        'hp4',\n        'hp5',\n    ];\n    $redis-&gt;del($key[0]);\n    $redis-&gt;del($key[1]);\n    $data = $redis-&gt;pfAdd($key[0], [1, 2, 2, 3, 3]);\n    var_dump($data);\n\n    $redis-&gt;pfAdd($key[1], [1, 2, 2, 3, 3]);\n    $data = $redis-&gt;pfCount([$key[0], $key[1]]);\n    var_dump($data);\n\n    $data = $redis-&gt;pfMerge($key[2], [$key[0], $key[1]]);\n    var_dump($data);\n});\n","link":"/Components/Redis/hyperLogLog.html"},{"id":225,"title":"发布/订阅(pub/sub)","content":"Redis 发布订阅\nRedis发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。\n操作方法\n\n\n\n方法名称\n参数\n说明\n备注\n\n\n\n\n\npSubscribe\n$callback, $pattern, ...$patterns\n订阅一个或多个符合给定模式的频道。\n$callback是回调函数\n\n\n\npubSub\n$subCommand, ...$arguments\n查看订阅与发布系统状态。\n\n\n\n\npublish\n$channel, $message\n将信息发送到指定的频道。\n\n\n\n\npUnSubscribe\n$pattern, ...$patterns\n退订所有给定模式的频道。\n\n\n\n\n\n\n\n\n\n\n\nsubscribe\n$callback, $channel, ...$channels\n订阅给定的一个或多个频道的信息。\n\n\n\n\n\n\n\n\n\n\n\nunsubscribe\n$channel, ...$channels\n指退订给定的频道。\n\n\n\n\n\n\n\n\n\n\n\nsetSubscribeStop\nbool $subscribeStop\n设置是否退出订阅\n当你回调函数想退出时,调用这个命令\n\n\n\nisSubscribeStop\n\n查看当前订阅状态\n\n\n\n\n\n基本使用\n\ndefined(\"REDIS_HOST\") ?: define('REDIS_HOST', '127.0.0.1');\ndefined(\"REDIS_PORT\") ?: define('REDIS_PORT', 6379);\ndefined(\"REDIS_AUTH\") ?: define('REDIS_AUTH', 'easyswoole');\ngo(function () {\n    $redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host'      =&gt; '127.0.0.1',\n        'port'      =&gt; '6379',\n        'auth'      =&gt; 'easyswoole',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]));;\n\n    //新开协程进行订阅\n    go(function () {\n        $redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n            'host' =&gt; REDIS_HOST,\n            'port' =&gt; REDIS_PORT,\n            'auth' =&gt; REDIS_AUTH\n        ]));\n        $redis-&gt;pSubscribe(function (\\EasySwoole\\Redis\\Redis $redis, $pattern, $str) {\n            var_dump($pattern,$str);\n            $data = $redis-&gt;unsubscribe('test');\n            var_dump($data);\n            $redis-&gt;setSubscribeStop(true);\n        }, 'test', 'test1', 'test2');\n    });\n\n    //新开协程进行订阅\n    go(function () {\n        $redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n            'host' =&gt; REDIS_HOST,\n            'port' =&gt; REDIS_PORT,\n            'auth' =&gt; REDIS_AUTH\n        ]));\n        $redis-&gt;subscribe(function (\\EasySwoole\\Redis\\Redis $redis, $pattern, $str) {\n            var_dump($pattern,$str);\n            $data = $redis-&gt;unsubscribe('test');\n            var_dump($data);\n            $redis-&gt;setSubscribeStop(true);\n        }, 'test', 'test1', 'test2');\n    });\n\n    $data = $redis-&gt;pubSub('CHANNELS');\n    var_dump($data);\n    \\Swoole\\Coroutine::sleep(1);\n\n    $data = $redis-&gt;publish('test2', 'test');\n    var_dump($data);\n\n    $data = $redis-&gt;pUnSubscribe('test');\n    var_dump($data);\n\n});\n","link":"/Components/Redis/pubSub.html"},{"id":226,"title":"事物(transaction)","content":"Redis 事务\nRedis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：\n\n批量操作在发送 EXEC 命令前被放入队列缓存。\n收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。\n在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。\n\n一个事务从开始到执行会经历以下三个阶段：\n\n开始事务。\n命令入队。\n执行事务。\n操作方法\n\n\n\n\n\n方法名称\n参数\n说明\n备注\n\n\n\n\ndiscard\n\n取消事务(回滚)\n\n\n\nexec\n\n执行事务(获取事务结果)\n\n\n\nmulti\n\n开始事务\n\n\n\nunWatch\n\n取消 WATCH 命令对所有 key 的监视\n\n\n\nwatch\n$key, ...$keys\n监视key\n\n\n\n\n开始事务之后,操作命令都将返回\"QUEUED\",直到取消事务或者执行事务,执行exec之后,将返回所有命令结果\n在集群中并不支持事务.\n基本使用\ngo(function () {\n    $redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host'      =&gt; '127.0.0.1',\n        'port'      =&gt; '6379',\n        'auth'      =&gt; 'easyswoole',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]));\n    $data = $redis-&gt;multi();\n    var_dump($data);\n    $redis-&gt;del('ha');\n    $data = $redis-&gt;hset('ha', 'a', 1);\n    var_dump($data);\n    $data = $redis-&gt;hset('ha', 'b', '2');\n    var_dump($data);\n    $data = $redis-&gt;hset('ha', 'c', '3');\n    var_dump($data);\n    $data = $redis-&gt;hGetAll('ha');\n    var_dump($data);\n    $data = $redis-&gt;exec();\n    var_dump($data);\n\n    $redis-&gt;multi();\n    $data = $redis-&gt;discard();\n    var_dump($data);\n    $data = $redis-&gt;watch('a', 'b', 'c');\n    var_dump($data);\n    $data = $redis-&gt;unwatch();\n    var_dump($data);\n\n});","link":"/Components/Redis/transaction.html"},{"id":227,"title":"管道(pipe)","content":"Redis 管道技术\nRedis 管道技术可以在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应。\n操作方法\n\n\n\n方法名称\n参数\n说明\n备注\n\n\n\n\ndiscardPipe\n\n取消管道\n\n\n\nexecPipe\n\n一次性发送命令\n\n\n\nstartPipe\n\n管道开始记录\n\n\n\n\n开始管道之后,操作命令都将返回\"PIPE\",直到取消管道或者执行,执行exec之后,将返回所有命令结果\n管道开始后,所有命令调用之后并不会执行,而是会记录起来,然后等待exec的时候一次性发送给redis服务端\n所以需要注意内存,一次管道不要执行过多的命令\n集群目前不支持管道模式,将会出现错误\n基本使用\ngo(function () {\n    $redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host'      =&gt; '127.0.0.1',\n        'port'      =&gt; '6379',\n        'auth'      =&gt; 'easyswoole',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]));;\n\n    $redis-&gt;get('a');\n    $data = $redis-&gt;startPipe();\n    var_dump($data);\n    $redis-&gt;del('ha');\n    $data = $redis-&gt;hset('ha', \"a\", \"a\\r\\nb\\r\\nc\");\n    var_dump($data);\n    $data = $redis-&gt;hset('ha', 'b', '2');\n    var_dump($data);\n    $data = $redis-&gt;hset('ha', 'c', '3');\n    var_dump($data);\n    $data = $redis-&gt;hGetAll('ha');\n    var_dump($data);\n    $data = $redis-&gt;execPipe();\n\n    var_dump($data);\n\n    $redis-&gt;startPipe();\n    $data = $redis-&gt;set(\"a\", '1');\n    var_dump($data);\n    $data = $redis-&gt;discardPipe();\n    var_dump($data);\n\n});","link":"/Components/Redis/pipe.html"},{"id":228,"title":"server命令","content":"Redis 服务器\nRedis 服务器命令主要是用于管理 redis 服务。\n操作方法\n\n\n\n方法列表\n方法名称\n参数\n说明\n备注\n\n\n\n\nbgRewriteAof\n\n手动触发重写操作。\n\n\n\nbgSave\n\n在后台异步保存当前数据库的数据到磁盘\n\n\n\nclientKill\n$data\n关闭客户端连接\n\n\n\nclientList\n\n获取连接到服务器的客户端连接列表\n\n\n\nclientGetName\n\n获取连接的名称\n\n\n\nclientPause\n$timeout\n在指定时间内终止运行来自客户端的命令\n\n\n\nclientSetName\n$connectionName\n设置当前连接的名称\n\n\n\ncommand\n\n获取 Redis 命令详情数组\n\n\n\ncommandCount\n\n获取 Redis 命令总数\n\n\n\ncommandGetKeys\n...$data\n获取给定命令的所有键\n\n\n\ntime\n\n返回当前redis服务器时间\n\n\n\ncommandInfo\n$commandName, ...$commandNames\n获取指定 Redis 命令描述的数组\n\n\n\nconfigGet\n$parameter\n获取指定配置参数的值\n\n\n\nconfigRewrite\n\n对启动 Redis 服务器时所指定的 redis.conf 配置文件进行改写\n\n\n\nconfigSet\n$parameter, $value\n修改 redis 配置参数,无需重启\n\n\n\nconfigResetStat\n\n重置 INFO 命令中的某些统计数据\n\n\n\ndBSize\n\n返回当前数据库的 key 的数量\n\n\n\ndebugObject\n$key\n获取 key 的调试信息\n\n\n\ndebugSegfault\n\n让 Redis 服务崩溃\n\n\n\nflushAll\n\n删除所有数据库的所有key\n\n\n\nflushDb\n\n删除当前数据库的所有key\n\n\n\ninfo\n$section = null\n获取 Redis 服务器的各种信息和统计数值\n\n\n\nlastSave\n\n返回最近一次 Redis 成功将数据保存到磁盘上的时间，以 UNIX 时间戳格式表示\n\n\n\nmonitor\ncallable $callback\nredis监视器,实时打印出 Redis 服务器接收到的命令\n\n\n\nisMonitorStop\n\n判断是否开启监视器\n\n\n\nsetMonitorStop\nbool $monitorStop\n设置停止监视器\n\n\n\nrole\n\n返回主从实例所属的角色\n\n\n\nsave\n\n同步保存数据到硬盘\n\n\n\nshutdown\n\n异步保存数据到硬盘，并关闭服务器\n\n\n\nslowLog\n$subCommand, ...$argument\n管理 redis 的慢日志\n\n\n\nSYNC\n\n用于复制功能(replication)的内部命令\n\n\n\n\n基本使用\n&lt;?php  \ngo(function () {\n    $redisConfig = new \\EasySwoole\\Redis\\Config\\RedisConfig();\n    $redisConfig-&gt;setAuth('easyswoole');\n    $redis = new \\EasySwoole\\Redis\\Redis($redisConfig);\n\n    $data = $redis-&gt;bgRewriteAof();\n    var_dump($data);\n    \\Swoole\\Coroutine::sleep(1);\n    $data = $redis-&gt;bgSave();\n    var_dump($data);\n    $data = $redis-&gt;clientList();\n    var_dump($data);\n    $data = $redis-&gt;clientSetName('test');\n    var_dump($data);\n    $data = $redis-&gt;clientGetName();\n    var_dump($data);\n    $data = $redis-&gt;clientPause(1);\n    var_dump($data);\n    $data = $redis-&gt;command();\n    var_dump($data);\n    $data = $redis-&gt;commandCount();\n    var_dump($data);\n    $data = $redis-&gt;commandGetKeys('MSET', 'a', 'b', 'c', 'd');\n    var_dump($data);\n    $data = $redis-&gt;time();\n    var_dump($data);\n    $data = $redis-&gt;commandInfo('get', 'set');\n    var_dump($data);\n    $data = $redis-&gt;configGet('*max-*-entries*');\n    var_dump($data);\n\n    $data = $redis-&gt;configSet('appendonly', 'yes');\n    var_dump($data);\n    $data = $redis-&gt;configRewrite();\n    var_dump($data);\n    $data = $redis-&gt;configResetStat();\n    var_dump($data);\n    $data = $redis-&gt;dBSize();\n    var_dump($data);\n    $redis-&gt;set('a', 1);\n    $data = $redis-&gt;debugObject('a');\n    var_dump($data);\n    $data = $redis-&gt;flushAll();\n    var_dump($data);\n    $data = $redis-&gt;flushDb();\n    var_dump($data);\n    $data = $redis-&gt;info();\n    var_dump($data);\n    $data = $redis-&gt;lastSave();\n    var_dump($data);\n    go(function () {\n        $redisConfig = new \\EasySwoole\\Redis\\Config\\RedisConfig();\n        $redisConfig-&gt;setAuth('easyswoole');\n        $redis = new \\EasySwoole\\Redis\\Redis($redisConfig);\n        $redis-&gt;monitor(function ( \\EasySwoole\\Redis\\Redis $redis, $data) {\n            $this-&gt;assertIsString($data);\n            $redis-&gt;set('a', 1);\n            $redis-&gt;setMonitorStop(true);\n        });\n    });\n\n    go(function () {\n        $redisConfig = new \\EasySwoole\\Redis\\Config\\RedisConfig();\n        $redisConfig-&gt;setAuth('easyswoole');\n        $redis = new \\EasySwoole\\Redis\\Redis($redisConfig);\n        \\Swoole\\Coroutine::sleep(1);\n        $redis-&gt;set('a', 1);\n    });\n\n    $data = $redis-&gt;save();\n    var_dump($data);\n    $data = $redis-&gt;clientKill($data[0]['addr']);\n    var_dump($data);\n    $data = $redis-&gt;slowLog('get', 'a');\n    var_dump($data, $redis-&gt;getErrorMsg());\n    var_dump($data);\n});","link":"/Components/Redis/server.html"},{"id":229,"title":"geohash","content":"操作方法\n\n\n\n方法名称\n参数\n说明\n备注\n\n\n\n\ngeoAdd\n$key, $locationData\n新增geohash数据\n$locationData为一个数组,写法为:[[longitude=&gt;'',latitude=&gt;'',name=&gt;'']] 或者 $locationData[[longitude,latitude,name]]\n\n\ngeoDist\n$key, $location1, $location2, $unit = 'm'\n返回排序集合表示的地理空间索引中两个成员之间的距离。\n\n\n\ngeoHash\n$key, $location, ...$locations\n返回表示地理空间索引的hash值\n\n\n\ngeoPos\n$key, $location1, ...$locations\n返回按键处有序集合表示的地理空间索引的所有指定成员的位置（经度，纬度）。\n\n\n\ngeoRadius\n$key, $longitude, $latitude, $radius, $unit = 'm', $withCoord = false, $withDist = false, $withHash = false, $count = null, $sort = null, $storeKey = null, $storeDistKey = null\n返回填充了地理空间信息的已排序集合的成员\n\n\n\ngeoRadiusByMember\n$key, $location, $radius, $unit = 'm', $withCoord = false, $withDist = false, $withHash = false, $count = null, $sort = null, $storeKey = null, $storeDistKey = null\n该命令与 GEORADIUS 完全相同，唯一的区别在于，它不是以查询区域的中心为经度和纬度值，而是采用已存在于有序集合所代表的地理空间索引内的成员的名称。\n\n\n\n\n基本使用\n\ngo(function () {\n    $redis = new \\EasySwoole\\Redis\\Redis(new \\EasySwoole\\Redis\\Config\\RedisConfig([\n        'host'      =&gt; '127.0.0.1',\n        'port'      =&gt; '6379',\n        'auth'      =&gt; 'easyswoole',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_NONE\n    ]));;\n\n    $key = 'testGeohash';\n\n    $redis-&gt;del($key);\n    $data = $redis-&gt;geoAdd($key, [\n        ['118.6197800000', '24.88849', 'user1',],\n        ['118.6197800000', '24.88859', 'user2',],\n        ['114.8197800000', '25.88849', 'user3'],\n        ['118.8197800000', '22.88849', 'user4'],\n    ]);\n    var_dump($data);\n\n    $data = $redis-&gt;geoDist($key, 'user1', 'user2');\n    var_dump($data);\n\n    $data = $redis-&gt;geoHash($key, 'user1', 'user2');\n    var_dump($data);\n\n    $data = $redis-&gt;geoPos($key, 'user1', 'user2');\n    var_dump($data);\n\n    $data = $redis-&gt;geoRadius($key, '118.6197800000', '24.88849', 100, 'm', false, false, false, null,'desc');\n    var_dump($data);\n\n    $data = $redis-&gt;geoRadiusByMember($key, 'user1', 100, 'm', false, false, false, 2,'DESC');\n    var_dump($data);\n});","link":"/Components/Redis/geoHash.html"},{"id":230,"title":"集群方法(cluster)","content":"操作方法\n方法列表\n\n\n\n方法名称\n参数\n说明\n备注\n\n\n\n\nclusterNodes\n\n获取集群节点\n\n\n\nclusterAddSlots\n$slots\n集群槽位变更,$slots可以为字符串,可以为数组\n\n\n\nclusterCountFailureReports\n$nodeId\n集群计数失败报告\n\n\n\nclusterCountKeySinSlot\n$slot\n返回指定的 Redis Cluster 哈希槽中的键的数量。\n\n\n\nclusterDelSlots\n$slot\n删除一个哈希槽\n\n\n\nclusterFailOver\n$option = null\n手动故障转移\n\n\n\nclusterForget\n$nodeId\n删除指定的节点。\n\n\n\nclusterGetKeySinSlot\n$slot, $count\n返回存储节点中的密钥名称数组，并哈希到指定的哈希槽。\n\n\n\nclusterInfo\n\n集群信息\n\n\n\nclusterKeySlot\n$key\n返回key的集群槽\n\n\n\nclusterMeet\n$ip, $port\n节点连接到工作群集。\n\n\n\nclusterReplicate\n$nodeId\n集群复制\n\n\n\nclusterReset\n$option = null\n集群重置\n\n\n\nclusterSaveConfig\n\n强制节点将nodes.conf配置保存到磁盘上。\n\n\n\nclusterSetConfigEpoch\n$configEpoch\n在新节点中设置特定的配置时期\n\n\n\nclusterSetSlot\n$slot, $subCommand, $nodeId = null\n更改接收节点中散列槽的状态\n\n\n\nclusterSlaves\n$nodeId\n获取从指定主节点复制的从节点列表。\n\n\n\nclusterSlots\n\n返回有关哪些集群插槽映射到哪些 Redis 实例的详细信息。。\n\n\n\nreadonly\n\n启用读取查询以连接到 Redis 群集从属节点。\n\n\n\nreadwrite\n\n禁用与 Redis 集群从属节点的连接的读取查询。\n\n\n\n\n基本使用\ngo(function () {\n    $redis = new \\EasySwoole\\Redis\\RedisCluster(new \\EasySwoole\\Redis\\Config\\RedisClusterConfig([\n        ['172.16.253.156', 9001],\n        ['172.16.253.156', 9002],\n        ['172.16.253.156', 9003],\n        ['172.16.253.156', 9004],\n    ], [\n        'auth'      =&gt; '',\n        'serialize' =&gt; \\EasySwoole\\Redis\\Config\\RedisConfig::SERIALIZE_PHP\n    ]));\n\n    $data = $redis-&gt;clusterNodes();\n    var_dump($data);\n\n    $data = $redis-&gt;clusterKeySlot('key1');\n    var_dump($data);\n\n    $data = $redis-&gt;clusterCountFailureReports(current($redis-&gt;getNodeList())['name']);\n    var_dump($data);\n\n    $data = $redis-&gt;clusterCountKeySinSlot(1);\n    var_dump($data);\n\n    $data = $redis-&gt;clusterFailOver('FORCE');\n    var_dump($data);\n\n    $redis-&gt;tryConnectServerList();\n    $data = $redis-&gt;clusterForget(array_column(($redis-&gt;getNodeList()), 'name')[0]);\n    var_dump($data);\n\n    $redis-&gt;set('a', 1);\n    $data = $redis-&gt;clusterKeySlot('a');\n    var_dump($data);\n    $data = $redis-&gt;clusterGetKeySinSlot($data, 1);\n    var_dump($data);\n\n    $data = $redis-&gt;clusterInfo();\n    var_dump($data);\n\n    $data = $redis-&gt;clusterKeySlot('b');\n    var_dump($data);\n\n    $data = $redis-&gt;clusterMeet('172.16.253.156', '9005');\n    var_dump($data);\n});\n\n由于集群方法运行较为复杂,需要操作不同的客户端实现某种方法的实例,所以本示例只提供了部分代码,没有全部,可自行调用测试","link":"/Components/Redis/clusterMethod.html"},{"id":231,"title":"安装及使用","content":"memcache协程客户端\nmemcache协程客户端,由swoole 协程client实现   \n组件要求\n\neasyswoole/spl: ^1.1 \n\n安装方法\n\ncomposer require easyswoole/memcache\n\n仓库地址\neasyswoole/memcache\n客户端调用\n$config = new \\EasySwoole\\Memcache\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 11211\n]);\n$client = new EasySwoole\\Memcache\\Memcache($config);\n使用示例:\n$config = new \\EasySwoole\\Memcache\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 11211\n]);\n$client = new EasySwoole\\Memcache\\Memcache($config);\n$client-&gt;set('a',1);\n$client-&gt;get('a');\n使用方法:\ntouch摸一下(刷新有效期)\ntouch($key, $expiration, $timeout = null)\nincrement自增KEY\nincrement($key, $offset = 1, $initialValue = 0, $expiration = 0, $timeout = null)\ndecrement自减KEY\ndecrement($key, $offset = 1, $initialValue = 0, $expiration = 0, $timeout = null)\nset设置KEY(覆盖)\nset($key, $value, $expiration = 0, $timeout = null)\nadd增加KEY(非覆盖)\nadd($key, $value, $expiration = 0, $timeout = null)\nreplace替换一个KEY\nreplace($key, $value, $expiration = 0, $timeout = null)\nappend追加数据到末尾\nappend($key, $value, $timeout = null)\nprepend追加数据到开头\nprepend($key, $value, $timeout = null)\nget获取KEY\nget($key, $timeout = null)\ndelete删除一个key\ndelete($key, $timeout = null)\nstats获取服务器状态\nstats($type = null, $timeout = null)\nversion获取服务器版本\nversion(int $timeout = null)\nflush  清空缓存\nflush(int $expiration = null, int $timeout = null)\nsetMulti 存储多个元素\npublic function setMulti(array $items, $expiration = null, $timeout = null)\ngetMulti 检索多个元素\npublic function getMulti(array $keys, bool $isCas = false, $timeout = null)\ncas 检查并设置\npublic function cas(float $casToken, string $key, $value, int $expiration = null, $timeout = null)\n进阶使用\nMemcache连接池示例\n安装 easyswoole/pool 组件\n\ncomposer require easyswoole/pool\n\n具体pool相关详细用法可查看 连接池\n新增MemcachePool管理器\n新增文件/App/Pool/MemcachePool.php\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: Tioncico\n * Date: 2019/10/15 0015\n * Time: 14:46\n */\n\nnamespace App\\Pool;\n\nuse EasySwoole\\Memcache\\Memcache;\nuse EasySwoole\\Pool\\Config;\nuse EasySwoole\\Pool\\AbstractPool;\nuse EasySwoole\\Memcache\\Config as MemcacheConfig;\n\nclass MemcachePool extends AbstractPool\n{\n    protected $memcacheConfig;\n\n    /**\n     * 重写构造函数,为了传入memcache配置\n     * RedisPool constructor.\n     * @param Config      $conf\n     * @param MemcacheConfig $memcacheConfig\n     * @throws \\EasySwoole\\Pool\\Exception\\Exception\n     */\n    public function __construct(Config $conf,MemcacheConfig $memcacheConfig)\n    {\n        parent::__construct($conf);\n        $this-&gt;memcacheConfig = $memcacheConfig;\n    }\n\n    protected function createObject():Memcache\n    {\n        //根据传入的memcache配置进行new 一个memcache客户端\n        $memcache = new Memcache($this-&gt;memcacheConfig);\n        return $memcache;\n    }\n}\n注册到Manager中(在initialize事件中注册):\n\n$config = new \\EasySwoole\\Pool\\Config();\n\n$memcacheConfig1 = new \\EasySwoole\\Memcache\\Config(Config::getInstance()-&gt;getConf('MEMCACHE1'));\n\\EasySwoole\\Pool\\Manager::getInstance()-&gt;register(new \\App\\Pool\\MemcachePool($config,$memcacheConfig1),'memcache1');\n\n$memcacheConfig2 = new \\EasySwoole\\Memcache\\Config(Config::getInstance()-&gt;getConf('MEMCACHE2'));\n\\EasySwoole\\Pool\\Manager::getInstance()-&gt;register(new \\App\\Pool\\MemcachePool($config,$memcacheConfig2),'memcache2');\n\n调用(可在控制器中全局调用):\ngo(function (){\n    $memcachePool1 = Manager::getInstance()-&gt;get('memcache1');\n    $memcachePool2 = Manager::getInstance()-&gt;get('memcache2');\n    $memcache1 = $memcachePool1-&gt;getObj();\n    $memcache2 = $memcachePool2-&gt;getObj();\n\n    var_dump($memcache1-&gt;set('name', '仙士可1'));\n    $this-&gt;response()-&gt;write($memcache1-&gt;get('name'));\n    var_dump($memcache2-&gt;set('name', '仙士可2'));\n    $this-&gt;response()-&gt;write($memcache2-&gt;get('name'));\n\n    //回收对象\n    $memcachePool1-&gt;recycleObj($memcache1);\n    $memcachePool2-&gt;recycleObj($memcache2);\n});","link":"/Components/Memcache/memcache.html"},{"id":232,"title":"安装及使用","content":"FastCache 2.x\nEasySwoole 提供了一个快速缓存，是基础UnixSock通讯和自定义进程存储数据实现的，提供基本的缓存服务，本缓存为解决小型应用中，需要动不动就部署Redis服务而出现。\n目前 Fast-Cache 组件最新版本为 2.x，2.x 版本为了让快速缓存变得更轻量级，所以放弃了落地重启恢复数据的特性，推荐用户使用 Memcached EasySwoole Memcached 组件 或者 Redis EasySwoole Redis 组件 对缓存数据进行落地处理。\n如果想要使用 1.3.x 版本的 Fast-Cache 组件，请查看文档 Fast-Cache 组件 1.3.x\n组件要求\n\nphp: &gt;=7.1.0\neasyswoole/component: ^2.0\neasyswoole/spl: ^1.1\n\n安装方法\n\ncomposer require easyswoole/fast-cache\n\n仓库地址\neasyswoole/fast-cache\n基本使用\n服务注册\n我们在EasySwoole全局的事件中进行注册\n&lt;?php\n\nuse EasySwoole\\FastCache\\Cache;\n// 在最新的 2.x 中，改为 config 配置文件配置\n$config = new \\EasySwoole\\FastCache\\Config();\n$config-&gt;setTempDir(EASYSWOOLE_TEMP_DIR);\nCache::getInstance($config)-&gt;attachToServer(ServerManager::getInstance()-&gt;getSwooleServer());\n\n// 老版本（2.x 以前）依旧使用以下即可\nCache::getInstance()-&gt;setTempDir(EASYSWOOLE_TEMP_DIR)-&gt;attachToServer(ServerManager::getInstance()-&gt;getSwooleServer());\nFastCache只能在服务启动之后使用,需要有创建unix sock权限(建议使用vm,docker或者linux系统开发),虚拟机共享目录文件夹是无法创建unix sock监听的\n客户端调用\n服务启动后，可以在任意位置调用\nuse EasySwoole\\FastCache\\Cache;\nCache::getInstance()-&gt;set('get','a');\nvar_dump(Cache::getInstance()-&gt;get('get'));\n相关方法\n\n设置临时目录\n\npublic function setTempDir(string $tempDir): Cache\n\n设置缓存进程数  \n\npublic function setProcessNum(int $num): Cache\n\n设置缓存进程所在服务名   \n\npublic function setServerName(string $serverName): Cache\n\n设置定时回调，可用于数据定时落地   \n\npublic function setOnTick($onTick): Cache\n\n设置定时回调间隔  \n\npublic function setTickInterval($tickInterval): Cache \n\n设置进程启动回调，可以用于数据落地恢复   \n\npublic function setOnStart($onStart): Cache   \n\n设置进程关闭回调，可以用于数据落地   \n\npublic function setOnShutdown(callable $onShutdown): Cache  \n\n设置指定 key 的值    \n\npublic function set($key, $value, ?int $ttl = null, float $timeout = 1.0)\n\n获取指定 key 的值\n\npublic function get($key, float $timeout = 1.0)\n\n删除指定 key的值\n\npublic function unset($key, float $timeout = 1.0)\n\n获取所有key的值\n\npublic function keys($key = null, float $timeout = 1.0): ?array\n\n清空所有进程的数据\n\npublic function flush(float $timeout = 1.0)\n\n推入队列\n\npublic function enQueue($key, $value, $timeout = 1.0)\n\n从队列中取出\n\npublic function deQueue($key, $timeout = 1.0)\n\n获取队列当前长度\n\npublic function queueSize($key, $timeout = 1.0)\n\n释放队列\n\npublic function unsetQueue($key, $timeout = 1.0)\n\n返回当前队列的全部key名称\n\npublic function queueList($timeout = 1.0): ?array\n\n清空所有队列\n\npublic function flushQueue(float $timeout = 1.0): bool\n\n设置一个key的过期时间\n\npublic function expire($key, int $ttl, $timeout = 1.0)\n\n移除一个key的过期时间   \n\npublic function persist($key, $timeout = 1.0)\n\n查看某个key的ttl   \n\npublic function ttl($key, $timeout = 1.0)\n\n将哈希表 key 中的字段 field 的值设为 value\n\nfunction hSet($key, $field, $value, float $timeout = 1.0)\n\n获取存储在哈希表中指定字段的值\n\nfunction hGet($key, $field = null, float $timeout = 1.0)\n\n删除一个哈希表字段\n\nfunction hDel($key, $field = null, float $timeout = 1.0)\n\n清空所有\n\nfunction hFlush(float $timeout = 1.0)\n\n获取所有哈希表中的字段\n\nfunction hKeys($key, float $timeout = 1.0)\n\n迭代哈希表中的键值对\n\nfunction hScan($key, $cursor = 0, $limit = 10, float $timeout = 1.0)\n\n只有在字段 field 不存在时，设置哈希表字段的值\n\nfunction hSetnx($key, $field, $value, float $timeout = 1.0)\n\n查看哈希表 key 中，指定的字段是否存在\n\nfunction hExists($key, $field, float $timeout = 1.0)\n\n获取哈希表中字段的数量\n\nfunction hLen($key, float $timeout = 1.0)\n\n为哈希表 key 中的指定字段的整数值加上\n\nfunction hIncrby($key, $field, $value, float $timeout = 1.0)\n\n同时将多个 field-value对设置到哈希表 key 中\n\nfunction hMset($key, $fieldValues, float $timeout = 1.0)\n\n获取所有给定字段的值\n\nfunction hMget($key, $fields, float $timeout = 1.0)\n\n获取哈希表中所有值\n\nfunction hVals($key, float $timeout = 1.0)\n\n获取在哈希表中指定 key 的所有字段和值\n\nfunction hGetAll($key, float $timeout = 1.0)\n\n\n消息队列支持\n如具体查看消息队列，请查看FastCacheQueue","link":"/Components/FastCache/fastCache.html"},{"id":233,"title":"安装及使用","content":"Queue 介绍\n原理\nEasySwoole 封装实现了一个轻量级的队列，默认使用 Redis 作为队列驱动器。\n用户可以自己实现一个队列驱动器来实现队列，用 kafka 作为队列驱动器或者 其他驱动器方式 作为队列驱动器，来进行存储。\n从上可知，Queue 并不是一个单独使用的组件，它更像一个对不同驱动的队列进行统一封装的门面组件。\nQueue 组件当前最新稳定版本为 3.x。\n旧版本 (2.1.x) 的 Queue 组件的使用，请看 Queue 2.1.x\n组件要求\n\next-swoole: &gt;=4.4.0\neasyswoole/component: ^2.0\neasyswoole/redis-pool: ~2.2.0\n\n安装方法\n\ncomposer require easyswoole/queue 3.x\n\n仓库地址\neasyswoole/queue 3.x\n基本使用\n默认自带的队列驱动为 Redis 队列。这里简单列举 2 种用户可使用的方式：\n\n在框架的任意位置进行生产和消费队列任务。\n在框架的任意位置进行生产队列任务， 然后在自定义进程中进行消费任务。\n\n在框架中进行生产和消费任务\n创建队列\nuse EasySwoole\\Queue\\Driver\\RedisQueue;\nuse EasySwoole\\Queue\\Job;\nuse EasySwoole\\Queue\\Queue;\nuse EasySwoole\\Redis\\Config\\RedisConfig;\n\n// 配置 Redis 队列驱动器\n$redisConfig = new RedisConfig([\n    'host' =&gt; '127.0.0.1', // 服务端地址 默认为 '127.0.0.1'\n    'port' =&gt; 6379, // 端口 默认为 6379\n    'auth' =&gt; '', // 密码 默认为 不设置\n    'db'   =&gt; 0, // 默认为 0 号库\n]);\n\n// 创建队列\n$queue = new Queue(new RedisQueue($redisConfig));\n普通生产任务\n$queue 为上述创建队列中得到的队列对象。\n// 创建任务\n$job = new Job();\n\n// 设置任务数据\n$job-&gt;setJobData(\"this is my job data time time \".date('Ymd h:i:s'));\n\n// 生产普通任务\n$queue-&gt;producer()-&gt;push($job);\n普通消费任务\n$queue 为上述创建队列中得到的队列对象。\n// 消费任务\n$job = $queue-&gt;consumer()-&gt;pop();\n\n// 或者是自定义进程中消费任务(具体使用请看下文自定义进程消费任务完整使用示例)\n$queue-&gt;consumer()-&gt;listen(function (Job $job){\n    var_dump($job);\n});\n生产延迟任务\n$queue 为上述创建队列中得到的队列对象。\n// 创建任务\n$job = new Job();\n\n// 设置任务数据\n$job-&gt;setJobData(\"this is my job data time time \".date('Ymd h:i:s'));\n\n// 设置任务延后执行时间\n$job-&gt;setDelayTime(5);\n\n// 生产延迟任务\n$queue-&gt;producer()-&gt;push($job);\n生产可信任务\n// 创建任务\n$job = new Job();\n\n// 设置任务数据\n$job-&gt;setJobData(\"this is my job data time time \".date('Ymd h:i:s'));\n\n// 设置任务重试次数为 3 次。任务如果没有确认，则会执行三次\n$job-&gt;setRetryTimes(3);\n\n// 如果5秒内没确认任务，会重新回到队列。默认为3秒\n$job-&gt;setWaitConfirmTime(5);\n\n// 投递任务\n$queue-&gt;producer()-&gt;push($job);\n\n// 确认一个任务\n$queue-&gt;consumer()-&gt;confirm($job);\n在框架中生产任务和自定义进程中消费任务\n\n注册队列驱动器\n设置消费进程\n生产者投递任务\n\n定义一个队列\n&lt;?php\n\nnamespace App\\Utility;\n\nuse EasySwoole\\Component\\Singleton;\nuse EasySwoole\\Queue\\Queue;\n\nclass MyQueue extends Queue\n{\n    use Singleton;\n}\n定义消费进程\n&lt;?php\n\nnamespace App\\Utility;\n\nuse EasySwoole\\Component\\Process\\AbstractProcess;\nuse EasySwoole\\Queue\\Job;\n\nclass QueueProcess extends AbstractProcess\n{\n    protected function run($arg)\n    {\n        go(function (){\n            MyQueue::getInstance()-&gt;consumer()-&gt;listen(function (Job $job){\n                var_dump($job-&gt;getJobData());\n            });\n        });\n    }\n}\n\n支持多进程、多协程消费\n\n注册队列驱动器、消费进程及设置生产者投递任务\n&lt;?php\n\nnamespace EasySwoole\\EasySwoole;\n\nuse App\\Utility\\MyQueue;\nuse App\\Utility\\QueueProcess;\nuse EasySwoole\\Component\\Timer;\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\nuse EasySwoole\\Queue\\Job;\n\nclass EasySwooleEvent implements Event\n{\n    public static function initialize()\n    {\n        date_default_timezone_set('Asia/Shanghai');\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        // redis pool 使用请看 redis 章节文档\n        $redisConfig = new \\EasySwoole\\Redis\\Config\\RedisConfig(\n            [\n                'host' =&gt; '127.0.0.1', // 服务端地址 默认为 '127.0.0.1'\n                'port' =&gt; 6379, // 端口 默认为 6379\n                'auth' =&gt; '', // 密码 默认为 不设置\n                'db'   =&gt; 0, // 默认为 0 号库\n            ]\n        );\n        // 配置 队列驱动器\n        $driver = new \\EasySwoole\\Queue\\Driver\\RedisQueue($redisConfig, 'easyswoole_queue');\n        MyQueue::getInstance($driver);\n        // 注册一个消费进程\n        $processConfig = new \\EasySwoole\\Component\\Process\\Config([\n            'processName' =&gt; 'QueueProcess', // 设置 自定义进程名称\n            'processGroup' =&gt; 'Queue', // 设置 自定义进程组名称\n            'enableCoroutine' =&gt; true, // 设置 自定义进程自动开启协程\n        ]);\n        \\EasySwoole\\Component\\Process\\Manager::getInstance()-&gt;addProcess(new QueueProcess($processConfig));\n        // 模拟生产者，可以在任意位置投递\n        $register-&gt;add($register::onWorkerStart, function ($server, $id) {\n            if ($id == 0) {\n                Timer::getInstance()-&gt;loop(3000, function () {\n                    $job = new Job();\n                    $job-&gt;setJobData(['time' =&gt; \\time()]);\n                    MyQueue::getInstance()-&gt;producer()-&gt;push($job);\n                });\n            }\n        });\n    }\n}\n\n进程安全退出问题请看 自定义进程 章节。\n\n控制器使用\n以在 http 服务中为例，使用示例代码如下：\n&lt;?php\n\nnamespace App\\HttpController;\n\nuse App\\Utility\\MyQueue;\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\nuse EasySwoole\\Http\\Message\\Status;\nuse EasySwoole\\Queue\\Driver\\RedisQueue;\nuse EasySwoole\\Queue\\Job;\nuse EasySwoole\\Queue\\Queue;\nuse EasySwoole\\Redis\\Config\\RedisConfig;\n\nclass Index extends Controller\n{\n    // 生产普通任务\n    public function producer1()\n    {\n        // 获取队列\n        $queue = MyQueue::getInstance();\n\n        // 创建任务\n        $job = new Job();\n\n        // 设置任务数据\n        $job-&gt;setJobData(\"this is my job data time time \" . date('Ymd h:i:s'));\n\n        var_dump('producer1 =&gt; ');\n        var_dump($job-&gt;getJobData());\n\n        // 生产普通任务\n        $produceRes = $queue-&gt;producer()-&gt;push($job);\n        if (!$produceRes) {\n            $this-&gt;writeJson(Status::CODE_OK, [], '队列生产普通任务失败!');\n        } else {\n            $this-&gt;writeJson(Status::CODE_OK, [], '队列生产普通任务成功!');\n        }\n    }\n\n    // 生产延迟任务\n    public function producer2()\n    {\n        // 获取队列\n        $queue = MyQueue::getInstance();\n\n        // 创建任务\n        $job = new Job();\n\n        // 设置任务数据\n        $job-&gt;setJobData(\"this is my job data time time \" . date('Ymd h:i:s'));\n\n        // 设置任务延后执行时间\n        $job-&gt;setDelayTime(5);\n\n        var_dump('producer2 =&gt; ');\n        var_dump($job-&gt;getJobData());\n\n        // 生产延迟任务\n        $produceRes = $queue-&gt;producer()-&gt;push($job);\n        if (!$produceRes) {\n            $this-&gt;writeJson(Status::CODE_OK, [], '队列生产延迟任务失败!');\n        } else {\n            $this-&gt;writeJson(Status::CODE_OK, [], '队列生产延迟任务成功!');\n        }\n    }\n\n    // 生产可信任务\n    public function producer3()\n    {\n        // 获取队列\n        $queue = MyQueue::getInstance();\n\n        // 创建任务\n        $job = new Job();\n\n        // 设置任务数据\n        $job-&gt;setJobData(\"this is my job data time time \" . date('Ymd h:i:s'));\n\n        var_dump('producer3 =&gt; ');\n        var_dump($job-&gt;getJobData());\n\n        // 设置任务重试次数为 3 次。任务如果没有确认，则会执行三次\n        $job-&gt;setRetryTimes(3);\n\n        // 如果5秒内没确认任务，会重新回到队列。默认为3秒\n        $job-&gt;setWaitConfirmTime(5);\n\n        // 投递任务\n        $queue-&gt;producer()-&gt;push($job);\n\n        // 确认一个任务\n        $queue-&gt;consumer()-&gt;confirm($job);\n    }\n\n    // 消费任务\n    public function consumer()\n    {\n        // 获取队列\n        $queue = MyQueue::getInstance();\n\n        ### 消费任务\n        // 获取到需要消费的任务\n        $job = $queue-&gt;consumer()-&gt;pop();\n\n        if (!$job) {\n            $this-&gt;writeJson(Status::CODE_OK, [], '没有队列任务需要消费了!');\n            return false;\n        }\n\n        // 获取需要消费的任务的数据\n        $jobData = $job-&gt;getJobData();\n        var_dump($jobData);\n    }\n}\n进阶使用\n我们可以自定义驱动，实现 RabbitMQ、Kafka 等消费队列软件的封装。\n用户需要定义类，并实现 \\EasySwoole\\Queue\\QueueDriverInterface 接口的几个方法即可。该接口的详细实现请看下文。\nQueueDriverInterface 接口类实现\n&lt;?php\n\nnamespace EasySwoole\\Queue;\n\ninterface QueueDriverInterface\n{\n    public function push(Job $job,float $timeout = 3.0): bool;\n\n    public function pop(float $timeout = 3.0, array $params = []): ?Job;\n\n    public function info(): ?array;\n\n    public function confirm(Job $job,float $timeout = 3.0): bool;\n}\n相关仓库\nEasySwoole 中利用 Redis 实现消息队列  \n如何利用 EasySwoole 多进程多协程 Redis 队列实现爬虫","link":"/Components/Queue/queue.html"},{"id":234,"title":"kafka","content":"kafka\nKafka是一种高吞吐量的分布式发布订阅消息系统，有如下特性：\n通过O(1)的磁盘数据结构提供消息的持久化，这种结构对于即使数以TB的消息存储也能够保持长时间的稳定性能。\n高吞吐量：即使是非常普通的硬件Kafka也可以支持每秒数百万的消息。\n支持通过Kafka服务器和消费机集群来分区消息。\n支持Hadoop并行数据加载。\n\n本项目代码参考自 https://github.com/weiboad/kafka-php\n\n组件要求\n\nphp: &gt;=7.1.0\next-swoole: ^4.4.5\neasyswoole/component: ^2.0\neasyswoole/spl: ^1.1\n\n安装方法\n\ncomposer require easyswoole/kafka\n\n仓库地址\neasyswoole/kafka\n基本使用\n注册kafka服务\nnamespace EasySwoole\\EasySwoole;\n\nuse App\\Producer\\Process as ProducerProcess;\nuse App\\Consumer\\Process as ConsumerProcess;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\n\nclass EasySwooleEvent implements Event\n{\n\n    public static function initialize()\n    {\n        // TODO: Implement initialize() method.\n        date_default_timezone_set('Asia/Shanghai');\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        // TODO: Implement mainServerCreate() method.\n        // 生产者\n        \\EasySwoole\\Component\\Process\\Manager::getInstance()-&gt;addProcess(new ProducerProcess());\n        // 消费者\n        \\EasySwoole\\Component\\Process\\Manager::getInstance()-&gt;addProcess(new ConsumerProcess());\n    }\n}\n\n生产者\nnamespace App\\Producer;\n\nuse EasySwoole\\Component\\Process\\AbstractProcess;\nuse EasySwoole\\Kafka\\Config\\ProducerConfig;\nuse EasySwoole\\Kafka\\Kafka;\n\nclass Process extends AbstractProcess\n{\n    protected function run($arg)\n    {\n        go(function () {\n            $config = new ProducerConfig();\n            $config-&gt;setMetadataBrokerList('127.0.0.1:9092,127.0.0.1:9093');\n            $config-&gt;setBrokerVersion('0.9.0');\n            $config-&gt;setRequiredAck(1);\n\n            $kafka = new Kafka($config);\n            $result = $kafka-&gt;producer()-&gt;send([\n                [\n                    'topic' =&gt; 'test',\n                    'value' =&gt; 'message--',\n                    'key'   =&gt; 'key--',\n                ],\n            ]);\n\n            var_dump($result);\n            var_dump('ok');\n        });\n    }\n}\n消费者\nnamespace App\\Consumer;\n\nuse EasySwoole\\Component\\Process\\AbstractProcess;\nuse EasySwoole\\Kafka\\Config\\ConsumerConfig;\nuse EasySwoole\\Kafka\\Kafka;\n\nclass Process extends AbstractProcess\n{\n    protected function run($arg)\n    {\n        go(function () {\n            $config = new ConsumerConfig();\n            $config-&gt;setRefreshIntervalMs(1000);\n            $config-&gt;setMetadataBrokerList('127.0.0.1:9092,127.0.0.1:9093');\n            $config-&gt;setBrokerVersion('0.9.0');\n            $config-&gt;setGroupId('test');\n\n            $config-&gt;setTopics(['test']);\n            $config-&gt;setOffsetReset('earliest');\n\n            $kafka = new Kafka($config);\n            // 设置消费回调\n            $func = function ($topic, $partition, $message) {\n                var_dump($topic);\n                var_dump($partition);\n                var_dump($message);\n            };\n            $kafka-&gt;consumer()-&gt;subscribe($func);\n        });\n    }\n}\n\n附赠\n\nKafka 集群部署 docker-compose.yml 一份，使用方式如下\n\n保证2181,9092,9093,9000端口未被占用（占用后可以修改compose文件中的端口号）\n根目录下，docker-compose up -d\n访问localhost:9000，可以查看kafka集群状态。\n\n\n\n\nhttps://github.com/easy-swoole/kafka/blob/master/docker-compose.yml\n","link":"/Components/kafka.html"},{"id":235,"title":"nsq","content":"NSQ客户端\nNSQ 是实时的分布式消息处理平台，其设计的目的是用来大规模地处理每天数以十亿计级别的消息。\n它具有分布式和去中心化拓扑结构，该结构具有无单点故障、故障容错、高可用性以及能够保证消息的可靠传递的特征。\n组件要求\n\nphp: &gt;=5.3.0\next-json: *\neasyswoole/easyswoole: 3.x\neasyswoole/http-client: ^1.2.5\neasyswoole/pool: ^1.0\neasyswoole/spl: ^1.1\nmonolog/monolog: ~1.0\nreact/react: &gt;=0.2.1\n\n安装方法\n\ncomposer require easyswoole/nsq\n\n仓库地址\neasyswoole/nsq\n基本使用\n注册Nsq服务\nnamespace EasySwoole\\EasySwoole;\n\nuse App\\Producer\\Process as ProducerProcess;\nuse App\\Consumer\\Process as ConsumerProcess;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\n\nclass EasySwooleEvent implements Event\n{\n\n    public static function initialize()\n    {\n        // TODO: Implement initialize() method.\n        date_default_timezone_set('Asia/Shanghai');\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        // TODO: Implement mainServerCreate() method.\n        // 生产者\n        \\EasySwoole\\Component\\Process\\Manager::getInstance()-&gt;addProcess(new ProducerProcess());\n        // 消费者\n        \\EasySwoole\\Component\\Process\\Manager::getInstance()-&gt;addProcess(new ConsumerProcess());\n    }\n\n    ......\n\n}\n\n生产者\nnamespace App\\Producer;\n\nuse EasySwoole\\Component\\Process\\AbstractProcess;\n\nclass Process extends AbstractProcess\n{\n    protected function run($arg)\n    {\n        go(function () {\n            $config = new \\EasySwoole\\Nsq\\Config();\n            $topic  = \"topic.test\";\n            $nsqlookup = new \\EasySwoole\\Nsq\\Lookup\\Nsqlookupd($config-&gt;getNsqdUrl());\n            $hosts = $nsqlookup-&gt;lookupHosts($topic);\n\n            foreach ($hosts as $host) {\n                $nsq = new \\EasySwoole\\Nsq\\Nsq();\n                for ($i = 0; $i &lt; 10; $i++) {\n                    $msg = new \\EasySwoole\\Nsq\\Message\\Message();\n                    $msg-&gt;setPayload(\"test$i\");\n                    $nsq-&gt;push(\n                        new \\EasySwoole\\Nsq\\Connection\\Producer($host, $config),\n                        $topic,\n                        $msg\n                    );\n                }\n            }\n        });\n    }\n}\n消费者\nnamespace App\\Consumer;\n\nuse EasySwoole\\Component\\Process\\AbstractProcess;\n\nclass Process extends AbstractProcess\n{\n    protected function run($arg)\n    {\n        go(function () {\n            $topic      = \"topic.test\";\n            $config     = new \\EasySwoole\\Nsq\\Config();\n            $nsqlookup  = new \\EasySwoole\\Nsq\\Lookup\\Nsqlookupd($config-&gt;getNsqdUrl());\n            $hosts      = $nsqlookup-&gt;lookupHosts($topic);\n            foreach ($hosts as $host) {\n                $nsq = new \\EasySwoole\\Nsq\\Nsq();\n                $nsq-&gt;subscribe(\n                    new \\EasySwoole\\Nsq\\Connection\\Consumer($host, $config, $topic, 'test.consuming'),\n                    function ($item) {\n                        var_dump($item['message']);\n                    }\n                );\n            }\n        });\n    }\n}\n\n附赠\n\nNsq 集群部署 docker-compose.yml 一份，使用方式如下\n\n保证4150,4151,4160,4161,4171端口未被占用（占用后可以修改compose文件中的端口号）\n根目录下，docker-compose up -d\n访问localhost:4171，可以查看Web版 nsqadmin 状态。\n\n\n\n\nhttps://github.com/easy-swoole/nsq/blob/master/docker-compose.yml\n","link":"/Components/nsq.html"},{"id":236,"title":"安装及使用","content":"FastCacheQueue\nEasySwoole FastCache组件在&gt;= 1.2.1的时候新增类似· beanstalkd消息队列 ·特性。\n\n可以创建多个queue\n支持延迟投递\n任务超时恢复执行\n任务重发执行\n任务最大重发次数\n支持putJob、delayJob、releaseJob、reserveJob、buryJob、kickJob等命令\n\n基本使用\nFastCacheQueue依托于FastCache，具体安装请查看FastCache\n服务注册\n更新后，EasySwoole\\FastCache\\CacheProcessConfig类多出以下方法\n/** 设置进程最大内存 默认512M */\npublic function setMaxMem(string $maxMem): void\n/** 设置消息队列保留时间 默认60s （取出任务后没有及时确认会重新放回队列） */\npublic function setQueueReserveTime(int $queueReserveTime): void\n/** 设置消息队列最大重发次数 默认10 达到次数后重发将会被丢弃 */\npublic function setQueueMaxReleaseTimes(int $queueMaxReleaseTimes): void\n开始使用\n下文示例代码的Job和Cache都使用以下命名空间\nuse EasySwoole\\FastCache\\Cache;\nuse EasySwoole\\FastCache\\Job;\n投递任务\n投递成功之后 将会返回该任务的jobId。\n没有失败情况，除非fastCache注册注册失败。\n$job = new Job();\n$job-&gt;setData(\"siam\"); // 任意类型数据\n$job-&gt;setQueue(\"siam_queue\");\n$jobId = Cache::getInstance()-&gt;putJob($job);\nvar_dump($jobId);\n取出任务\n可以开启自定义进程当消费者，循环监听队列，执行任务处理。\n注意：任务执行完成一定要有一个结果。要么删除该任务，要么重发。否则当任务取出一定时间后（默认60s）会自动放回队列中。\n$job = Cache::getInstance()-&gt;getJob('siam_queue');// Job对象或者null\nif ($job === null){\n    echo \"没有任务\\n\";\n}else{\n    // 执行业务逻辑\n    var_dump($job);\n    // 执行完了要删除或者重发，否则超时会自动重发\n    Cache::getInstance()-&gt;deleteJob($job);\n}\n清空ready任务队列\n\n var_dump(Cache::getInstance()-&gt;flushReadyJobQueue('siam_queue'));\n\n var_dump(Cache::getInstance()-&gt;jobQueueSize('siam_queue'));\n延迟执行任务\n$job = new Job();\n$job-&gt;setData(\"siam\");\n$job-&gt;setQueue(\"siam_queue_delay\");\n$job-&gt;setDelay(5);// 延时5s\n$jobId = Cache::getInstance()-&gt;putJob($job);\nvar_dump($jobId);\n// 马上取会失败 隔5s取才成功\n$job = Cache::getInstance()-&gt;getJob('siam_queue_delay');\nvar_dump($job);\n删除任务\n可以是由getJob取出的对象，也可以自己声明Job对象，传入JobId来删除。\n$job = new Job();\n$job-&gt;setJobId(1);\n$job-&gt;setQueue('siam_queue_delay');\nCache::getInstance()-&gt;deleteJob($job);\n任务重发\n任务执行失败，或者某些场景需要重新执行，则可以重发。\n重发时，可以指定是否延迟执行。\n// get出来的任务执行失败可以重发\n$job = new Job();\n$job-&gt;setData(\"siam\");\n$job-&gt;setQueue(\"siam_queue\");\n$jobId = Cache::getInstance()-&gt;putJob($job);\n\n$job = Cache::getInstance()-&gt;getJob('siam_queue');\n\nif ($job === null){\n    echo \"没有任务\\n\";\n}else{\n    // 执行业务逻辑\n    $doRes = false;\n    if (!$doRes){\n        // 业务逻辑失败,需要重发  \n        // 如果延迟队列需要马上重发,在这里需要清空delay属性\n        // $job-&gt;setDelay(0);\n        // 如果普通队列需要延迟重发,则设置delay属性\n        // $job-&gt;setDelay(5);\n        $res = Cache::getInstance()-&gt;releaseJob($job);\n        var_dump($res);\n    }else{\n        // 执行完了要删除或者重发，否则超时会自动重发\n        Cache::getInstance()-&gt;deleteJob($job);\n    }\n}\n返回现在有什么队列\n$queues = Cache::getInstance()-&gt;jobQueues();\nvar_dump($queues);\n返回某个队列的长度\n$queueSize = Cache::getInstance()-&gt;jobQueueSize(\"siam_queue\");\n$queueSize2 = Cache::getInstance()-&gt;jobQueueSize(\"siam_queue_delay\");\nvar_dump($queueSize);\nvar_dump($queueSize2);\n清空队列 可指定名称\n// 清空全部\n$res = Cache::getInstance()-&gt;flushJobQueue();\nvar_dump($res);\n\n// 清空siam_queue队列\n$res = Cache::getInstance()-&gt;flushJobQueue('siam_queue');\nvar_dump($res);\n将任务改为延迟状态\n//添加任务\n$job = new Job();\n$job-&gt;setData(\"LuffyQAQ\");\n$job-&gt;setQueue(\"LuffyQAQ_queue_delay\");\n$jobId = Cache::getInstance()-&gt;putJob($job);\n\n//方法一 直接传入jobId\n$job-&gt;setJobId($jobId);\n$job-&gt;setDelay(30);\nvar_dump(Cache::getInstance()-&gt;delayJob($job));\n\n//方法二 取出任务\n$job = Cache::getInstance()-&gt;getJob('LuffyQAQ_queue_delay');\n$job-&gt;setDelay(30);\nvar_dump(Cache::getInstance()-&gt;delayJob($job));\n\n//使用jobQueueSize查看队列长度\n$queueSize = Cache::getInstance()-&gt;jobQueueSize(\"LuffyQAQ_queue_delay\");\nvar_dump($queueSize);\n\n从延迟执行队列中拿取\n//传入队列名\nvar_dump(Cache::getInstance()-&gt;getDelayJob('LuffyQAQ_queue_delay'));\n\n清空delay任务队列\n\n var_dump(Cache::getInstance()-&gt;flushDelayJobQueue('LuffyQAQ_queue_delay'));\n\n var_dump(Cache::getInstance()-&gt;jobQueueSize('LuffyQAQ_queue_delay'));\n将任务改为保留状态\n//添加任务\n$job = new Job();\n$job-&gt;setData(\"LuffyQAQ\");\n$job-&gt;setQueue(\"LuffyQAQ_queue_reserve\");\n$jobId = Cache::getInstance()-&gt;putJob($job);\n\n//方法一 直接传入jobId\n$job-&gt;setJobId($jobId);\nvar_dump(Cache::getInstance()-&gt;reserveJob($job));\n\n//方法二 取出任务\n$job = Cache::getInstance()-&gt;getJob('LuffyQAQ_queue_reserve');\nvar_dump(Cache::getInstance()-&gt;reserveJob($job));\n\n//使用jobQueueSize查看队列长度\n$queueSize = Cache::getInstance()-&gt;jobQueueSize(\"LuffyQAQ_queue_reserve\");\nvar_dump($queueSize);\n从保留队列中拿取\n//传入队列名\nvar_dump(Cache::getInstance()-&gt;getReserveJob('LuffyQAQ_queue_reserve'));\n\n清空reserve任务队列\n\n var_dump(Cache::getInstance()-&gt;flushReserveJobQueue('LuffyQAQ_queue_reserve'));\n\n var_dump(Cache::getInstance()-&gt;jobQueueSize('LuffyQAQ_queue_reserve'));\n将任务改为埋藏状态\n$job = new Job();\n$job-&gt;setQueue('LuffyQAQ_queue_bury');\n$job-&gt;setData('LuffyQAQ');\n$jobId = Cache::getInstance()-&gt;putJob($job);\n$job-&gt;setJobId($jobId);\n\nvar_dump(Cache::getInstance()-&gt;buryJob($job));\n\n//使用jobQueueSize查看队列长度\n$queueSize = Cache::getInstance()-&gt;jobQueueSize(\"LuffyQAQ_queue_bury\");\nvar_dump($queueSize);\n\n从埋藏队列中拿取\n//传入队列名\nvar_dump(Cache::getInstance()-&gt;getBuryJob('LuffyQAQ_queue_bury'));\n\n将埋藏队列任务恢复到ready中\n\nvar_dump(Cache::getInstance()-&gt;kickJob($job));\n\n清空bury任务队列\n\n var_dump(Cache::getInstance()-&gt;flushBuryJobQueue('LuffyQAQ_queue_bury'));\n\n var_dump(Cache::getInstance()-&gt;jobQueueSize('LuffyQAQ_queue_bury'));","link":"/Components/FastCache/fastCacheQueue.html"},{"id":237,"title":"微服务理念","content":"微服务\n微服务的意义\n&ensp;&ensp;&ensp;&ensp;例如我们在开发一个基础的商场系统时，可能分为 用户模块、商品模块、订单模块、活动模块 等，系统建设初期，我们也许为了快速上线和节约成本，那么就会采用直接把一整套的模块代码，全部写在一个项目代码中。\n而在后期流量上来后，我们会发现，经常因为某个模块的的功能模块失效，导致整个服务瘫痪。例如 活动模块 和 商品模块 是最容易在高流量下瘫痪的模块。\n举个例子，在 2018 年的双十一活动中，某商场系统花了很多钱去做广告，导致很高流量直接进入到商场系统当中，而在此之前，也没做服务拆分，那么 活动模块 的高流量导致 数据库 和 带宽 完全无法支撑，最终整个商场系统全部进入黑洞状态，用户既无法进入活动页面，就连正常的商场首页也无法打开。\n后面，在 EasySwoole 项目组 的建议下，将商场系统进行了 模块化服务拆分，例如，活动系统 就是一个独立的服务，用户参与活动的时候，直接从客户端调用活动服务接口，活动服务需要验证商品和用户数据的时候，又通过 RPC 调用 进行服务间的数据交互。\n从而实现压力的分摊，不再让全部的服务压力都堆积到 单台服务器 或 数据库 上，且在最糟糕的情况下，即使活动模块瘫痪，也不会导致整个商场系统不可用。\n因此微服务的主要意义在于：流量分压、模块高度自治、服务隔离保护。\n什么是微服务框架\n&ensp;&ensp;&ensp;&ensp;实际上，所谓的 微服务框架，是一种错误的说法，微服务是一种架构性上的概念，与框架无关。例如，在上述的案例当中，我们服务间的互相调用，可以用 HTTP 协议 或者是 原生 TCP 协议 来实现，因此实际上，微服务和框架没有一点关系。而如果真的要牵强地说是微服务框架的话，那其实无非是类似某些框架做了一些组件的封装，让你更加方便的实现 RPC 调用。例如 EasySwoole 就提供了 RPC 封装、基础的服务发现 和 注册中心。但是实际上，这仅仅是工具，真正的微服务，最核心的其实是 如何做好服务间的最小粒度切分，其实这个 服务切分 是属于架构规划上的范畴。\n服务限流\n再举一个我们生活中的例子：一些热门的旅游景点，往往会对每日的旅游参观人数有严格的限制，比如厦门的鼓浪屿、北京的故宫等，每天只会卖出固定数目的门票，如果你去的晚了，可能当天的票就已经卖完了，当天就无法进去游玩了。\n为什么旅游景点要做这样的限制呢？多卖一些门票多赚一些钱岂不是更好？\n其实对于旅游景点而言，他们也很无奈，因为景点的服务资源有限，每日能服务的人数是有限的，一旦放开限制了，景点的工作人员就会不够用，卫生情况也得不到保障，安全也有隐患，超密集的人群也会严重影响游客的体验。\n但由于景区名气大，来游玩的旅客络绎不绝，远超出了景区的承载能力，因此景区只好做出限制每日人员流量的举措。\n同理，在 IT 软件行业中，系统服务也是这样的。如果你的系统理论上单位时间内可服务 100W 用户，但是今天却突然来了 300W 用户，由于用户流量的随机性，如果不加以限流，很有可能这 300W 用户一下子就压垮了系统，导致所有人都得不到服务。\n因此为了保证系统至少还能为 100W 用户提供正常服务，我们需要对系统进行限流设计。\n有的人可能会想，既然会有 300W 用户来访问，那么为什么系统不干脆设计成能足以支撑这么大用户量的集群呢？\n这是个好问题。如果系统是长期有 300W 的用户来访问，肯定是要做上述升级的，但是常常面临的情况是，系统的日常访问量就是 100W，只不过偶尔由于一些不可预知的特定原因导致的短时间的流量激增，这个时候，公司往往出于节约成本的考虑，不会为了一个不常见的尖峰来把我们的系统扩容到最大的尺寸。\n如何限流\n在实际的应用当中，流量入口应该是：\n防火墙 --&gt; API 网关  -&gt; 服务\n因此，实际上我们是有三个地方可以进行限流。那么，防火墙 和 API 网关 我们则不再进行讲解，那是运维做的事情。我们要说的是 API 网关 的自我保护。在 EasySwoole 中，有提供了一个基础的 AtomicLimit 组件，原理与令牌桶差不多，有兴趣的同学可以去看下。当然 EasySwoole 也支持其他方式的限流，你可以在流量入口的 onRequest 方法中进行拦截。\n熔断保护\n这个模式是需要系统在设计之初，就要把 熔断措施 考虑进去。当系统出现问题时，如果短时间内无法修复，系统要自动做出判断，开启熔断开关，拒绝流量访问，避免大流量对后端的过载请求。系统也应该能够动态监测后端程序的修复情况，当程序已恢复稳定时，可以关闭熔断开关，恢复正常服务。\n服务降级\n将系统的所有功能服务进行一个分级，当系统出现问题，需要紧急限流时，可将不是那么重要的功能进行降级处理，停止服务，这样可以释放出更多的资源提供给核心功能去使用。\n例如在电商平台中，如果突发流量激增，可临时将商品评论、积分等非核心功能进行降级，停止这些服务，释放出机器和 CPU 等资源来保障用户正常下单，而这些降级的功能服务可以等整个系统恢复正常后，再来启动，进行补单/补偿处理。\n除了功能降级以外，还可以采用不直接操作数据库，而全部读缓存、写缓存的方式作为临时降级方案。\n延迟处理\n这个模式需要在系统的前端设置一个流量缓冲池，将所有的请求全部缓冲进这个池子，不立即处理。然后后端真正的业务处理程序从这个池子中取出请求依次处理，常见的可以用队列模式来实现。这就相当于用异步的方式去减少了后端的处理压力，但是当流量较大时，后端的处理能力有限，缓冲池里的请求可能处理不及时，会有一定程度延迟。\n特权处理\n这个模式需要将用户进行分类，通过预设的分类，让系统优先处理需要高保障的用户群体，其它用户群体的请求就会延迟处理或者直接不处理。\n当然，微服务还有很多东西，本文只是进行基础的概念科普，具体可以请教架构师。","link":"/Microservices/introduction.html"},{"id":238,"title":"架构说明","content":"EasySwoole RPC\n基础概念介绍\n很多传统的 Phper 并不懂 RPC 是什么，RPC 全称 Remote Procedure Call，中文译为 远程过程调用，其实你可以把它理解为是一种架构性上的设计，或者是一种解决方案。\n例如在某庞大商场系统中，你可以把整个商场拆分为 N 个微服务（理解为 N 个独立的小模块也行），例如：\n\n订单系统\n用户管理系统\n商品管理系统\n等等 \n\n那么在这样的架构中，就会存在一个 API 网关 的概念，或者是叫 服务集成者。我的 API 网关 的职责，就是把一个请求，拆分成 N 个小请求，分发到各个小服务里面，再整合各个小服务的结果，返回给用户。例如在某次下单请求中，那么大概发送的逻辑如下：\n\nAPI 网关接受请求\nAPI 网关提取用户参数，请求用户管理系统，获取用户余额等信息，等待结果\nAPI 网关提取商品参数，请求商品管理系统，获取商品剩余库存和价格等信息，等待结果\nAPI 网关融合用户管理系统、商品管理系统的返回结果，进行下一步调用（假设满足购买条件）\nAPI 网关调用用户管理信息系统进行扣款，调用商品管理系统进行库存扣减，调用订单系统进行下单（事务逻辑和撤回可以用 请求 id 保证，或者自己实现其他逻辑调度）\nAPI 网关返回综合信息给用户\n\n而在以上发生的行为，就称为 远程过程调用。而调用过程实现的通讯协议可以有很多，比如常见的 HTTP 协议。而 EasySwoole RPC 采用自定义短链接的 TCP 协议实现，每个请求包，都是一个 JSON，从而方便实现跨平台调用。\n微服务相关概念说明\n\n什么是服务熔断？\n\n简单理解，一般是 某个服务故障 或者是 异常 引起的，类似现实世界中的 &quot;保险丝&quot;，当某个异常条件被触发，直接熔断整个服务，而不是一直等到此服务超时。\n\n什么是服务降级?\n\n简单理解，一般是从整体负荷考虑，就是当某个服务熔断之后，服务器将不再被调用，此时客户端可以自己准备一个本地的 fallback 回调，返回一个缺省值，这样做，虽然服务水平下降，但总比服务直接挂掉要强。服务降级处理是在客户端实现完成的，与服务端没有关系。\n\n什么是服务限流？\n\n简单理解，例如某个服务器最多同时仅能处理 100 个请求，或者是 CPU 负载达到百分之80 的时候，为了保护服务的稳定性，则不再希望继续收到 新的连接。那么此时就要求客户端不再对其发起请求。因此 EasySwoole RPC 提供了 NodeManager (节点管理器)接口，你可以以任何形式来 监控你的服务提供者，在 getNodes() 方法中，返回对应的服务器节点信息即可。\nRPC 5.x 全新特性\n\n协程调度\n服务自动发现\n服务熔断\n服务降级\nOpenssl 加密\n跨平台、跨语言支持\n支持接入第三方注册中心\n\n目前最新稳定版本的 RPC 组件为 RPC 5.x。4.x 版本的 RPC 组件的使用，请看 RPC 4.x。其他旧版本组件的使用文档请看 Github\n组件要求\n\nphp: &gt;=7.1.0\next-swoole: &gt;=4.4.5\next-json: &gt;=1.0\next-sockets: *\next-openssl: &gt;=7.1\neasyswoole/spl: ^1.0\neasyswoole/utility: ^1.0\neasyswoole/component: ^2.0\n\n安装方法\n\ncomposer require easyswoole/rpc=5.x\n\n仓库地址\neasyswoole/rpc=5.x\n执行流程\n\n基础使用 Demo\n关于 RPC 5.x 版本使用的基础 demo 可查看 Github RPC 5.x Demo Github 或者 Gitee RPC 5.x Demo Gitee","link":"/Microservices/Rpc/introduction.html"},{"id":239,"title":"配置","content":"RPC 组件配置及使用\n配置\n主配置\n&lt;?php\n// 构造方法内用户可传入 节点管理器实现类(实现 `NodeManagerInterface` 接口的类) 默认为 `MemoryManager`\n$config = new \\EasySwoole\\Rpc\\Config();\n\n// 设置服务名称\n$config-&gt;setServerName('User'); // 默认 EasySwoole\n\n// 设置节点id\n$config-&gt;setNodeId(\\EasySwoole\\Utility\\Random::character(10)); // 可忽略 构造函数已经设置\n\n// 【必须设置】设置异常处理器，对 Service-Worker 和 AssistWorker 的异常进行处理，防止未捕获导致进程退出\n$config-&gt;setOnException(function (\\Throwable $throwable) {\n\n});\n服务端\n&lt;?php\n/** @var \\EasySwoole\\Rpc\\Config $config */\n$serverConfig = $config-&gt;getServer();\n\n// 【必须设置】设置本机 ip 外网 或者 内网 ip 向其他服务端同步本机信息\n$serverConfig-&gt;setServerIp('127.0.0.1');\n\n// 设置工作进程数量\n$serverConfig-&gt;setWorkerNum(4);\n\n// 设置监听地址及端口 端口可被复用\n$serverConfig-&gt;setListenAddress('0.0.0.0');\n$serverConfig-&gt;setListenPort('9600');\n\n// 设置服务端最大接受包大小\n$serverConfig-&gt;setMaxPackageSize(1024 * 1024 * 2);\n\n// 设置接收客户端数据时间\n$serverConfig-&gt;setNetworkReadTimeout(3);\n广播配置\n&lt;?php\n /** @var \\EasySwoole\\Rpc\\Config $config */\n$assistConfig = $config-&gt;getAssist();\n\n// 服务定时自刷新到节点管理器\n$assistConfig-&gt;setAliveInterval(5000);\n\n// 广播进程设置\n$serviceFinderConfig = $assistConfig-&gt;getUdpServiceFinder();\n\n// 监听地址和端口\n$serviceFinderConfig-&gt;setEnableListen(true);\n$serviceFinderConfig-&gt;setListenAddress('0.0.0.0');\n$serviceFinderConfig-&gt;setListenPort(9600);\n\n// 设置广播地址\n$serviceFinderConfig-&gt;setEnableBroadcast(true);\n// 255.255.255.255 udp 广播地址 \n$serviceFinderConfig-&gt;setBroadcastAddress(['127.0.0.1:9600', '127.0.0.1:9601','255.255.255.255:9600']);\n$serviceFinderConfig-&gt;setBroadcastInterval(5000); // 5s 广播一次\n\n// 设置广播秘钥 \n$serviceFinderConfig-&gt;setEncryptKey('EasySwoole');\n客户端配置\n&lt;?php\n// 如果只是暴露 rpc 服务 不进行调用别的rpc服务 可不用设置\n/** @var \\EasySwoole\\Rpc\\Config $config */\n$clientConfig = $config-&gt;getClient();\n\n// 传输最大数据包大小\n$clientConfig-&gt;setMaxPackageSize(1024 * 1024 * 2);\n\n// 设置全局回调函数  成功及失败 $response-&gt;getStatus !== 0 全部为失败\n$clientConfig-&gt;setOnGlobalSuccess(function (\\EasySwoole\\Rpc\\Protocol\\Response $response){\n\n});\n$clientConfig-&gt;setOnGlobalFail(function (\\EasySwoole\\Rpc\\Protocol\\Response $response){\n\n});\n注册服务\n注册 rpc 服务\nEasySwooleEvent 事件 mainServerCreate 注册\n&lt;?php\n\n###### 配置服务端 ######\n// 构造方法内用户可传入 节点管理器实现类(实现 `NodeManagerInterface` 接口的类) 默认为 `MemoryManager`\n$config = new \\EasySwoole\\Rpc\\Config();\n// 设置服务名称\n$config-&gt;setServerName('User'); // 默认 EasySwoole\n// 设置节点id，可忽略，构造函数已经设置\n$config-&gt;setNodeId(\\EasySwoole\\Utility\\Random::character(10)); // \n\n// 【必须设置】设置异常处理器，对 Service-Worker 和 AssistWorker 的异常进行处理，防止未捕获导致进程退出\n$config-&gt;setOnException(function (\\Throwable $throwable) {\n\n});\n\n$serverConfig = $config-&gt;getServer();\n\n// 【必须设置】设置本机ip\n$serverConfig-&gt;setServerIp('127.0.0.1');\n\n/** \n * 注册服务 \n */\n$rpc = new \\EasySwoole\\Rpc\\Rpc($config);\n\n// 创建 ServiceOne 服务 \n$serviceOne = new \\EasySwoole\\Rpc\\Tests\\Service\\ServiceOne();\n// 在 ServiceOne 服务中添加 ModuleOne 模块\n$serviceOne-&gt;addModule(new \\EasySwoole\\Rpc\\Tests\\Service\\ModuleOne());\n// 在 ServiceOne 服务中添加 ModuleTwo 模块\n$serviceOne-&gt;addModule(new \\EasySwoole\\Rpc\\Tests\\Service\\ModuleTwo());\n\n// 创建 ServiceTwo 服务 \n$serviceTwo = new \\EasySwoole\\Rpc\\Tests\\Service\\ServiceTwo();\n// 在 ServiceTwo 服务中添加 ModuleOne 模块\n$serviceTwo-&gt;addModule(new \\EasySwoole\\Rpc\\Tests\\Service\\ModuleOne());\n// 在 ServiceTwo 服务中添加 ModuleTwo 模块\n$serviceTwo-&gt;addModule(new \\EasySwoole\\Rpc\\Tests\\Service\\ModuleTwo());\n\n// 添加服务到服务管理器\n$rpc-&gt;serviceManager()-&gt;addService($serviceOne);\n$rpc-&gt;serviceManager()-&gt;addService($serviceTwo);\n\n// 注册服务\n$http = \\EasySwoole\\EasySwoole\\ServerManager::getInstance()-&gt;getSwooleServer();\n\n$rpc-&gt;attachServer($http);\nRedis 节点管理器实现类(实现 NodeManagerInterface 接口即可)，来完成 rpc 服务端的配置。下文将介绍使用默认节点管理器(即 MemoryManager) 完成 rpc 服务端的配置、rpc 服务的注册及服务调用。\n节点管理器\n&lt;?php\n/** 节点管理器 */\n\n// 用户在调用rpc过程中 当发现节点不可用 可自行调用下线\n\n// 构造方法内用户可传入节点管理器实现`NodeManagerInterface` 默认`MemoryManager`\n$config = new \\EasySwoole\\Rpc\\Config();\n$rpc = new \\EasySwoole\\Rpc\\Rpc($config);\n\n$nodeManager = $rpc-&gt;getConfig()-&gt;getNodeManager();\n\n// 获取服务的所有节点\n$nodeManager-&gt;getNodes('serviceOne', 1);\n\n// 随机获取服务的一个节点\n$nodeManager-&gt;getNode('serviceOne', 1);\n\n// 下线一个服务节点\n$nodeManager-&gt;offline(new \\EasySwoole\\Rpc\\Server\\ServiceNode());\n\n// 刷新一个服务节点\n$nodeManager-&gt;alive(new \\EasySwoole\\Rpc\\Server\\ServiceNode());\n\n// 宕机一个服务节点\n$nodeManager-&gt;failDown(new \\EasySwoole\\Rpc\\Server\\ServiceNode());","link":"/Microservices/Rpc/config.html"},{"id":240,"title":"服务端","content":"Rpc-Server\n场景\n例如在一个商场系统中，我们将商品库和系统公告两个服务切分开到不同的服务器当中。当用户打开商场首页的时候，\n我们希望 App 向某个网关发起请求，该网关可以自动地帮我们请求商品列表和系统公共等数据，合并返回。\n服务定义\n每一个 Rpc 服务其实就是一个 EasySwoole\\Rpc\\Service\\AbstractService 类，在服务下面我们又分为多个子模块，每个子模块提供不同的服务。 如下：\n定义商品服务\n&lt;?php\n\nnamespace App\\RpcServices;\n\nuse EasySwoole\\Rpc\\Protocol\\Request;\nuse EasySwoole\\Rpc\\Service\\AbstractService;\n\nclass Goods extends AbstractService\n{\n    /**\n     *  重写onRequest(比如可以对方法做ip拦截或其它前置操作)\n     *\n     * @param Request $request\n     * @return bool\n     */\n    protected function onRequest(Request $request): bool\n    {\n        return true;\n    }\n\n    function serviceName(): string\n    {\n        return 'Goods';\n    }\n}\n定义商品服务的子模块\n&lt;?php\n\nnamespace App\\RpcServices;\n\nuse EasySwoole\\Rpc\\Service\\AbstractServiceModule;\n\nclass GoodsModule extends AbstractServiceModule\n{\n    function moduleName(): string\n    {\n        return 'GoodsModule';\n    }\n\n    function list()\n    {\n        $this-&gt;response()-&gt;setResult([\n            [\n                'goodsId' =&gt; '100001',\n                'goodsName' =&gt; '商品1',\n                'prices' =&gt; 1124\n            ],\n            [\n                'goodsId' =&gt; '100002',\n                'goodsName' =&gt; '商品2',\n                'prices' =&gt; 599\n            ]\n        ]);\n        $this-&gt;response()-&gt;setMsg('get goods list success');\n    }\n\n    function exception()\n    {\n        throw new \\Exception('the GoodsModule exception');\n\n    }\n\n    protected function onException(\\Throwable $throwable)\n    {\n        $this-&gt;response()-&gt;setStatus(-1)-&gt;setMsg($throwable-&gt;getMessage());\n    }\n}\n定义公共服务\n&lt;?php\n\nnamespace App\\RpcServices;\n\nuse EasySwoole\\Rpc\\Service\\AbstractService;\n\nclass Common extends AbstractService\n{\n    function serviceName(): string\n    {\n        return 'Common';\n    }\n}\n定义公共服务的子模块\n&lt;?php\n\nnamespace App\\RpcServices;\n\nuse EasySwoole\\Rpc\\Service\\AbstractServiceModule;\n\nclass CommonModule extends AbstractServiceModule\n{\n    function moduleName(): string\n    {\n        return 'CommonModule';\n    }\n\n    public function mailBox()\n    {\n        // 获取client 全局参数\n        $this-&gt;request()-&gt;getClientArg();\n        // 获取参数\n        $this-&gt;request()-&gt;getArg();\n        $this-&gt;response()-&gt;setResult([\n            [\n                'mailId'=&gt;'100001',\n                'mailTitle'=&gt;'系统消息1',\n            ],\n            [\n                'mailId'=&gt;'100001',\n                'mailTitle'=&gt;'系统消息1',\n            ],\n        ]);\n        $this-&gt;response()-&gt;setMsg('get mail list success');\n    }\n\n    public function serverTime()\n    {\n        $this-&gt;response()-&gt;setResult(time());\n        $this-&gt;response()-&gt;setMsg('get server time success');\n    }\n}\n服务注册\n在 EasySwoole 全局事件（即项目根目录的 EasySwooleEvent 文件）中，进行服务注册。至于节点管理、服务类定义等具体用法请看对应章节。\n&lt;?php\n\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\n\nclass EasySwooleEvent implements Event\n{\n    public static function initialize()\n    {\n        date_default_timezone_set('Asia/Shanghai');\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        ###### 注册 rpc 服务 ######\n        /** rpc 服务端配置 */\n        $config = new \\EasySwoole\\Rpc\\Config();\n        $config-&gt;setNodeId('EasySwooleRpcNode1');\n        $config-&gt;setServerName('EasySwoole'); // 默认 EasySwoole\n        $config-&gt;setOnException(function (\\Throwable $throwable) {\n\n        });\n\n        $serverConfig = $config-&gt;getServer();\n        // 单机部署内部调用时可指定为 127.0.0.1\n        // 分布式部署时多台调用时请填 0.0.0.0\n        $serverConfig-&gt;setServerIp('127.0.0.1');\n\n        // rpc 具体配置请看配置章节\n        $rpc = new \\EasySwoole\\Rpc\\Rpc($config);\n\n        // 创建 Goods 服务\n        $goodsService = new \\App\\RpcServices\\Goods();\n        // 添加 GoodsModule 模块到 Goods 服务中\n        $goodsService-&gt;addModule(new \\App\\RpcServices\\GoodsModule());\n        // 添加 Goods 服务到服务管理器中\n        $rpc-&gt;serviceManager()-&gt;addService($goodsService);\n\n        // 创建 Common 服务\n        $commonService = new \\App\\RpcServices\\Common();\n        // 添加 CommonModule 模块到 Common 服务中\n        $commonService-&gt;addModule(new \\App\\RpcServices\\CommonModule());\n        // 添加 Common 服务到服务管理器中\n        $rpc-&gt;serviceManager()-&gt;addService($commonService);\n\n        // 此刻的rpc实例需要保存下来 或者采用单例模式继承整个Rpc类进行注册 或者使用Di\n\n        // 注册 rpc 服务\n        $rpc-&gt;attachServer(ServerManager::getInstance()-&gt;getSwooleServer());\n\n    }\n}\n服务端响应状态码说明\n\n\n\n状态码\n说明\n\n\n\n\n0\n调用成功\n\n\n1001\n获取不到服务端可用节点，调用失败\n\n\n1002\n客户端连接服务端节点超时，调用失败\n\n\n1003\n服务端响应超时，调用失败\n\n\n2001\n服务端读取客户端请求数据包超时，调用失败\n\n\n2002\n客户端发送的数据包不合法，调用失败\n\n\n3000\n服务端节点宕机，调用失败\n\n\n3001\n调用的服务不存在，调用失败\n\n\n3002\n调用服务的子模块不存在，调用失败\n\n\n3003\n调用服务错误，调用失败\n\n\n其他\n未知错误，调用失败\n\n\n\n\n为了方便测试，我把两个服务放在同一台机器中注册。实际生产场景应该是 N 台机注册商品服务，N 台机器注册公告服务，把服务分开。\n","link":"/Microservices/Rpc/server.html"},{"id":241,"title":"客户端","content":"Rpc-Client\n在服务端章节已注册商品及公共服务.\n控制器调用\n&lt;?php\n\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\nuse EasySwoole\\Rpc\\Protocol\\Response;\n\nclass Index extends Controller\n{\n    public function index()\n    {\n        // 如果在同server中 直接用保存的rpc实例调用即可\n        // 如果不是需要重新new一个rpc 注意config的配置 节点管理器 以及所在ip是否能被其他服务广播到 如果不能请调整其他服务的广播地址\n        $config = new \\EasySwoole\\Rpc\\Config();\n        $rpc = new \\EasySwoole\\Rpc\\Rpc($config);\n\n        $ret = [];\n        $client = $rpc-&gt;client();\n        // client 全局参数\n        $client-&gt;setClientArg([1,2,3]);\n        /**\n         * 调用商品列表\n         */\n        $ctx1 = $client-&gt;addRequest('Goods.GoodsModule.list');\n        // 设置请求参数\n        $ctx1-&gt;setArg(['a','b','c']);\n        // 设置调用成功执行回调\n        $ctx1-&gt;setOnSuccess(function (Response $response) use (&amp;$ret) {\n            $ret[] = [\n                'list' =&gt; [\n                    'msg' =&gt; $response-&gt;getMsg(),\n                    'result' =&gt; $response-&gt;getResult()\n                ]\n            ];\n        });\n\n        /**\n         * 调用信箱公共\n         */\n        $ctx2 = $client-&gt;addRequest('Common.CommonModule.mailBox');\n        // 设置调用成功执行回调\n        $ctx2-&gt;setOnSuccess(function (Response $response) use (&amp;$ret) {\n            $ret[] = [\n                'mailBox' =&gt; [\n                    'msg' =&gt; $response-&gt;getMsg(),\n                    'result' =&gt; $response-&gt;getResult()\n                ]\n            ];\n        });\n\n        /**\n         * 获取系统时间\n         */\n        $ctx2 = $client-&gt;addRequest('Common.CommonModule.serverTime');\n        // 设置调用成功执行回调\n        $ctx2-&gt;setOnSuccess(function (Response $response) use (&amp;$ret) {\n            $ret[] = [\n                'serverTime' =&gt; [\n                    'msg' =&gt; $response-&gt;getMsg(),\n                    'result' =&gt; $response-&gt;getResult()\n                ]\n            ];\n        });\n\n        // 执行调用\n        $client-&gt;exec();\n        $this-&gt;writeJson(200, $ret);\n    }\n}","link":"/Microservices/Rpc/client.html"},{"id":242,"title":"自定义节点管理器","content":"EasySwoole RPC 自定义注册中心\nEasySwoole 默认为通过 UDP 广播 + 自定义进程定时刷新自身节点信息的方式来实现无主化/注册中心的服务发现。在服务正常关闭的时候，自定义定时进程的onShutdown\n方法会执行 deleteServiceNode 方法来实现节点下线。在非正常关闭的时候，心跳超时也会被节点管理器踢出。\n有些情况，比如服务都不在一个网段上，由于udp协议的设置，将会广播不到，只能点对点的进行广播数据，就不是很方便。那么 EasySwoole 支持你自定义一个节点管理器，来变更服务注册及发现方式。\n下面实现的 Redis 节点管理器示例是基于 easyswoole/redis-pool 组件 实现，所以请先执行 composer require easyswoole/redis-pool 安装 redis-pool 组件。关于 easyswoole/redis-pool 组件具体用户请查看 easyswoole/redis-pool 章节。\n例如使用 Redis 来实现\n&lt;?php\n\nnamespace App\\RpcServices\\NodeManager;\n\nuse EasySwoole\\Redis\\Redis;\nuse EasySwoole\\RedisPool\\Pool;\nuse EasySwoole\\RedisPool\\RedisPool;\nuse EasySwoole\\Rpc\\NodeManager\\NodeManagerInterface;\nuse EasySwoole\\Rpc\\Server\\ServiceNode;\n\nclass RedisManager implements NodeManagerInterface\n{\n    protected $redisKey;\n\n    protected $ttl;\n\n    /**\n     * @var Pool $pool\n     */\n    protected $pool;\n\n    public function __construct(Pool $pool, string $hashKey = 'rpc', int $ttl = 30)\n    {\n        $this-&gt;pool = $pool;\n        $this-&gt;redisKey = $hashKey;\n        $this-&gt;ttl = $ttl;\n    }\n\n    function getNodes(string $serviceName, ?int $version = null): array\n    {\n        $fails = [];\n        $hits = [];\n        $time = time();\n\n        $redisPool = $this-&gt;pool;\n\n        /** @var Redis $redis */\n        $redis = $redisPool-&gt;defer(15);\n\n        try {\n            $nodes = $redis-&gt;hGetAll(\"{$this-&gt;redisKey}_{$serviceName}\");\n\n            $nodes = $nodes ?: [];\n\n            foreach ($nodes as $nodeId =&gt; $value) {\n                $node = json_decode($value, true);\n                if ($time - $node['lastHeartbeat'] &gt; $this-&gt;ttl) {\n                    $fails[] = $nodeId;\n                    continue;\n                }\n                if ($node['service'] === $serviceName) {\n                    if ($version !== null &amp;&amp; $version === $node['version']) {\n                        $serviceNode = new ServiceNode($node);\n                        $serviceNode-&gt;setNodeId(strval($nodeId));\n                        $hits[$nodeId] = $serviceNode;\n                    } else {\n                        $serviceNode = new ServiceNode($node);\n                        $serviceNode-&gt;setNodeId(strval($nodeId));\n                        $hits[] = $serviceNode;\n                    }\n                }\n            }\n            if (!empty($fails)) {\n                foreach ($fails as $failKey) {\n                    $this-&gt;deleteServiceNode($serviceName, $failKey);\n                }\n            }\n            return $hits;\n        } catch (\\Throwable $throwable) {\n            // 如果该 redis 断线则销毁\n            $redisPool-&gt;unsetObj($redis);\n        } finally {\n            $redisPool-&gt;recycleObj($redis);\n        }\n\n        return [];\n    }\n\n    function getNode(string $serviceName, ?int $version = null): ?ServiceNode\n    {\n        $list = $this-&gt;getNodes($serviceName, $version);\n        if (empty($list)) {\n            return null;\n        }\n        $allWeight = 0;\n\n        $redisPool = $this-&gt;pool;;\n\n        /** @var Redis $redis */\n        $redis = $redisPool-&gt;getObj(15);\n\n        $time = time();\n\n        try {\n            foreach ($list as $node) {\n                /** @var ServiceNode $nodee */\n                $key = $node-&gt;getNodeId();\n                $nodeConfig = $redis-&gt;hGet(\"{$this-&gt;redisKey}_{$serviceName}\", $key);\n                $nodeConfig = json_decode($nodeConfig, true);\n                $lastFailTime = $nodeConfig['lastFailTime'];\n                if ($time - $lastFailTime &gt;= 10) {\n                    $weight = 10;\n                } else {\n                    $weight = abs(10 - ($time - $lastFailTime));\n                }\n                $allWeight += $weight;\n                $node-&gt;__weight = $weight;\n            }\n            mt_srand(intval(microtime(true)));\n            $allWeight = rand(0, $allWeight - 1);\n            foreach ($list as $node) {\n                $allWeight = $allWeight - $node-&gt;__weight;\n                if ($allWeight &lt;= 0) {\n                    return $node;\n                }\n            }\n        } catch (\\Throwable $throwable) {\n            // 如果该 redis 断线则销毁\n            $redisPool-&gt;unsetObj($redis);\n        } finally {\n            $redisPool-&gt;recycleObj($redis);\n        }\n\n        return null;\n    }\n\n    function failDown(ServiceNode $serviceNode): bool\n    {\n\n        $redisPool = $this-&gt;pool;;\n\n        /** @var Redis $redis */\n        $redis = $redisPool-&gt;getObj(15);\n        try {\n            $serviceName = $serviceNode-&gt;getService();\n            $nodeId = $serviceNode-&gt;getNodeId();\n            $hashKey = \"{$this-&gt;redisKey}_{$serviceName}\";\n            $nodeConfig = $redis-&gt;hGet($hashKey, $nodeId);\n            $nodeConfig = json_decode($nodeConfig, true);\n            $nodeConfig['lastFailTime'] = time();\n            $redis-&gt;hSet($hashKey, $nodeId, json_encode($nodeConfig));\n            return true;\n        } catch (\\Throwable $throwable) {\n            // 如果该 redis 断线则销毁\n            $redisPool-&gt;unsetObj($redis);\n        } finally {\n            $redisPool-&gt;recycleObj($redis);\n        }\n\n        return false;\n    }\n\n    function offline(ServiceNode $serviceNode): bool\n    {\n\n        $redisPool = $this-&gt;pool;;\n\n        /** @var Redis $redis */\n        $redis = $redisPool-&gt;getObj(15);\n        try {\n            $serviceName = $serviceNode-&gt;getService();\n            $nodeId = $serviceNode-&gt;getNodeId();\n            $hashKey = \"{$this-&gt;redisKey}_{$serviceName}\";\n            $redis-&gt;hDel($hashKey, $nodeId);\n            return true;\n        } catch (\\Throwable $throwable) {\n            // 如果该 redis 断线则销毁\n            $redisPool-&gt;unsetObj($redis);\n        } finally {\n            $redisPool-&gt;recycleObj($redis);\n        }\n\n        return false;\n    }\n\n    function alive(ServiceNode $serviceNode): bool\n    {\n        $info = [\n            'service' =&gt; $serviceNode-&gt;getService(),\n            'ip' =&gt; $serviceNode-&gt;getIp(),\n            'port' =&gt; $serviceNode-&gt;getPort(),\n            'version' =&gt; $serviceNode-&gt;getVersion(),\n            'lastHeartbeat' =&gt; time(),\n            'lastFailTime' =&gt; 0\n        ];\n\n        $redisPool = $this-&gt;pool;;\n\n        /** @var Redis $redis */\n        $redis = $redisPool-&gt;getObj();\n\n        try {\n            $serviceName = $serviceNode-&gt;getService();\n            $nodeId = $serviceNode-&gt;getNodeId();\n            $hashKey = \"{$this-&gt;redisKey}_{$serviceName}\";\n            $redis-&gt;hSet($hashKey, $nodeId, json_encode($info));\n            return true;\n        } catch (\\Throwable $throwable) {\n            // 如果该 redis 断线则销毁\n            $redisPool-&gt;unsetObj($redis);\n        } finally {\n            $redisPool-&gt;recycleObj($redis);\n        }\n\n        return false;\n    }\n\n    private function deleteServiceNode($serviceName, $failKey): bool\n    {\n        $redisPool = $this-&gt;pool;;\n\n        /** @var Redis $redis */\n        $redis = $redisPool-&gt;getObj(15);\n        try {\n            $redis-&gt;hDel(\"{$this-&gt;redisKey}_{$serviceName}\", $failKey);\n            return true;\n        } catch (\\Throwable $throwable) {\n            $redisPool-&gt;unsetObj($redis);\n        } finally {\n            $redisPool-&gt;recycleObj($redis);\n        }\n\n        return false;\n    }\n}\n /** @var \\EasySwoole\\Rpc\\Config $config */\n$assistConfig = $config-&gt;getAssist();\n\n// 服务定时自刷新到节点管理器\n$assistConfig-&gt;setAliveInterval(5000);\n\n即使关闭了 UDP 定时广播，EasySwoole Rpc 的 AssistWorker 进程依旧会每 5 秒执行一次 serviceAlive 用于更新自身的节点心跳信息。\n\n注册\n&lt;?php\n\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;use EasySwoole\\Redis\\Config\\RedisConfig;use EasySwoole\\RedisPool\\Pool;use EasySwoole\\RedisPool\\RedisPool;\n\nclass EasySwooleEvent implements Event\n{\n    public static function initialize()\n    {\n        date_default_timezone_set('Asia/Shanghai');\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        ###### 注册 rpc 服务 ######\n        /** rpc 服务端配置 */\n        // 采用了redis 节点管理器 可以关闭udp 广播了。\n        $redisM = new RedisManager(new Pool(new RedisConfig(['host' =&gt; '127.0.0.1'])));\n        $config = new \\EasySwoole\\Rpc\\Config($redisM);\n        $config-&gt;setNodeId('EasySwooleRpcNode1');\n        $config-&gt;setServerName('EasySwoole'); // 默认 EasySwoole\n        $config-&gt;setOnException(function (\\Throwable $throwable) {\n\n        });\n\n        $serverConfig = $config-&gt;getServer();\n        $serverConfig-&gt;setServerIp('127.0.0.1');\n\n        // rpc 具体配置请看配置章节\n        $rpc = new \\EasySwoole\\Rpc\\Rpc($config);\n\n        // 创建 Goods 服务\n        $goodsService = new \\App\\RpcServices\\Goods();\n        // 添加 GoodsModule 模块到 Goods 服务中\n        $goodsService-&gt;addModule(new \\App\\RpcServices\\GoodsModule());\n        // 添加 Goods 服务到服务管理器中\n        $rpc-&gt;serviceManager()-&gt;addService($goodsService);\n\n        // 创建 Common 服务\n        $commonService = new \\App\\RpcServices\\Common();\n        // 添加 CommonModule 模块到 Common 服务中\n        $commonService-&gt;addModule(new \\App\\RpcServices\\CommonModule());\n        // 添加 Common 服务到服务管理器中\n        $rpc-&gt;serviceManager()-&gt;addService($commonService);\n\n        // 此刻的rpc实例需要保存下来 或者采用单例模式继承整个Rpc类进行注册 或者使用Di\n\n        // 注册 rpc 服务\n        $rpc-&gt;attachServer(ServerManager::getInstance()-&gt;getSwooleServer());\n\n    }\n}","link":"/Microservices/Rpc/registerCenter.html"},{"id":243,"title":"跨语言","content":"跨平台\nRpc 的请求响应是通过 tcp 作为传输层协议实现，服务广播使用 udp 协议，所以当我们使用其他语言作为 Rpc 客户端时，只需要实现对应的应用层网络协议即可。\n下面客户端使用的服务端是 微服务 - 服务端章节 基于自定义节点管理器 Redis 节点管理器 实现的。\n具体 RPC 服务端 demo 代码可查看 Github RPC 5.x Demo Github 或者 Gitee RPC 5.x Demo Gitee\nPHP RPC 客户端示例代码\n&lt;?php\n/**\n * This file is part of EasySwoole.\n *\n * @link https://www.easyswoole.com\n * @document https://www.easyswoole.com\n * @contact https://www.easyswoole.com/Preface/contact.html\n * @license https://github.com/easy-swoole/easyswoole/blob/3.x/LICENSE\n */\n\n$data = [\n    'service' =&gt; 'Goods', // 需要调用的服务名称\n    'module'  =&gt; 'GoodsModule', // 需要调用的服务下的子模块名称\n    'action'  =&gt; 'list',  // 需要调用的服务下的子模块的方法名称\n    'arg'     =&gt; ['a', 'b', 'c'], // 需要传递的参数\n];\n\n$raw = json_encode($data, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);\n\n// tcp://127.0.0.1:9600（示例请求地址） 是 rpc 服务端的地址，这里是本地，所以使用 127.0.0.1\n// 开发者需要根据实际情况调整进行调用\n$fp = stream_socket_client('tcp://127.0.0.1:9600');\nfwrite($fp, pack('N', strlen($raw)) . $raw); // pack 数据校验\n\n$data = fread($fp, 65533);\n// 做长度头部校验\n$len = unpack('N', $data);\n$data = substr($data, '4');\nif (strlen($data) != $len[1]) {\n    echo 'data error';\n} else {\n    $data = json_decode($data, true);\n    // 这就是服务端返回的结果\n    var_dump($data);\n}\nfclose($fp);\n\n/**\n * 调用结果如下：\n * 其中 \n * statue 为服务端返回给客户端的调用状态码 （具体可查看服务端：https://www.easyswoole.com/Microservices/Rpc/client.html）\n * result 为服务端返回给客户端的调用结果\n * msg    为服务端返回给客户端的调用状态信息\n * responseUUID 为服务端响应客户端的唯一标识\n */\narray(4) {\n  [\"status\"]=&gt;\n  int(0)\n  [\"result\"]=&gt;\n  array(2) {\n    [0]=&gt;\n    array(3) {\n      [\"goodsId\"]=&gt;\n      string(6) \"100001\"\n      [\"goodsName\"]=&gt;\n      string(7) \"商品1\"\n      [\"prices\"]=&gt;\n      int(1124)\n    }\n    [1]=&gt;\n    array(3) {\n      [\"goodsId\"]=&gt;\n      string(6) \"100002\"\n            [\"goodsName\"]=&gt;\n      string(7) \"商品2\"\n            [\"prices\"]=&gt;\n      int(599)\n    }\n  }\n  [\"msg\"]=&gt;\n  string(22) \"get goods list success\"\n  [\"responseUUID\"]=&gt;\n  string(36) \"3897f7ea-12a0-39c1-8948-ee9b9bc37274\"\n}\nGo RPC 客户端示例代码\n/**\n * This file is part of EasySwoole.\n *\n * @link https://www.easyswoole.com\n * @document https://www.easyswoole.com\n * @contact https://www.easyswoole.com/Preface/contact.html\n * @license https://github.com/easy-swoole/easyswoole/blob/3.x/LICENSE\n */\n\npackage main\n\nimport (\n    \"encoding/binary\"\n    \"net\"\n)\n\nfunc main() {\n    var tcpAddr *net.TCPAddr\n    tcpAddr, _ = net.ResolveTCPAddr(\"tcp\",\"192.168.1.107:9600\")\n    conn, _ := net.DialTCP(\"tcp\", nil, tcpAddr)\n    defer conn.Close()\n    sendEasyswooleMsg(conn)\n}\n\nfunc sendEasyswooleMsg(conn *net.TCPConn) {\n    var sendData []byte\n    data := `{\"service\":\"Goods\",\"module\":\"GoodsModule\",\"action\":\"list\",\"arg\":[\"a\",\"b\",\"c\"]}`\n    b := []byte(data)\n    // 大端字节序(网络字节序)大端就是将高位字节放到内存的低地址端，低位字节放到高地址端。\n    // 网络传输中(比如TCP/IP)低地址端(高位字节)放在流的开始，对于2个字节的字符串(AB)，传输顺序为：A(0-7bit)、B(8-15bit)。\n    sendData = int32ToBytes8(int32(len(data)))\n    // 将数据byte拼装到sendData的后面\n    for _, value := range b {\n        sendData = append(sendData, value)\n    }\n    conn.Write(sendData)\n}\n\nfunc int32ToBytes8(n int32) []byte {\n    var buf = make([]byte, 4)\n    binary.BigEndian.PutUint32(buf, uint32(n))\n    return buf\n}\nJava RPC 客户端示例代码\n/**\n * This file is part of EasySwoole.\n *\n * @link https://www.easyswoole.com\n * @document https://www.easyswoole.com\n * @contact https://www.easyswoole.com/Preface/contact.html\n * @license https://github.com/easy-swoole/easyswoole/blob/3.x/LICENSE\n */\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        byte[] msg = \"{\\\"service\\\":\\\"Goods\\\",\\\"module\\\":\\\"GoodsModule\\\",\\\"action\\\":\\\"list\\\",\\\"arg\\\":[\\\"a\\\",\\\"b\\\",\\\"c\\\"]}\".getBytes();\n        byte[] head = Main.toLH(msg.length);\n        byte[] data = Main.mergeByteArr(head, msg);\n\n        // 创建 Socket 对象，连接  rpc 服务器\n        Socket socket = new Socket(\"127.0.0.1\",9600);\n        // 通过客户端的套接字对象 Socket 方法，获取字节输出流，将数据写向服务器\n        OutputStream out = socket.getOutputStream();\n        out.write(data);\n\n        // 读取服务器返回的数据，使用 socket 套接字对象中的字节输入流\n        InputStream in = socket.getInputStream();\n        byte[] response = new byte[1024];\n        int len = in.read(response);\n        // 这里是 rpc 服务端返回的结果为 json 字符串\n        System.out.println(new String(response, 4, len-4));\n        socket.close();\n    }\n\n    public static byte[] toLH(int n) {\n        byte[] b = new byte[4];\n        b[3] = (byte) (n &amp; 0xff);\n        b[2] = (byte) (n &gt;&gt; 8 &amp; 0xff);\n        b[1] = (byte) (n &gt;&gt; 16 &amp; 0xff);\n        b[0] = (byte) (n &gt;&gt; 24 &amp; 0xff);\n        return b;\n    }\n\n    public static byte[] mergeByteArr(byte[] a, byte[] b) {\n        byte[] c = new byte[a.length + b.length];\n        System.arraycopy(a, 0, c, 0, a.length);\n        System.arraycopy(b, 0, c, a.length, b.length);\n        return c;\n    }\n}\n\n/**\n * 服务端返回结果如下：\n */\n{\"status\":0,\"result\":[{\"goodsId\":\"100001\",\"goodsName\":\"商品1\",\"prices\":1124},{\"goodsId\":\"100002\",\"goodsName\":\"商品2\",\"prices\":599}],\"msg\":\"get goods list success\",\"responseUUID\":\"66b81f45-10f7-1a3e-fecd-9b57b021e31e\"}\n其他语言只需要实现对应的应用层协议即可","link":"/Microservices/Rpc/otherPlatform.html"},{"id":244,"title":"安装","content":"微信SDK EasySwoole WeChat 2.x - 公众号\nEasySwoole WeChat 是一个基于 Swoole 4.x 全协程支持的微信 SDK 库，告别同步阻塞，轻松编写高性能的微信公众号/小程序/开放平台/企业微信业务接口。用户如果想要使用关于微信支付业务的使用可以查看 EasySwoole Pay 组件。\n该组件库是仿照 easywechat API 实现的协程安全的 wechat sdk 库。\n用户可以在一切支持 Swoole 协程环境的框架（EasySwoole、Hyperf、Swoft 等）中使用，安装和使用方法请看下文。\n旧版组件兼容说明\n注意：WeChat 组件目前最新版本为 2.0.0 版。完全不兼容旧版本 wechat 1.2.x 版本。旧版本 1.2.x 微信公众号组件的文档请移步查看 1.2.x 微信公众号 SDK 文档的 安装 和 API 接口\n说明\n首先感谢 easywechat 作者们创造的优秀项目，但由于在协程环境下使用会有潜在的跨协程问题，故有了此项目。考虑到大多数用户的习惯，我们保留了绝大多数 API 的命名和风格习惯，以便用户更好地上手使用；但在部分可能存在潜在风险的地方， 我们则进行了重新设计，以保障协程环境下的运行安全。\n组件要求\n\nphp &gt;= 7.2\next-swoole: ^4.4.19 (推荐使用 Swoole 4.4.23)\next-openssl: *\next-json: *\next-libxml: *\next-simplexml: *\next-openssl: *\npsr/log: ^1.1\npsr/http-message: ^1.0\npsr/simple-cache: ^1.0\npimple/pimple: ^3.0\neasyswoole/utility: ^1.1\n\n\n注意：在编译安装 Swoole 扩展时，请务必把编译参数 --enable-openssl 加上，以启用 SSL 支持\n\n安装方法\n\n$ composer require easyswoole/wechat\n\n仓库地址\neasyswoole/wechat=2.x\n常见问题汇总\n为了让用户在微信公众平台开发的道路上少掉坑，我们在这里将使用此组件进行开发时遇到的各种问题进行汇总，并给出对应的解决办法。这样用户就可以更效地进行开发了。\n时区不对\n\n报错情形如下：Setting The Correct Timezone In CentOS And Ubuntu Servers With NTP。\n解决方法：使用命令 date 可以在服务器上查看当前时间，如果发现时区不对则需要修改时区。\n\nredirect_url 参数错误\n\n\n出现原因：这是由于程序使用了 网页授权 而公众号没有正确配置 【网页授权域名】 所致。此时你需要登录微信公众平台，在 【开发】 -&gt; 【接口权限】 页面找到 网页授权获取用户基本信息 进行配置并保存。\n\n\n解决方法：\n\n网页授权域名应该为通过 ICP 备案的有效域名，否则保存时无法通过安全监测。\n网页授权域名即程序完成授权获得授权 code 后跳转到的页面的域名，一般情况下为你的业务域名。\n网页授权域名配置成功后会立即生效。\n公众号的网页授权域名只可配置一个，请合理规划你的业务，否则你会发现 …… 授权域名不够用哈。\n\n\n\nJSAPI config: invalid url domain\n\n出现原因：在使用 JS-SDK 进行开发时，每个页面都需要调用 wx.config() 方法配置 JSPAI 参数。如果没有正确配置 JSAPI 安全域名并且开启了调试模式，此时就报此错误。\n解决方法：遇到这个问题时，开发者需要登录微信公众平台，进入 【公众号设置】-&gt;【功能设置】 页面，将项目所使用的域名添加至 【JSAPI 安全域名】 列表中。\n注意事项说明：\n\n一个公众号同时最多可绑定三个安全域名，并且这些域名必须为通过 ICP 备案的一级或一级以上的有效域名。\n\nJSAPI 安全域名每个月限修改三次，修改任何一个都算，所以，请谨慎操作。\n\n\n","link":"/Components/WeChat2.x/officialAccount/install.html"},{"id":245,"title":"入门","content":"入门\nEasySwoole WeChat 组件公众号的各模块相对比较统一，用法如下：\n在服务端中，我们通过如下方式获取到公众号操作相关的整个实例，用法如下：\n&lt;?php\n\n$config = [\n    // 微信公众平台后台的 appid\n    'appId' =&gt; 'wxefe41fdeexxxxxx', \n\n    // 微信公众平台后台配置的 Token\n    'token' =&gt; 'dczmnau31ea9nzcnxxxxxxxxx',\n\n    // 微信公众平台后台配置的 EncodingAESKey\n    'aesKey' =&gt; 'easyswoole',\n\n    // 微信公众平台后台配置的 AppSecret\n    'appSecret' =&gt; 'your-AppSecret'\n];\n\n// 公众号\n$officialAccount = \\EasySwoole\\WeChat\\Factory::officialAccount($config);\n$officialAccount 在后文所有相关公众号的文档都是指 \\EasySwoole\\WeChat\\Factory::officialAccount 得到的实例，下面就不在每个页面单独写了。\n重点总结\n所有的应用服务都通过主入口 EasySwoole\\WeChat\\Factory 类来创建：\n&lt;?php\n\nuse EasySwoole\\WeChat\\Factory;\n\n// 公众号\n$officialAccount = Factory::officialAccount($config);\n\n// 小程序\n$miniProgram = Factory::miniProgram($config);\n\n// 开放平台\n$openPlatform = Factory::openPlatform($config);\n\n// 企业微信\n$work = Factory::work($config);","link":"/Components/WeChat2.x/officialAccount/getStart.html"},{"id":246,"title":"快速开始","content":"快速开始\n在我们已经成功安装完成 EasySwoole WeChat SDK 组件后，就可以很快地开始使用它了，当然你还是有必要明白 PHP 的基本知识，如命名空间等，我这里就不赘述了。\n接下来我们以完成 服务器端验证 与 接收响应用户发送的消息 为例来演示，首先我们有必要先了解一下微信交互的运行流程：\n具体交互流程如下：\n                                 +-----------------+                       +---------------+\n+----------+                     |                 |    POST/GET/PUT       |               |\n|          | ------------------&gt; |                 | -------------------&gt;  |               |\n|   user   |                     |  wechat server  |                       |  your server  |\n|          | &lt; - - - - - - - - - |                 |                       |               |\n+----------+                     |                 | &lt;- - - - - - - - - -  |               |\n                                 +-----------------+                       +---------------+\n其实我们要做的就是图中 微信服务器把用户消息转到我们的自有服务器（虚线返回部分） 后的处理过程。\n服务端验证\n在微信接入开始有一个 &quot;服务器验证&quot; 的过程，这一步其实就是 微信服务器 向 我们服务器 发起一个请求（上图实线部分），传了一个名称为 echostr 的字符串过来，我们只需要原样返回就好了。\n作为开发者，你应该知道，微信后台只能填写一个服务器地址，所以 服务器验证 与 消息的接收与回复，都在这一个链接内完成交互。\n考虑到这些，我们已经把验证这一步给封装到 SDK 里了，你可以完全忽略这一步。\n下面我们来配置一个基本的服务端，这里假设我们自己的服务器域名叫 easyswoolewechat.com，并且我们在服务端已经安装好了一个 EasySwoole 框架，或者我们在服务器上准备一个文件 server.php（使用原生 Swoole 实现，下文只提供伪代码）。\n使用 EasySwoole 框架配置服务端验证\n以下为了演示，我们只在 App\\HttpController\\Index 控制器类下进行编码实现配置服务端验证，用户可自行选择其他控制器类进行编码实现。\n在服务器的 EasySwoole 框架的 HTTP 服务的 控制器 中来配置一个基本的服务端：\n配置主服务为 HTTP 服务，然后我们可以在 App\\HttpController\\Index 控制器类下编写 server 方法，编写如下代码实现服务端验证： \n&lt;?php\n\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\nuse EasySwoole\\WeChat\\Factory;\n\nclass Index extends Controller\n{\n    public function server()\n    {\n        $config = [\n            // 微信公众平台后台的 appid\n            'appId' =&gt; 'wxefe41fdeexxxxxx',\n\n            // 微信公众平台后台配置的 Token\n            'token' =&gt; 'dczmnau31ea9nzcnxxxxxxxxx',\n\n            // 微信公众平台后台配置的 EncodingAESKey\n            'aesKey' =&gt; 'easyswoole'\n        ];\n\n        $officialAccount = Factory::officialAccount($config);\n\n        $server = $officialAccount-&gt;server;\n\n        /** @var \\Psr\\Http\\Message\\ServerRequestInterface $psr7Request */\n        $psr7Request = $this-&gt;request();\n\n        /**\n         * @var \\Psr\\Http\\Message\\ResponseInterface $replyResponse\n         * forceValidate() 表示启用请求验证，以确保请求来自微信发送。默认不启用验证\n         * serve() 会解析本次请求后回调之前注册的事件（包括 AES 解密和解析 XML）\n         * serve() 接受一个显式实现了 \\Psr\\Http\\Message\\ServerRequestInterface 的 request 对象\n         */\n        $replyResponse = $server-&gt;forceValidate()-&gt;serve($psr7Request);\n\n        /**\n         * $replyResponse 是一个显式实现了 PSR-7 的对象，用户只需要处理该对象即可正确响应给微信\n         * 下面是一个使用 EasySwoole 的响应方法\n         */\n        $this-&gt;response()-&gt;withStatus($replyResponse-&gt;getStatusCode());\n\n        /**\n         * PSR-7 的 Header 并不是单纯的 k =&gt; v 结构\n         */\n        foreach ($replyResponse-&gt;getHeaders() as $name =&gt; $values) {\n            $this-&gt;response()-&gt;withHeader($name, implode(\", \", $values));\n        }\n\n        $this-&gt;response()-&gt;write($replyResponse-&gt;getBody()-&gt;__toString());\n    }\n}\n使用原生 Swoole 配置服务端验证\nserver.php 的实现形式我就以原生 Swoole 的 http_server 来启动一个服务，伪代码内容如下：\n&lt;?php\n\nuse EasySwoole\\WeChat\\Factory;\n\nrequire_once __DIR__ . '/vendor/autoload.php';\n\n$http = new Swoole\\Http\\Server('0.0.0.0', 9501);\n\n$http-&gt;on('request', function (\\Swoole\\Http\\Request $request, \\Swoole\\Http\\Response $response) {\n\n    $config = [\n        // 微信公众平台后台的 appid\n        'appId' =&gt; 'wxefe41fdeexxxxxx',\n\n        // 微信公众平台后台配置的 Token\n        'token' =&gt; 'dczmnau31ea9nzcnxxxxxxxxx',\n\n        // 微信公众平台后台配置的 EncodingAESKey\n        'aesKey' =&gt; 'easyswoole'\n    ];\n\n    $officialAccount = Factory::officialAccount($config);\n\n    $server = $officialAccount-&gt;server;\n\n    // 此处为实现了 \\Psr\\Http\\Message\\ServerRequestInterface 的 request 对象\n    /** @var \\Psr\\Http\\Message\\ServerRequestInterface $psr7Request  */\n    $psr7Request = new XxxReuest($request); // 伪代码\n\n    /**\n     * @var \\Psr\\Http\\Message\\ResponseInterface $replyResponse\n     * forceValidate() 表示启用请求验证，以确保请求来自微信发送。默认不启用验证\n     * serve() 会解析本次请求后回调之前注册的事件（包括 AES 解密和解析 XML）\n     * serve() 接受一个显式实现了 \\Psr\\Http\\Message\\ServerRequestInterface 的 request 对象\n     */\n    $replyResponse = $server-&gt;forceValidate()-&gt;serve($psr7Request);\n\n    /**\n     * $replyResponse 是一个显式实现了 PSR-7 的对象，用户只需要处理该对象即可正确响应给微信\n     * 下面是一个原生 swoole 的响应方法\n     */\n    $response-&gt;status($replyResponse-&gt;getStatusCode());\n\n    /**\n     * PSR-7 的 Header 并不是单纯的 k =&gt; v 结构\n     */\n    foreach ($replyResponse-&gt;getHeaders() as $name =&gt; $values) {\n        $response-&gt;header($name, implode(\", \", $values));\n    }\n\n    // 将响应输出到客户端\n    $response-&gt;write($replyResponse-&gt;getBody()-&gt;__toString());\n});\n\n$http-&gt;start();\n\n上述 $psr7Request 请用户参考 PSR-7 标准自行实现 Psr\\Http\\Message\\ServerRequestInterface 接口。\n\n注意：安全模式下请一定要配置 aesKey。\n很简单，一个服务端带验证功能的代码已经完成，当然我们没有对消息做处理，别着急，后面我们再讲。\n我们先来分析上面的代码：\n&lt;?php\n\n// 引入我们的主项目工厂类\nuse EasySwoole\\WeChat\\Factory;\n\n// 一些配置\n$config = [...];\n\n// 使用配置来初始化一个公众号应用实例\n$officialAccount = Factory::officialAccount($config);\n\n// 得到一个 Server\\Guard $server 实例\n$server = $officialAccount-&gt;server;\n\n// 构造 实现了 \\Psr\\Http\\Message\\ServerRequestInterface 的 request 对象\n// 此处为实现了 \\Psr\\Http\\Message\\ServerRequestInterface 的 request 对象\n/** @var \\Psr\\Http\\Message\\ServerRequestInterface $psr7Request  */\n$psr7Request = new XxxReuest($request); // 伪代码\n\n// 得到一个实现了 `Psr\\Http\\Message\\ResponseInterface` 接口的 response 响应实例对象\n$replyReponse = $server-&gt;forceValidate()-&gt;serve($psr7Request);\n\n### 构建 Swoole 响应给到客户端\n// 设置响应 HTTP 状态码\n$response-&gt;status($replyResponse-&gt;getStatusCode());\n// 设置响应头 Header\nforeach ($replyResponse-&gt;getHeaders() as $name =&gt; $values) {\n    $response-&gt;header($name, implode(\", \", $values));\n}\n// 将响应输出到客户端\n$response-&gt;write($replyResponse-&gt;getBody()-&gt;__toString());\n最后这一行我有必要详细讲一下：\n\n我们的 $server-&gt;forceValidate()-&gt;serve($psr7Request); 就是执行服务端业务了，那么它的返回值是一个实现了 Psr\\Http\\Message\\ResponseInterface 接口的实例对象。\n我这里是直接调用了 Swoole 原生的响应方法 write()。在一些的 Swoole 相关的框架中，你可以直接拿到 $replyResponse 实例对象进行相关的操作，然后输出到客户端即可。在 EasySwoole 中，可以直接使用上文示例的方法操作即可输出到客户端。\n\nOK，有了上面的代码，那么请你按 微信官方的接入指引 在公众号后台完成配置并启用，并相应修改上面的 $config 的相关配置。\nURL 就是我们的 http://easyswoolewechat.com/server，这里我是举例哦，你可不要填写我的域名。由于我使用的是 Swoole 的 9501 端口提供服务，请用户自行进行反向代理配置，具体如何配置反向代理请看 EasySwoole 反向代理。\n请一定要将微信后台的开发者模式 ”启用” ！！！！！！看到红色 “停用” 才真正的是启用了。最后，请不要用浏览器访问这个地址，它是给微信服务器访问的，不是给人访问的。\n接收 &amp; 回复用户消息\n上述完成服务端验证通过后，接下来我们就来试一下接收消息吧。\n在刚刚上文代码最后一行使用 $this-&gt;response()-&gt;write($replyResponse-&gt;getBody()-&gt;__toString()); (在 EasySwoole 框架中响应) 或 使用 $response-&gt;write($replyResponse-&gt;getBody()-&gt;__toString()); (原生 Swoole 响应); 在前面，现在我们调用 $officialAccount-&gt;server 的 push() 方法来注册一个消息处理器，这里用到了 PHP 闭包 的知识，如果你不熟悉赶紧补课去。\n\nEasySwoole 中 App\\HttpController\\Index.php 实现：\n\n&lt;?php\n\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\nuse EasySwoole\\WeChat\\Factory;\n\nclass Index extends Controller\n{\n\n    public function server()\n    {\n        // 这里省略 \n\n        $server = $officialAccount-&gt;server;\n\n        /** 注册消息事件回调 */\n        $server-&gt;push(function (\\EasySwoole\\WeChat\\Kernel\\Contracts\\MessageInterface $message) {\n            return new \\EasySwoole\\WeChat\\Kernel\\Messages\\Text(\"您好！欢迎使用 EasySwoole WeChat!\");\n        });\n\n        $psr7Request = $this-&gt;request();\n        /** @var \\Psr\\Http\\Message\\ResponseInterface $replyResponse */\n        $replyResponse = $server-&gt;forceValidate()-&gt;serve($psr7Request);\n\n        $this-&gt;response()-&gt;withStatus($replyResponse-&gt;getStatusCode());\n        foreach ($replyResponse-&gt;getHeaders() as $name =&gt; $values) {\n            $this-&gt;response()-&gt;withHeader($name, implode(\", \", $values));\n        }\n\n        // 将响应输出到客户端\n        $this-&gt;response()-&gt;write($replyResponse-&gt;getBody()-&gt;__toString());\n    }\n}\n\n原生 Swoole 中单独实现 server.php：\n\n&lt;?php\n\nuse EasySwoole\\WeChat\\Factory;\n\nrequire_once __DIR__ . '/vendor/autoload.php';\n\n// 这里省略\n\n$http-&gt;on('request', function (\\Swoole\\Http\\Request $request, \\Swoole\\Http\\Response $response) {\n\n    // 这里省略\n\n    $server = $officialAccount-&gt;server;\n\n    /** 注册消息事件回调 */\n    $server-&gt;push(function (\\EasySwoole\\WeChat\\Kernel\\Contracts\\MessageInterface $message) {\n        return new \\EasySwoole\\WeChat\\Kernel\\Messages\\Text(\"您好！欢迎使用 EasySwoole WeChat!\");\n    });\n\n    /** @var \\Psr\\Http\\Message\\ServerRequestInterface $psr7Request  */\n    $psr7Request = new XxxReuest($request); // 伪代码\n\n    $replyResponse = $server-&gt;forceValidate()-&gt;serve($psr7Request);\n    $response-&gt;status($replyResponse-&gt;getStatusCode());\n    foreach ($replyResponse-&gt;getHeaders() as $name =&gt; $values) {\n        $response-&gt;header($name, implode(\", \", $values));\n    }\n\n    // 将响应输出\n    $response-&gt;write($replyResponse-&gt;getBody()-&gt;__toString());\n});\n\n// 这里省略\nOK，打开你的微信客户端，向你的公众号发送任意一条消息，你应该会收到回复：您好！欢迎使用 EasySwoole WeChat!。\n如果您没有收到回复，但是看到了 “你的公众号暂时无法提供服务”，好，那检查一下你的日志吧，日志在哪儿？我们的配置里写了日志路径了(sys_get_temp_dir() . '/wechat.log')。没有这个文件？看看权限。\n一个基本的服务端验证就完成了。\n总结\n所有的应用服务都通过主入口 EasySwoole\\WeChat\\Factory 类来创建：\n&lt;?php\n\nuse EasySwoole\\WeChat\\Factory;\n\n// 公众号\n$officialAccount = Factory::officialAccount($config);\n\n// 小程序\n$miniProgram = Factory::miniProgram($config);\n\n// 开放平台\n$openPlatform = Factory::openPlatform($config);\n\n// 企业微信\n$work = Factory::work($config);\n最后\n希望您在使用本 SDK 的时候如果您发现 SDK 的不足，欢迎提交 PR 或者给我们 提建议 &amp; 报告问题。","link":"/Components/WeChat2.x/officialAccount/quickStart.html"},{"id":247,"title":"配置","content":"配置\n常用的配置参数会比较少，因为除非你有特别的定制，否则基本上默认值就可以了：\n&lt;?php\n\nuse EasySwoole\\WeChat\\Factory;\n\n$config = [\n    // 微信公众平台后台的 appid\n    'appId' =&gt; 'wxefe41fdeexxxxxx',\n\n    // 微信公众平台后台配置的 Token\n    'token' =&gt; 'dczmnau31ea9nzcnxxxxxxxxx',\n\n    // 微信公众平台后台配置的 EncodingAESKey\n    'aesKey' =&gt; 'easyswoole',\n\n    // 微信公众平台后台配置的 AppSecret\n    'appSecret' =&gt; 'AppSecret',\n\n    //...\n];\n\n// 公众号\n$officialAccount = Factory::officialAccount($config);\n下面是一个完整的配置样例：\n不建议你在配置的时候弄这么多，用到啥就配置啥才是最好的，因为大部分用默认值即可。\n&lt;?php\n\nreturn [\n    /**\n     * 账号基本信息，请从微信公众平台/开放平台获取\n     */\n    'appId'      =&gt; 'your-app-id',         // AppID\n    'appSecret'  =&gt; 'your-app-secret',     // AppSecret\n    'token'      =&gt; 'your-token',          // Token\n    'aesKey'     =&gt; 'your-EncodingAESKey', // EncodingAESKey，兼容与安全模式下请一定要填写！！！\n\n    /** \n     * 缓存配置\n     *\n     * tempDir：缓存文件存放位置 (绝对路径!!!)，要求可写权限 \n     */\n    'cache' =&gt; [\n        'tempDir' =&gt; sys_get_temp_dir(), // 默认使用的 sys_get_temp_dir()\n    ]\n];\n自定义日志驱动\n暂时略。\n自定义缓存驱动\n暂时略。\n自定义实现 httpClient 驱动\n暂时略。\n安全模式下请一定要填写 aesKey。","link":"/Components/WeChat2.x/officialAccount/config.html"},{"id":248,"title":"基础接口","content":"基础接口\n清理接口调用次数\n此接口官方有每月调用限制，不可随意调用\n$officialAccount-&gt;base-&gt;clearQuota();\n获取微信服务器 IP (或 IP 段)\n$officialAccount-&gt;base-&gt;getValidIps();","link":"/Components/WeChat2.x/officialAccount/base.html"},{"id":249,"title":"服务端","content":"服务端\n我们在入门小教程一节中以服务端为例讲解了一个基本的消息的处理，这里就不再讲服务器验证的流程了，请直接参考前面的入门实例即可。\n服务端的作用，在整个微信开发中主要是负责 接收用户发送过来的消息，还有 用户触发的一系列事件。\n首先我们得理清 消息与事件的回复逻辑，当你收到用户消息后（消息由微信服务器推送到你的服务器），在你对消息进行一些处理后，不管是选择回复一个消息还是什么不都回给用户，你也应该给微信服务器一个 “答复”，如果是选择回复一条消息，就直接返回一个消息 xml 就好，如果选择不做任何回复，你也得回复一个 空字符串 或者 字符串 SUCCESS（不然用户就会看到 该公众号暂时无法提供服务）。\n基本使用\n在 SDK 中使用 $officialAccount-&gt;server-&gt;push(callable $callback) 来设置消息处理器：\n&lt;?php\n\n$server = $officialAccount-&gt;server;\n\n/** 注册消息事件回调 */\n$server-&gt;push(function (\\EasySwoole\\WeChat\\Kernel\\Contracts\\MessageInterface $message) {\n    // $message-&gt;getType(); // 消息类型：消息类型：event、text ......\n    return new \\EasySwoole\\WeChat\\Kernel\\Messages\\Text(\"您好！欢迎使用 EasySwoole WeChat!\");\n});\n这里我们使用 push 传入了一个 闭包（Closure），该闭包接收一个参数 $message 为消息对象（类型为实现了 \\EasySwoole\\WeChat\\Kernel\\Contracts\\MessageInterface 接口的实例对象），你可以在全局消息处理器中对消息类型进行筛选：\n&lt;?php\n\n$server = $officialAccount-&gt;server;\n\n$server-&gt;push(function (\\EasySwoole\\WeChat\\Kernel\\Contracts\\MessageInterface $message) {\n    switch ($message-&gt;getType()) {\n        case 'event':\n            $text = '收到事件消息';\n            break;\n        case 'text':\n            $text = '收到文字消息';\n            break;\n        case 'image':\n            $text = '收到图片消息';\n            break;\n        case 'voice':\n            $text = '收到语音消息';\n            break;\n        case 'video':\n            $text = '收到视频消息';\n            break;\n        case 'location':\n            $text = '收到坐标消息';\n            break;\n        case 'link':\n            $text = '收到链接消息';\n            break;\n        case 'file':\n            $text = '收到文件消息';\n            break;\n        // ... 其它消息\n        default:\n            $text = '收到其它消息';\n            break;\n    }\n\n    // ...\n\n    return new \\EasySwoole\\WeChat\\Kernel\\Messages\\Text($text);\n});\n当然，因为这里 push 接收一个 callable 的参数，所以你不一定要传入一个 Closure 闭包，你可以选择传入一个函数名，一个 [$class, $method] 或者 Foo::bar 这样的类型。\n注册多个消息处理器\n有时候你可能需要对消息记日志，或者一系列的自定义操作，你可以注册多个 handler：\n&lt;?php\n\n$server = $officialAccount-&gt;server;\n\n$server-&gt;push(MessageLogHandler::class);\n$server-&gt;push(MessageReplyHandler::class);\n$server-&gt;push(OtherHandler::class);\n$server-&gt;push(...);\n\n注意：\n\n最后一个非空返回值将作为最终应答给用户的消息内容，如果中间某一个 handler 返回值 false, 则将终止整个调用链，不会调用后续的 handlers。\n传入的自定义 Handler 类需要实现 \\EasySwoole\\WeChat\\Kernel\\Contracts\\EventHandlerInterface 接口。\n\n\n注册指定消息类型的消息处理器\n我们想对特定类型的消息应用不同的处理器，可以在第二个参数传入类型筛选：\n\n注意，第二个参数必须是 \\EasySwoole\\WeChat\\Kernel\\Messages\\Message 类的常量。\n\n&lt;?php\n\nuse EasySwoole\\WeChat\\Kernel\\Messages\\Message;\n\n$server = $officialAccount-&gt;server;\n\n$server-&gt;push(ImageMessageHandler::class, Message::IMAGE); // 图片消息\n$server-&gt;push(TextMessageHandler::class, Message::TEXT); // 文本消息\n\n// 同时处理多种类型的处理器\n// 当消息为 三种中任意一种都可触发\n$server-&gt;push(MediaMessageHandler::class, [Message::VOICE, Message::VIDEO, Message::SHORT_VIDEO]);\n请求消息的属性\n当你接收到用户发来的消息时，可能会提取消息中的相关属性，参考：\n请求消息基本属性 (以下所有消息都有的基本属性)：\n\n\nToUserName 接收方帐号（该公众号 ID）\n\nFromUserName 发送方帐号（OpenID, 代表用户的唯一标识）\n\nCreateTime 消息创建时间（时间戳）\n\nMsgId 消息 ID（64 位整型）\n\n文本：\n\n\nMsgType text\n\n\nContent 文本消息内容\n\n图片：\n\n\nMsgType image\n\n\nMediaId 图片消息媒体 id，可以调用多媒体文件下载接口拉取数据。\n\nPicUrl 图片链接\n\n语音：\n\n\nMsgType voice\n\n\nMediaId 语音消息媒体 id，可以调用多媒体文件下载接口拉取数据。\n\nFormat 语音格式，如 amr、speex 等\n\nRecognition * 开通语音识别后才有\n\n\n请注意，开通语音识别后，用户每次发送语音给公众号时，微信会在推送的语音消息 XML 数据包中，增加一个 Recongnition 字段\n\n视频：\n\n\nMsgType video\n\n\nMediaId 视频消息媒体 id，可以调用多媒体文件下载接口拉取数据。\n\nThumbMediaId 视频消息缩略图的媒体 id，可以调用多媒体文件下载接口拉取数据。\n\n小视频：\n\n\nMsgType shortvideo\n\n\nMediaId 视频消息媒体 id，可以调用多媒体文件下载接口拉取数据。\n\nThumbMediaId 视频消息缩略图的媒体 id，可以调用多媒体文件下载接口拉取数据。\n\n事件：\n\n\nMsgType event\n\n\nEvent 事件类型 （如：subscribe (订阅)、unsubscribe (取消订阅) ...， CLICK 等）\n\n扫描带参数二维码事件：\n\n\nEventKey 事件 KEY 值，比如：qrscene_123123，qrscene_ 为前缀，后面为二维码的参数值\n\nTicket 二维码的 ticket，可用来换取二维码图片\n\n上报地理位置事件：\n\n\nLatitude 23.137466 地理位置纬度\n\nLongitude 113.352425 地理位置经度\n\nPrecision 119.385040 地理位置精度\n\n自定义菜单事件：\n\n\nEventKey 事件 KEY 值，与自定义菜单接口中 KEY 值对应，如：CUSTOM_KEY_001、www.qq.com\n\n\n地理位置：\n\n\nMsgType location\n\n\nLocation_X 地理位置纬度\n\nLocation_Y 地理位置经度\n\nScale 地图缩放大小\n\nLabel 地理位置信息\n\n链接：\n\n\nMsgType link\n\n\nTitle 消息标题\n\nDescription 消息描述\n\nUrl 消息链接\n\n文件：\n\n\nMsgType file \n\nTitle 文件名 \n\nDescription 文件描述，可能为 null\n\n\nFileKey 文件 KEY \n\nFileMd5 文件 MD5 值 \n\nFileTotalLen 文件大小，单位字节\n\n回复消息\n回复的消息可以为 null，此时 SDK 会返回给微信一个 \"SUCCESS\"，你也可以回复一个普通字符串，比如：欢迎关注 EasySwoole WeChat.，此时 SDK 会对它进行一个封装，产生一个 \\EasySwoole\\WeChat\\Kernel\\Messages\\Text 类型的消息并在最后的 $officialAccount-&gt;server-&gt;serve(); 时生成对应的消息 XML 格式。\n如果你想返回一个自己手动拼的原生 XML 格式消息，请返回一个 \\EasySwoole\\WeChat\\Kernel\\Messages\\Raw 实例即可。\n消息转发给客服系统\n参见：多客服消息转发\n关于消息的使用，请参考 消息 章节。","link":"/Components/WeChat2.x/officialAccount/server.html"},{"id":250,"title":"消息","content":"消息\n我们的 SDK 把微信的 API 里的所有 “消息” 都按类型抽象出来了，也就是说，你不用区分它是回复消息还是主动推送消息，免去了你去手动拼装微信的 XML 以及乱七八糟命名不统一的 JSON 了。\n在阅读以下内容时请忽略是 接收消息 还是 回复消息，后面我会给你讲它们的区别。\n消息类型\n消息分为以下几种：文本、图片、视频、声音、链接、坐标、图文、文章 和一种特殊的 原始消息。\n另外还有一种特殊的消息类型：素材消息，用于群发或者客服时发送已有素材用。\n\n注意：回复消息与客服消息里的图文类型为：图文，群发与素材中的图文为 文章\n\n所有的消息类都在 EasySwoole\\WeChat\\Kernel\\Messages 这个命名空间下，下面我们来分开讲解：\n文本消息\n属性列表：\n\n\ncontent 文本内容\n\n&lt;?php\n\nuse EasySwoole\\WeChat\\Kernel\\Messages\\Text;\n\n$text = new Text('您好! EasySwoole WeChat!');\n\n// or\n$text = new Text('');\n$text-&gt;setContent('您好! EasySwoole WeChat!');\n\n// or\n$text = new Text('');\n$text-&gt;setAttribute('content', '您好! EasySwoole WeChat!');\n图片消息\n属性列表：\n\n\nmedia_id 媒体资源 ID\n\n\n&lt;?php\n\nuse EasySwoole\\WeChat\\Kernel\\Messages\\Image;\n\n$image = new Image($mediaId);\n视频消息\n属性列表：\n\n\ntitle 标题\n\ndescription 描述\n\nmedia_id 媒体资源 ID\n\n\nthumb_media_id 封面资源 ID\n\n\n&lt;?php\n\nuse EasySwoole\\WeChat\\Kernel\\Messages\\Video;\n\n$title = 'i am title!';\n$description = 'i am description!';\n$video = new Video($mediaId);\n$video-&gt;setAttributes([\n    'title'       =&gt; $title,\n    'description' =&gt; $description\n]);\n\n// or\n$video = new Video($mediaId);\n$video-&gt;setAttribute('title', $title);\n$video-&gt;setAttribute('description', $description);\n声音消息\n属性列表：\n\n\nmedia_id 媒体资源 ID\n\n\n&lt;?php\n\nuse EasySwoole\\WeChat\\Kernel\\Messages\\Voice;\n\n$voice = new Voice($mediaId);\n链接消息\n微信目前不支持回复链接消息\n坐标消息\n微信目前不支持回复坐标消息\n图文消息\n图文消息分为 NewsItem 与 News，NewsItem 为图文内容条目。\n\n10 月 12 日起，被动回复消息 与 客服消息接口 的 图文消息类型 中 图文数目 只能为一条。\n\nNewsItem 属性：\n\n\ntitle 标题\n\ndescription 描述\n\nimage 图片链接\n\nurl 链接 URL\n\n\n&lt;?php\n\nuse EasySwoole\\WeChat\\Kernel\\Messages\\News;\nuse EasySwoole\\WeChat\\Kernel\\Messages\\NewsItem;\n\n$items = [\n    new NewsItem([\n        'title'       =&gt; $title,\n        'description' =&gt; '...',\n        'url'         =&gt; $url,\n        'image'       =&gt; $image,\n        // ...\n    ]),\n];\n$news = new News($items);\n文章\n属性列表：\n\n\ntitle 标题\n\nauthor 作者\n\ncontent 具体内容\n\nthumb_media_id 图文消息的封面图片素材 id（必须是永久 mediaID ）\n\ndigest 图文消息的摘要，仅有单图文消息才有摘要，多图文此处为空\n\nsource_url 来源 URL\n\n\nshow_cover 是否显示封面，0 为 false，即不显示，1 为 true，即显示\n\n&lt;?php\n\nuse EasySwoole\\WeChat\\Kernel\\Messages\\Article;\n\n$article = new Article([\n    'title'   =&gt; 'EasySwoole WeChat',\n    'author'  =&gt; 'EasySwoole',\n    'content' =&gt; 'EasySwoole WeChat 是一个开源的微信 SDK!',\n    // ...\n]);\n\n// or\n$article = new Article();\n$article-&gt;setAttribute('title', 'EasySwoole WeChat');\n$article-&gt;setAttribute('author', 'EasySwoole');\n$article-&gt;setAttribute('content', 'EasySwoole WeChat 是一个开源的微信 SDK!');\n\n// ...\n素材消息\n素材消息用于群发与客服消息时使用。\n\n素材消息不支持被动回复，如需被动回复素材消息，首先组装后，再 News 方法返回。\n\n属性就一个：media_id。\n在构造时有两个参数：\n\n\n$type 素材类型，目前只支持：mpnews、 mpvideo、voice、image 等。\n\n$mediaId 素材 ID，从接口查询或者上传后得到。\n\n&lt;?php\n\nuse EasySwoole\\WeChat\\Kernel\\Messages\\Media;\n\n$media = new Media($mediaId, 'mpnews');\n以上呢，是所有微信支持的基本消息类型。\n\n需要注意的是，你不需要关心微信的消息字段叫啥，因为这里我们使用了更标准的命名，然后最终在中间做了转换，所以你不需要关注。\n\n原始消息\n原始消息是一种特殊的消息，它的场景是：你不想使用其它消息类型，你想自己手动拼消息。比如，回复消息时，你想自己拼 XML，那么你就直接用它就可以了：\n&lt;?php\n\nuse EasySwoole\\WeChat\\Kernel\\Messages\\Raw;\nuse EasySwoole\\WeChat\\Kernel\\Utility\\XML;\n\n$dataArr = [\n    'ToUserName' =&gt; 'toUser',\n    'FromUserName' =&gt; 'fromUser',\n    'CreateTime' =&gt; '12345678',\n    'MsgType' =&gt; 'image',\n    'Image' =&gt; [\n        'MediaId' =&gt; 'media_id'\n    ],\n];\n// 即 '&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;12345678&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[image]]&gt;&lt;/MsgType&gt;&lt;Image&gt;&lt;MediaId&gt;&lt;![CDATA[media_id]]&gt;&lt;/MediaId&gt;&lt;/Image&gt;&lt;/xml&gt;'\n$rawXml = XML::build($dataArr);\n\n$message = new Raw($rawXml);\n\n// or\n$message = new Raw('&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;12345678&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[image]]&gt;&lt;/MsgType&gt;&lt;Image&gt;&lt;MediaId&gt;&lt;![CDATA[media_id]]&gt;&lt;/MediaId&gt;&lt;/Image&gt;&lt;/xml&gt;');\n比如，你要用于客服消息 (客服消息是 JSON 结构)：\n&lt;?php\n\nuse EasySwoole\\WeChat\\Kernel\\Messages\\Raw;\n\n$dataArr1 = [\n    'touser' =&gt; 'OPENID',\n    'msgtype' =&gt; 'text',\n    'text' =&gt; [\n        'content' =&gt; 'Hello World'\n    ]\n];\n$message = new Raw(json_encode($dataArr1));\n\n// or\n$message = new Raw('{\"touser\":\"OPENID\",\"msgtype\":\"text\",\"text\":{\"content\":\"Hello World\"}}');\n总之，就是直接写微信接口要求的格式内容就好，此类型消息在 SDK 中不存在转换行为，所以请注意不要写错格式。\n在 SDK 中使用消息\n在服务端回复消息\n在 服务端 章节中，我们讲了回复消息的写法：\n&lt;?php\n\n// ... 前面部分省略\n\n$server = $officialAccount-&gt;server;\n\n/** 注册消息事件回调 */\n$server-&gt;push(function (\\EasySwoole\\WeChat\\Kernel\\Contracts\\MessageInterface $message) {\n    return new \\EasySwoole\\WeChat\\Kernel\\Messages\\Text(\"您好！欢迎使用 EasySwoole WeChat!\");\n});\n\n$replyResponse = $server-&gt;forceValidate()-&gt;serve($psr7Request);\n上面 return 转换为 Text 文本类型的动作。\n如果你要回复其它类型的消息，可以选择返回一个其他具体的实例，比如回复一个图片类型的消息：\n&lt;?php\n\nuse EasySwoole\\WeChat\\Kernel\\Messages\\Image;\n\n// ...\n\n$server = $officialAccount-&gt;server;\n\n/** 注册消息事件回调 */\n$server-&gt;push(function (\\EasySwoole\\WeChat\\Kernel\\Contracts\\MessageInterface $message) {\n    return new \\EasySwoole\\WeChat\\Kernel\\Messages\\Image('media-id');\n});\n\n// ...\n回复多图文消息\n\n10 月 12 日起，被动回复消息 与 客服消息接口 的 图文消息类型 中 图文数目 只能为一条。\n\n多图文消息其实就是单图文消息的一个数组而已了：\n&lt;?php\n\nuse EasySwoole\\WeChat\\Kernel\\Messages\\News;\nuse EasySwoole\\WeChat\\Kernel\\Messages\\NewsItem;\n\n// ...\n\n$server = $officialAccount-&gt;server;\n\n/** 注册消息事件回调 */\n$server-&gt;push(function (\\EasySwoole\\WeChat\\Kernel\\Contracts\\MessageInterface $message) {\n\n    $items = [\n        new NewsItem([\n            'title'       =&gt; $title,\n            'description' =&gt; '...',\n            'url'         =&gt; $url,\n            'image'       =&gt; $image,\n            // ...\n        ]),\n        new NewsItem([\n            'title'       =&gt; $title,\n            'description' =&gt; '...',\n            'url'         =&gt; $url,\n            'image'       =&gt; $image,\n            // ...\n        ]),\n    ];\n    return new News($items);\n});\n\n// ...\n作为客服消息发送\n在客服消息里的使用也一样，都是直接传入消息实例即可：\n暂时略。\n发送多图文消息\n\n10 月 12 日起，被动回复消息 与 客服消息接口 的 图文消息类型 中 图文数目 只能为一条。\n\n多图文消息其实就是单图文消息组成的一个 News 对象而已：\n暂时略。\n群发消息\n请参考：群发消息\n消息转发给客服系统\n参见：多客服消息转发","link":"/Components/WeChat2.x/officialAccount/messages.html"},{"id":251,"title":"多客服消息转发","content":"多客服消息转发\n多客服的消息转发绝对是超级的简单，转发的消息类型为 transfer：\n&lt;?php\n\n$server = $officialAccount-&gt;server;\n\n// 转发收到的消息给客服\n$server-&gt;push(function (\\EasySwoole\\WeChat\\Kernel\\Contracts\\MessageInterface $message) {\n    return new \\EasySwoole\\WeChat\\Kernel\\Messages\\Transfer();\n});\n\n/** @var \\Psr\\Http\\Message\\ServerRequestInterface $psr7Request */\n// 在 EasySwoole 中\n$psr7Request = $this-&gt;request();\n# $psr7Request = new XxxReuest($request); // 伪代码 （在原生 Swoole 中）\n\n$replyResponse = $server-&gt;forceValidate()-&gt;serve($psr7Request);\n当然，你也可以指定转发给某一个客服：\n&lt;?php\n\n$server = $officialAccount-&gt;server;\n\n// 转发收到的消息给客服\n$server-&gt;push(function (\\EasySwoole\\WeChat\\Kernel\\Contracts\\MessageInterface $message) {\n    return new \\EasySwoole\\WeChat\\Kernel\\Messages\\Transfer($account);\n});\n\n// ... 这里省略","link":"/Components/WeChat2.x/officialAccount/messageTransfer.html"},{"id":252,"title":"消息群发","content":"消息群发\n微信的群发消息接口有各种乱七八糟的注意事项及限制，具体请阅读 微信官方文档。\n发送消息\n以下所有方法均有第二个参数 $to 用于指定接收对象：\n\n当 $to 为整型时为标签 id\n\n当 $to 为数组时为用户的 openid 列表（至少两个用户的 openid）\n当 $to 为 null 时表示全部用户\n\n$officialAccount-&gt;broadcasting-&gt;sendMessage(\\EasySwoole\\WeChat\\Kernel\\Contracts\\MessageInterface $message, array | int $to = null);\n下面的别名方法 sendXXX 都是基于上面 sendMessage 方法的封装。\n文本消息\n&lt;?php\n// 发送给全部用户\n$officialAccount-&gt;broadcasting-&gt;sendText(\"大家好！欢迎使用 EasySwoole WeChat。\");\n\n// 指定目标用户\n// 至少两个用户的 openid，必须是数组。\n$officialAccount-&gt;broadcasting-&gt;sendText(\"大家好！欢迎使用 EasySwoole WeChat。\", [$openid1, $openid2]);\n\n// 指定标签组用户\n$officialAccount-&gt;broadcasting-&gt;sendText(\"大家好！欢迎使用 EasySwoole WeChat。\", $tagId); // $tagId 必须是整型数字\n图文消息\n&lt;?php\n$officialAccount-&gt;broadcasting-&gt;sendNews($mediaId);\n\n$officialAccount-&gt;broadcasting-&gt;sendNews($mediaId, [$openid1, $openid2]);\n\n$officialAccount-&gt;broadcasting-&gt;sendNews($mediaId, $tagId);\n图片消息\n&lt;?php\n$officialAccount-&gt;broadcasting-&gt;sendImage($mediaId);\n\n$officialAccount-&gt;broadcasting-&gt;sendImage($mediaId, [$openid1, $openid2]);\n\n$officialAccount-&gt;broadcasting-&gt;sendImage($mediaId, $tagId);\n\n$mediaIds = [\n    'aaa',\n    'bbb',\n    'ccc'\n];\n$extraParams = [\n    'recomand' =&gt; 'xxx',\n    'need_open_comment' =&gt; 1,\n    'only_fans_can_comment' =&gt; 0\n];\n$officialAccount-&gt;broadcasting-&gt;sendImages($mediaIds, 2, [], $extraParams);\n语音消息\n&lt;?php\n$officialAccount-&gt;broadcasting-&gt;sendVoice($mediaId);\n\n$officialAccount-&gt;broadcasting-&gt;sendVoice($mediaId, [$openid1, $openid2]);\n\n$officialAccount-&gt;broadcasting-&gt;sendVoice($mediaId, $tagId);\n视频消息\n用于群发的视频消息，需要先创建消息对象。\n&lt;?php\n// 1. 先上传视频素材用于群发：\n$video = '/path/to/video.mp4';\n$videoMedia = $officialAccount-&gt;material-&gt;uploadVideo($video, '视频标题', '视频描述');\n\n// 结果如下：\n//{\n//  \"media_id\":\"IhdaAQXuvJtGzwwc0abfXnzeezfO0NgPK6AQYShD8RQYMTtfzbLdBIQkQziv2XJc\",\n//  \"url\": \"URL\"\n//}\n\n// 2. 使用上面得到的 media_id 群发视频消息\n$officialAccount-&gt;broadcasting-&gt;sendVideo($videoMedia['media_id']);\n\n// to tag\n$officialAccount-&gt;broadcasting-&gt;sendVideo($videoMedia['media_id'], $tagId);\n\n// to user\n$officialAccount-&gt;broadcasting-&gt;sendVideo($videoMedia['media_id'], [$openid1, $openid2]);\n卡券消息\n&lt;?php\n$officialAccount-&gt;broadcasting-&gt;sendCard($cardId);\n\n// to user\n$officialAccount-&gt;broadcasting-&gt;sendCard($cardId, [$openid1, $openid2]);\n\n// to tag\n$officialAccount-&gt;broadcasting-&gt;sendCard($cardId, $tagId);\n发送预览群发消息给指定的 openId 用户\n&lt;?php\n$officialAccount-&gt;broadcasting-&gt;previewText($text, $openId);\n$officialAccount-&gt;broadcasting-&gt;previewNews($mediaId, $openId);\n$officialAccount-&gt;broadcasting-&gt;previewVoice($mediaId, $openId);\n$officialAccount-&gt;broadcasting-&gt;previewImage($mediaId, $openId);\n$officialAccount-&gt;broadcasting-&gt;previewVideo($mediaId, $openId);\n$officialAccount-&gt;broadcasting-&gt;previewCard($cardId, $openId);\n发送预览群发消息给指定的微信号用户\n\n$wxanme 是用户的微信号，比如：easyswoole\n\n&lt;?php\n$officialAccount-&gt;broadcasting-&gt;previewText($text, $wxname, \\EasySwoole\\WeChat\\OfficialAccount\\Broadcasting\\Client::PREVIEW_BY_NAME);\n$officialAccount-&gt;broadcasting-&gt;previewNews($mediaId, $wxname, \\EasySwoole\\WeChat\\OfficialAccount\\Broadcasting\\Client::PREVIEW_BY_NAME);\n$officialAccount-&gt;broadcasting-&gt;previewVoice($mediaId, $wxname, \\EasySwoole\\WeChat\\OfficialAccount\\Broadcasting\\Client::PREVIEW_BY_NAME);\n$officialAccount-&gt;broadcasting-&gt;previewImage($mediaId, $wxname, \\EasySwoole\\WeChat\\OfficialAccount\\Broadcasting\\Client::PREVIEW_BY_NAME);\n$officialAccount-&gt;broadcasting-&gt;previewVideo($mediaId, $wxname, \\EasySwoole\\WeChat\\OfficialAccount\\Broadcasting\\Client::PREVIEW_BY_NAME);\n$officialAccount-&gt;broadcasting-&gt;previewCard($cardId, $wxname, \\EasySwoole\\WeChat\\OfficialAccount\\Broadcasting\\Client::PREVIEW_BY_NAME);\n删除群发消息\n&lt;?php\n$officialAccount-&gt;broadcasting-&gt;delete($msgId);\n\n$officialAccount-&gt;broadcasting-&gt;delete($msgId, $index);\n查询群发消息发送状态\n$officialAccount-&gt;broadcasting-&gt;status($msgId);","link":"/Components/WeChat2.x/officialAccount/broadcasting.html"},{"id":253,"title":"模板消息","content":"模板消息\n模板消息仅用于公众号向用户发送重要的服务通知，只能用于符合其要求的服务场景中，如信用卡刷卡通知、商品购买成功通知等。不支持广告等营销类消息以及其它所有可能对用户造成骚扰的消息。\n修改账号所属行业\n$officialAccount-&gt;templateMessage-&gt;setIndustry($industryId1, $industryId2);\n获取支持的行业列表\n$officialAccount-&gt;templateMessage-&gt;getIndustry();\n添加模板\n在公众号后台获取 $shortId 并添加到账户。\n$officialAccount-&gt;templateMessage-&gt;addTemplate($shortId);\n获取所有模板列表\n$officialAccount-&gt;templateMessage-&gt;getPrivateTemplates();\n删除模板\n$officialAccount-&gt;templateMessage-&gt;deletePrivateTemplate($templateId);\n发送模板消息\n&lt;?php\n\n$officialAccount-&gt;templateMessage-&gt;send([\n    'touser' =&gt; 'user-openid',\n    'template_id' =&gt; 'template-id',\n    'url' =&gt; 'https://www.easyswoole.com',\n    'miniprogram' =&gt; [\n        'appid' =&gt; 'xxxxxxx',\n        'pagepath' =&gt; 'pages/xxx',\n    ],\n    'data' =&gt; [\n        'key1' =&gt; 'VALUE',\n        'key2' =&gt; 'VALUE2',\n        // ...\n    ],\n]);\n如果 url 和 miniprogram 字段都传，会优先跳转小程序。\n发送一次性订阅消息\n&lt;?php\n\n$officialAccount-&gt;templateMessage-&gt;sendSubscription([\n    'touser' =&gt; 'user-openid',\n    'template_id' =&gt; 'template-id',\n    'url' =&gt; 'https://www.easyswoole.com',\n    'scene' =&gt; 1000,\n    'data' =&gt; [\n        'key1' =&gt; 'VALUE',\n        'key2' =&gt; 'VALUE2',\n        // ...\n    ],\n]);\n如果你想为发送的内容字段指定颜色，你可以将 \"data\" 部分写成下面 4 种不同的样式，不写 color 将会是默认黑色：\n'data' =&gt; [\n    'foo' =&gt; '你好',  // 不需要指定颜色\n    'bar' =&gt; ['你好', '#F00'], // 指定为红色\n    'baz' =&gt; ['value' =&gt; '你好', 'color' =&gt; '#550038'], // 与第二种一样\n    'zoo' =&gt; ['value' =&gt; '你好'], // 与第一种一样\n]","link":"/Components/WeChat2.x/officialAccount/templateMessage.html"},{"id":254,"title":"用户","content":"用户\n用户信息的获取是微信开发中比较常用的一个功能了，以下所有的用户信息的获取与更新，都是 基于微信的 openid 的，并且是已关注当前账号的，其它情况可能无法正常使用。\n获取用户信息\n获取单个：\n$user = $officialAccount-&gt;user-&gt;get($openId);\n获取多个：\n$users = $officialAccount-&gt;user-&gt;select([$openId1, $openId2, ...]);\n获取用户列表\n$officialAccount-&gt;user-&gt;list($nextOpenId = null);  // $nextOpenId 可选\n使用示例：\n&lt;?php\n$users = $officialAccount-&gt;user-&gt;list();\n获取结果 (result) 如下：\n{\n    \"total\": 2,\n    \"count\": 2,\n    \"data\": {\n        \"openid\": [\n            \"OPENID1\",\n            \"OPENID2\"\n        ]\n    },\n    \"next_openid\": \"NEXT_OPENID\"\n}\n修改用户备注\n$officialAccount-&gt;user-&gt;remark($openId, $remark); // 成功返回 boolean\n使用示例：\n$officialAccount-&gt;user-&gt;remark($openId, \"僵尸粉\");\n拉黑用户\n&lt;?php\n\n$officialAccount-&gt;user-&gt;block(['openidxxxxx']);\n\n// 或者拉黑多个用户\n$officialAccount-&gt;user-&gt;block(['openid1', 'openid2', 'openid3', ...]);\n取消拉黑用户\n&lt;?php\n\n$officialAccount-&gt;user-&gt;unblock(['openidxxxxx']);\n\n// 或者取消拉黑多个用户\n$officialAccount-&gt;user-&gt;unblock(['openid1', 'openid2', 'openid3', ...]);\n获取黑名单\n$officialAccount-&gt;user-&gt;blacklist($beginOpenid = null); // $beginOpenid 可选\n账号迁移 openid 转换\n账号迁移请从这里了解：https://kf.qq.com/product/weixinmp.html#hid=2488\n微信用户关注不同的公众号，对应的 OpenID 是不一样的，迁移成功后，粉丝的 OpenID 以目标帐号（即新公众号）对应的 OpenID 为准。但开发者可以通过开发接口转换 OpenID，开发文档可以参考： 提供一个 openid 转换的 API 接口，当帐号迁移后，可以通过该接口：\n\n将原帐号粉丝的 openid 转换为新帐号的 openid。\n将有授权关系用户的 openid 转换为新帐号的 openid。\n将卡券关联用户的 openid 转换为新帐号的 openid。\n\n\n原帐号：准备要迁移的帐号，当审核完成且管理员确认后即被回收。\n新帐号：用来接纳粉丝的帐号。新帐号在整个流程中均能正常使用。\n\n一定要按照下面的步骤来操作。\n\n一定要在原帐号被冻结之前，最好是准备提交审核前，获取原帐号的用户列表。如果没有原帐号的用户列表，用不了转换工具。如果原账号被回收，这时候也没办法调用接口获取用户列表。\n\n如何获取用户列表见这里：https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421140840\n\n转换 openid 的 API 接口如下，可在帐号迁移审核完成后开始调用，并最多保留 15 天。若帐号迁移没完成，调用时无返回结果或报错。帐号迁移 15 天后，该转换接口将会失效、无法拉取到数据。\n\n$officialAccount-&gt;user-&gt;changeOpenid($oldAppId, $openidList);\n返回值样例：\n{\n   \"errcode\":0,\n   \"errmsg\":\"ok\",\n   \"result_list\":[\n      {\n         \"ori_openid\":\"oEmYbwN-n24jxvk4Sox81qedINkQ\",\n         \"new_openid\":\"o2FwqwI9xCsVadFah_HtpPfaR-X4\",\n         \"err_msg\":\"ok\"\n      },\n      {\n         \"ori_openid\":\"oEmYbwH9uVd4RKJk7ZZg6SzL6tTo\",\n         \"err_msg\":\"ori_openid error\"\n      }\n   ]\n}","link":"/Components/WeChat2.x/officialAccount/user.html"},{"id":255,"title":"用户标签","content":"用户标签\n获取所有标签\n$officialAccount-&gt;userTag-&gt;list();\n使用示例：\n$tags = $officialAccount-&gt;userTag-&gt;list();\n获取结果：\n{\n    \"tags\": [\n        {\n            \"id\": 0,\n            \"name\": \"标签1\",\n            \"count\": 72596\n        },\n        {\n            \"id\": 1,\n            \"name\": \"标签2\",\n            \"count\": 36\n        },\n        // ...\n    ]\n}\n创建标签\n$officialAccount-&gt;userTag-&gt;create($name);\n使用示例：\n$officialAccount-&gt;userTag-&gt;create('测试标签');\n修改标签信息\n$officialAccount-&gt;userTag-&gt;update($tagId, $name);\n使用示例：\n$officialAccount-&gt;userTag-&gt;update(12, \"新的名称\");\n删除标签\n$officialAccount-&gt;userTag-&gt;delete($tagId);\n获取指定 openid 用户所属的标签\n$userTags = $officialAccount-&gt;userTag-&gt;userTags($openId);\n获取结果：\n{\n    \"tagid_list\":[\"标签1\",\"标签2\"]\n}\n获取标签下用户列表\n&lt;?php\n\n// $nextOpenId：第一个拉取的 OPENID，不填默认从头开始拉取\n$officialAccount-&gt;userTag-&gt;usersOfTag($tagId, $nextOpenId = '');\n获取结果示例：\n{\n    \"count\":2, // 这次获取的粉丝数量\n    \"data\":{ // 粉丝列表\n         \"openid\":[\n             \"ocYxcuAEy30bX0NXmGn4ypqx3tI0\",\n             \"ocYxcuBt0mRugKZ7tGAHPnUaOW7Y\"\n         ]\n    },\n    \"next_openid\":\"ocYxcuBt0mRugKZ7tGAHPnUaOW7Y\" // 拉取列表最后一个用户的openid\n}\n批量为用户添加标签\n&lt;?php\n\n$openIds = [$openId1, $openId2, ...];\n$officialAccount-&gt;userTag-&gt;tagUsers($openIds, $tagId);\n批量为用户移除标签\n&lt;?php\n\n$openIds = [$openId1, $openId2, ...];\n$officialAccount-&gt;userTag-&gt;untagUsers($openIds, $tagId);","link":"/Components/WeChat2.x/officialAccount/userTag.html"},{"id":256,"title":"网页授权","content":"网页授权\n关于 OAuth 2.0\nOAuth 是一个关于授权（authorization）的开放网络标准，在全世界得到广泛应用，目前的版本是 2.0 版。\nOAuth 授权流程大致如下：\n\n\n摘自：RFC 6749\n\n步骤解释：\n\n（A）用户打开客户端以后，客户端要求用户给予授权。\n（B）用户同意给予客户端授权。\n（C）客户端使用上一步获得的授权，向认证服务器申请令牌。\n（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。\n（E）客户端使用令牌，向资源服务器申请获取资源。\n（F）资源服务器确认令牌无误，同意向客户端开放资源。\n\n关于 OAuth 协议我们就简单了解到这里，如果还有不熟悉的同学，请 Google 相关资料\n微信 OAuth\n在微信里的 OAuth 其实有两种：公众平台网页授权获取用户信息、开放平台网页登录。\n它们的区别有两处，授权地址 不同，scope 不同。\n\n\n公众平台网页授权获取用户信息 \n\n\n授权 URL：https://open.weixin.qq.com/connect/oauth2/authorize\n\n\nScopes：snsapi_base 与 snsapi_userinfo\n\n\n\n开放平台网页登录 \n\n\n授权 URL：https://open.weixin.qq.com/connect/qrconnect \n\nScopes：snsapi_login\n\n\n\n他们的逻辑都一样：\n\n用户尝试访问一个我们的业务页面，例如: /user/profile\n\n如果用户已经登录，则正常显示该页面\n系统检查当前访问的用户并未登录（从 session 或者其它方式检查），则跳转到 微信授权服务器（上面的两种中一种 授权 URL ），并告知微信授权服务器我的 回调 URL（redirect_uri=callback.php)，此时用户看到蓝色的授权确认页面（scope 为 snsapi_base 时不显示）\n用户点击确定完成授权，浏览器跳转到 回调URL：callback.php 并带上 code： ?code=CODE&amp;state=STATE。\n在 callback.php 中得到 code 后，通过 code 再次向微信服务器请求得到 网页授权 access_token 与 openid\n\n你可以选择拿 openid 去请求 API 得到用户信息（可选）\n将用户信息写入 SESSION。\n跳转到第 3 步写入的 target_url 页面（/user/profile）。\n\n看懵了？没事，使用 SDK，你不用管这么多。\n注意，上面的第 3 步：redirect_uri=callback.php 实际上我们在 Swoole 中用 redirect_uri=callback 回调地址，后面还会带上授权目标页面 user/profile，所以完整的 redirect_uri 应该是下面的这样的 PHP 去拼出来：'redirect_uri=' . urlencode('callback?target=user/profile')，拼接结果为：redirect_uri=callback%3Ftarget%3Duser%2Fprofile\n逻辑组成\n从上面我们所描述的授权流程来看，我们至少有 3 个页面：\n\n\n业务页面，也就是需要授权才能访问的页面。\n\n发起授权页，此页面其实可以省略，可以做成一个中间件，全局检查未登录就发起授权。\n\n授权回调页，接收用户授权后的状态，并获取用户信息，写入用户会话状态（SESSION）。\n\n开始之前\n在开始之前请一定要记住，先登录公众号后台，找到 边栏 “开发” 模块下的 “接口权限”，点击 “网页授权获取用户基本信息” 后面的修改，添加你的网页授权域名。\n\n如果你的授权地址为：http://www.abc.com/xxxxx，那么请填写 www.abc.com，也就是说请填写与网址匹配的域名，前者如果填写 abc.com 是通过不了的。\n\nSDK 中 OAuth 模块的 API\n在 SDK 中，我们使用名称为 oauth 的模块来完成授权服务，我们主要用到以下两个 API：\n发起授权\n// $redirectUrl 为跳转目标，请自行 `302` 跳转到目标地址\n$redirectUrl = $officialAccount-&gt;oauth-&gt;scopes(['snsapi_userinfo'])\n    -&gt;redirect();\n当然你也可以在发起授权的时候指定回调 URL，比如设置回调 URL 为当前页面：\n&lt;?php\n\n// 在 EasySwoole 中，$this-&gt;request() 为 EasySwoole 的请求对象\n$redirectUrl = $officialAccount-&gt;oauth-&gt;scopes(['snsapi_userinfo'])\n    -&gt;redirect($this-&gt;request()-&gt;getUri());\n\n// 在原生 Swoole 中，$request 为 \\Swoole\\Http\\Request 的实例对象\n$redirectUrl = $officialAccount-&gt;oauth-&gt;scopes(['snsapi_userinfo'])\n    -&gt;redirect($request-&gt;server['request_uri']);\n它的返回值 $redirectUrl 是一个字符串跳转地址，请自行使用框架的跳转方法实现跳转，在 EasySwoole 中写法为：\n$this-&gt;response()-&gt;redirect($redirectUrl);\n在原生 Swoole 中可以这样写：\n// $response 为 \\Swoole\\Http\\Response 的实例对象\n$response-&gt;redirect($redirectUrl);\n获取已授权用户\n&lt;?php\n\n$code = \"微信回调URL携带的 code\";\n\n$user = $officialAccount-&gt;oauth-&gt;userFromCode($code);\n返回的 $user 是 EasySwoole\\WeChat\\OfficialAccount\\OAuth\\User 对象，你可以从该对象拿到更多的信息。\n$user 可以用的方法:\n\n\n$user-&gt;getId(); 对应微信的 openid\n\n\n$user-&gt;getNickname(); 对应微信的 nickname\n\n\n$user-&gt;getName(); 对应微信的 nickname\n\n\n$user-&gt;getAvatar(); 头像地址\n\n$user-&gt;getRaw(); 原始 API 返回的结果\n\n$user-&gt;getAccessToken(); access_token\n\n\n$user-&gt;getRefreshToken(); refresh_token\n\n\n$user-&gt;getExpiresIn(); expires_in，access_token 的过期时间\n\n$user-&gt;getTokenResponse(); 返回 access_token 时的响应值\n\n\n注意：$user 里没有 openid，$user-&gt;id 便是 openid。如果你想拿微信返回给你的原样的全部信息，请使用：$user-&gt;getRaw();\n\n当 scope 为 snsapi_base 时 $officialAccount-&gt;oauth-&gt;user(); 对象里只有 id，没有其它信息。\n网页授权实例\n我们这里来用 PHP 原生 Swoole 写法举个例子，oauth_callback 是我们的授权回调 URL (未 urlencode 编码的 URL)，user/profile 是我们需要授权才能访问的页面，它的 PHP 代码如下：\n\n// http://easyswoolewechat.com/user/profile\n\n&lt;?php\n\n// ... 这里省略\n\n$http-&gt;on('request', function (\\Swoole\\Http\\Request $request, \\Swoole\\Http\\Response $response) {\n\n    $config = [\n        // ...\n        'oauth' =&gt; [\n            'scopes' =&gt; ['snsapi_userinfo'],\n            'callback' =&gt; '/oauth_callback',\n        ],\n        // ..\n    ];\n\n    $officialAccount = \\EasySwoole\\WeChat\\Factory::officialAccount($config);\n\n    $oauth = $officialAccount-&gt;oauth;\n\n    // 未登录\n    if (empty($_SESSION['wechat_user'])) {\n\n        $_SESSION['target_url'] = 'user/profile';\n        $redirectUrl = $oauth-&gt;redirect();\n        $request-&gt;redirct($redirectUrl);\n        exit;\n    }\n\n    // 已经登录过\n    $user = $_SESSION['wechat_user'];\n});\n\n// ... 这里省略\n授权回调页：\n// http://easyswoolewechat.com/oauth_callback\n\n&lt;?php\n\n// ... 这里省略\n\n$http-&gt;on('request', function (\\Swoole\\Http\\Request $request, \\Swoole\\Http\\Response $response) {\n\n    $config = [\n        // ...\n    ];\n\n    $officialAccount = \\EasySwoole\\WeChat\\Factory::officialAccount($config);\n\n    $oauth = $officialAccount-&gt;oauth;\n\n    // 获取 OAuth 授权结果用户信息\n    $code = \"微信回调URL携带的 code\";\n\n    $user = $oauth-&gt;userFromCode($code);\n\n    $_SESSION['wechat_user'] = $user-&gt;toArray();\n\n    $targetUrl = empty($_SESSION['target_url']) ? '/' : $_SESSION['target_url'];\n\n    // 跳转到 user/profile\n    $response-&gt;redirect($targetUrl);\n});\n\n// ... 这里省略\n上面的例子呢都是基于 $_SESSION 来保持会话的，在微信客户端中，你可以结合 Cookies 来存储，但是有效期平台不一样时间也不一样，好像 Android 的失效会快一些，不过基本也够用了。","link":"/Components/WeChat2.x/officialAccount/oauth.html"},{"id":257,"title":"jssdk","content":"JSSDK\n微信 JSSDK 官方文档：https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421141115\nAPI\n获取 JSSDK 的配置数组\n$officialAccount-&gt;jssdk-&gt;buildConfig(string $url, array $apis, bool $debug = false, bool $beta = false, array $openTagList = []);\n返回 JSON 字符串。\n设置当前 URL\n$officialAccount-&gt;jssdk-&gt;buildConfig($url, []);\n如果不想用默认读取的 URL，可以使用此方法手动设置，通常不需要。\n使用示例：\n我们可以生成 js 配置文件：\n&lt;script src=\"https://res.wx.qq.com/open/js/jweixin-1.4.0.js\" type=\"text/javascript\" charset=\"utf-8\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\" charset=\"utf-8\"&gt;\n    wx.config(&lt;?php echo $officialAccount-&gt;jssdk-&gt;buildConfig(array('updateAppMessageShareData', 'updateTimelineShareData'), true) ?&gt;);\n&lt;/script&gt;\n结果如下：\n&lt;script src=\"https://res.wx.qq.com/open/js/jweixin-1.4.0.js\" type=\"text/javascript\" charset=\"utf-8\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\" charset=\"utf-8\"&gt;\nwx.config({\n    debug: true, // 请在上线前删除它\n    appId: 'wx3cf0f39249eb0e60',\n    timestamp: 1430009304,\n    nonceStr: 'qey94m021ik',\n    signature: '4F76593A4245644FAE4E1BC940F6422A0C3EC03E',\n    jsApiList: ['updateAppMessageShareData', 'updateTimelineShareData']\n});\n&lt;/script&gt;","link":"/Components/WeChat2.x/officialAccount/jssdk.html"},{"id":258,"title":"临时素材","content":"临时素材\n上传的临时多媒体文件有格式和大小限制，如下：\n\n图片（image）: 2M，支持 JPG 格式\n语音（voice）：2M，播放长度不超过 60s，支持 AMR\\MP3 格式\n视频（video）：10MB，支持 MP4 格式\n缩略图（thumb）：64KB，支持 JPG 格式\n\n上传图片\n\n注意：微信图片上传服务有敏感检测系统，图片内容如果含有敏感内容，如色情，商品推广，虚假信息等，上传可能失败。\n\n$officialAccount-&gt;media-&gt;uploadImage($path);\n上传声音\n$officialAccount-&gt;media-&gt;uploadVoice($path);\n上传视频\n$officialAccount-&gt;media-&gt;uploadVideo($path);\n上传缩略图\n用于视频封面或者音乐封面。\n$officialAccount-&gt;media-&gt;uploadThumb($path);\n上传群发视频\n上传视频获取 media_id 用以创建群发消息用。\n&lt;?php\n\n$uploadRet = $officialAccount-&gt;media-&gt;uploadVideo($path);\n\n$officialAccount-&gt;media-&gt;createVideoForBroadcasting($uploadRet['media_id'], $title, $description);\n运行结果：\n{\n    \"media_id\": \"rF4UdIMfYK3efUfyoddYRMU50zMiRmmt_l0kszupYh_SzrcW5Gaheq05p_lHuOTQ\",\n    \"title\": \"TITLE\",\n    \"description\": \"Description\"\n}\n创建群发消息\n使用 media_id 加标题和描述，创建一条消息素材 用来发送给用户。详情参见：消息群发\n$officialAccount-&gt;media-&gt;createVideoForBroadcasting($mediaId, $title, $description);\n$officialAccount-&gt;media-&gt;createVideoForBroadcasting($mediaId, $title, $description);\n运行结果：\n{\n    \"type\": \"video\",\n    \"media_id\": \"IhdaAQXuvJtGzwwc0abfXnzeezfO0NgPK6AQYShD8RQYMTtfzbLdBIQkQziv2XJc\",\n    \"created_at\": 1398848981\n}\n获取临时素材内容\n比如图片、语音等二进制流内容，响应为 EasyWeChat\\Kernel\\Http\\StreamResponse 实例。\n&lt;?php\n\n$stream = $officialAccount-&gt;media-&gt;get($mediaId);\n\nif ($stream instanceof \\EasySwoole\\WeChat\\Kernel\\Psr\\StreamResponse) {\n    // 以内容 md5 为文件名存到本地\n    $stream-&gt;save('保存目录');\n\n    // 自定义文件名，不需要带后缀\n    $stream-&gt;saveAs('保存目录', '文件名');\n}\n获取 JSSDK 上传的高清语音\n&lt;?php\n\n$stream = $officialAccount-&gt;media-&gt;getJssdkMedia($mediaId);\n$stream-&gt;saveAs('保存目录', 'custom-name.speex');","link":"/Components/WeChat2.x/officialAccount/media.html"},{"id":259,"title":"二维码","content":"二维码\n目前有 2 种类型的二维码：\n\n临时二维码，是有过期时间的，最长可以设置为在二维码生成后的 30 天后过期，但能够生成较多数量。临时二维码主要用于帐号绑定等不要求二维码永久保存的业务场景\n永久二维码，是无过期时间的，但数量较少（目前为最多 10 万个）。永久二维码主要用于适用于帐号绑定、用户来源统计等场景。\n\n创建临时二维码\n&lt;?php\n\n$result = $officialAccount-&gt;qrcode-&gt;temporary('foo', 6 * 24 * 3600);\n\n// 运行结果：\n/*\nArray\n(\n    [ticket] =&gt; gQFD8TwAAAAAAAAAAS5odHRwOi8vd2VpeGluLnFxLmNvbS9xLzAyTmFjVTRWU3ViUE8xR1N4ajFwMWsAAgS2uItZAwQA6QcA\n    [expire_seconds] =&gt; 518400\n    [url] =&gt; http://weixin.qq.com/q/02NacU4VSubPO1GSxj1p1k\n)\n*/\n创建永久二维码\n$result = $officialAccount-&gt;qrcode-&gt;forever(56);\n\n// 或者\n$officialAccount-&gt;qrcode-&gt;forever(\"foo\");\n\n// 运行结果：\n/*\nArray\n(\n    [ticket] =&gt; gQFD8TwAAAAAAAAAAS5odHRwOi8vd2VpeGluLnFxLmNvbS9xLzAyTmFjVTRWU3ViUE8xR1N4ajFwMWsAAgS2uItZAwQA6QcA\n    [url] =&gt; http://weixin.qq.com/q/02NacU4VSubPO1GSxj1p1k\n)\n*/\n获取二维码网址\n$url = $officialAccount-&gt;qrcode-&gt;url($ticket);\n// https://api.weixin.qq.com/cgi-bin/showqrcode?ticket=TICKET\n获取二维码内容\n&lt;?php\n\n$url = $officialAccount-&gt;qrcode-&gt;url($ticket);\n\n$content = file_get_contents($url); // 得到二进制图片内容\n\n// 在 EasySwoole 框架中\nfile_put_contents(EASYSWOOLE_ROOT . '/code.jpg', $content); // 写入文件，这里的路径请使用绝对路径\n\n// 或者 在原生 Swoole 中\n// file_put_contents(__DIR__ . '/code.jpg', $content); // 写入文件，这里的路径请使用绝对路径","link":"/Components/WeChat2.x/officialAccount/qrcode.html"},{"id":260,"title":"素材管理","content":"素材管理\n在微信里的图片、音乐、视频等等都需要先上传到微信服务器作为素材才可以在消息中使用。\n上传图片\n\n注意：微信图片上传服务有敏感检测系统，图片内容如果含有敏感内容，如色情，商品推广，虚假信息等，上传可能失败。\n\n$result = $officialAccount-&gt;material-&gt;uploadImage(\"/path/to/your/image.jpg\");\n\n// 运行结果：\n{\n    \"media_id\": MEDIA_ID,\n    \"url\": URL\n}\nurl 只有上传图片素材有返回值。\n上传语音\n语音 大小不超过 5M，长度不超过 60 秒，支持 mp3/wma/wav/amr 格式。\n$result = $officialAccount-&gt;material-&gt;uploadVoice(\"/path/to/your/voice.mp3\");\n\n// 运行结果：\n{\n    \"media_id\": MEDIA_ID,\n}\n上传视频\n$result = $officialAccount-&gt;material-&gt;uploadVideo(\"/path/to/your/video.mp4\", \"视频标题\", \"视频描述\");\n\n// 运行结果：\n{\n    \"media_id\": MEDIA_ID,\n}\n上传缩略图\n用于视频封面或者音乐封面。\n$result = $officialAccount-&gt;material-&gt;uploadThumb(\"/path/to/your/thumb.jpg\");\n\n// 运行结果：\n{\n    \"media_id\": MEDIA_ID,\n}\n上传图文消息\n&lt;?php\n\nuse EasySwoole\\WeChat\\Kernel\\Messages\\Article;\n\n// 上传单篇图文\n$article = new Article([\n    'title' =&gt; 'xxx',\n    'thumb_media_id' =&gt; $mediaId,\n    // ...\n]);\n$officialAccount-&gt;material-&gt;uploadArticle($article);\n\n// 或者上传多篇图文\n$officialAccount-&gt;material-&gt;uploadArticle([$article, $article2, ...]);\n\n// 运行结果：\n/*\n{\n    \"media_id\": MEDIA_ID,\n    \"url\": URL\n}\n*/\n修改图文消息\n有三个参数：\n\n\n$mediaId 要更新的文章的 mediaId\n\n\n$article 文章内容，Article 实例或者 全字段数组\n\n\n$index 要更新的文章在图文消息中的位置（多图文消息时，此字段才有意义，单图片忽略此参数），第一篇为 0；\n\n&lt;?php\n\nuse EasySwoole\\WeChat\\Kernel\\Messages\\Article;\n\n$result = $officialAccount-&gt;material-&gt;updateArticle($mediaId, new Article(...));\n\n// or\n$result = $officialAccount-&gt;material-&gt;updateArticle($mediaId, [\n    'title' =&gt; 'EasySwoole WeChat 2.0 发布了！',\n    'thumb_media_id' =&gt; 'qQFxUQGO21Li4YrSn3MhnrqtRp9Zi3cbM9uBsepvDmE', // 封面图片 mediaId\n    'author' =&gt; 'overtrue', // 作者\n    'show_cover' =&gt; 1, // 是否在文章内容显示封面图片\n    'digest' =&gt; '这里是文章摘要',\n    'content' =&gt; '这里是文章内容，你可以放很长的内容',\n    'source_url' =&gt; 'https://www.easyswoolewechat.com',\n]);\n\n// 指定更新多图文中的第 2 篇\n$result = $officialAccount-&gt;material-&gt;updateArticle($mediaId, new Article(...), 1); // 第 2 篇\n上传图文消息图片\n返回值中 url 就是上传图片的 URL，可用于后续群发中，放置到图文消息中。\n$result = $officialAccount-&gt;material-&gt;uploadArticleImage($path);\n\n// 运行结果：\n{\n    \"url\":  \"http://mmbiz.qpic.cn/mmbiz/gLO17UPS6FS2xsypf378iaNhWacZ1G1UplZYWEYfwvuU6Ont96b1roYsCNFwaRrSaKTPCUdBK9DgEHicsKwWCBRQ/0\"\n}\n获取永久素材\n$resource = $officialAccount-&gt;material-&gt;get($mediaId);\n如果请求的素材为图文消息，则响应如下：\n{\n    \"news_item\": [\n        {\n            \"title\": TITLE,\n            \"thumb_media_id\": THUMB_MEDIA_ID,\n            \"show_cover_pic\": SHOW_COVER_PIC(0/1),\n            \"author\": AUTHOR,\n            \"digest\": DIGEST,\n            \"content\": CONTENT,\n            \"url\": URL,\n            \"content_source_url\": CONTENT_SOURCE_URL\n        },\n        // 多图文消息有多篇文章\n    ]\n}\n如果返回的是视频消息素材，则内容如下：\n{\n    \"title\": TITLE,\n    \"description\": DESCRIPTION,\n    \"down_url\": DOWN_URL,\n}\n其他类型的素材消息，则响应为 \\EasySwoole\\WeChat\\Kernel\\Psr\\StreamResponse 实例，开发者可以自行保存为文件。例如\n&lt;?php\n\n$stream = $officialAccount-&gt;material-&gt;get($mediaId);\n\nif ($stream instanceof StreamResponse) {\n    // 以内容 md5 为文件名\n    $stream-&gt;save('保存目录');\n\n    // 自定义文件名，不需要带后缀\n    $stream-&gt;saveAs('保存目录', '文件名');\n}\n获取永久素材列表\n\n\n$type 素材的类型，图片（image）、视频（video）、语音 （voice）、图文（news）\n\n$offset 从全部素材的该偏移位置开始返回，可选，默认 0，0 表示从第一个素材 返回\n\n$count 返回素材的数量，可选，默认 20, 取值在 1 到 20 之间\n\n$officialAccount-&gt;material-&gt;list($type, $offset, $count);\n使用示例：\n$list = $officialAccount-&gt;material-&gt;list('image', 0, 10);\n图片、语音、视频 等类型的返回如下：\n{\n    \"total_count\": TOTAL_COUNT,\n    \"item_count\": ITEM_COUNT,\n    \"item\": [\n        {\n            \"media_id\": MEDIA_ID,\n            \"name\": NAME,\n            \"update_time\": UPDATE_TIME,\n            \"url\": URL\n        },\n        // 可能会有多个素材\n    ]\n}\n永久图文消息素材列表的响应如下：\n{\n    \"total_count\": TOTAL_COUNT,\n    \"item_count\": ITEM_COUNT,\n    \"item\": [\n        {\n            \"media_id\": MEDIA_ID,\n            \"content\": {\n                \"news_item\": [\n                    {\n                        \"title\": TITLE,\n                        \"thumb_media_id\": THUMB_MEDIA_ID,\n                        \"show_cover_pic\": SHOW_COVER_PIC(0 / 1),\n                        \"author\": AUTHOR,\n                        \"digest\": DIGEST,\n                        \"content\": CONTENT,\n                        \"url\": URL,\n                        \"content_source_url\": CONTETN_SOURCE_URL\n                    }\n                    // 多图文消息会在此处有多篇文章\n                ]\n            },\n            \"update_time\": UPDATE_TIME\n        }\n        // 可能有多个图文消息item结构\n    ]\n}\n获取素材计数\n$stats = $officialAccount-&gt;material-&gt;stats();\n\n// 运行结果：\n{\n    \"voice_count\": COUNT,\n    \"video_count\": COUNT,\n    \"image_count\": COUNT,\n    \"news_count\": COUNT\n}\n删除永久素材\n$officialAccount-&gt;material-&gt;delete($mediaId);\n文章预览\n文章预览请参阅 “消息群发” 章节。","link":"/Components/WeChat2.x/officialAccount/material.html"},{"id":261,"title":"菜单","content":"菜单\n读取（查询）已设置菜单\n$list = $officialAccount-&gt;menu-&gt;query();\n获取当前菜单\n$current = $officialAccount-&gt;menu-&gt;queryConfig();\n添加菜单\n添加普通菜单\n&lt;?php\n\n$buttons = [\n    'button' =&gt; [\n        [\n            \"type\" =&gt; \"click\",\n            \"name\" =&gt; \"今日歌曲\",\n            \"key\" =&gt; \"V1001_TODAY_MUSIC\"\n        ],\n        [\n            \"name\" =&gt; \"菜单\",\n            \"sub_button\" =&gt; [\n                [\n                    \"type\" =&gt; \"view\",\n                    \"name\" =&gt; \"搜索\",\n                    \"url\" =&gt; \"http://www.soso.com/\"\n                ],\n                [\n                    \"type\" =&gt; \"view\",\n                    \"name\" =&gt; \"视频\",\n                    \"url\" =&gt; \"http://v.qq.com/\"\n                ],\n                [\n                    \"type\" =&gt; \"click\",\n                    \"name\" =&gt; \"赞一下我们\",\n                    \"key\" =&gt; \"V1001_GOOD\"\n                ],\n            ],\n        ],\n    ]\n];\n\n$officialAccount-&gt;menu-&gt;create($buttons);\n以上将会创建一个普通菜单。\n添加个性化菜单\n与创建普通菜单不同的是，需要在 create() 方法中将个性化匹配规则作为第二个参数传进去：\n&lt;?php\n\n$matchRule = [\n    \"matchrule\" =&gt; [\n        \"tag_id\" =&gt; \"2\",\n        \"sex\" =&gt; \"1\",\n        \"country\" =&gt; \"中国\",\n        \"province\" =&gt; \"广东\",\n        \"city\" =&gt; \"广州\",\n        \"client_platform_type\" =&gt; \"2\",\n        \"language\" =&gt; \"zh_CN\"\n    ],\n];\n\n$buttons = [\n    'button' =&gt; [\n        [\n            \"type\" =&gt; \"click\",\n            \"name\" =&gt; \"今日歌曲\",\n            \"key\" =&gt; \"V1001_TODAY_MUSIC\"\n        ],\n        [\n            \"name\" =&gt; \"菜单\",\n            \"sub_button\" =&gt; [\n                [\n                    \"type\" =&gt; \"view\",\n                    \"name\" =&gt; \"搜索\",\n                    \"url\" =&gt; \"http://www.soso.com/\"\n                ],\n                [\n                    \"type\" =&gt; \"view\",\n                    \"name\" =&gt; \"视频\",\n                    \"url\" =&gt; \"http://v.qq.com/\"\n                ],\n                [\n                    \"type\" =&gt; \"click\",\n                    \"name\" =&gt; \"赞一下我们\",\n                    \"key\" =&gt; \"V1001_GOOD\"\n                ],\n            ],\n        ],\n    ],\n    $matchRule\n];\n\n$officialAccount-&gt;menu-&gt;addconditional($buttons);\n删除菜单\n有两种删除方式，一种是全部删除，另外一种是根据菜单 ID 来删除(删除个性化菜单时用，ID 从查询接口获取)：\n// 删除全部\n$officialAccount-&gt;menu-&gt;delete();\n删除个性化菜单\n$officialAccount-&gt;menu-&gt;delconditional($menuId);\n测试个性化菜单\n$officialAccount-&gt;menu-&gt;match($userId);\n$userId 可以是粉丝的 OpenID，也可以是粉丝的微信号。\n返回 $menu 与指定的 $userId 匹配的菜单项。","link":"/Components/WeChat2.x/officialAccount/menu.html"},{"id":262,"title":"卡券","content":"卡券\n获取实例\n$card = $officialAccount-&gt;card;\n\n注意：后文用到的 $card 都为此实例。\n\n通用功能\n获取卡券颜色\n$card-&gt;colors();\n卡券开放类目查询\n$card-&gt;categories();\n创建卡券\n创建卡券接口是微信卡券的基础接口，用于创建一类新的卡券，获取 card_id，创建成功并通过审核后，商家可以通过文档提供的其他接口将卡券下发给用户，每次成功领取，库存数量相应扣除。\n$card-&gt;create(string $cardType, array $attributes);\n\n\nattributes array 卡券信息\n\n使用示例：\n&lt;?php\n\n$cardType = 'GROUPON';\n\n$attributes = [\n    'base_info' =&gt; [\n        'brand_name' =&gt; '微信餐厅',\n        'code_type' =&gt; 'CODE_TYPE_TEXT',\n        'title' =&gt; '132元双人火锅套餐',\n        // ...\n    ],\n    'advanced_info' =&gt; [\n        'use_condition' =&gt; [\n            'accept_category' =&gt; '鞋类',\n            'reject_category' =&gt; '阿迪达斯',\n            'can_use_with_other_discount' =&gt; true,\n        ],\n        // ...\n    ],\n];\n\n$result = $card-&gt;create($cardType, $attributes);\n获取卡券详情\n$cardInfo = $card-&gt;get($cardId);\n批量查询卡列表\n$card-&gt;list($offset = 0, $count = 10, $statusList = 'CARD_STATUS_VERIFY_OK');\n\n\noffset int - 查询卡列表的起始偏移量，从 0 开始\n\ncount int - 需要查询的卡片的数量\n\nstatusList - 支持开发者拉出指定状态的卡券列表，详见 example\n\n\n使用示例：\n// CARD_STATUS_NOT_VERIFY, 待审核；\n// CARD_STATUS_VERIFY_FAIL, 审核失败；\n// CARD_STATUS_VERIFY_OK， 通过审核；\n// CARD_STATUS_USER_DELETE，卡券被商户删除；\n// CARD_STATUS_DISPATCH，在公众平台投放过的卡券；\n\n$result = $card-&gt;list($offset, $count, 'CARD_STATUS_NOT_VERIFY');\n更改卡券信息接口\n支持更新所有卡券类型的部分通用字段及特殊卡券中特定字段的信息。\n$card-&gt;update($cardId, $type, $attributes = []);\n\n\ntype string - 卡券类型\n\n使用示例：\n&lt;?php\n\n$cardId = 'pdkJ9uCzKWebwgNjxosee0ZuO3Os';\n\n$type = 'groupon';\n\n$attributes = [\n    'base_info' =&gt; [\n        'logo_url' =&gt; 'http://mmbiz.qpic.cn/mmbiz/2aJY6aCPatSeibYAyy7yct9zJXL9WsNVL4JdkTbBr184gNWS6nibcA75Hia9CqxicsqjYiaw2xuxYZiaibkmORS2oovdg/0',\n        'center_title' =&gt; '顶部居中按钮',\n        'center_sub_title' =&gt; '按钮下方的wording',\n        'center_url' =&gt; 'http://www.easyswoolewechat.com',\n        'custom_url_name' =&gt; '立即使用',\n        'custom_url' =&gt; 'http://www.qq.com',\n        'custom_url_sub_title' =&gt; '6个汉字tips',\n        'promotion_url_name' =&gt; '更多优惠',\n        'promotion_url' =&gt; 'http://www.qq.com',\n    ],\n    // ...\n];\n\n$result = $card-&gt;update($cardId, $type, $attributes);\n删除卡券\n$card-&gt;delete($cardId);\n创建二维码\n开发者可调用该接口生成一张卡券二维码供用户扫码后添加卡券到卡包。\n自定义 Code 码的卡券调用接口时，POST 数据中需指定 code，非自定义 code 不需指定，指定 openid 同理。指定后的二维码只能被用户扫描领取一次。\n$card-&gt;createQrCode($cards);\n\n\ncards array - 卡券相关信息\n\n使用示例：\n&lt;?php\n\n// 领取单张卡券\n$cards = [\n    'action_name' =&gt; 'QR_CARD',\n    'expire_seconds' =&gt; 1800,\n    'action_info' =&gt; [\n        'card' =&gt; [\n            'card_id' =&gt; 'pdkJ9uFS2WWCFfbbEfsAzrzizVyY',\n            'is_unique_code' =&gt; false,\n            'outer_id' =&gt; 1,\n        ],\n    ],\n];\n\n$result = $card-&gt;createQrCode($cards);\n&lt;?php\n\n// 领取多张卡券\n$cards = [\n    'action_name' =&gt; 'QR_MULTIPLE_CARD',\n    'action_info' =&gt; [\n        'multiple_card' =&gt; [\n            'card_list' =&gt; [\n                ['card_id' =&gt; 'pdkJ9uFS2WWCFfbbEfsAzrzizVyY'],\n            ],\n        ],\n    ],\n];\n\n$result = $card-&gt;createQrCode($cards);\n请求成功返回值示例：\n{\n    \"errcode\": 0,\n    \"errmsg\": \"ok\",\n    // 获取 ticket 后需调用换取二维码接口获取二维码图片，详情见字段说明。\n    \"ticket\": \"gQHB8DoAAAAAAAAAASxodHRwOi8vd2VpeGluLnFxLmNvbS9xL0JIV3lhX3psZmlvSDZmWGVMMTZvAAIEsNnKVQMEIAMAAA==\",\n    \"expire_seconds\": 1800,\n    \"url\": \"http://weixin.qq.com/q/BHWya_zlfioH6fXeL16o \",\n    \"show_qrcode_url\": \"https://mp.weixin.qq.com/cgi-bin/showqrcode?  ticket=gQH98DoAAAAAAAAAASxodHRwOi8vd2VpeGluLnFxLmNvbS9xL0czVzRlSWpsamlyM2plWTNKVktvAAIE6SfgVQMEgDPhAQ%3D%3D\"\n}\nticket 换取二维码图片\n获取二维码 ticket 后，开发者可用 ticket 换取二维码图片。\n$card-&gt;getQrCode($ticket);\n\nstring $ticket。获取的二维码 ticket，凭借此 ticket 可以在有效时间内换取二维码。\n\n使用示例：\n&lt;?php\n\n$ticket = 'gQFF8DoAAAAAAAAAASxodHRwOi8vd2VpeGluLnFxLmNvbS9xL01VTzN0T0hsS1BwUlBBYUszbVN5AAIEughxVwMEAKd2AA==';\n\n$result = $card-&gt;getQrCode($ticket);\nticket 换取二维码链接\n$card-&gt;getQrCodeUrl($ticket);\n使用示例：\n&lt;?php\n\n$ticket = 'gQFF8DoAAAAAAAAAASxodHRwOi8vd2VpeGluLnFxLmNvbS9xL01VTzN0T0hsS1BwUlBBYUszbVN5AAIEughxVwMEAKd2AA==';\n\n$card-&gt;getQrCodeUrl($ticket);\n创建货架接口\n开发者需调用该接口创建货架链接，用于卡券投放。创建货架时需填写投放路径的场景字段。\n$card-&gt;createLandingPage($banner, $pageTitle, $canShare, $scene, $cardList);\n\nstring $banner。页面的 banner 图\nstring $pageTitle。页面的 title\n\nbool   $canShare。页面是不是可以分享，true 或 false\n\nstring $scene。投放页面的场景值，具体值请参考下面的 使用示例。\narray  $cardList。卡券列表，每个元素有两个字段\n\n使用示例：\n&lt;?php\n\n$banner = 'http://mmbiz.qpic.cn/mmbiz/iaL1LJM1mF9aRKPZJkmG8xXhiaHqkKSVMMWeN3hLut7X7hicFN';\n\n$pageTitle = '惠城优惠大派送';\n\n$canShare = true;\n\n// SCENE_NEAR_BY          附近\n// SCENE_MENU             自定义菜单\n// SCENE_QRCODE           二维码\n// SCENE_ARTICLE          公众号文章\n// SCENE_H5               h5页面\n// SCENE_IVR              自动回复\n// SCENE_CARD_CUSTOM_CELL 卡券自定义 cell\n\n$scene = 'SCENE_NEAR_BY';\n\n$cardList = [\n    ['card_id' =&gt; 'pdkJ9uLRSbnB3UFEjZAgUxAJrjeY', 'thumb_url' =&gt; 'http://test.digilinx.cn/wxApi/Uploads/test.png'],\n    ['card_id' =&gt; 'pdkJ9uJ37aU-tyRj4_grs8S45k1c', 'thumb_url' =&gt; 'http://test.digilinx.cn/wxApi/Uploads/aa.jpg'],\n];\n\n$result = $card-&gt;createLandingPage($banner, $pageTitle, $canShare, $scene, $cardList);\n图文消息群发卡券\n特别注意：目前该接口仅支持填入非自定义 code 的卡券吗，自定义 code 的卡券需先进行 code 导入后调用。\n$card-&gt;getHtml($cardId);\n使用示例：\n&lt;?php\n\n$cardId = 'pdkJ9uLCEF_HSKO7JdQOUcZ-PUzo';\n\n$result = $card-&gt;getHtml($cardId);\n设置测试白名单\n同时支持 “openid”、“username” 两种字段设置白名单，总数上限为 10 个。\n// 使用 openid\n$card-&gt;setTestWhitelist($openids);\n\n\narray $openids：测试的 openid 列表\n\n// 使用 username\n$card-&gt;setTestWhitelistByName($usernames);\n\n\narray $usernames：测试的微信号列表\n\n使用示例：\n&lt;?php\n\n// by openid\n$openids = [$openId, $openId2, $openid3, ...];\n$result = $card-&gt;setTestWhitelist($openids);\n\n// by username\n$usernames = ['easyswoole', 'easyswoole wechat'];\n$result = $card-&gt;setTestWhitelistByName($usernames);\n获取用户已领取卡券接口\n用于获取用户卡包里的，属于该 appid 下所有可用卡券，包括正常状态和未生效状态。\n$card-&gt;getUserCards($openid, $cardId);\n使用示例：\n&lt;?php\n\n$openid = 'odkJ9uDUz26RY-7DN1mxkznfo9xU';\n$cardId = ''; // 卡券ID。不填写时默认查询当前 appid 下的卡券。\n$result = $card-&gt;getUserCards($openid, $cardId);\n设置微信买单接口\n$card-&gt;setPayCell($cardId, $isOpen = true);\n\n\nstring $isOpen。是否开启买单功能，填 true/false，不填默认 true\n\n\n使用示例：\n&lt;?php\n\n$cardId = 'pdkJ9uH7u11R-Tu1kilbaW_zDFow';\n\n// isOpen = true\n$result = $card-&gt;setPayCell($cardId);\n\n$result = $card-&gt;setPayCell($cardId, $isOpen);\n修改库存接口\n// 增加库存\n$card-&gt;increaseStock($cardId, $amount);\n// 减少库存\n$card-&gt;reduceStock($cardId, $amount); \n\n\nstring $cardId。卡券 ID\n\n\nint $amount。修改多少库存\n\n使用示例：\n&lt;?php\n\n$cardId = 'pdkJ9uLRSbnB3UFEjZAgUxAJrjeY';\n$result = $card-&gt;increaseStock($cardId, 100);\n卡券 Code\n导入 Code 接口\n在自定义 Code 卡券成功创建并且通过审核后，必须将自定义 code 按照与发券方的约定数量调用导入 code 接口导入微信后台。\n$card-&gt;code-&gt;deposit($cardId, $codes);\n\n\nstring cardId。要导入 code 的卡券 ID\n\n\narray codes。要导入微信卡券后台的自定义 code，最多 100 个\n\n使用示例：\n&lt;?php\n\n$cardId = 'pdkJ9uLCEF_HSKO7JdQOUcZ-PUzo';\n$codes = ['11111', '22222', '33333'];\n$result = $card-&gt;code-&gt;deposit($cardId, $codes);\n查询导入 Code 数目\n// 要导入 code 的卡券 ID\n$card-&gt;code-&gt;getDepositedCount($cardId);  \n使用示例：\n&lt;?php\n\n$cardId = 'pdkJ9uLCEF_HSKO7JdQOUcZ-PUzo';\n$result = $card-&gt;code-&gt;getDepositedCount($cardId);\n核查 Code 接口\n为了避免出现导入差错，强烈建议开发者在查询完 code 数目的时候核查 code 接口，校验 code 导入微信后台的情况。\n$card-&gt;code-&gt;check($cardId, $codes);\n使用示例：\n&lt;?php\n\n$cardId = 'pdkJ9uLCEF_HSKO7JdQOUcZ-PUzo';\n\n$codes = ['807732265476', '22222', '33333'];\n\n$result = $card-&gt;code-&gt;check($cardId, $codes);\n查询 Code 接口\n$card-&gt;code-&gt;get($code, $cardId, $checkConsume = true);\n\n\nbool checkConsume。是否校验 code 核销状态，true 和 false\n\n\n使用示例：\n&lt;?php\n\n$code = '736052543512';\n$cardId = 'pdkJ9uDgnm0pKfrTb1yV0dFMO_Gk';\n\n$result = $card-&gt;code-&gt;get($code, $cardId);\n\n// check_consume = false\n$result = $card-&gt;code-&gt;get($code, $cardId, false);\n核销 Code 接口\n$card-&gt;code-&gt;consume($code);\n\n// 或者指定 cardId\n$card-&gt;code-&gt;consume($code, $cardId);\n使用示例：\n&lt;?php\n\n$code = '789248558333';\n$cardId = 'pdkJ9uDmhkLj6l5bm3cq9iteQBck';\n\n$result = $card-&gt;code-&gt;consume($code);\n// 或\n$result = $card-&gt;code-&gt;consume($code, $cardId);\nCode 解码接口\n$card-&gt;code-&gt;decrypt($encryptedCode);\n使用示例：\n&lt;?php\n\n$encryptedCode = 'XXIzTtMqCxwOaawoE91+VJdsFmv7b8g0VZIZkqf4GWA60Fzpc8ksZ/5ZZ0DVkXdE';\n\n$result = $card-&gt;code-&gt;decrypt($encryptedCode);\n更改 Code 接口\n$card-&gt;code-&gt;update($code, $newCode, $cardId);\n\n\nstring $newCode。变更后的有效 Code 码\n\n使用示例：\n&lt;?php\n\n$code = '148246271394';\n$newCode = '659266965266';\n$cardId = '';\n\n$result = $card-&gt;code-&gt;update($code, $newCode, $cardId);\n设置卡券失效\n$card-&gt;code-&gt;disable($code, $cardId);\n使用示例：\n&lt;?php\n\n$code = '736052543512';\n$cardId = '';\n\n$result = $card-&gt;code-&gt;disable($code, $cardId);\n会员卡\n会员卡激活\n$result = $card-&gt;memberCard-&gt;activate($info);\n\n\narray $info。需要激活的会员卡信息\n\n使用示例：\n&lt;?php\n\n$info = [\n    'membership_number'        =&gt; '357898858', // 会员卡编号，由开发者填入，作为序列号显示在用户的卡包里。可与 Code 码保持等值。\n    'code'                     =&gt; '916679873278', // 创建会员卡时获取的初始 code。\n    'activate_begin_time'      =&gt; '1397577600', // 激活后的有效起始时间。若不填写默认以创建时的 data_info 为准。Unix 时间戳格式\n    'activate_end_time'        =&gt; '1422724261', // 激活后的有效截至时间。若不填写默认以创建时的 data_info 为准。Unix 时间戳格式。\n    'init_bonus'               =&gt; '持白金会员卡到店消费，可享8折优惠。', // 初始积分，不填为 0。\n    'init_balance'             =&gt; '持白金会员卡到店消费，可享8折优惠。', // 初始余额，不填为 0。\n    'init_custom_field_value1' =&gt; '白银', // 创建时字段 custom_field1 定义类型的初始值，限制为 4 个汉字，12 字节。\n    'init_custom_field_value2' =&gt; '9折', // 创建时字段 custom_field2 定义类型的初始值，限制为 4 个汉字，12 字节。\n    'init_custom_field_value3' =&gt; '200', // 创建时字段 custom_field3 定义类型的初始值，限制为 4 个汉字，12 字节。\n];\n\n$result = $card-&gt;memberCard-&gt;activate($info);\n设置开卡字段\n$card-&gt;memberCard-&gt;setActivationForm($cardId, $settings);\n\n\narray settings。会员卡激活时的选项\n\n使用示例：\n&lt;?php\n\n$cardId = 'pdkJ9uJYAyfLXsUCwI2LdH2Pn1AU';\n\n$settings = [\n    'required_form' =&gt; [\n        'common_field_id_list' =&gt; [\n            'USER_FORM_INFO_FLAG_MOBILE',\n            'USER_FORM_INFO_FLAG_LOCATION',\n            'USER_FORM_INFO_FLAG_BIRTHDAY',\n        ],\n        'custom_field_list' =&gt; [\n            '喜欢的食物',\n        ],\n    ],\n    'optional_form' =&gt; [\n        'common_field_id_list' =&gt; [\n            'USER_FORM_INFO_FLAG_EMAIL',\n        ],\n        'custom_field_list' =&gt; [\n            '喜欢的食物',\n        ],\n    ],\n];\n\n$result = $card-&gt;memberCard-&gt;setActivationForm($cardId, $settings);\n拉取会员信息\n$card-&gt;memberCard-&gt;getUser($cardId, $code);\n使用示例：\n&lt;?php\n\n$cardId = 'pbLatjtZ7v1BG_ZnTjbW85GYc_E8';\n$code = '916679873278';\n\n$result = $card-&gt;memberCard-&gt;getUser($cardId, $code);\n更新会员信息\n$card-&gt;memberCard-&gt;updateUser($params);\narray $info。可以更新的会员信息\n使用示例：\n&lt;?php\n\n$info = [\n    'code'                =&gt; '916679873278', // 卡券 Code 码。\n    'card_id'             =&gt; 'pbLatjtZ7v1BG_ZnTjbW85GYc_E8', //卡券 ID。\n    'record_bonus'        =&gt; '消费30元，获得3积分', // 商家自定义积分消耗记录，不超过 14 个汉字。\n    'bonus'               =&gt; '100', // 需要设置的积分全量值，传入的数值会直接显示，如果同时传入 add_bonus 和 bonus，则前者无效。\n    'balance'             =&gt; '持白金会员卡到店消费，可享8折优惠。', // 需要设置的余额全量值，传入的数值会直接显示，如果同时传入 add_balance 和 balance，则前者无效。\n    'record_balance'      =&gt; '持白金会员卡到店消费，可享8折优惠。', // 商家自定义金额消耗记录，不超过 14 个汉字。\n    'custom_field_value1' =&gt; '100', // 创建时字段 custom_field1 定义类型的最新数值，限制为 4 个汉字，12 字节。\n    'custom_field_value2' =&gt; '200', // 创建时字段 custom_field2 定义类型的最新数值，限制为 4 个汉字，12 字节。\n    'custom_field_value3' =&gt; '300', // 创建时字段 custom_field3 定义类型的最新数值，限制为 4 个汉字，12 字节。\n];\n\n$result = $card-&gt;memberCard-&gt;updateUser($info);\n子商户\n添加子商户\n$card-&gt;subMerchant-&gt;create(array $info);\n使用示例：\n&lt;?php\n\n$info = [\n    'brand_name' =&gt; 'overtrue',\n    'logo_url' =&gt; 'http://mmbiz.qpic.cn/mmbiz/iaL1LJM1mF9aRKPZJkmG8xXhiaHqkKSVMMWeN3hLut7X7hicFNjakmxibMLGWpXrEXB33367o7zHN0CwngnQY7zb7g/0',\n    'protocol' =&gt; 'qIqwTfzAdJ_1-VJFT0fIV53DSY4sZY2WyhkzZzbV498Qgdp-K5HJtZihbHLS0Ys0',\n    'end_time' =&gt; '1438990559',\n    'primary_category_id' =&gt; 1,\n    'secondary_category_id' =&gt; 101,\n    'agreement_media_id' =&gt; '',\n    'operator_media_id' =&gt; '',\n    'app_id' =&gt; '',\n];\n\n$result = $card-&gt;subMerchant-&gt;create($info);\n更新子商户\n$card-&gt;subMerchant-&gt;update(int $merchantId, array $info = []);\n\n\nint   $merchantId。子商户 ID\n\n\narray $info。参数与创建子商户参数一样\n\n使用示例：\n&lt;?php\n\n$info = [\n    // ...\n];\n$result = $card-&gt;subMerchant-&gt;update('12', $info);\n特殊票券\n机票值机\n$card-&gt;boardingPass-&gt;checkin(array $params);\n更新会议门票 - 更新用户\n$card-&gt;meetingTicket-&gt;updateUser(array $params);\n更新电影门票 - 更新用户\n$card-&gt;movieTicket-&gt;updateUser(array $params);\nJSAPI\n卡券批量下发到用户\n&lt;?php\n\n$cards = [\n    ['card_id' =&gt; 'pdkJ9uLRSbnB3UFEjZAgUxAJrjeY', 'outer_id' =&gt; 2],\n    ['card_id' =&gt; 'pdkJ9uJ37aU-tyRj4_grs8S45k1c', 'outer_id' =&gt; 3],\n];\n\n// 返回 json 格式\n$json = $card-&gt;jssdk-&gt;assign($cards); \n返回值为 json，在模板里的用法如下：\nwx.addCard({\n    cardList: &lt;?= $json ?&gt;, // 需要打开的卡券列表\n    success: function (res) {\n        var cardList = res.cardList; // 添加的卡券列表信息\n    }\n});\n获取 Ticket\n$card-&gt;jssdk-&gt;getTicket();\n\n// 强制刷新\n$card-&gt;jssdk-&gt;getTicket(true);","link":"/Components/WeChat2.x/officialAccount/card.html"},{"id":263,"title":"门店","content":"门店\n创建门店\n用 POI 接口新建门店时所使用的图片 url 必须为微信自己域名的 url，因此需要先用上传图片接 口上传图片并获取 url，再创建门店。上传的图片限制文件大小限制 1MB,支持 JPG 格式，图片接口请参考：临时素材\n$officialAccount-&gt;poi-&gt;create($baseInfo);\n\n\narray $baseInfo。为门店的基本信息数组\n\n使用示例：\n&lt;?php\n\n$info = array(\n    \"sid\"             =&gt; \"33788392\",\n    \"business_name\"   =&gt; \"麦当劳\",\n    \"branch_name\"     =&gt; \"艺苑路店\",\n    \"province\"        =&gt; \"广东省\",\n    \"city\"            =&gt; \"广州市\",\n    \"district\"        =&gt; \"海珠区\",\n    \"address\"         =&gt; \"艺苑路 11 号\",\n    \"telephone\"       =&gt; \"020-12345678\",\n    \"categories\"      =&gt; array(\"美食,快餐小吃\"),\n    \"offset_type\"     =&gt; 1,\n    \"longitude\"       =&gt; 115.32375,\n    \"latitude\"        =&gt; 25.097486,\n    \"photo_list\"      =&gt; array(\n        array(\"photo_url\" =&gt; \"https://XXX.com\"),\n        array(\"photo_url\" =&gt; \"https://XXX.com\"),\n    ),\n    \"recommend\"       =&gt; \"麦辣鸡腿堡套餐,麦乐鸡,全家桶\",\n    \"special\"         =&gt; \"免费 wifi,外卖服务\",\n    \"introduction\"    =&gt; \"麦当劳是全球大型跨国连锁餐厅,1940 年创立于美国,在世界上大约拥有 3  万间分店。主要售卖汉堡包,以及薯条、炸鸡、汽水、冰品、沙拉、水果等 快餐食品\",\n    \"open_time\"       =&gt; \"8:00-20:00\",\n    \"avg_price\"       =&gt; 35,\n);\n\n$result = $officialAccount-&gt;poi-&gt;create($info); // true or exception\n\n注意：新创建的门店在审核通过后,会以事件形式推送给商户填写的回调 URL\n\n获取指定门店信息\n$officialAccount-&gt;poi-&gt;get($poiId);\n\n\nint $poiId。为门店ID\n\n使用示例：\n&lt;?php\n\n$info = $officialAccount-&gt;poi-&gt;get(271262077);\n获取门店列表\n// begin: 0, limit: 10\n$officialAccount-&gt;poi-&gt;list($begin, $limit);\n\n\nint $begin 就是查询起点，MySQL 里的 offset；\n\nint $limit 查询条数，同 MySQL 里的 limit；\n\n两参数均可选。\n使用示例：\n&lt;?php\n\n// 取 2 条记录\n$pois = $officialAccount-&gt;poi-&gt;list(0, 2);\n\n// 获取结果：\n/*\n[\n    {\n        \"sid\": \"100\",\n        \"poi_id\": \"271864249\",\n        \"business_name\": \"麦当劳\",\n        \"branch_name\": \"艺苑路店\",\n        \"address\": \"艺苑路 11 号\",\n        \"available_state\": 3\n    },\n    {\n        \"sid\": \"101\",\n        \"business_name\": \"麦当劳\",\n        \"branch_name\": \"赤岗路店\",\n        \"address\": \"赤岗路 102 号\",\n        \"available_state\": 4\n    }\n]\n*/\n修改门店信息\n商户可以通过该接口，修改门店的服务信息，包括：图片列表、营业时间、推荐、特色服务、简 介、人均价格、电话 7 个字段。目前基础字段包括(名称、坐标、地址等不可修改)。\n$officialAccount-&gt;poi-&gt;update($poiId, $baseInfo);\n\n\nint   $poiId。为门店 ID\n\n\narray $baseInfo。需要更新的部分数据，若有填写内容则为覆盖更新，若无内容则视为不 修改，维持原有内容。photo_list 字段为全列表覆盖，若需要增加图片，需将之前图片同样放入 list 中，在其后增加新增图片。如：已有 A、B、C 三张图片，又要增加 D、E 两张图，则需要调用该接口，在 photo_list 中传入 A、B、C、D、E 五张图片的链接。\n\n使用示例：\n&lt;?php\n\n$data = array(\n    \"telephone\" =&gt; \"020-12345678\",\n    \"recommend\" =&gt; \"麦辣鸡腿堡套餐,麦乐鸡,全家桶\",\n    // ...\n);\n\n// true or exception\n$res = $officialAccount-&gt;poi-&gt;update(271262077, $data);\n删除门店\n$officialAccount-&gt;poi-&gt;delete($poiId);\n使用示例：\n// true or exception\n$officialAccount-&gt;poi-&gt;delete(271262077);","link":"/Components/WeChat2.x/officialAccount/poi.html"},{"id":264,"title":"客服","content":"客服\n使用客服系统可以向用户发送消息以及群发消息，客服的管理等功能。\n客服管理\n获取所有客服\n$officialAccount-&gt;customerService-&gt;list();\n获取所有在线的客服\n$officialAccount-&gt;customerService-&gt;online();\n添加客服\n$officialAccount-&gt;customerService-&gt;create('foo@test', '客服1');\n修改客服\n$officialAccount-&gt;customerService-&gt;update('foo@test', '客服1');\n删除账号\n$officialAccount-&gt;customerService-&gt;delete('foo@test');\n设置客服头像\n// $avatarPath 为本地图片路径，非 URL\n$officialAccount-&gt;customerService-&gt;setAvatar('foo@test', $avatarPath);\n获取客服与客户聊天记录\n$officialAccount-&gt;customerService-&gt;messages($startTime, $endTime, $msgId = 1, $number = 10000);\n使用示例:\n&lt;?php\n\n$records = $officialAccount-&gt;customerService-&gt;messages('2015-06-07', '2015-06-21', 1, 20000);\n主动发送消息给用户\n$officialAccount-&gt;customerService-&gt;send(array $message);\n$message 为数组，请参考：消息\n使用示例：\n暂略。\n邀请微信用户加入客服\n以账号 foo@test 邀请 微信号 为 xxxx 的微信用户加入客服。\n$officialAccount-&gt;customerService-&gt;invite('foo@test', 'xxxx');\n客服会话控制\n创建会话\n$officialAccount-&gt;customerServiceSession-&gt;create('test1@test', 'OPENID');\n关闭会话\n$officialAccount-&gt;customerServiceSession-&gt;close('test1@test', 'OPENID');\n获取客户会话状态\n$officialAccount-&gt;customerServiceSession-&gt;get('OPENID');\n获取客服会话列表\n$officialAccount-&gt;customerServiceSession-&gt;list('test1@test');\n获取未接入会话列表\n$officialAccount-&gt;customerServiceSession-&gt;waiting();","link":"/Components/WeChat2.x/officialAccount/customerService.html"},{"id":265,"title":"摇一摇周边","content":"摇一摇周边\n摇一摇周边是微信在线下的全新功能, 为线下商户提供近距离连接用户的能力, 并支持线下商户向周边用户提供个性化营销、互动及信息推荐等服务。\n获取实例\n$shakearound = $officialAccount-&gt;shakeAround;\n说明\n\n特别提醒：\n\n1、下述所有的接口调用的方法参数都要严格按照方法参数前的类型传入相应类型的实参，否则可能会得到非预期的结果。 \n2、涉及需要传入设备 id（$deviceIdentifier）的参数时，该参数是一个以 device_id 或包含 uuid major minor 为 key 的关联数组。\n3、涉及需要传入设备 id 列表（$deviceIdentifiers）的参数时，该参数是一个二维数组，第一层为索引类型，第二层为关联类型（$deviceIdentifier）。\n\n\n// 参数 $deviceIdentifier 的实参形式：\n['device_id' =&gt; 10097]\n\n// 或\n[\n    'uuid' =&gt; 'FDA50693-A4E2-4FB1-AFCF-C6EB07647825',\n    'major' =&gt; 10001,\n    'minor' =&gt; 12102,\n]\n\n// 参数$deviceIdentifiers的实参形式：\n[\n    ['device_id' =&gt; 10097],\n    ['device_id' =&gt; 10098],\n]\n\n// 或\n[\n    [\n        'uuid' =&gt; 'FDA50693-A4E2-4FB1-AFCF-C6EB07647825',\n        'major' =&gt; 10001,\n        'minor' =&gt; 12102,\n    ],\n    [\n        'uuid' =&gt; 'FDA50693-A4E2-4FB1-AFCF-C6EB07647825',\n        'major' =&gt; 10001,\n        'minor' =&gt; 12103,\n    ]\n]\n开通摇一摇周边\n\n提示：若不是做 公众号第三方平台 开发，建议直接在微信管理后台申请开通摇一摇周边功能。\n\n申请开通\n申请开通摇一摇周边功能。成功提交申请请求后，工作人员会在三个工作日内完成审核。若审核不通过，可以重新提交申请请求。若是审核中，请耐心等待工作人员审核，在审核中状态不能再提交申请请求。\n方法：\n$shakearound-&gt;register($data)\n\n注意： \n\n1、相关资质文件的图片是使用本页面下方的素材管理的接口上传的，切勿和另一个 素材管理 接口混淆。 \n2、行业代码请务必传入 字符串 类型的实参，否则以数字 0 开头的行业代码将会被当成八进制数处理（将转换为十进制数），这可能不是期望的。\n\n\n查询审核状态\n查询已经提交的开通摇一摇周边功能申请的审核状态。在申请提交后，工作人员会在三个工作日内完成审核。\n方法：\n$shakearound-&gt;status()\n获取摇一摇的设备及用户信息\n获取设备信息，包括 UUID、major、minor，以及距离、openID 等信息。\n方法：\n$shakearound-&gt;user($ticket);\n\n// 或者需要返回门店 poi_id\n$shakearound-&gt;user($ticket, true);\n设备管理\n申请设备 ID\n申请配置设备所需的 UUID、Major、Minor。申请成功后返回批次 ID，可用返回的批次 ID 通过 “查询设备ID申请状态” 接口查询目前申请的审核状态。一个公众账号最多可申请 100000 个设备 ID，如需申请的设备 ID 数超过最大限额，请邮件至 zhoubian@tencent.com，邮件格式如下：\n\n标题：申请提升设备 ID额度。\n内容：\n\n1、公众账号名称及 appid（wx 开头的字符串，在 mp 平台可查看） \n2、用途 \n3、预估需要多少设备 ID\n\n\n\n方法：\n$shakearound-&gt;device-&gt;apply($data);\n查询设备 ID 申请审核状态\n查询设备 ID 申请的审核状态。若单次申请的设备 ID 数量小于等于 500 个，系统会进行快速审核；若单次申请的设备 ID 数量大于 500 个，则在三个工作日内完成审核。\n方法：\n// $applyId 批次ID，申请设备ID时所返回的批次ID\n$shakearound-&gt;device-&gt;status($applyId);\n编辑设备信息\n\n仅能修改设备的备注信息。\n\n方法：\n$shakearound-&gt;device-&gt;update(array $deviceIdentifier, string $comment);\n参数：\n\n\narray  $deviceIdentifier。设备 id，设备编号 device_id 或 UUID、major、minor 的关联数组，若二者都填，则以设备编号为优先\n\nstring $comment。设备的备注信息，不超过 15 个汉字或 30 个英文字母\n\n使用示例：\n&lt;?php\n\n$result = $shakearound-&gt;device-&gt;update(['device_id' =&gt; 10011], 'test');   \n// 或\n$result = $shakearound-&gt;device-&gt;update(['uuid' =&gt; 'FDA50693-A4E2-4FB1-AFCF-C6EB07647825',\n    'major' =&gt; 1002,\n    'minor' =&gt; 1223,\n], 'test');\n\n// 返回结果：\n/*\n{\n    \"data\": {},\n    \"errcode\": 0,\n    \"errmsg\": \"success.\"\n}\n*/\n\nvar_dump($result['errcode']); // 0\n配置设备与门店/其他公众账号门店的关联关系\n关联本公众账号门店时，支持创建门店后直接关联在设备上，无需为审核通过状态，摇周边后台自动更新门店的最新信息和状态。 关联其他公众账号门店时，支持设备关联其他公众账号的门店，门店需为审核通过状态。\n\n因为第三方门店不归属本公众账号，所以未保存到设备详情中，查询设备列表接口与获取摇周边的设备及用户信息接口不会返回第三方门店。\n\n方法：\n$shakearound-&gt;device-&gt;bindPoi(array $deviceIdentifier, $poiId);\n\n// 或者 绑定第三方\n$shakearound-&gt;device-&gt;bindThirdPoi(array $deviceIdentifier, $poiId, $poiAppId);\n参数：\n\n\narray $deviceIdentifier。设备 id，设备编号 device_id 或 UUID、major、minor 的关联数组，若二者都填，则以设备编号为优先 \n\nint $poiId。设备关联的门店 ID，关联门店后，在门店 1KM 的范围内有优先摇出信息的机会。当值为 0 时，将清除设备已关联的门店 ID \n\nstring $poiAppId。关联门店所归属的公众账号的 APPID\n\n\n使用示例：\n&lt;?php\n\n// 关联本公众账号门店\n$result = $shakearound-&gt;device-&gt;bindPoi(['device_id' =&gt; 10011], 1231);\n// 或\n$result = $shakearound-&gt;device-&gt;bindPoi([\n    'uuid' =&gt; 'FDA50693-A4E2-4FB1-AFCF-C6EB07647825',\n    'major' =&gt; 1002,\n    'minor' =&gt; 1223,\n], 1231);\n\n// 关联其他公众账号门店\n// wxappid 为关联门店所归属的公众账号的 APP ID\n$result = $shakearound-&gt;device-&gt;bindThirdPoi(['device_id' =&gt; 10011], 1231, 'wxappid');\n\n// 或\n$result = $shakearound-&gt;device-&gt;bindThirdPoi([\n    'uuid' =&gt; 'FDA50693-A4E2-4FB1-AFCF-C6EB07647825',\n    'major' =&gt; 1002,\n    'minor' =&gt; 1223,\n], 1231, 'wxappid');\n\n/* 返回结果\n{\n    \"data\": {},\n    \"errcode\": 0,\n    \"errmsg\": \"success.\"\n}\n*/\n查询设备列表\n查询已有的设备 ID、UUID、Major、Minor、激活状态、备注信息、关联门店、关联页面等信息。\n根据设备 id 批量取回设备数据\n方法：\n$shakearound-&gt;device-&gt;listByIds(array $deviceIdentifiers);\n参数：\n\n\narray $deviceIdentifiers。设备 id 列表\n\n使用示例：\n&lt;?php\n\n$result = $shakearound-&gt;device-&gt;listByIds([\n    ['device_id' =&gt; 10097],\n    ['device_id' =&gt; 10098],\n]);\n// 或\n$result = $shakearound-&gt;device-&gt;listByIds([\n    [\n        'uuid' =&gt; 'FDA50693-A4E2-4FB1-AFCF-C6EB07647825',\n        'major' =&gt; 10001,\n        'minor' =&gt; 12102,\n    ],\n    [\n        'uuid' =&gt; 'FDA50693-A4E2-4FB1-AFCF-C6EB07647825',\n        'major' =&gt; 10001,\n        'minor' =&gt; 12103,\n    ]\n]);\n\n/* 返回结果\n{\n    \"data\": {\n        \"devices\": [\n            {\n                \"comment\": \"\",\n                \"device_id\": 10097,\n                \"major\": 10001,\n                \"minor\": 12102,\n                \"status\": 1,\n                \"last_active_time\":1437276018,\n                \"poi_id\": 0,\n                \"uuid\": \"FDA50693-A4E2-4FB1-AFCF-C6EB07647825\"\n            },\n            {\n                \"comment\": \"\",\n                \"device_id\": 10098,\n                \"major\": 10001,\n                \"minor\": 12103,\n                \"status\": 1,\n                \"last_active_time\":1437276018,\n                \"poi_appid\":\"wxe3813f5d8c546fc7\"\n                \"poi_id\": 123,\n                \"uuid\": \"FDA50693-A4E2-4FB1-AFCF-C6EB07647825\"\n            }\n        ],\n        \"total_count\": 151\n    },\n    \"errcode\": 0,\n    \"errmsg\": \"success.\"\n}\n*/\n分页批量取回设备数据\n方法：\n$shakearound-&gt;device-&gt;list(int $lastId, int $count);\n参数：\n\n\nint $lastId 前一次查询列表末尾的设备编号 device_id，第一次查询 lastId 为 0，$count 待查询的设备数量，不能超过 50 个\n\n使用示例：\n&lt;?php\n\n$result = $shakearound-&gt;device-&gt;list(10097, 3);\n\n// 返回结果同上\n根据申请时的批次 ID 分页批量取回设备数据\n方法：\n$shakearound-&gt;device-&gt;listByApplyId(int $applyId, int $lastId, int $count)\n参数：\n\n\nint $applyId 批次 ID，申请设备 ID 时所返回的批次 ID \n\nint $lastId 前一次查询列表末尾的设备编号 device_id，第一次查询 lastId 为 0\n\n\nint $count 待查询的设备数量，不能超过 50 个\n\n使用示例：\n&lt;?php\n\n$result = $shakearound-&gt;device-&gt;listByApplyId(1231, 10097, 3);\n\n// 返回结果同上\n页面管理\n新增页面\n新增摇一摇出来的页面信息，包括在摇一摇页面出现的主标题、副标题、图片和点击进去的超链接。其中，图片必须为用素材管理接口上传至微信侧服务器后返回的链接。\n\n注意：图片是使用本页面下方的素材管理的接口上传的，切勿和另一个 素材管理 接口混淆。\n\n方法：\n$shakearound-&gt;page-&gt;create($data);\n具体需要传递的参数请查看：微信开发官网 https://developers.weixin.qq.com/doc/offiaccount/Shake_Nearby/Pages_management/Page_management.html\n参数：\n\n\n$title 在摇一摇页面展示的主标题，不超过 6 个汉字或 12 个英文字母 \n\n$description 在摇一摇页面展示的副标题，不超过 7 个汉字或 14 个英文字母 \n\n$pageUrl 点击进去的超链接 \n\n$iconUrl 在摇一摇页面展示的图片。图片需先上传至微信侧服务器，用 “素材管理-上传图片素材” 接口上传图片，返回的图片 URL 再配置在此处 \n\n$comment 可选，页面的备注信息，不超过 15 个汉字或 30 个英文字母\n\n使用示例：\n&lt;?php\n\n$data = [\n    \"title\"       =&gt; \"主标题\",\n    \"description\" =&gt; \"副标题\",\n    \"page_url\"    =&gt; \" https://zb.weixin.qq.com \",\n    \"comment\"     =&gt; \"数据示例\",\n    \"icon_url\"    =&gt; \"http://3gimg.qq.com/shake_nearby/dy/icon \"\n];\n\n$result = $shakearound-&gt;page-&gt;create($data);\n\n/* 返回结果\n{\n   \"data\": {\n       \"page_id\": 28840\n   }\n   \"errcode\": 0,\n   \"errmsg\": \"success.\"\n}\n*/\n编辑页面信息\n编辑摇一摇出来的页面信息，包括在摇一摇页面出现的主标题、副标题、图片和点击进去的超链接。\n方法：\n$shakearound-&gt;page-&gt;update(int $pageId, array $data);\n具体需要传递的参数请查看：微信开发官网 https://developers.weixin.qq.com/doc/offiaccount/Shake_Nearby/Pages_management/Edit_page_information.html\n参数：\n\n\nint $pageId。摇周边页面唯一 ID \n\narray $data 需要更新的信息\n\n使用示例：\n&lt;?php\n\n$result = $shakearound-&gt;page-&gt;update(28840, [\n    'title' =&gt; '主标题',\n    'description' =&gt; '副标题',\n    // ...\n]);\n查询页面列表\n查询已有的页面，包括在摇一摇页面出现的主标题、副标题、图片和点击进去的超链接。\n根据页面 id 批量取回页面数据\n方法：\n$shakearound-&gt;page-&gt;listByIds(array $pageIds);\n参数：\n\n\narray $pageIds。页面的 id 列表，索引数组\n\n使用示例：\n&lt;?php\n\n$result = $shakearound-&gt;page-&gt;listByIds([28840, 28842]);\n\n/* 返回结果\n{\n   \"data\": {\n       \"pages\": [\n           {\n               \"comment\": \"just for test\",\n               \"description\": \"test\",\n               \"icon_url\": \"https://www.baidu.com/img/bd_logo1\",\n               \"page_id\": 28840,\n               \"page_url\": \"http://xw.qq.com/testapi1\",\n               \"title\": \"测试1\"\n           },\n           {\n               \"comment\": \"just for test\",\n               \"description\": \"test\",\n               \"icon_url\": \"https://www.baidu.com/img/bd_logo1\",\n               \"page_id\": 28842,\n               \"page_url\": \"http://xw.qq.com/testapi2\",\n               \"title\": \"测试2\"\n           }\n       ],\n       \"total_count\": 2\n   },\n   \"errcode\": 0,\n   \"errmsg\": \"success.\"\n}\n*/\n分页批量取回页面数据\n方法：\n$shakearound-&gt;page-&gt;list(int $begin, int $count);\n参数：\n\n\nint $begin 页面列表的起始索引值 \n\nint $count 待查询的页面数量，不能超过 50 个\n\n使用示例：\n&lt;?php\n\n$result = $shakearound-&gt;page-&gt;list(0,2);\n\n// 返回结果同上\n删除页面\n删除已有的页面，包括在摇一摇页面出现的主标题、副标题、图片和点击进去的超链接。\n\n注意： 只有页面与设备没有关联关系时，才可被删除。\n\n方法：\n$shakearound-&gt;page-&gt;delete(int $pageId);\n参数：\n\n\nint $pageId。页面的 id\n\n\n使用示例：\n&lt;?php\n\n$result = $shakearound-&gt;page-&gt;delete(34567);\n\n/* 返回结果\n{\n    \"data\": {\n    },\n    \"errcode\": 0,\n    \"errmsg\": \"success.\"\n}\n*/\n素材管理\n上传在摇一摇功能中需使用到的图片素材，素材保存在微信侧服务器上。图片格式限定为：jpg/jpeg/png/gif。若图片为在摇一摇页面展示的图片，则其素材为 icon 类型的图片，图片大小建议 120 px *120 px ，限制不超过 200 px *200 px ，图片需为 正方形。若图片为申请开通摇一摇周边功能需要上传的资质文件图片，则其素材为 license 类型的图片，图片的文件大小不超过 2MB ，尺寸不限，形状不限。\n方法：\n$shakearound-&gt;material-&gt;uploadImage(string $path [,string $type = 'icon'])\n参数：\n\n\nstring $path。图片所在路径 \n\nstring $type。可选参数，值为 icon 或 license。\n\n使用示例：\n&lt;?php\n\n$result = $shakearound-&gt;material-&gt;uploadImage(__DIR__ . '/stubs/image.jpg');\n\n/* 返回结果\n{\n    \"data\": {\n        \"pic_url\": http://shp.qpic.cn/wechat_shakearound_pic/0/1428377032e9dd2797018cad79186e03e8c5aec8dc/120\"\n    },\n    \"errcode\": 0,\n    \"errmsg\": \"success.\"\n}\n*/\n管理设备与页面的关系\n通过接口申请的设备 ID，需先配置页面，若未配置页面，则摇不出页面信息。\n配置设备与页面的关联关系\n配置完成后，在此设备的信号范围内，即可摇出关联的页面信息。若设备配置多个页面，则随机出现页面信息。一个设备最多可配置 30 个关联页面。\n\n注意：\n\n1、配置时传入该设备需要关联的页面的 id 列表，该设备原有的关联关系将被直接清除。\n2、页面的 id 列表允许为空（传入空数组），当页面的 id 列表为空时则会清除该设备的所有关联关系。\n\n\n方法：\n$shakearound-&gt;relation-&gt;bindPages(array $deviceIdentifier, array $pageIds);\n参数：\n\n\narray $deviceIdentifier。设备 id，设备编号 device_id 或 UUID、major、minor 的关联数组，若二者都填，则以设备编号为优先 \n\narray $pageIds。页面的 id 列表，索引数组\n\n使用示例：\n&lt;?php\n\n$result = $shakearound-&gt;relation-&gt;bindPages(['device_id' =&gt; 10011], [12345, 23456, 334567]);\n// 或\n$result = $shakearound-&gt;relation-&gt;bindPages([\n    'uuid' =&gt; 'FDA50693-A4E2-4FB1-AFCF-C6EB07647825',\n    'major' =&gt; 1002,\n    'minor' =&gt; 1223,\n], [12345, 23456, 334567]);\n\n/* 返回结果\n{\n    \"data\": {\n    },\n    \"errcode\": 0,\n    \"errmsg\": \"success.\"\n}\n*/\n\nvar_dump($result-&gt;errcode); // 0\n查询设备与页面的关联关系\n查询指定设备所关联的页面\n根据设备 ID 或完整的 UUID、Major、Minor 查询该设备所关联的所有页面信息\n方法：\n$shakearound-&gt;relation-&gt;listByDeviceId(array $deviceIdentifier);\n\n注意：该方法默认对返回的数据进行处理后返回一个包含页面 id 的索引数组。\n\n参数：\n\n\narray $deviceIdentifier。设备 id，设备编号 device_id 或 UUID、Major、Minor 的关联数组，若二者都填，则以设备编号为优先\n\n使用示例：\n&lt;?php\n\n$result = $shakearound-&gt;relation-&gt;listByDeviceId(['device_id' =&gt; 10011]);\n// 或\n$result = $shakearound-&gt;relation-&gt;listByDeviceId([\n    'uuid' =&gt; 'FDA50693-A4E2-4FB1-AFCF-C6EB07647825',\n    'major' =&gt; 1002,\n    'minor' =&gt; 1223,\n]);\n\n// 返回结果\nvar_dump($result); // [50054,50055]\n查询指定页面所关联的设备\n指定页面 ID 分页查询该页面所关联的所有的设备信息\n方法：\n$shakearound-&gt;relation-&gt;listByPageId(int $pageId, int $begin, int $count);\n参数：\n\n\nint $pageId。指定的页面 id\n\n\nint $begin。关联关系列表的起始索引值 \n\nint $count。待查询的关联关系数量，不能超过 50 个\n\n使用示例：\n&lt;?php\n\n$result = $shakearound-&gt;relation-&gt;listByPageId(50054, 0, 3);\n\n/* 返回结果\n{\n    \"data\": {\n        \"relations\": [{\n                \"device_id\": 797994,\n                \"major\": 10001,\n                \"minor\": 10023,\n                \"page_id\": 50054,\n                \"uuid\": \"FDA50693-A4E2-4FB1-AFCF-C6EB07647825\"\n            },\n            {\n                \"device_id\": 797995,\n                \"major\": 10001,\n                \"minor\": 10024,\n                \"page_id\": 50054,\n                \"uuid\": \"FDA50693-A4E2-4FB1-AFCF-C6EB07647825\"\n            }\n        ],\n        \"total_count\": 2\n    },\n    \"errcode\": 0,\n    \"errmsg\": \"success.\"\n}\n*/\n摇一摇数据统计\n\n此接口无法获取当天的数据，最早只能获取前一天的数据。由于系统在凌晨处理前一天的数据，太早调用此接口可能获取不到数据，建议在早上 8：00 之后调用此接口。\n\n以设备为维度的数据统计\n查询单个设备进行摇周边操作的人数、次数，点击摇周边消息的人数、次数。\n\n注意：查询的最长时间跨度为 30 天。只能查询最近 90 天的数据。\n\n方法：\n$shakearound-&gt;stats-&gt;deviceSummary(array $deviceIdentifier, int $beginDate, int $endDate);\n参数：\n\n\narray $deviceIdentifier 设备 id，设备编号 device_id 或 UUID、major、minor 的关联数组，若二者都填，则以设备编号为优先 \n\nint $beginDate 起始日期时间戳，最长时间跨度为 30 天，单位为秒 \n\nint $endDate 结束日期时间戳，最长时间跨度为 30 天，单位为秒\n\n使用示例：\n&lt;?php\n\n$result = $shakearound-&gt;stats-&gt;deviceSummary(['device_id' =&gt; 10011], 1425052800, 1425139200);\n// 或\n$result = $shakearound-&gt;stats-&gt;deviceSummary([\n    'uuid' =&gt; 'FDA50693-A4E2-4FB1-AFCF-C6EB07647825',\n    'major' =&gt; 1002,\n    'minor' =&gt; 1223,\n], 1425052800, 1425139200);\n\n/* 返回结果\n{\n    \"data\": [{\n            \"click_pv\": 0,\n            \"click_uv\": 0,\n            \"ftime\": 1425052800,\n            \"shake_pv\": 0,\n            \"shake_uv\": 0\n        },\n        {\n            \"click_pv\": 0,\n            \"click_uv\": 0,\n            \"ftime\": 1425139200,\n            \"shake_pv\": 0,\n            \"shake_uv\": 0\n        }\n    ],\n    \"errcode\": 0,\n    \"errmsg\": \"success.\"\n}\n*/\n批量查询设备统计数据\n查询指定时间商家帐号下的每个设备进行摇周边操作的人数、次数，点击摇周边消息的人数、次数。\n\n只能查询最近 90 天内的数据，且一次只能查询一天。注意：对于摇周边人数、摇周边次数、点击摇周边消息的人数、点击摇周边消息的次数都为 0 的设备，不在结果列表中返回。\n\n方法：\n$shakearound-&gt;stats-&gt;devicesSummary(int $timestamp, int $pageIndex);\n参数：\n\n\nint $timestamp。指定查询日期时间戳，单位为秒 \n\nint $pageIndex。指定查询的结果页序号，返回结果按摇周边人数降序排序，每 50 条记录为一页\n\n使用示例：\n&lt;?php\n\n$result = $shakearound-&gt;stats-&gt;devicesSummary(1435075200, 1);\n\n/* 返回结果\n{\n    \"data\": {\n        \"devices\": [\n            {\n                \"device_id\": 10097,\n                \"major\": 10001,\n                \"minor\": 12102,\n                \"uuid\": \"FDA50693-A4E2-4FB1-AFCF-C6EB07647825\"\n                \"shake_pv\": 1\n                \"shake_uv\": 2\n                \"click_pv\": 3\n                \"click_uv\": 4\n            },\n            {\n                \"device_id\": 10098,\n                \"major\": 10001,\n                \"minor\": 12103,\n                \"uuid\": \"FDA50693-A4E2-4FB1-AFCF-C6EB07647825\"\n                \"shake_pv\": 1\n                \"shake_uv\": 2\n                \"click_pv\": 3\n                \"click_uv\": 4\n            }\n        ],\n    },\n    \"date\":1435075200\n    \"total_count\": 151\n    \"page_index\":1\n    \"errcode\": 0,\n    \"errmsg\": \"success.\"\n}\n*/\n以页面为维度的数据统计\n查询单个页面通过摇周边摇出来的人数、次数，点击摇周边页面的人数、次数\n\n注意：查询的最长时间跨度为 30 天。只能查询最近 90 天的数据。\n\n方法：\n$shakearound-&gt;stats-&gt;pageSummary(int $pageId, int $beginDate, int $endDate);\n参数：\n\n\nint $pageId。指定页面的页面 ID\n\n\nint $beginDate。起始日期时间戳，最长时间跨度为 30 天，单位为秒 \n\nint $endDate。结束日期时间戳，最长时间跨度为 30 天，单位为秒\n\n使用示例：\n&lt;?php\n\n$result = $shakearound-&gt;stats-&gt;pageSummary(12345, 1425052800, 1425139200);\n\n/* 返回结果\n{\n    \"data\": [\n        {\n            \"click_pv\": 0,\n            \"click_uv\": 0,\n            \"ftime\": 1425052800,\n            \"shake_pv\": 0,\n            \"shake_uv\": 0\n        },\n        {\n            \"click_pv\": 0,\n            \"click_uv\": 0,\n            \"ftime\": 1425139200,\n            \"shake_pv\": 0,\n            \"shake_uv\": 0\n        }\n    ],\n    \"errcode\": 0,\n    \"errmsg\": \"success.\"\n}\n*/\n批量查询页面统计数据\n查询指定时间商家帐号下的每个页面进行摇周边操作的人数、次数，点击摇周边消息的人数、次数。\n\n注意：对于摇周边人数、摇周边次数、点击摇周边消息的人数、点击摇周边消息的次数都为 0 的页面，不在结果列表中返回。\n\n方法：\n$shakearound-&gt;stats-&gt;pagesSummary(int $timestamp, int $pageIndex);\n参数：\n\n\nint $timestamp。指定查询日期时间戳，单位为秒 \n\nint $pageIndex。指定查询的结果页序号，返回结果按摇周边人数降序排序，每 50 条记录为一页\n\n示例：\n&lt;?php\n\n$result = $shakearound-&gt;stats-&gt;pagesSummary(1435075200, 1);\n\n/* 返回结果\n{\n    \"data\": {\n        \"pages\": [\n            {\n                \"page_id\": 1234 \"click_pv\": 1,\n                \"click_uv\": 3,\n                \"shake_pv\": 0,\n                \"shake_uv\": 0\n            },\n            {\n                \"page_id\": 5678 \"click_pv\": 1,\n                \"click_uv\": 2,\n                \"shake_pv\": 0,\n                \"shake_uv\": 0\n            },\n        ],\n    },\n    \"date\": 1435075200,\n    \"total_count\": 151,\n    \"page_index\": 1,\n    \"errcode\": 0,\n    \"errmsg\": \"success.\"\n}\n*/\n设备分组管理\n调用 H5 页面获取设备信息 JS API 接口，需要先把设备分组，微信客户端只会返回已在分组中的设备信息。\n新增分组\n新建设备分组，每个帐号下最多只有 1000 个分组。\n方法：\n$shakearound-&gt;group-&gt;create(string $name);\n参数：\n\n\nstring $name。分组名称，不超过 100 汉字或 200 个英文字母\n\n使用示例：\n&lt;?php\n$result = $shakearound-&gt;group-&gt;create('test');\n\n/* 返回结果\n{\n    \"data\": {\n        \"group_id\": 123,\n        \"group_name\": \"test\"\n    },\n    \"errcode\": 0,\n    \"errmsg\": \"success.\"\n}\n*/\n编辑分组信息\n编辑设备分组信息，目前只能修改分组名。\n方法：\n$shakearound-&gt;group-&gt;update(int $groupId, string $name);\n参数：\n\n\nint $groupId。分组唯一标识，全局唯一 \n\nstring $name。分组名称，不超过 100 汉字或 200 个英文字母\n\n使用示例：\n&lt;?php\n\n$result = $shakearound-&gt;group-&gt;update(123, 'newName');\n\n/* 返回结果\n{\n    \"data\": {},\n    \"errcode\": 0,\n    \"errmsg\": \"success.\"\n}\n*/\n删除分组\n删除设备分组，若分组中还存在设备，则不能删除成功。需把设备移除以后，才能删除。\n\n在执行删除前，最好先使用 get 方法查询分组详情，若分组内有设备，先使用 removeDevices 方法移除。\n\n方法：\n$shakearound-&gt;group-&gt;delete(int $groupId);\n参数：\n\n\nint $groupId。分组唯一标识，全局唯一\n\n使用示例：\n&lt;?php\n\n$result = $shakearound-&gt;group-&gt;delete(123);\n\n/* 返回结果\n{\n    \"data\": {},\n    \"errcode\": 0,\n    \"errmsg\": \"success.\"\n}\n*/\n查询分组列表\n查询账号下所有的分组。\n方法：\n$shakearound-&gt;group-&gt;list(int $begin, int $count);\n参数：\n\n\nint $begin。分组列表的起始索引值\n\nint $count。待查询的分组数量，不能超过 1000 个\n\n使用示例：\n&lt;?php\n\n$result = $shakearound-&gt;group-&gt;list(0, 2);\n\n/* 返回结果\n{\n    \"data\": {\n        \"groups\":[\n            {\n                \"group_id\" : 123,\n                \"group_name\" : \"test1\"\n            },\n            {\n                \"group_id\" : 124,\n                \"group_name\" : \"test2\"\n            }\n        ],\n        \"total_count\": 100\n    },\n    \"errcode\": 0,\n    \"errmsg\": \"success.\"\n}\n*/\n查询分组详情\n查询分组详情，包括分组名、分组 id、分组里的设备列表。\n方法：\n$shakearound-&gt;group-&gt;get(int $groupId, int $begin, int $count);\n参数：\n\n\nint $groupId。分组唯一标识，全局唯一 \n\nint $begin。分组里设备的起始索引值 \n\nint $count。待查询的分组里设备的数量，不能超过 1000 个\n\n使用示例：\n&lt;?php\n\n$result = $shakearound-&gt;group-&gt;get(123, 0, 2);\n\n/* 返回结果\n{\n    \"data\": {\n        \"group_id\" : 123,\n        \"group_name\" : \"test\",\n        \"total_count\": 100,\n        \"devices\" :[\n            {\n                \"device_id\" : 123456,\n                \"uuid\" : \"FDA50693-A4E2-4FB1-AFCF-C6EB07647825\",\n                \"major\" : 10001,\n                \"minor\" : 10001,\n                \"comment\" : \"test device1\",\n                \"poi_id\" : 12345,\n            },\n            {\n                \"device_id\" : 123457,\n                \"uuid\" : \"FDA50693-A4E2-4FB1-AFCF-C6EB07647825\",\n                \"major\" : 10001,\n                \"minor\" : 10002,\n                \"comment\" : \"test device2\",\n                \"poi_id\" : 12345,\n            }\n        ]\n    },\n    \"errcode\": 0,\n    \"errmsg\": \"success.\"\n}\n*/\n添加设备到分组\n添加设备到分组，每个分组能够持有的设备上限为 10000，并且每次添加操作的添加上限为 1000。\n\n只有在摇周边申请的设备才能添加到分组。\n\n方法：\n$shakearound-&gt;group-&gt;addDevices(int $groupId, array $deviceIdentifiers);\n参数：\n\n\nint $groupId。分组唯一标识，全局唯一 \n\narray $deviceIdentifiers。设备 id 列表\n\n使用示例：\n&lt;?php\n\n$result = $shakearound-&gt;group-&gt;addDevices(123, [\n    ['device_id' =&gt; 10097],\n    ['device_id' =&gt; 10098],\n]);\n\n// 或\n$result = $shakearound-&gt;group-&gt;addDevices(123, [\n    [\n        'uuid' =&gt; 'FDA50693-A4E2-4FB1-AFCF-C6EB07647825',\n        'major' =&gt; 10001,\n        'minor' =&gt; 12102,\n    ],\n    [\n        'uuid' =&gt; 'FDA50693-A4E2-4FB1-AFCF-C6EB07647825',\n        'major' =&gt; 10001,\n        'minor' =&gt; 12103,\n    ]\n]);\n\n/* 返回结果\n{\n    \"data\": {},\n    \"errcode\": 0,\n    \"errmsg\": \"success.\"\n}\n*/\n从分组中移除设备\n从分组中移除设备，每次删除操作的上限为 1000。\n方法：\n$shakearound-&gt;group-&gt;removeDevices(int $groupId, array $deviceIdentifiers);\n参数：\n\n\nint $groupId。分组唯一标识，全局唯一 \n\nint $deviceIdentifiers。设备 id 列表\n\n使用示例：\n&lt;?php\n\n$result = $shakearound-&gt;group-&gt;removeDevices(123, [\n    ['device_id' =&gt; 10097],\n    ['device_id' =&gt; 10098],\n]);\n// 或\n$result = $shakearound-&gt;group-&gt;removeDevices(123, [\n    [\n        'uuid' =&gt; 'FDA50693-A4E2-4FB1-AFCF-C6EB07647825',\n        'major' =&gt; 10001,\n        'minor' =&gt; 12102,\n    ],\n    [\n        'uuid' =&gt; 'FDA50693-A4E2-4FB1-AFCF-C6EB07647825',\n        'major' =&gt; 10001,\n        'minor' =&gt; 12103,\n    ]\n]);\n摇一摇事件通知\n用户进入摇一摇界面，在 “周边” 页卡下摇一摇时，微信会把这个事件推送到开发者填写的 URL（登录公众平台进入开发者中心设置）。推送内容包含摇一摇时 “周边” 页卡展示出来的页面所对应的设备信息，以及附近最多五个属于该公众账号的设备的信息。当摇出列表时，此事件不推送。\n\n摇一摇事件的事件类型：ShakearoundUserShake\n\n关于事件的处理请移步：请参考：服务端，关于事件类型请参考微信官方文档：http://mp.weixin.qq.com/wiki/","link":"/Components/WeChat2.x/officialAccount/shakeAround.html"},{"id":266,"title":"数据统计与分析","content":"数据统计与分析\n通过数据接口，开发者可以获取与公众平台官网统计模块类似但更灵活的数据，还可根据需要进行高级处理。\n\n接口侧的公众号数据的数据库中仅存储了 2014 年 12 月 1 日 之后的数据，将查询不到在此之前的日期，即使有查到，也是不可信的脏数据；\n请开发者在调用接口获取数据后，将数据保存在自身数据库中，即加快下次用户的访问速度，也降低了微信侧接口调用的不必要损耗。\n额外注意，获取图文群发每日数据接口的结果中，只有 中间页阅读人数 + 原文页阅读人数 + 分享转发人数 + 分享转发次数 + 收藏次数 >=3 的结果才会得到统计，过小的阅读量的图文消息无法统计。\n\n示例\n&lt;?php\n\n$userSummary = $officialAccount-&gt;dateCube-&gt;userSummary('2014-12-07', '2014-12-08');\n\nvar_dump($userSummary);\n\n/* 运行结果：\n[\n    {\n        \"ref_date\": \"2014-12-07\",\n        \"user_source\": 0,\n        \"new_user\": 0,\n        \"cancel_user\": 0\n    }\n    // 后续还有 ref_date 在 begin_date 和 end_date 之间的数据\n]\n*/\nAPI\n$from  示例： `2014-02-13` 获取数据的起始日期\n$to    示例： `2014-02-18` 获取数据的结束日期，`$to`允许设置的最大值为昨日\n\n`$from` 和 `$to` 的差值需小于 “最大时间跨度”（比如最大时间跨度为 1 时，`$from` 和 `$to` 的差值只能为 0，才能小于 1 ），否则会报错\n\n\narray userSummary(string $from, string $to)。获取用户增减数据, 最大时间跨度：7;\n\narray userCumulate(string $from, string $to)。获取累计用户数据, 最大时间跨度：7;\n\narray articleSummary(string $from, string $to)。获取图文群发每日数据, 最大时间跨度：1;\n\narray articleTotal(string $from, string $to)。获取图文群发总数据, 最大时间跨度：1;\n\narray userReadSummary(string $from, string $to)。获取图文统计数据, 最大时间跨度：3;\n\narray userReadHourly(string $from, string $to)。获取图文统计分时数据, 最大时间跨度：1;\n\narray userShareSummary(string $from, string $to)。获取图文分享转发数据, 最大时间跨度：7;\n\narray userShareHourly(string $from, string $to)。获取图文分享转发分时数据, 最大时间跨度：1;\n\narray upstreamMessageSummary(string $from, string $to)。获取消息发送概况数据, 最大时间跨度：7;\n\narray upstreamMessageHourly(string $from, string $to)。获取消息发送分时数据, 最大时间跨度：1;\n\narray upstreamMessageWeekly(string $from, string $to)。获取消息发送周数据, 最大时间跨度：30;\n\narray upstreamMessageMonthly(string $from, string $to)。获取消息发送月数据, 最大时间跨度：30;\n\narray upstreamMessageDistSummary(string $from, string $to)。获取消息发送分布数据, 最大时间跨度：15;\n\narray upstreamMessageDistWeekly(string $from, string $to)。获取消息发送分布周数据, 最大时间跨度：30;\n\narray upstreamMessageDistMonthly(string $from, string $to)。获取消息发送分布月数据, 最大时间跨度：30;\n\narray interfaceSummary(string $from, string $to)。获取接口分析数据, 最大时间跨度：30;\n\narray interfaceSummaryHourly(string $from, string $to)。获取接口分析分时数据, 最大时间跨度：1;\n\narray cardSummary(string $from, string $to, int $condSource = 0)。获取普通卡券分析分时数据, 最大时间跨度：1;\n\narray freeCardSummary(string $from, string $to, int $condSource = 0, string $cardId = '')。获取免费券分析分时数据, 最大时间跨度：1;\n\narray memberCardSummary(string $from, string $to, int $condSource = 0)。获取会员卡分析分时数据, 最大时间跨度：1;\n","link":"/Components/WeChat2.x/officialAccount/dataCube.html"},{"id":267,"title":"语义理解","content":"语义理解\n\n貌似此接口已经下线，调用无正确返回值。\n\n$officialAccount-&gt;semantic-&gt;query(string $keyword, string $categories, array $optional = []);\n参数说明：\n\n\nstring $keyword 为关键字\n\nstring $categories 需要使用的服务类型，多个用 “,” 隔开字符串，不能为空\n`$optional 为其它属性：\n\n\nfloat latitude 纬度坐标，与经度同时传入；与城市二选一传入\n\nfloat longitude 经度坐标，与纬度同时传入；与城市二选一传入\n\nstring city 城市名称，与经纬度二选一传入\n\nstringregion 区域名称，在城市存在的情况下可省；与经纬度二选一传入\n\nstring uid 用户唯一 id（非开发者 id），用户区分公众号下的不同用户（建议填入用户 openid），如果为空，则无法使用上下文理解功能。appid 和 uid 同时存在的情况下，才可以使用上下文理解功能。\n\n\n\n\n注：单类别意图比较明确，识别的覆盖率比较大，所以如果只要使用特定某个类别，建议将 category 只设置为该类别。\n\n使用示例：\n&lt;?php\n\n$result = $officialAccount-&gt;semantic-&gt;query('查一下明天从北京到上海的南航机票', \"flight,hotel\", array(\n            'city' =&gt; '北京', \n            'uid' =&gt; '123456'\n        ));\n\n// 查询参数：\n/*\n{\n    \"query\": \"查一下明天从北京到上海的南航机票\",\n    \"city\": \"北京\",\n    \"category\": \"flight,hotel\",\n    \"appid\": \"wxaaaaaaaaaaaaaaaa\",\n    \"uid\": \"123456\"\n}\n*/\n返回值示例：\n{\n    \"errcode\": 0,\n    \"query\": \"查一下明天从北京到上海的南航机票\",\n    \"type\": \"flight\",\n    \"semantic\": {\n        \"details\": {\n            \"start_loc\": {\n                \"type\": \"LOC_CITY\",\n                \"city\": \"北京市\",\n                \"city_simple\": \"北京\",\n                \"loc_ori\": \"北京\"\n            },\n            \"end_loc\": {\n                \"type\": \"LOC_CITY\",\n                \"city\": \"上海市\",\n                \"city_simple\": \"上海\",\n                \"loc_ori\": \"上海\"\n            },\n            \"start_date\": {\n                \"type\": \"DT_ORI\",\n                \"date\": \"2014-03-05\",\n                \"date_ori\": \"明天\"\n            },\n            \"airline\": \"中国南方航空公司\"\n        },\n        \"intent\": \"SEARCH\"\n    }\n}","link":"/Components/WeChat2.x/officialAccount/semantic.html"},{"id":268,"title":"自动回复","content":"自动回复\n获取当前设置的回复规则\n$officialAccount-&gt;autoReplay-&gt;current();","link":"/Components/WeChat2.x/officialAccount/autoReply.html"},{"id":269,"title":"评论数据管理","content":"评论数据管理\n打开已群发文章评论\n$officialAccount-&gt;comment-&gt;open(string $msgId, int $index = null);\n关闭已群发文章评论\n$officialAccount-&gt;comment-&gt;close(string $msgId, int $index = null);\n查看指定文章的评论数据\n$officialAccount-&gt;comment-&gt;list(string $msgId, int $index, int $begin, int $count, int $type = 0);\n将评论标记精选\n$officialAccount-&gt;comment-&gt;markElect(string $msgId, int $index, int $commentId);\n将评论取消精选\n$officialAccount-&gt;comment-&gt;unmarkElect(string $msgId, int $index, int $commentId);\n删除评论\n$officialAccount-&gt;comment-&gt;delete(string $msgId, int $index, int $commentId);\n回复评论\n$officialAccount-&gt;comment-&gt;reply(string $msgId, int $index, int $commentId, string $content);\n删除回复\n$officialAccount-&gt;comment-&gt;deleteReply(string $msgId, int $index, int $commentId);","link":"/Components/WeChat2.x/officialAccount/comment.html"},{"id":270,"title":"返佣商品","content":"返佣商品\n\n微信文档：https://mp.weixin.qq.com/cgi-bin/announce?action=getannouncement&amp;key=11533749572M9ODP&amp;version=1&amp;lang=zh_CN&amp;platform=2\n\n导入商品\n每次调用支持批量导入不超过 1000 条的商品信息。每分钟单个商户全局调用次数不得超过 200 次。每天调用次数不得超过 100 万次。每次请求包大小不超过 2M。\n&lt;?php\n\n$data = [\n    [\n        'pid' =&gt; 'pid001',\n        'image_info' =&gt; [\n            'main_image_list' =&gt; [\n                [\n                    'url' =&gt; 'http://www.google.com/a.jpg',\n                ],\n                [\n                    'url' =&gt; 'http://www.google.com/b.jpg',\n                ],\n            ],\n        ],\n\n        // ...\n    ],\n\n    // ...\n];\n\n$result = $officialAccount-&gt;goods-&gt;add($data);\n\n/* $result:\n{\n    \"errcode\": 0,\n    \"errmsg\": \"ok\",\n    \"status_ticket\": \"115141102647330200\"\n}\n*/\nstatus_ticket 用于获取此次导入的详细结果。\n更新商品\n更新时，字段不填代表不更新该字段（此处的字段不填，代表无此字段，而不是把字段的值设为空，设为空即代表更新该字段为空）。\n对于字符串类型的选填字段，如副标题，若清空不展示，则可设置为空；对于数字类型的选填字段，如原价，若清空不展示，则需设置为 0。\n\n基本字段更新中 pid 为必填字段，且无法修改。\n\n&lt;?php\n\n$data = [\n    [\n        'pid' =&gt; 'pid001',\n        'image_info' =&gt; [\n            'main_image_list' =&gt; [\n                [\n                    'url' =&gt; 'http://www.baidu.com/c.jpg',\n                ],\n                [\n                    'url' =&gt; 'http://www.baidu.com/d.jpg',\n                ],\n            ],\n        ],\n        // ...\n    ],\n    // ...\n];\n\n$result = $officialAccount-&gt;goods-&gt;update($data);\n\n/* $result:\n{\n    \"errcode\": 0,\n    \"errmsg\": \"ok\",\n    \"status_ticket\": \"115141102647330200\"\n}\n*/\n\n说明：导入商品和更新商品使用的是同一个接口。\n\n查询导入/更新商品状态\n用于查询导入或更新商品的结果，当导入或更新商品失败时，若为系统错误可进行重试；若为其他错误，请排查解决后进行重试。\n&lt;?php\n\n$status_ticket = '115141102647330200';\n\n$result = $officialAccount-&gt;goods-&gt;status($status_ticket);\n\n/* $result:\n{\n    \"errcode\": 0,\n    \"errmsg\": \"ok\",\n    \"result\": {\n        \"succ_cnt\": 2,\n        \"fail_cnt\": 0,\n        \"total_cnt\": 2,\n        \"progress\": \"100.00%\",\n        \"statuses\": [\n            {\n                \"pid\": \"pid001\",\n                \"ret\": 0,\n                \"err_msg\": \"success\",\n                \"err_msg_zh_cn\": \"成功\"\n            },\n            {\n                \"pid\": \"pid002\",\n                \"ret\": 0,\n                \"err_msg\": \"success\",\n                \"err_msg_zh_cn\": \"成功\"\n            }\n        ]\n    }\n}\n*/\n获取单个商品信息\n使用该接口获取已导入的商品信息，供验证信息及抽查导入情况使用。\n&lt;?php\n\n$pid = 'pid001';\n\n$officialAccount-&gt;goods-&gt;get($pid);\n\n返回结果中的 product 字段内容与 导入商品接口 字段一致，导入时未设置的值有可能获取时仍会返回，但显示为空。\n\n分页获取商品信息\n使用该接口可获取已导入的全量商品信息，供全量验证信息使用。\n&lt;?php\n\n// $page 为 1 时传空即可。当 $page 大于 1 时必填，填入上一次访问本接口返回的 page_context。\n$context = '';  \n$page = 1; // 页码\n$size = 10; // 每页数据大小，目前限制为 100 以内，注意一次全量验证过程中该参数的值需保持不变\n\n$officialAccount-&gt;goods-&gt;list($context, $page, $size);\n\n返回结果中的 product 字段内容与 导入商品接口 字段一致，导入时未设置的值有可能获取时仍会返回，但显示为空。page_context 字段用于获取下一页数据时使用。\n","link":"/Components/WeChat2.x/officialAccount/goods.html"},{"id":271,"title":"安装","content":"微信SDK EasySwoole WeChat 2.x - 小程序\nEasySwoole WeChat 是一个基于 Swoole 4.x 全协程支持的微信 SDK 库，告别同步阻塞，轻松编写高性能的微信公众号/小程序/开放平台/企业微信业务接口。用户如果想要使用关于微信支付业务的使用可以查看 EasySwoole Pay 组件。\n该组件库是仿照 easywechat API 实现的协程安全的 wechat sdk 库。\n用户可以在一切支持 Swoole 协程环境的框架（EasySwoole、Hyperf、Swoft 等）中使用，安装和使用方法请看下文。\n旧版组件兼容说明\n注意：WeChat 组件目前最新版本为 2.0.0 版。完全不兼容旧版本 wechat 1.2.x 版本。旧版本 1.2.x 微信小程序组件的文档请移步查看 1.2.x 微信小程序 SDK 文档的 安装 和 API 接口\n说明\n首先感谢 easywechat 作者们创造的优秀项目，但由于在协程环境下使用会有潜在的跨协程问题，故有了此项目。考虑到大多数用户的习惯，我们保留了绝大多数 API 的命名和风格习惯，以便用户更好地上手使用；但在部分可能存在潜在风险的地方， 我们则进行了重新设计，以保障协程环境下的运行安全。\n组件要求\n\nphp &gt;= 7.2\next-swoole: ^4.4.19 (推荐使用 Swoole 4.4.23)\next-openssl: *\next-json: *\next-libxml: *\next-simplexml: *\next-openssl: *\npsr/log: ^1.1\npsr/http-message: ^1.0\npsr/simple-cache: ^1.0\npimple/pimple: ^3.0\neasyswoole/utility: ^1.1\n\n\n注意：在编译安装 Swoole 扩展时，请务必把编译参数 --enable-openssl 加上，以启用 SSL 支持\n\n安装方法\n\n$ composer require easyswoole/wechat\n\n仓库地址\neasyswoole/wechat=2.x\n常见问题汇总\n为了让用户在微信公众平台开发的道路上少掉坑，我们在这里将使用此组件进行开发时遇到的各种问题进行汇总，并给出对应的解决办法。这样用户就可以更效地进行开发了。\n时区不对\n\n报错情形如下：Setting The Correct Timezone In CentOS And Ubuntu Servers With NTP。\n解决方法：使用命令 date 可以在服务器上查看当前时间，如果发现时区不对则需要修改时区。\n\nredirect_url 参数错误\n\n\n出现原因：这是由于程序使用了 网页授权 而公众号没有正确配置 【网页授权域名】 所致。此时你需要登录微信公众平台，在 【开发】 -&gt; 【接口权限】 页面找到 网页授权获取用户基本信息 进行配置并保存。\n\n\n解决方法：\n\n网页授权域名应该为通过 ICP 备案的有效域名，否则保存时无法通过安全监测。\n网页授权域名即程序完成授权获得授权 code 后跳转到的页面的域名，一般情况下为你的业务域名。\n网页授权域名配置成功后会立即生效。\n公众号的网页授权域名只可配置一个，请合理规划你的业务，否则你会发现 …… 授权域名不够用哈。\n\n\n\nJSAPI config: invalid url domain\n\n出现原因：在使用 JS-SDK 进行开发时，每个页面都需要调用 wx.config() 方法配置 JSPAI 参数。如果没有正确配置 JSAPI 安全域名并且开启了调试模式，此时就报此错误。\n解决方法：遇到这个问题时，开发者需要登录微信公众平台，进入 【公众号设置】-&gt;【功能设置】 页面，将项目所使用的域名添加至 【JSAPI 安全域名】 列表中。\n注意事项说明：\n\n一个公众号同时最多可绑定三个安全域名，并且这些域名必须为通过 ICP 备案的一级或一级以上的有效域名。\n\nJSAPI 安全域名每个月限修改三次，修改任何一个都算，所以，请谨慎操作。\n\n\n","link":"/Components/WeChat2.x/miniProgram/install.html"},{"id":272,"title":"入门","content":"小程序\n&lt;?php\n$config = [\n    // 微信公众平台后台的 appid\n    'appId' =&gt; 'wxefe41fdeexxxxxx', \n\n    // 微信公众平台后台配置的 Token\n    'token' =&gt; 'dczmnau31ea9nzcnxxxxxxxxx',\n\n    // 微信公众平台后台配置的 EncodingAESKey\n    'aesKey' =&gt; 'easyswoole',\n\n    // 微信公众平台后台配置的 AppSecret\n    'appSecret' =&gt; 'your-AppSecret'\n];\n\n// 小程序\n$miniProgram = \\EasySwoole\\WeChat\\Factory::miniProgram($config);\n$miniProgram 在所有相关小程序的文档都是指 Factory::miniProgram 得到的实例，就不在每个页面单独写了。","link":"/Components/WeChat2.x/miniProgram/getStart.html"},{"id":273,"title":"小程序码","content":"小程序码\n获取小程序码\n接口 A：适用于需要的码数量较少的业务场景\n\nAPI：\n\n$miniProgram-&gt;appCode-&gt;get(string $path, array $optional = []);\n其中 $optional 为以下可选参数：\n\n\nwidth int - 默认 430 二维码的宽度\n\nauto_color 默认 false 自动配置线条颜色，如果颜色依然是黑色，则说明不建议配置主色调\n\nline_color 数组，auto_color 为 false 时生效，使用 rgb 设置颜色，例如：[\"r\" =&gt; 0,\"g\" =&gt; 0,\"b\" =&gt; 0]。\n\n\n示例代码：\n\n&lt;?php\n$response = $miniProgram-&gt;appCode-&gt;get('path/to/page');\n// 或者\n$response = $miniProgram-&gt;appCode-&gt;get('path/to/page', [\n    'width' =&gt; 600,\n    // ...\n]);\n\n// 或者指定颜色\n$response = $miniProgram-&gt;appCode-&gt;get('path/to/page', [\n    'width' =&gt; 600,\n    'line_color' =&gt; [\n        'r' =&gt; 105,\n        'g' =&gt; 166,\n        'b' =&gt; 134,\n    ],\n]);\n\n// $response 成功时为 EasySwoole\\WeChat\\Kernel\\Psr\\StreamResponse 实例，失败时会返回 bool 值或抛出异常（可通过捕获异常的形式获取失败原因）\n\n// 保存小程序码到文件\nif ($response instanceof \\EasySwoole\\WeChat\\Kernel\\Psr\\StreamResponse) {\n    $filename = $response-&gt;save('/path/to/directory');\n}\n\n// 或\nif ($response instanceof \\EasySwoole\\WeChat\\Kernel\\Psr\\StreamResponse) {\n    $filename = $response-&gt;saveAs('/path/to/directory', 'appcode.png');\n}\n接口 B：适用于需要的码数量极多，或仅临时使用的业务场景\n\nAPI：\n\n$miniProgram-&gt;appCode-&gt;getUnlimit(string $scene, array $optional = []);\n其中 $scene 必填，$optinal 与 get 方法一致，多一个 page 参数。\n\n示例代码：\n\n&lt;?php\n$response = $miniProgram-&gt;appCode-&gt;getUnlimit('scene-value', [\n    'page'  =&gt; 'path/to/page',\n    'width' =&gt; 600,\n]);\n// $response 成功时为 EasySwoole\\WeChat\\Kernel\\Psr\\StreamResponse 实例，失败时会返回 bool 值或抛出异常（可通过捕获异常的形式获取失败原因）\n\n// 保存小程序码到文件\nif ($response instanceof \\EasySwoole\\WeChat\\Kernel\\Psr\\StreamResponse) {\n    $filename = $response-&gt;save('/path/to/directory');\n}\n// 或\nif ($response instanceof \\EasySwoole\\WeChat\\Kernel\\Psr\\StreamResponse) {\n    $filename = $response-&gt;saveAs('/path/to/directory', 'appcode.png');\n}\n获取小程序二维码\n\nAPI: \n\n$miniProgram-&gt;appCode-&gt;getQrCode(string $path, int $width = null);\n其中 $path 必填，其余参数可留空。\n\n示例代码：\n\n&lt;?php\n$response = $miniProgram-&gt;appCode-&gt;getQrCode('/path/to/page');\n\n// $response 成功时为 \\EasySwoole\\WeChat\\Kernel\\Psr\\StreamResponse 实例，失败时会返回 bool 值或抛出异常（可通过捕获异常的形式获取失败原因）\n\n// 保存小程序码到文件\nif ($response instanceof \\EasySwoole\\WeChat\\Kernel\\Psr\\StreamResponse) {\n    $filename = $response-&gt;save('/path/to/directory');\n}\n\n// 或\nif ($response instanceof \\EasySwoole\\WeChat\\Kernel\\Psr\\StreamResponse) {\n    $filename = $response-&gt;saveAs('/path/to/directory', 'appcode.png');\n}","link":"/Components/WeChat2.x/miniProgram/appCode.html"},{"id":274,"title":"客服消息","content":"客服消息\n获取实例\n$service = $miniProgram-&gt;customerService;\n使用方法详看 公众号-客服 章节。","link":"/Components/WeChat2.x/miniProgram/customerService.html"},{"id":275,"title":"数据统计与分析","content":"数据统计与分析\n获取小程序概况趋势：\n$miniProgram-&gt;dataCube-&gt;summaryTrend('20170313', '20170313');\n开始日期与结束日期的格式为 YYYYmmdd。\nAPI\n\nsummaryTrend(string $from, string $to); 概况趋势\ndailyVisitTrend(string $from, string $to); 访问日趋势\nweeklyVisitTrend(string $from, string $to); 访问周趋势\nmonthlyVisitTrend(string $from, string $to); 访问月趋势\nvisitDistribution(string $from, string $to); 访问分布\ndailyRetainInfo(string $from, string $to); 访问日留存\nweeklyRetainInfo(string $from, string $to); 访问周留存\nmonthlyRetainInfo(string $from, string $to); 访问月留存\nvisitPage(string $from, string $to); 访问页面\nuserPortrait(string $from, string $to); 用户画像分布数\n","link":"/Components/WeChat2.x/miniProgram/dataCube.html"},{"id":276,"title":"微信登录","content":"微信登录\n根据 jsCode 获取用户 session 信息\n\nAPI：\n\n$miniProgram-&gt;auth-&gt;session(string $code);","link":"/Components/WeChat2.x/miniProgram/auth.html"},{"id":277,"title":"模板消息","content":"模板消息\n获取小程序模板库标题列表\n$miniProgram-&gt;templateMessage-&gt;list($offset, $count);\n获取模板库某个模板标题下关键词库\n$miniProgram-&gt;templateMessage-&gt;get($id);\n组合模板并添加至帐号下的个人模板库\n$miniProgram-&gt;templateMessage-&gt;add($id, $keywordIdList);\n获取帐号下已存在的模板列表\n$miniProgram-&gt;templateMessage-&gt;getTemplates($offset, $count);\n删除帐号下的某个模板\n$miniProgram-&gt;templateMessage-&gt;delete($templateId);\n发送模板消息\n$miniProgram-&gt;templateMessage-&gt;send([\n    'touser' =&gt; 'user-openid',\n    'template_id' =&gt; 'template-id',\n    'page' =&gt; 'index',\n    'form_id' =&gt; 'form-id',\n    'data' =&gt; [\n        'keyword1' =&gt; 'VALUE',\n        'keyword2' =&gt; 'VALUE2',\n        // ...\n    ],\n]);\n","link":"/Components/WeChat2.x/miniProgram/templateMessage.html"},{"id":278,"title":"消息解密","content":"微信小程序消息解密\n比如获取电话等功能，信息是加密的，需要解密。\nAPI：\n&lt;?php\n$encryptObj = new \\EasySwoole\\WeChat\\MiniProgram\\Encryptor();\n\n$decryptedData = $encryptObj-&gt;decryptData($session, $iv, $encryptedData);","link":"/Components/WeChat2.x/miniProgram/decrypt.html"},{"id":279,"title":"物流助手","content":"物流助手\n生成运单\n&lt;?php\n$miniProgram-&gt;express-&gt;createWaybill($data);\n\n// 例如：\ntry {\n    $ret = $miniProgram-&gt;express-&gt;createWaybill($data);\n} catch (\\EasySwoole\\WeChat\\Kernel\\Exceptions\\HttpException $httpException) {\n    $error = $httpException-&gt;getMessage();\n}\n\n// 成功返回\n{\n  \"order_id\": \"01234567890123456789\",\n  \"waybill_id\": \"123456789\",\n  \"waybill_data\": [\n    {\n      \"key\": \"SF_bagAddr\",\n      \"value\": \"广州\"\n    },\n    {\n      \"key\": \"SF_mark\",\n      \"value\": \"101- 07-03 509\"\n    }\n  ]\n}\n\n// 失败返回，抛出 \\EasySwoole\\WeChat\\Kernel\\Exceptions\\HttpException 异常\n取消运单\n&lt;?php\n$miniProgram-&gt;express-&gt;deleteWaybill($data);\n\n// 例如：\ntry {\n    $ret = $miniProgram-&gt;express-&gt;deleteWaybill($data);\n} catch (\\EasySwoole\\WeChat\\Kernel\\Exceptions\\HttpException $httpException) {\n    $error = $httpException-&gt;getMessage();\n}\n获取支持的快递公司列表\n&lt;?php\n$miniProgram-&gt;express-&gt;listProviders();\n\n// 例如：\ntry {\n    $ret = $miniProgram-&gt;express-&gt;listProviders();\n} catch (\\EasySwoole\\WeChat\\Kernel\\Exceptions\\HttpException $httpException) {\n    $error = $httpException-&gt;getMessage();\n}\n\n// 列表：\n{\n  \"count\": 8,\n  \"data\": [\n    {\n      \"delivery_id\": \"BEST\",\n      \"delivery_name\": \"百世快递\"\n    },\n    ...\n  ]\n}\n获取运单数据\n&lt;?php\n$miniProgram-&gt;express-&gt;getWaybill($data);\n\n// 例如：\ntry {\n    $ret = $miniProgram-&gt;express-&gt;getWaybill($data);\n} catch (\\EasySwoole\\WeChat\\Kernel\\Exceptions\\HttpException $httpException) {\n    $error = $httpException-&gt;getMessage();\n}\n查询运单轨迹\n&lt;?php\n$miniProgram-&gt;express-&gt;getWaybillTrack($data);\n\n// 例如：\ntry {\n    $ret = $miniProgram-&gt;express-&gt;getWaybillTrack($data);\n} catch (\\EasySwoole\\WeChat\\Kernel\\Exceptions\\HttpException $httpException) {\n    $error = $httpException-&gt;getMessage();\n}\n获取打印员\n&lt;?php\n$miniProgram-&gt;express-&gt;getPrinter();\n\n// 例如：\ntry {\n    $ret = $miniProgram-&gt;express-&gt;getPrinter();\n} catch (\\EasySwoole\\WeChat\\Kernel\\Exceptions\\HttpException $httpException) {\n    $error = $httpException-&gt;getMessage();\n}\n获取电子面单余额\n仅在使用加盟类快递公司时，才可以调用。\n&lt;?php\n$miniProgram-&gt;express-&gt;getBalance($deliveryId, $bizId);\n\n// 例如：\ntry {\n    $ret = $miniProgram-&gt;express-&gt;getBalance('YTO', 'xyz');\n} catch (\\EasySwoole\\WeChat\\Kernel\\Exceptions\\HttpException $httpException) {\n    $error = $httpException-&gt;getMessage();\n}\n绑定打印员\n若需要使用微信打单 PC 软件，才需要调用。\n&lt;?php\n$miniProgram-&gt;express-&gt;bindPrinter($openid);\n\n// 例如：\ntry {\n    $ret = $miniProgram-&gt;express-&gt;bindPrinter($openid);\n} catch (\\EasySwoole\\WeChat\\Kernel\\Exceptions\\HttpException $httpException) {\n    $error = $httpException-&gt;getMessage();\n}\n解绑打印员\n若需要使用微信打单 PC 软件，才需要调用。\n&lt;?php\n$miniProgram-&gt;express-&gt;unbindPrinter($openid);\n\n// 例如：\ntry {\n    $ret = $miniProgram-&gt;express-&gt;unbindPrinter($openid);\n} catch (\\EasySwoole\\WeChat\\Kernel\\Exceptions\\HttpException $httpException) {\n    $error = $httpException-&gt;getMessage();\n}","link":"/Components/WeChat2.x/miniProgram/express.html"},{"id":280,"title":"生物认证","content":"生物认证\n生物认证秘钥签名验证\n$miniProgram-&gt;soter-&gt;verifySignature($openid, $json, $signature);\n返回值示例：\n{\n    \"is_ok\": true\n}\n参数说明：\n\nstring $openid - 用户 openid\nstring $json - 通过 wx.startSoterAuthentication 成功回调获得的 resultJSON 字段\nstring $signature - 通过 wx.startSoterAuthentication 成功回调获得的 resultJSONSign\n","link":"/Components/WeChat2.x/miniProgram/soter.html"},{"id":281,"title":"插件管理","content":"插件管理\n微信文档：https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/plugin-management/pluginManager.applyPlugin.html\n申请使用插件\n&lt;?php\n$pluginAppId = 'xxxxxxxxx';\n\n$miniProgram-&gt;plugin-&gt;apply($pluginAppId);\n查询已添加的插件\n$miniProgram-&gt;plugin-&gt;list();\n删除已添加的插件\n&lt;?php\n$pluginAppId = 'xxxxxxxxx';\n\n$miniProgram-&gt;plugin-&gt;unbind($pluginAppId);\n获取当前所有插件使用方\n&lt;?php\n$page = 1;\n$size = 10;\n\n$miniProgram-&gt;pluginDev-&gt;getUsers($page, $size);\n同意插件使用申请\n&lt;?php\n$appId = 'wxxxxxxxxxxxxxx';\n\n$miniProgram-&gt;pluginDev-&gt;agree($appId);\n拒绝插件使用申请\n$miniProgram-&gt;pluginDev-&gt;refuse('拒绝理由');\n删除已拒绝的申请者\n$miniProgram-&gt;pluginDev-&gt;delete();","link":"/Components/WeChat2.x/miniProgram/plugin.html"},{"id":282,"title":"附近的小程序","content":"附近的小程序\n微信文档：https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/nearby-poi/nearbyPoi.add.html\n添加地点\n&lt;?php\n$params = [\n    'kf_info' =&gt; '{\"open_kf\":true,\"kf_headimg\":\"http://mmbiz.qpic.cn/mmbiz_jpg/kKMgNtnEfQzDKpLXYhgo3W3Gndl34gITqmP914zSwhajIEJzUPpx40P7R8fRe1QmicneQMhFzpZNhSLjrvU1pIA/0?wx_fmt=jpeg\",\"kf_name\":\"Harden\"}',\n    'pic_list' =&gt; '{\"list\":[\"http://mmbiz.qpic.cn/mmbiz_jpg/kKMgNtnEfQzDKpLXYhgo3W3Gndl34gITqmP914zSwhajIEJzUPpx40P7R8fRe1QmicneQMhFzpZNhSLjrvU1pIA/0?wx_fmt=jpeg\",\"http://mmbiz.qpic.cn/mmbiz_jpg/kKMgNtnEfQzDKpLXYhgo3W3Gndl34gITRneE5FS9uYruXGMmrtmhsBySwddEWUGOibG8Ze2NT5E3Dyt79I0htNg/0?wx_fmt=jpeg\"]}',\n    'service_infos' =&gt; '{\"service_infos\":[{\"id\":2,\"type\":1,\"name\":\"快递\",\"appid\":\"wx1373169e494e0c39\",\"path\":\"index\"},{\"id\":0,\"type\":2,\"name\":\"自定义\",\"appid\":\"wx1373169e494e0c39\",\"path\":\"index\"}]}',\n    'store_name' =&gt; '羊村小马烧烤',\n    'contract_phone' =&gt; '111111111',\n    'hour' =&gt; '00:00-11:11',\n    'company_name' =&gt; '深圳市腾讯计算机系统有限公司',\n    'credential' =&gt; '156718193518281',\n    'address' =&gt; '新疆维吾尔自治区克拉玛依市克拉玛依区碧水路15-1-8号(碧水云天广场)',\n    'qualification_list' =&gt; '3LaLzqiTrQcD20DlX_o-OV1-nlYMu7sdVAL7SV2PrxVyjZFZZmB3O6LPGaYXlZWq',\n];\n\n$miniProgram-&gt;nearbyPoi-&gt;add($params);\n更新地点\n&lt;?php\n$poiId = 'xxxxxxxx';\n\n$params = [\n    'kf_info' =&gt; '{\"open_kf\":true,\"kf_headimg\":\"http://mmbiz.qpic.cn/mmbiz_jpg/kKMgNtnEfQzDKpLXYhgo3W3Gndl34gITqmP914zSwhajIEJzUPpx40P7R8fRe1QmicneQMhFzpZNhSLjrvU1pIA/0?wx_fmt=jpeg\",\"kf_name\":\"Harden\"}',\n    'pic_list' =&gt; '{\"list\":[\"http://mmbiz.qpic.cn/mmbiz_jpg/kKMgNtnEfQzDKpLXYhgo3W3Gndl34gITqmP914zSwhajIEJzUPpx40P7R8fRe1QmicneQMhFzpZNhSLjrvU1pIA/0?wx_fmt=jpeg\",\"http://mmbiz.qpic.cn/mmbiz_jpg/kKMgNtnEfQzDKpLXYhgo3W3Gndl34gITRneE5FS9uYruXGMmrtmhsBySwddEWUGOibG8Ze2NT5E3Dyt79I0htNg/0?wx_fmt=jpeg\"]}',\n    'service_infos' =&gt; '{\"service_infos\":[{\"id\":2,\"type\":1,\"name\":\"快递\",\"appid\":\"wx1373169e494e0c39\",\"path\":\"index\"},{\"id\":0,\"type\":2,\"name\":\"自定义\",\"appid\":\"wx1373169e494e0c39\",\"path\":\"index\"}]}',\n    'contract_phone' =&gt; '111111111',\n    'hour' =&gt; '00:00-11:11',\n    'company_name' =&gt; '深圳市腾讯计算机系统有限公司',\n    'credential' =&gt; '156718193518281',\n    'address' =&gt; '新疆维吾尔自治区克拉玛依市克拉玛依区碧水路15-1-8号(碧水云天广场)',\n    'qualification_list' =&gt; '3LaLzqiTrQcD20DlX_o-OV1-nlYMu7sdVAL7SV2PrxVyjZFZZmB3O6LPGaYXlZWq',\n];\n\n$miniProgram-&gt;nearbyPoi-&gt;update($poiId, $params);\n删除地点\n&lt;?php\n$poiId = 'xxxxxxxx';\n\n$miniProgram-&gt;nearbyPoi-&gt;delete($poiId);\n地点列表\n&lt;?php\n$page = 1;\n$pageRows = 10;\n\n$miniProgram-&gt;nearbyPoi-&gt;list($page, $pageRows);\n设置地点展示状态\n&lt;?php\n$poiId = 'xxxxxxxx';\n$status = 0; // 0: 不展示，1：展示\n\n$miniProgram-&gt;nearbyPoi-&gt;setVisibility($poiId, $status);","link":"/Components/WeChat2.x/miniProgram/nearByPoi.html"},{"id":283,"title":"订阅消息","content":"订阅消息\n微信文档：https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/subscribe-message/subscribeMessage.addTemplate.html\n组合模板并添加至帐号下的个人模板库\n&lt;?php\n$tid = 563; // 模板标题 id，可通过接口获取，也可登录小程序后台查看获取\n$kidList = [1, 2]; // 开发者自行组合好的模板关键词列表，可以通过 `getTemplateKeywords` 方法获取\n$sceneDesc = '提示用户图书到期'; // 服务场景描述，非必填\n\n$miniProgram-&gt;subscribeMessage-&gt;addTemplate($tid, $kidList, $sceneDesc);\n删除帐号下的个人模板\n&lt;?php\n$templateId = 'bDmywsp2oEHjwAadTGKkUHpC0RgBVPvfAM7Cu1s03z8';\n\n$miniProgram-&gt;subscribeMessage-&gt;deleteTemplate($templateId);\n获取小程序账号的类目\n&lt;?php\n$miniProgram-&gt;subscribeMessage-&gt;getCategory();\n获取模板标题的关键词列表\n&lt;?php\n$tid = 563; // 模板标题 id，可通过接口获取，也可登录小程序后台查看获取\n\n$miniProgram-&gt;subscribeMessage-&gt;getTemplateKeywords($tid);\n获取帐号所属类目下的公共模板标题\n&lt;?php\n$ids = [612, 613]; // 类目 id\n$start = 0; // 用于分页，表示从 start 开始。从 0 开始计数。  \n$limit = 30; // 用于分页，表示拉取 limit 条记录。最大为 30。\n\n$miniProgram-&gt;subscribeMessage-&gt;getTemplateTitles($ids, $start, $limit);\n获取当前帐号下的个人模板列表\n&lt;?php\n$miniProgram-&gt;subscribeMessage-&gt;getTemplates();\n发送订阅消息\n&lt;?php\n$data = [\n    'template_id' =&gt; 'bDmywsp2oEHjwAadTGKkUJ-eJEiMiOf7H-dZ7wjdw80', // 所需下发的订阅模板id\n    'touser' =&gt; 'oSyZp5OBNPBRhG-7BVgWxbiNZm', // 接收者（用户）的 openid\n    'page' =&gt; '', // 点击模板卡片后的跳转页面，仅限本小程序内的页面。支持带参数,（示例index?foo=bar）。该字段不填则模板无跳转。\n    'data' =&gt; [ // 模板内容，格式形如 { \"key1\": { \"value\": any }, \"key2\": { \"value\": any } }\n        'date01' =&gt; [\n            'value' =&gt; '2019-12-01',\n        ],\n        'number01' =&gt; [\n            'value' =&gt; 10,\n        ],\n    ],\n];\n\n$miniProgram-&gt;subscribeMessage-&gt;send($data);","link":"/Components/WeChat2.x/miniProgram/subscribeMessage.html"},{"id":284,"title":"直播","content":"直播\n微信文档：https://developers.weixin.qq.com/miniprogram/dev/framework/liveplayer/live-player-plugin.html\n\n微信规定以下两个接口调用限制共享 500 次/天 建议开发者自己做缓存，合理分配调用频次。\n\n获取直播房间列表\n&lt;?php\n$miniProgram-&gt;live-&gt;getRooms();\n获取回放源视频\n&lt;?php\n$roomId = 1; // 直播房间id\n\n$miniProgram-&gt;live-&gt;getPlaybacks($roomId);","link":"/Components/WeChat2.x/miniProgram/live.html"},{"id":285,"title":"安全风控","content":"安全风控\n微信文档：https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/safety-control-capability/riskControl.getUserRiskRank.html\n\n根据提交的用户信息数据获取用户的安全等级 risk_rank，无需用户授权。\n\n获取用户的安全等级\n&lt;?php\n$miniProgram-&gt;riskControl-&gt;getUserRiskRank([\n    'appid' =&gt; 'wx311232323',\n    'openid' =&gt; 'oahdg535ON6vtkUXLdaLVKvzJdmM',\n    'scene' =&gt; 1,\n    'client_ip' =&gt; '12.234.134.2',\n]);","link":"/Components/WeChat2.x/miniProgram/safetyControl.html"},{"id":286,"title":"url scheme","content":"URL Scheme\n微信文档：https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/url-scheme/urlscheme.generate.html\n\n目前仅针对国内非个人主体的小程序开放。\n\n获取小程序 scheme 码\n&lt;?php\n$miniProgram-&gt;urlScheme-&gt;generate();","link":"/Components/WeChat2.x/miniProgram/urlSchemeGenerate.html"},{"id":287,"title":"安装","content":"微信SDK EasySwoole WeChat 2.x - 开放平台\nEasySwoole WeChat 是一个基于 Swoole 4.x 全协程支持的微信 SDK 库，告别同步阻塞，轻松编写高性能的微信公众号/小程序/开放平台/企业微信业务接口。用户如果想要使用关于微信支付业务的使用可以查看 EasySwoole Pay 组件。\n该组件库是仿照 easywechat API 实现的协程安全的 wechat sdk 库。\n用户可以在一切支持 Swoole 协程环境的框架（EasySwoole、Hyperf、Swoft 等）中使用，安装和使用方法请看下文。\n\n注意：WeChat 组件目前最新版本为 2.0.0 版。\n\n旧版组件兼容说明\n注意：WeChat 组件目前最新版本为 2.0.0 版。完全不兼容旧版本 wechat 1.2.x 版本。旧版本 1.2.x 微信开放平台组件的文档请移步查看 1.2.x 微信开放平台 SDK 文档的 安装 和 API 接口\n说明\n首先感谢 easywechat 作者们创造的优秀项目，但由于在协程环境下使用会有潜在的跨协程问题，故有了此项目。考虑到大多数用户的习惯，我们保留了绝大多数 API 的命名和风格习惯，以便用户更好地上手使用；但在部分可能存在潜在风险的地方， 我们则进行了重新设计，以保障协程环境下的运行安全。\n组件要求\n\nphp &gt;= 7.2\next-swoole: ^4.4.19 (推荐使用 Swoole 4.4.23)\next-openssl: *\next-json: *\next-libxml: *\next-simplexml: *\next-openssl: *\npsr/log: ^1.1\npsr/http-message: ^1.0\npsr/simple-cache: ^1.0\npimple/pimple: ^3.0\neasyswoole/utility: ^1.1\n\n\n注意：在编译安装 Swoole 扩展时，请务必把编译参数 --enable-openssl 加上，以启用 SSL 支持\n\n安装方法\n\n$ composer require easyswoole/wechat\n\n仓库地址\neasyswoole/wechat=2.x\n常见问题汇总\n为了让用户在微信公众平台开发的道路上少掉坑，我们在这里将使用此组件进行开发时遇到的各种问题进行汇总，并给出对应的解决办法。这样用户就可以更效地进行开发了。\n时区不对\n\n报错情形如下：Setting The Correct Timezone In CentOS And Ubuntu Servers With NTP。\n解决方法：使用命令 date 可以在服务器上查看当前时间，如果发现时区不对则需要修改时区。\n\nredirect_url 参数错误\n\n\n出现原因：这是由于程序使用了 网页授权 而公众号没有正确配置 【网页授权域名】 所致。此时你需要登录微信公众平台，在 【开发】 -&gt; 【接口权限】 页面找到 网页授权获取用户基本信息 进行配置并保存。\n\n\n解决方法：\n\n网页授权域名应该为通过 ICP 备案的有效域名，否则保存时无法通过安全监测。\n网页授权域名即程序完成授权获得授权 code 后跳转到的页面的域名，一般情况下为你的业务域名。\n网页授权域名配置成功后会立即生效。\n公众号的网页授权域名只可配置一个，请合理规划你的业务，否则你会发现 …… 授权域名不够用哈。\n\n\n\nJSAPI config: invalid url domain\n\n出现原因：在使用 JS-SDK 进行开发时，每个页面都需要调用 wx.config() 方法配置 JSPAI 参数。如果没有正确配置 JSAPI 安全域名并且开启了调试模式，此时就报此错误。\n解决方法：遇到这个问题时，开发者需要登录微信公众平台，进入 【公众号设置】-&gt;【功能设置】 页面，将项目所使用的域名添加至 【JSAPI 安全域名】 列表中。\n注意事项说明：\n\n一个公众号同时最多可绑定三个安全域名，并且这些域名必须为通过 ICP 备案的一级或一级以上的有效域名。\n\nJSAPI 安全域名每个月限修改三次，修改任何一个都算，所以，请谨慎操作。\n\n\n","link":"/Components/WeChat2.x/openPlatform/install.html"},{"id":288,"title":"入门","content":"微信开放平台第三方平台\n此页涉及接口信息与说明请参见：授权流程技术说明 - 官方文档\n实例化\n&lt;?php\n\n$config = [\n    // 开放平台第三方平台 APPID\n    'appId' =&gt; 'wxefe41fdeexxxxxx', \n\n    // 开放平台第三方平台 Token\n    'token' =&gt; 'dczmnau31ea9nzcnxxxxxxxxx',\n\n    // 开放平台第三方平台 AES Key\n    'aesKey' =&gt; 'easyswoole',\n\n    // 开放平台第三方平台 Secret\n    'appSecret' =&gt; 'your-AppSecret'\n];\n\n// 开放平台\n$openPlatform = \\EasySwoole\\WeChat\\Factory::openPlatform($config);\n$openPlatform 在所有相关开放平台的文档都是指 Factory::openPlatform 得到的实例，就不在每个页面单独写了。\n获取用户授权页 URL\n// 传入回调URI即可\n$openPlatform-&gt;getPreAuthorizationUrl('https://easyswoole.wechat.com/callback'); \n使用授权码换取接口调用凭据和授权信息\n在用户在授权页授权流程完成后，授权页会自动跳转进入回调URI，并在URL参数中返回授权码和过期时间，如：(https://easyswoole.wechat.com/callback?auth_code=xxx&amp;expires_in=600)\n$openPlatform-&gt;handleAuthorize(string $authCode = null);\n\n$authCode 不传的时候会获取 url 中的 auth_code 参数值\n\n获取授权方的帐号基本信息\n$openPlatform-&gt;getAuthorizer(string $appId);\n获取授权方的选项设置信息\n$openPlatform-&gt;getAuthorizerOption(string $appId, string $name);\n设置授权方的选项信息\n$openPlatform-&gt;setAuthorizerOption(string $appId, string $name, string $value);\n\n该 API 用于获取授权方的公众号或小程序的选项设置信息，如：地理位置上报，语音识别开关，多客服开关。注意，获取各项选项设置信息，需要有授权方的授权，详见权限集说明。\n\n获取已授权的授权方列表\n$openPlatform-&gt;getAuthorizers(int $offset = 0, int $count = 500);","link":"/Components/WeChat2.x/openPlatform/getStart.html"},{"id":289,"title":"服务端","content":"服务端\n第三方平台推送事件\n公众号第三方平台推送的有四个事件：\n\n如已经授权的公众号、小程序再次进行授权，而未修改已授权的权限的话，是没有相关事件推送的。\n\n授权成功 authorized\n​授权更新 updateauthorized\n​授权取消 unauthorized\n​VerifyTicket component_verify_ticket\nSDK 默认会处理事件 component_verify_ticket ，并会缓存 verify_ticket 所以如果你暂时不需要处理其他事件，直接这样使用即可：\n在 EasySwoole 框架中配置服务端验证，示例代码如下：\n&lt;?php\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\nuse EasySwoole\\WeChat\\Factory;\n\nclass Index extends Controller\n{\n    public function index()\n    {\n        $config = [\n            // 开放平台第三方平台 APPID\n            'appId' =&gt; 'wxefe41fdeexxxxxx', \n\n            // 开放平台第三方平台 Token\n            'token' =&gt; 'dczmnau31ea9nzcnxxxxxxxxx',\n\n            // 开放平台第三方平台 AES Key\n            'aesKey' =&gt; 'easyswoole',\n\n            // 开放平台第三方平台 Secret\n            'secret' =&gt; 'your-AppSecret'\n        ];\n\n        // 开放平台\n        $openPlatform = Factory::openPlatform($config);\n\n        $server = $openPlatform-&gt;server;\n\n        /** @var \\Psr\\Http\\Message\\ServerRequestInterface $psr7Request */\n        $psr7Request = $this-&gt;request();\n\n        // $psr7esponse 是一个显式实现了 PSR-7 的对象，用户只需要处理该对象即可正确响应给微信\n        $psr7Response = $server-&gt;serve($psr7Request);\n\n        $this-&gt;response()-&gt;withStatus($psr7Response-&gt;getStatusCode());\n\n        // PSR-7 的 Header 并不是单纯的 k =&gt; v 结构\n        foreach ($psr7Response-&gt;getHeaders() as $name =&gt; $values) {\n            $this-&gt;response()-&gt;withHeader($name, implode(\", \", $values));\n        }\n        $this-&gt;response()-&gt;write($psr7Response-&gt;getBody()-&gt;__toString());\n    }\n}\n使用原生 Swoole 配置服务端验证，示例代码如下：\nserver.php 的实现形式下面就以原生 Swoole 的 http_server 来启动一个服务，伪代码内容如下：\n&lt;?php\n\nuse EasySwoole\\WeChat\\Factory;\n\nrequire_once __DIR__ . '/vendor/autoload.php';\n\n$http = new Swoole\\Http\\Server('0.0.0.0', 9501);\n\n$http-&gt;on('request', function (\\Swoole\\Http\\Request $request, \\Swoole\\Http\\Response $response) {\n\n    $config = [\n        // 开放平台第三方平台 APPID\n        'appId' =&gt; 'wxefe41fdeexxxxxx', \n\n        // 开放平台第三方平台 Token\n        'token' =&gt; 'dczmnau31ea9nzcnxxxxxxxxx',\n\n        // 开放平台第三方平台 AES Key\n        'aesKey' =&gt; 'easyswoole',\n\n        // 开放平台第三方平台 Secret\n        'secret' =&gt; 'your-AppSecret'\n    ];\n\n    // 开放平台\n    $openPlatform = \\EasySwoole\\WeChat\\Factory::openPlatform($config);\n\n    $server = $openPlatform-&gt;server;\n\n    // 此处为实现了 \\Psr\\Http\\Message\\ServerRequestInterface 的 request 对象\n    /** @var \\Psr\\Http\\Message\\ServerRequestInterface $psr7Request  */\n    $psr7Request = new XxxReuest($request); // 伪代码\n\n    /**\n     * @var \\Psr\\Http\\Message\\ResponseInterface $psr7Response\n     * forceValidate() 表示启用请求验证，以确保请求来自微信发送。默认不启用验证\n     * serve() 会解析本次请求后回调之前注册的事件（包括 AES 解密和解析 XML）\n     * serve() 接受一个显式实现了 \\Psr\\Http\\Message\\ServerRequestInterface 的 request 对象\n     */\n    $psr7Response = $server-&gt;serve($psr7Request);\n\n    /**\n     * $replyResponse 是一个显式实现了 PSR-7 的对象，用户只需要处理该对象即可正确响应给微信\n     * 下面是一个原生 swoole 的响应方法\n     */\n    $response-&gt;status($psr7Response-&gt;getStatusCode());\n\n    /**\n     * PSR-7 的 Header 并不是单纯的 k =&gt; v 结构\n     */\n    foreach ($psr7Response-&gt;getHeaders() as $name =&gt; $values) {\n        $response-&gt;header($name, implode(\", \", $values));\n    }\n\n    // 将响应输出到客户端\n    $response-&gt;write($psr7Response-&gt;getBody()-&gt;__toString());\n});\n\n$http-&gt;start();\n自定义消息处理器\n\n消息处理器详细说明见 公众号开发 - 服务端章节\n\n&lt;?php\n\nuse EasySwoole\\WeChat\\OpenPlatform\\Server\\Guard;\nuse EasySwoole\\WeChat\\Kernel\\Messages\\Message;\n\n$server = $openPlatform-&gt;server;\n\n// 处理授权成功事件\n$server-&gt;push(function (\\EasySwoole\\WeChat\\Kernel\\Contracts\\MessageInterface $message) {\n    // ...\n}, Guard::EVENT_AUTHORIZED);\n\n// 处理授权更新事件\n$server-&gt;push(function (\\EasySwoole\\WeChat\\Kernel\\Contracts\\MessageInterface $message) {\n    // ...\n}, Guard::EVENT_UPDATE_AUTHORIZED);\n\n// 处理授权取消事件\n$server-&gt;push(function (\\EasySwoole\\WeChat\\Kernel\\Contracts\\MessageInterface $message) {\n    // ...\n}, Guard::EVENT_UNAUTHORIZED);\n使用示例（在 EasySwoole 框架中使用）\n\n使用示例 1：在 App\\HttpController\\Router.php （即路由）中使用：\n\n示例代码如下：\n&lt;?php\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\AbstractRouter;\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\nuse EasySwoole\\WeChat\\OpenPlatform\\Server\\Guard;\nuse FastRoute\\RouteCollector;\n\nclass Router extends AbstractRouter\n{\n    function initialize(RouteCollector $routeCollector)\n    {\n        // 假设你的开放平台第三方平台设置的授权事件接收 URL 为: https://easyswoole.wechat.com/openPlatform （其他事件推送同样会推送到这个 URL）\n        $routeCollector-&gt;post('/openPlatform', function (Request $request, Response $response) {\n\n            // $openPlatform 为你实例化的开放平台对象，此处省略实例化步骤\n            // $psr7esponse 是一个显式实现了 PSR-7 的对象，用户只需要处理该对象即可正确响应给微信\n            $psr7Response = $openPlatform-&gt;server-&gt;serve($request); // Done!\n\n            $response-&gt;withStatus($psr7Response-&gt;getStatusCode());\n\n            // PSR-7 的 Header 并不是单纯的 k =&gt; v 结构\n            foreach ($psr7Response-&gt;getHeaders() as $name =&gt; $values) {\n                $response-&gt;withHeader($name, implode(\", \", $values));\n            }\n            $response-&gt;write($psr7Response-&gt;getBody()-&gt;__toString());\n\n            return false;\n        });\n\n        // 处理事件\n        $routeCollector-&gt;post('/openPlatform', function (Request $request, Response $response) {\n\n            // $openPlatform 为你实例化的开放平台对象，此处省略实例化步骤\n            $server = $openPlatform-&gt;server;\n\n            // 处理授权成功事件，其他事件同理\n            $server-&gt;push(function (\\EasySwoole\\WeChat\\Kernel\\Contracts\\MessageInterface $message) {\n                // $message 为微信推送的通知内容，不同事件不同内容，详看微信官方文档\n                // 获取授权公众号 AppId： $message['AuthorizerAppid']\n                // 获取 AuthCode：$message['AuthorizationCode']\n                // 然后进行业务处理，如存数据库等...\n            }, Guard::EVENT_AUTHORIZED);\n\n            // $psr7esponse 是一个显式实现了 PSR-7 的对象，用户只需要处理该对象即可正确响应给微信\n            $psr7Response = $server-&gt;serve($request); // Done!\n\n            $response-&gt;withStatus($psr7Response-&gt;getStatusCode());\n\n            // PSR-7 的 Header 并不是单纯的 k =&gt; v 结构\n            foreach ($psr7Response-&gt;getHeaders() as $name =&gt; $values) {\n                $response-&gt;withHeader($name, implode(\", \", $values));\n            }\n            $response-&gt;write($psr7Response-&gt;getBody()-&gt;__toString());\n\n            return false;\n        });\n    }\n}\n\n使用示例 2：在 App\\HttpController\\Index.php （即控制器类）中使用，用户可在自定义其他控制器中实现：\n\n假设你的开放平台第三方平台设置的授权事件接收 URL 为: https://easyswoole.wechat.com/openPlatform （其他事件推送同样会推送到这个 URL）\n示例代码如下：\n首先在 App\\HttpController\\Router.php 中定义路由：\n&lt;?php\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\AbstractRouter;\nuse FastRoute\\RouteCollector;\nuse EasySwoole\\WeChat\\OpenPlatform\\Server\\Guard;\n\nclass Router extends AbstractRouter\n{\n    function initialize(RouteCollector $routeCollector)\n    {\n        // 假设你的开放平台第三方平台设置的授权事件接收 URL 为: https://easyswoole.wechat.com/openPlatform （其他事件推送同样会推送到这个 URL）\n        $routeCollector-&gt;post('/openPlatform', '/Index/openPlatform');\n    }\n}\n然后在 App\\HttpController\\Index.php 控制器中处理事件：\n&lt;?php\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\nuse EasySwoole\\WeChat\\OpenPlatform\\Server\\Guard;\n\nclass Index extends Controller\n{\n    public function openPlatform()\n    {\n        // $openPlatform 为你实例化的开放平台对象，此处省略实例化步骤\n        $server = $openPlatform-&gt;server;\n\n        // 处理授权成功事件，其他事件同理\n        $server-&gt;push(function (\\EasySwoole\\WeChat\\Kernel\\Contracts\\MessageInterface $message) {\n            // $message 为微信推送的通知内容，不同事件不同内容，详看微信官方文档\n            // 获取授权公众号 AppId： $message['AuthorizerAppid']\n            // 获取 AuthCode：$message['AuthorizationCode']\n            // 然后进行业务处理，如存数据库等...\n        }, Guard::EVENT_AUTHORIZED);\n\n        /** @var \\Psr\\Http\\Message\\ServerRequestInterface $psr7Request */\n        $psr7Request = $this-&gt;request();\n\n        // $psr7esponse 是一个显式实现了 PSR-7 的对象，用户只需要处理该对象即可正确响应给微信\n        $psr7Response = $server-&gt;serve($psr7Request);\n\n        $this-&gt;response()-&gt;withStatus($psr7Response-&gt;getStatusCode());\n\n        // PSR-7 的 Header 并不是单纯的 k =&gt; v 结构\n        foreach ($psr7Response-&gt;getHeaders() as $name =&gt; $values) {\n            $this-&gt;response()-&gt;withHeader($name, implode(\", \", $values));\n        }\n        $this-&gt;response()-&gt;write($psr7Response-&gt;getBody()-&gt;__toString());\n    }\n}","link":"/Components/WeChat2.x/openPlatform/server.html"},{"id":290,"title":"代授权","content":"代授权方实现业务\n\n授权方已经把公众号、小程序授权给你的开放平台第三方平台了，接下来的代授权方实现业务只需一行代码即可获得授权方实例。\n\n实例化\n&lt;?php\n$config = [\n    // 开放平台第三方平台 APPID\n    'appId' =&gt; 'wxefe41fdeexxxxxx', \n\n    // 开放平台第三方平台 Token\n    'token' =&gt; 'dczmnau31ea9nzcnxxxxxxxxx',\n\n    // 开放平台第三方平台 AES Key\n    'aesKey' =&gt; 'easyswoole',\n\n    // 开放平台第三方平台 Secret\n    'secret' =&gt; 'your-AppSecret'\n];\n\n// 开放平台\n$openPlatform = \\EasySwoole\\WeChat\\Factory::openPlatform($config);\n\n获取授权方实例\n// 代公众号实现业务\n$officialAccount = $openPlatform-&gt;officialAccount(string $appId, string $refreshToken);\n\n// 代小程序实现业务\n$miniProgram = $openPlatform-&gt;miniProgram(string $appId, string $refreshToken);\n\n\n$appId 为授权方公众号 APPID，非开放平台第三方平台 APPID\n\n\n$refreshToken 为授权方的 refresh_token，可通过 获取授权方授权信息 接口获得。\n\n帮助授权方管理开放平台账号\n&lt;?php\n// 代公众号实现业务\n$account = $officialAccount-&gt;account;\n\n// 代小程序实现业务\n$account = $miniProgram-&gt;account;\n\n// 创建开放平台账号\n// 并绑定公众号或小程序\n$result = $account-&gt;create();\n\n// 将公众号或小程序绑定到指定开放平台帐号下\n$result = $account-&gt;bindTo($openAppId);\n\n// 将公众号/小程序从开放平台帐号下解绑\n$result = $account-&gt;unbindFrom($openAppid);\n\n// 获取公众号/小程序所绑定的开放平台帐号\n$result = $account-&gt;getBinding();\n授权第三方平台注册的开放平台帐号只可用于获取用户 unionid 实现用户身份打通。第三方平台不可操作（包括绑定/解绑）通过 open.weixin.qq.com 线上流程注册的开放平台帐号。公众号只可将此权限集授权给一个第三方平台，授权互斥。\n代码示例（在 EasySwoole 框架中使用）\n\n使用示例 1：在 App\\HttpController\\Router.php （即路由）中使用：\n\n示例代码如下：\n&lt;?php\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\AbstractRouter;\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\nuse FastRoute\\RouteCollector;\n\nclass Router extends AbstractRouter\n{\n    function initialize(RouteCollector $routeCollector)\n    {\n        // 假设你的公众号消息与事件接收 URL 为：https://easyswoole.wechat.com/callback?appId=Xxxx ...\n        $routeCollector-&gt;post('/callback', function (Request $request, Response $response) {\n\n            $appId = $request-&gt;getQueryParam('appId');\n\n            // $openPlatform 为你实例化的开放平台对象，此处省略实例化步骤\n            $officialAccount = $openPlatform-&gt;officialAccount($appId);\n\n            // 这里的 server 为授权方的 server，而不是开放平台的 server，请注意！！！\n            $server = $officialAccount-&gt;server;\n\n            $server-&gt;push(function (\\EasySwoole\\WeChat\\Kernel\\Contracts\\MessageInterface $message) {\n                return new \\EasySwoole\\WeChat\\Kernel\\Messages\\Text('Welcome!');\n            });\n\n            // $psr7esponse 是一个显式实现了 PSR-7 的对象，用户只需要处理该对象即可正确响应给微信\n            $psr7Response = $server-&gt;serve($request); // Done!\n\n            $response-&gt;withStatus($psr7Response-&gt;getStatusCode());\n\n            // PSR-7 的 Header 并不是单纯的 k =&gt; v 结构\n            foreach ($psr7Response-&gt;getHeaders() as $name =&gt; $values) {\n                $response-&gt;withHeader($name, implode(\", \", $values));\n            }\n            $response-&gt;write($psr7Response-&gt;getBody()-&gt;__toString());\n\n            return false;\n        });\n\n        // 调用授权方业务例子\n        $routeCollector-&gt;get('/how-to-use', function (Request $request, Response $response) {\n\n            $officialAccount = $openPlatform-&gt;officialAccount('已授权的公众号 APPID', 'Refresh-token');\n\n            // 获取用户列表：\n            $officialAccount-&gt;user-&gt;list();\n\n            $miniProgram = $openPlatform-&gt;miniProgram('已授权的小程序 APPID', 'Refresh-token');\n\n            // 根据 code 获取 session\n            $miniProgram-&gt;auth-&gt;session('js-code');\n\n            // 其他同理\n\n            return false;\n        });\n    }\n}\n\n使用示例 2：在 App\\HttpController\\Index.php （即控制器类）中使用，用户可在自定义其他控制器中实现：\n\n假设你的开放平台第三方平台设置的授权事件接收 URL 为: https://easyswoole.wechat.com/openPlatform （其他事件推送同样会推送到这个 URL）\n示例代码如下：\n首先在 App\\HttpController\\Router.php 中定义路由：\n&lt;?php\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\AbstractRouter;\nuse FastRoute\\RouteCollector;\nuse EasySwoole\\WeChat\\OpenPlatform\\Server\\Guard;\n\nclass Router extends AbstractRouter\n{\n    function initialize(RouteCollector $routeCollector)\n    {\n        // 假设你的公众号消息与事件接收 URL 为：https://easyswoole.wechat.com/callback?appId=Xxxx ...\n        $routeCollector-&gt;post('/callback', '/Index/callback');\n\n        // 调用授权方业务例子\n        $routeCollector-&gt;get('/how-to-use', '/Index/how_to_use');\n    }\n}\n然后在 App\\HttpController\\Index.php 控制器中处理事件：\n&lt;?php\n\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\nuse EasySwoole\\WeChat\\Kernel\\Messages\\Message;\n\nclass Index extends Controller\n{\n    // 假设你的公众号消息与事件接收 URL 为：https://easyswoole.wechat.com/callback?appId=Xxxx ...\n    public function callback()\n    {\n        $appId = $this-&gt;request()-&gt;getQueryParam('appId');\n\n        // $openPlatform 为你实例化的开放平台对象，此处省略实例化步骤\n        $officialAccount = $openPlatform-&gt;officialAccount($appId);\n\n        // 这里的 server 为授权方的 server，而不是开放平台的 server，请注意！！！\n        $server = $officialAccount-&gt;server;\n\n        $server-&gt;push(function (\\EasySwoole\\WeChat\\Kernel\\Contracts\\MessageInterface $message) {\n            return new \\EasySwoole\\WeChat\\Kernel\\Messages\\Text('Welcome!');\n        });\n\n        /** @var \\Psr\\Http\\Message\\ServerRequestInterface $psr7Request */\n        $psr7Request = $this-&gt;request();\n\n        // $psr7esponse 是一个显式实现了 PSR-7 的对象，用户只需要处理该对象即可正确响应给微信\n        $psr7Response = $server-&gt;serve($psr7Request);\n\n        $this-&gt;response()-&gt;withStatus($psr7Response-&gt;getStatusCode());\n\n        // PSR-7 的 Header 并不是单纯的 k =&gt; v 结构\n        foreach ($psr7Response-&gt;getHeaders() as $name =&gt; $values) {\n            $this-&gt;response()-&gt;withHeader($name, implode(\", \", $values));\n        }\n        $this-&gt;response()-&gt;write($psr7Response-&gt;getBody()-&gt;__toString());\n    }\n\n    // 调用授权方业务例子\n    public function how_to_use()\n    {\n        $officialAccount = $openPlatform-&gt;officialAccount('已授权的公众号 APPID', 'Refresh-token');\n\n        // 获取用户列表：\n        $officialAccount-&gt;user-&gt;list();\n\n        $miniProgram = $openPlatform-&gt;miniProgram('已授权的小程序 APPID', 'Refresh-token');\n\n        // 根据 code 获取 session\n        $miniProgram-&gt;auth-&gt;session('js-code');\n\n        // 其他同理\n    }\n}","link":"/Components/WeChat2.x/openPlatform/authorizerDelegate.html"},{"id":291,"title":"安装","content":"微信SDK EasySwoole WeChat 2.x - 企业微信\nEasySwoole WeChat 是一个基于 Swoole 4.x 全协程支持的微信 SDK 库，告别同步阻塞，轻松编写高性能的微信公众号/小程序/开放平台/企业微信业务接口。用户如果想要使用关于微信支付业务的使用可以查看 EasySwoole Pay 组件。\n该组件库是仿照 easywechat API 实现的协程安全的 wechat sdk 库。\n用户可以在一切支持 Swoole 协程环境的框架（EasySwoole、Hyperf、Swoft 等）中使用，安装和使用方法请看下文。\n说明\n首先感谢 easywechat 作者们创造的优秀项目，但由于在协程环境下使用会有潜在的跨协程问题，故有了此项目。考虑到大多数用户的习惯，我们保留了绝大多数 API 的命名和风格习惯，以便用户更好地上手使用；但在部分可能存在潜在风险的地方， 我们则进行了重新设计，以保障协程环境下的运行安全。\n组件要求\n\nphp &gt;= 7.2\next-swoole: ^4.4.19 (推荐使用 Swoole 4.4.23)\next-openssl: *\next-json: *\next-libxml: *\next-simplexml: *\next-openssl: *\npsr/log: ^1.1\npsr/http-message: ^1.0\npsr/simple-cache: ^1.0\npimple/pimple: ^3.0\neasyswoole/utility: ^1.1\n\n\n注意：在编译安装 Swoole 扩展时，请务必把编译参数 --enable-openssl 加上，以启用 SSL 支持\n\n安装方法\n\n$ composer require easyswoole/wechat\n\n仓库地址\neasyswoole/wechat=2.x\n常见问题汇总\n为了让用户在微信公众平台开发的道路上少掉坑，我们在这里将使用此组件进行开发时遇到的各种问题进行汇总，并给出对应的解决办法。这样用户就可以更效地进行开发了。\n时区不对\n\n报错情形如下：Setting The Correct Timezone In CentOS And Ubuntu Servers With NTP。\n解决方法：使用命令 date 可以在服务器上查看当前时间，如果发现时区不对则需要修改时区。\n\nredirect_url 参数错误\n\n\n出现原因：这是由于程序使用了 网页授权 而公众号没有正确配置 【网页授权域名】 所致。此时你需要登录微信公众平台，在 【开发】 -&gt; 【接口权限】 页面找到 网页授权获取用户基本信息 进行配置并保存。\n\n\n解决方法：\n\n网页授权域名应该为通过 ICP 备案的有效域名，否则保存时无法通过安全监测。\n网页授权域名即程序完成授权获得授权 code 后跳转到的页面的域名，一般情况下为你的业务域名。\n网页授权域名配置成功后会立即生效。\n公众号的网页授权域名只可配置一个，请合理规划你的业务，否则你会发现 …… 授权域名不够用哈。\n\n\n\nJSAPI config: invalid url domain\n\n出现原因：在使用 JS-SDK 进行开发时，每个页面都需要调用 wx.config() 方法配置 JSPAI 参数。如果没有正确配置 JSAPI 安全域名并且开启了调试模式，此时就报此错误。\n解决方法：遇到这个问题时，开发者需要登录微信公众平台，进入 【公众号设置】-&gt;【功能设置】 页面，将项目所使用的域名添加至 【JSAPI 安全域名】 列表中。\n注意事项说明：\n\n一个公众号同时最多可绑定三个安全域名，并且这些域名必须为通过 ICP 备案的一级或一级以上的有效域名。\n\nJSAPI 安全域名每个月限修改三次，修改任何一个都算，所以，请谨慎操作。\n\n\n","link":"/Components/WeChat2.x/work/install.html"},{"id":292,"title":"入门","content":"企业微信\n企业微信的使用与公众号以及其它几个应用的使用方式都是一致的，使用 \\EasySwoole\\WeChat\\Factory::work($config) 来初始化：\n&lt;?php\n$config = [\n    // 企业微信后台的 企业 ID\n    'corpId' =&gt; 'xxxxxxxxxxxxxxxxx',\n\n    // 企业微信后台的 secret\n    'corpSecret' =&gt; 'xxxxxxxxxxxxxxxxx',\n\n    // 企业微信后台的 agentid\n    'agentId' =&gt; 100020, // 如果有 agentid 则填写\n];\n\n// 企业微信\n$work = \\EasySwoole\\WeChat\\Factory::work($config);\n然后你就可以用 $work 来调用企业微信的服务了。","link":"/Components/WeChat2.x/work/getStart.html"},{"id":293,"title":"服务端","content":"服务端\n我们在企业微信应用开启接收消息的功能，将设置页面的 token 与 aeskey 配置到 agents 下对应的应用内：\n&lt;?php\n$config = [\n    // 企业微信后台的 企业 ID\n    'corpId' =&gt; 'xxxxxxxxxxxxxxxxx',\n    // 企业微信后台的 secret\n    'corpSecret' =&gt; 'xxxxxxxxxxxxxxxxx',\n    // 企业微信后台的 agentid\n    'agentId' =&gt; 100022,\n\n    // server config\n    'token' =&gt; 'xxxxxxxxx',\n    'aesKey' =&gt; 'xxxxxxxxxxxxxxxxxx',\n\n    //...\n];\n\n$work = \\EasySwoole\\WeChat\\Factory::work($config);\n接着配置服务端与公众号的服务端用法一样：\n&lt;?php\n/** 注册消息事件回调 */\n$work-&gt;server-&gt;push(function (\\EasySwoole\\WeChat\\Kernel\\Contracts\\MessageInterface $message) {\n    return new \\EasySwoole\\WeChat\\Kernel\\Messages\\Text('Hello EasySwoole WeChat!');\n});\n\n/** @var \\Psr\\Http\\Message\\ServerRequestInterface $psr7Request */\n$psr7Request = $this-&gt;request();\n\n$response = $work-&gt;server-&gt;serve($psr7Request);\n\n/**\n * $response 是一个显式实现了 PSR-7 的对象，用户只需要处理该对象即可正确响应给微信\n * 下面是一个使用 EasySwoole 的响应方法\n */\n$this-&gt;response()-&gt;withStatus($response-&gt;getStatusCode());\n/**\n * PSR-7 的 Header 并不是单纯的 k =&gt; v 结构\n */\nforeach ($response-&gt;getHeaders() as $name =&gt; $values) {\n    $this-&gt;response()-&gt;withHeader($name, implode(\", \", $values));\n}\n$this-&gt;response()-&gt;write($response-&gt;getBody()-&gt;__toString());\n$response 是一个显式实现了 PSR-7 的对象，用户只需要处理该对象即可正确响应给微信\n具体使用可查看 公众号-快速开始章节","link":"/Components/WeChat2.x/work/server.html"},{"id":294,"title":"应用管理","content":"应用管理\n企业微信在 2017 年 11 月对 API 进行了大量的改动，应用管理部分已经没啥用了。\n应用管理是企业微信中比较特别的地方，因为它的使用是不基于应用的，或者说基于任何一个应用都能访问这些 API，所以在用法上是直接调用 work 实例的 agent 属性。\n&lt;?php\n$config = [\n    // ...\n];\n\n$work = \\EasySwoole\\WeChat\\Factory::work($config);\n应用列表\n$agents = $work-&gt;agent-&gt;list();\n应用详情\n$agents = $work-&gt;agent-&gt;get($agentId); \n设置应用\n$agents = $work-&gt;agent-&gt;set($agentId, ['foo' =&gt; 'bar']);\n设置工作台自定义展示\n模版类型数据结构\n可以通过接口配置展示类型。具体可设置:\n\n关键数据型\n图片型\n列表型\nwebview型\n\n\n官方文档：https://open.work.weixin.qq.com/api/doc/90000/90135/92535\n\n设置应用在工作台展示的模版\n&lt;?php\n$params = [\n    'agentid' =&gt; 1000005,\n      'type' =&gt; 'image', //展示类型\n      'image' =&gt; [\n          'url' =&gt; 'xxxx',\n          'jump_url' =&gt; 'http://www.qq.com',\n          'pagepath' =&gt; 'pages/index'\n      ],\n      'replace_user_data' =&gt; true\n  ];\n\n$work-&gt;agentWorkbench-&gt;setWorkbenchTemplate(array $params);\n获取应用在工作台展示的模版\n&lt;?php\n$agentId = 100005;\n\n$work-&gt;agentWorkbench-&gt;getWorkbenchTemplate(int $agentId);\n设置应用在用户工作台展示的数据\n&lt;?php\n$params = [\n    'agentid' =&gt; 1000005,\n    'userid' =&gt; 'test', //员工id\n    'type' =&gt; 'keydata', //展示类型\n    'keydata' =&gt; [\n        'items' =&gt; [\n            [\n                'key' =&gt; '待审批',\n                'data' =&gt; '2',\n                'jump_url' =&gt; 'http://www.qq.com',\n                'pagepath' =&gt; 'pages/index'\n            ],\n            [\n                'key' =&gt; '带批阅作业',\n                'data' =&gt; '4',\n                'jump_url' =&gt; 'http://www.qq.com',\n                'pagepath' =&gt; 'pages/index'\n            ],\n            [\n                'key' =&gt; '成绩录入',\n                'data' =&gt; '45',\n                'jump_url' =&gt; 'http://www.qq.com',\n                'pagepath' =&gt; 'pages/index'\n            ],\n            [\n                'key' =&gt; '综合评价',\n                'data' =&gt; '98',\n                'jump_url' =&gt; 'http://www.qq.com',\n                'pagepath' =&gt; 'pages/index'\n            ]\n        ]\n    ]\n];\n\n$work-&gt;agentWorkbench-&gt;setWorkbenchData(array $params);","link":"/Components/WeChat2.x/work/agents.html"},{"id":295,"title":"消息发送","content":"消息发送\n主动发送消息\n&lt;?php\nuse EasySwoole\\WeChat\\Kernel\\Messages\\TextCard;\n\n// 获取 Messenger 实例\n$messenger = $work-&gt;messenger;\n\n// 准备消息\n$message = new TextCard([\n    'title' =&gt; '你的请假单审批通过',\n    'description' =&gt; '单号：1928373, ....',\n    'url' =&gt; 'http://easywechat.com/oa/....'\n]);\n\n// 发送\n$messenger-&gt;message($message)-&gt;toUser('easyswoole')-&gt;send();\n你也可以很方便地发送普通文本消息：\n&lt;?php\n$messenger-&gt;message('你的请假单（单号：1928373）已经审批通过！')-&gt;toUser('easyswoole')-&gt;send();\n\n// 或者写成\n$messenger-&gt;toUser('easyswoole')-&gt;send('你的请假单（单号：1928373）已经审批通过！');\n接收消息\n被动接收消息，与回复消息，请参考：服务端","link":"/Components/WeChat2.x/work/message.html"},{"id":296,"title":"通讯录","content":"通讯录\n&lt;?php\n$config = [\n    // 企业微信后台的 企业 ID\n    'corpId' =&gt; 'xxxxxxxxxxxxxxxxx',\n\n    // 通讯录的 secret\n    'corpSecret' =&gt; 'xxxxxxxxxxxxxxxxx',\n\n    // ...\n];\n\n// 企业微信\n$work = \\EasySwoole\\WeChat\\Factory::work($config);\n成员管理\n创建成员\n&lt;?php\n$data = [\n    \"userid\" =&gt; \"easyswoole\",\n    \"name\" =&gt; \"EasySwoole\",\n    \"english_name\" =&gt; \"easyswoole\",\n    \"mobile\" =&gt; \"12345678910\",\n];\n$work-&gt;user-&gt;create($data);\n读取成员\n$work-&gt;user-&gt;get('easyswoole');\n更新成员\n&lt;?php\n$work-&gt;user-&gt;update('easyswoole', [\n    \"isleader\" =&gt; 0,\n    'position' =&gt; 'PHP 工程师',\n    // ...\n]);\n删除成员\n&lt;?php\n$work-&gt;user-&gt;delete('easyswoole');\n// 或者删除多个\n$work-&gt;user-&gt;delete(['easyswoole', 'zhangsan', 'wangwu']);\n获取部门成员\n&lt;?php\n$work-&gt;user-&gt;getDepartmentUsers($departmentId);\n// 递归获取子部门下面的成员\n$work-&gt;user-&gt;getDepartmentUsers($departmentId, true);\n获取部门成员详情\n&lt;?php\n$work-&gt;user-&gt;getDetailedDepartmentUsers($departmentId);\n// 递归获取子部门下面的成员\n$work-&gt;user-&gt;getDetailedDepartmentUsers($departmentId, true);\n用户 ID 转为 openid\n&lt;?php\n$work-&gt;user-&gt;userIdToOpenid($userId);\n// 或者指定应用 ID\n$work-&gt;user-&gt;userIdToOpenid($userId, $agentId);\nopenid 转为用户 ID\n$work-&gt;user-&gt;openidToUserId($openid);\n手机号转为用户 ID\n$work-&gt;user-&gt;mobileToUserId($mobile);\n二次验证\n企业在成员验证成功后，调用如下接口即可让成员加入成功\n$work-&gt;user-&gt;accept($userId);\n邀请成员\n企业可通过接口批量邀请成员使用企业微信，邀请后将通过短信或邮件下发通知。\n&lt;?php\n$params = [\n    // 成员ID列表, 最多支持1000个\n    'user' =&gt; ['UserID1', 'UserID2', 'UserID3'],\n\n    // 部门ID列表，最多支持100个\n    'party' =&gt; ['PartyID1', 'PartyID2'],\n\n    // 标签ID列表，最多支持100个\n    'tag' =&gt; ['TagID1', 'TagID2']\n];\n\n$work-&gt;user-&gt;invite($params);\n\nuser、party、tag 三者不能同时为空\n\n获取邀请二维码\n&lt;?php\n// qrcode尺寸类型，1: 171 x 171; 2: 399 x 399; 3: 741 x 741; 4: 2052 x 2052\n$sizeType = 1; \n\n$work-&gt;user-&gt;getInvitationQrCode($sizeType);\n部门管理\n创建部门\n&lt;?php\n$work-&gt;department-&gt;create([\n    'name' =&gt; '广州研发中心',\n    'parentid' =&gt; 1,\n    'order' =&gt; 1,\n    'id' =&gt; 2,\n]);\n更新部门\n&lt;?php\n$work-&gt;department-&gt;update($id, [\n    'name' =&gt; '广州研发中心',\n    'parentid' =&gt; 1,\n    'order' =&gt; 1,\n]);\n删除部门\n&lt;?php\n$work-&gt;department-&gt;delete($id);\n获取部门列表\n&lt;?php\n$work-&gt;department-&gt;list();\n// 获取指定部门及其下的子部门\n$work-&gt;department-&gt;list($id);\n标签管理\n创建标签\n$work-&gt;user-&gt;tag-&gt;create($tagName, $tagId);\n更新标签名字\n$work-&gt;user-&gt;tag-&gt;update($tagId, $tagName);\n删除标签\n$work-&gt;user-&gt;tag-&gt;delete($tagId);\n获取标签列表\n$work-&gt;user-&gt;tag-&gt;list();\n获取标签成员(标签详情)\n$work-&gt;user-&gt;tag-&gt;get($tagId);\n增加标签成员\n&lt;?php\n$work-&gt;user-&gt;tag-&gt;tagUsers($tagId, [$userId1, $userId2, ...]);\n// 指定部门\n$work-&gt;user-&gt;tag-&gt;tagDepartments($tagId, [$departmentId1, $departmentId2, ...]);\n删除标签成员\n&lt;?php\n$work-&gt;user-&gt;tag-&gt;untagUsers($tagId, [$userId1, $userId2, ...]);\n// 指定部门\n$work-&gt;user-&gt;tag-&gt;untagDepartments($tagId, [$departmentId1, $departmentId2, ...]);\n异步批量接口\n注意: 【异步批量接口】需要使用 ”通讯录同步” secret 所获取的 accesstoken 来调用。 传送门: https://work.weixin.qq.com/wework_admin/frame#apps/contactsApi\n增量更新成员\n&lt;?php\n$params = [\n    'media_id' =&gt; 'mediaId',\n    'to_invite' =&gt; true,\n    'callback' =&gt; [\n        'url' =&gt; 'xxx',\n        'token' =&gt; 'xxx',\n        'encodingaeskey' =&gt; 'xxx'\n    ]\n];\n\n$work-&gt;user-&gt;batchJobs-&gt;batchUpdateUsers(array $params);\n全量覆盖成员\n&lt;?php\n$params = [\n    'media_id' =&gt; 'mediaId',\n    'to_invite' =&gt; true,\n    'callback' =&gt; [\n        'url' =&gt; 'xxx',\n        'token' =&gt; 'xxx',\n        'encodingaeskey' =&gt; 'xxx'\n    ]\n];\n\n$work-&gt;user-&gt;batchJobs-&gt;batchReplaceUsers(array $params);\n全量覆盖部门\n&lt;?php\n$params = [\n    'media_id' =&gt; 'mediaId',\n    'callback' =&gt; [\n        'url' =&gt; 'xxx',\n        'token' =&gt; 'xxx',\n        'encodingaeskey' =&gt; 'xxx'\n    ]\n];\n\n$work-&gt;user-&gt;batchJobs-&gt;batchReplaceDepartments(array $params);\n获取异步任务结果\n&lt;?php\n$jobId = '2322232';\n\n$work-&gt;user-&gt;batchJobs-&gt;getJobStatus(array $jobId);\n互联企业\n获取应用的可见范围\n$work-&gt;user-&gt;linkedCorp-&gt;getAgentPermissions();\n获取互联企业成员详细信息\n&lt;?php\n$userId = 'corpId/userId';\n\n$work-&gt;user-&gt;linkedCorp-&gt;getUser(string $userId);\n获取互联企业部门成员\n&lt;?php\n$departmentId = 'linkedId/departmentId';\n$fetchChild = true;\n\n$work-&gt;user-&gt;linkedCorp-&gt;getUsers(string $departmentId, bool $fetchChild = true);\n获取互联企业部门成员详情\n&lt;?php\n$departmentId = 'linkedId/departmentId';\n$fetchChild = true;\n\n$work-&gt;user-&gt;linkedCorp-&gt;getDetailedUsers(string $departmentId, bool $fetchChild = true);\n获取互联企业部门列表\n&lt;?php\n$departmentId = 'linkedId/departmentId';\n\n$work-&gt;user-&gt;linkedCorp-&gt;getDepartments(string $departmentId);","link":"/Components/WeChat2.x/work/contacts.html"},{"id":297,"title":"网页授权","content":"网页授权\n此文档为企业微信内部应用开发的网页授权\n企业微信官方文档\n创建实例：\n&lt;?php\n$config = [\n    // 企业微信后台的 企业 ID\n    'corpId' =&gt; 'xxxxxxxxxxxxxxxxx',\n\n    // 企业微信后台的 secret\n    'corpSecret' =&gt; 'xxxxxxxxxxxxxxxxx',\n\n    // 企业微信后台的 agentid\n    'agentId' =&gt; 100001,\n];\n\n// 企业微信\n$work = \\EasySwoole\\WeChat\\Factory::work($config);\n跳转授权\n&lt;?php\n// $callbackUrl 为授权回调地址\n$callbackUrl = 'https://xxx.xxx'; // 需设置可信域名\n\n// 获取企业微信跳转目标地址\n$redirectUrl = $work-&gt;oauth-&gt;redirect($callbackUrl);\n获取授权用户信息\n在回调页面中，你可以使用以下方式获取授权者信息：\n&lt;?php\n$code = \"回调 URL 中的 code\";\n\n/** @var \\EasySwoole\\WeChat\\Work\\OAuth\\User\\User $user */\n$user = $work-&gt;oauth-&gt;userFromCode($code);\n\n// 获取用户信息\n$user-&gt;getUserId(); // 对应企业微信英文名（userid）\n$user-&gt;getRaw(); // 获取企业微信接口返回的原始信息","link":"/Components/WeChat2.x/work/oauth.html"},{"id":298,"title":"客户联系(原外部联系人)","content":"客户联系（原外部联系人）\n暂略。","link":"/Components/WeChat2.x/work/externalContact.html"},{"id":299,"title":"自定义菜单","content":"自定义菜单\n自定义菜单是指为单个应用设置自定义菜单功能，所以在使用时请注意调用正确的应用实例。\n&lt;?php\n$config = [\n    // 企业微信后台的 企业 ID\n    'corpId' =&gt; 'xxxxxxxxxxxxxxxxx',\n\n    // 企业微信后台的 secret\n    'corpSecret' =&gt; 'xxxxxxxxxxxxxxxxx',\n\n    // ...\n];\n\n// 企业微信\n$work = \\EasySwoole\\WeChat\\Factory::work($config);\n创建菜单\n&lt;?php\n$menus = [\n    'button' =&gt; [\n        [\n            'name' =&gt; '首页',\n            'type' =&gt; 'view',\n            'url' =&gt; 'https://www.easyswoole.com'\n        ],\n        [\n            'name' =&gt; '关于我们',\n            'type' =&gt; 'view',\n            'url' =&gt; 'https://www.easyswoole.com/about'\n        ],\n        // ...\n    ],\n];\n$work-&gt;menu-&gt;create($menus);\n获取菜单\n$work-&gt;menu-&gt;get();\n删除菜单\n$work-&gt;menu-&gt;delete();","link":"/Components/WeChat2.x/work/menu.html"},{"id":300,"title":"素材管理","content":"临时素材\n它的使用是不基于应用的，或者说基于任何一个应用都能访问这些 API，所以在用法上是直接调用 work 实例的 media 属性：\n上传的媒体文件限制：\n所有文件 size 必须大于 5 个字节\n\n图片（image）：2MB，支持 JPG、PNG 格式\n语音（voice）：2MB，播放长度不超过 60s，支持 AMR 格式\n视频（video）：10MB，支持 MP4 格式\n普通文件（file）：20MB\n\n上传图片\n注意：微信图片上传服务有敏感检测系统，图片内容如果含有敏感内容，如色情、商品推广、虚假信息等，上传可能失败。\n// $path 为本地文件路径\n$work-&gt;media-&gt;uploadImage($path);\n上传声音\n$work-&gt;media-&gt;uploadVoice($path);\n上传视频\n$work-&gt;media-&gt;uploadVideo($path);\n上传普通文件\n&lt;?php\n$path = '/path/to/企业微信操作手册.pdf';\n\n$form = [ \n    // 可选 发送时，中文文件名不显示或被过滤，可传此参数\n    'filename' =&gt; '企业微信操作手册.pdf'\n];\n\n$work-&gt;media-&gt;uploadFile(string $path, array $form = []);\n获取素材\n$work-&gt;media-&gt;get($mediaId);","link":"/Components/WeChat2.x/work/media.html"},{"id":301,"title":"oa","content":"OA\n&lt;?php\n$config = [\n    // 企业微信后台的 企业 ID\n    'corpId' =&gt; 'xxxxxxxxxxxxxxxxx',\n\n    // 企业微信后台的 secret\n    'corpSecret' =&gt; 'xxxxxxxxxxxxxxxxx',\n\n    // ...\n];\n\n// 企业微信\n$work = \\EasySwoole\\WeChat\\Factory::work($config);\n获取打卡数据\nAPI：\nmixed checkinRecords(int $startTime, int $endTime, array $userList, int $type = 3)\n\n$type: 打卡类型 1：上下班打卡；2：外出打卡；3：全部打卡\n\n&lt;?php\n// 全部打卡数据\n$work-&gt;oa-&gt;checkinRecords(1492617600, 1492790400, [\"james\",\"paul\"]);\n\n// 获取上下班打卡\n$work-&gt;oa-&gt;checkinRecords(1492617600, 1492790400, [\"james\",\"paul\"], 1);\n\n// 获取外出打卡\n$work-&gt;oa-&gt;checkinRecords(1492617600, 1492790400, [\"james\",\"paul\"], 2);\n获取审批数据\nAPI：\nmixed approvalRecords(int $startTime, int $endTime, int $nextNumber = null)\n\n$nextNumber: 第一个拉取的审批单号，不填从该时间段的第一个审批单拉取\n\n&lt;?php\n$work-&gt;oa-&gt;approvalRecords(1492617600, 1492790400);\n\n// 指定第一个拉取的审批单号，不填从该时间段的第一个审批单拉取\n$work-&gt;oa-&gt;approvalRecords(1492617600, 1492790400, '201704240001');","link":"/Components/WeChat2.x/work/oa.html"},{"id":302,"title":"企业互联","content":"企业互联\n获取应用共享信息\n&lt;?php\n$agentId = 100001;\n\n$work-&gt;corpGroup-&gt;getAppShareInfo(int $agentId);\n获取下级企业的 access_token\n\n&lt;?php\n$corpId = 'wwd216fa8c4c5c0e7x';\n$agentId = 100001;\n\n$work-&gt;corpGroup-&gt;getToken(string $corpId, int $agentId)\n获取下级企业的小程序 session\n\n&lt;?php\n$userId = 'wmAoNVCwAAUrSqEqz7oQpEIEMVWDrPeg';\n$sessionKey = 'n8cnNEoyW1pxSRz6/Lwjwg==';\n\n$work-&gt;corpGroup-&gt;getMiniProgramTransferSession(string $userId, string $sessionKey);","link":"/Components/WeChat2.x/work/corpGroup.html"},{"id":303,"title":"会话内容存档","content":"企业互联\n获取应用共享信息\n&lt;?php\n$agentId = 100001;\n\n$work-&gt;corpGroup-&gt;getAppShareInfo(int $agentId);\n获取下级企业的 access_token\n\n&lt;?php\n$corpId = 'wwd216fa8c4c5c0e7x';\n$agentId = 100001;\n\n$work-&gt;corpGroup-&gt;getToken(string $corpId, int $agentId)\n获取下级企业的小程序 session\n\n&lt;?php\n$userId = 'wmAoNVCwAAUrSqEqz7oQpEIEMVWDrPeg';\n$sessionKey = 'n8cnNEoyW1pxSRz6/Lwjwg==';\n\n$work-&gt;corpGroup-&gt;getMiniProgramTransferSession(string $userId, string $sessionKey);","link":"/Components/WeChat2.x/work/corpGroup.html"},{"id":304,"title":"电子发票","content":"电子发票\n&lt;?php\n$config = [\n    // 企业微信后台的 企业 ID\n    'corpId' =&gt; 'xxxxxxxxxxxxxxxxx',\n\n    // 企业微信后台的 secret\n    'corpSecret' =&gt; 'xxxxxxxxxxxxxxxxx',\n\n    // ...\n];\n\n// 企业微信\n$work = \\EasySwoole\\WeChat\\Factory::work($config);\n查询电子发票\nAPI：\nmixed get(string $cardId, string $encryptCode)\nExample：\n&lt;?php\n$work-&gt;invoice-&gt;get('CARDID', 'ENCRYPTCODE');\n批量查询电子发票\nAPI：\nmixed select(array $invoices)\n\n$invoices: 发票参数列表\n\nExample：\n&lt;?php\n$invoices = [\n    [\"card_id\" =&gt; \"CARDID1\", \"encrypt_code\" =&gt; \"ENCRYPTCODE1\"],\n    [\"card_id\" =&gt; \"CARDID2\", \"encrypt_code\" =&gt; \"ENCRYPTCODE2\"]\n];\n\n$work-&gt;invoice-&gt;select($invoices);\n更新发票状态\nAPI：\nmixed update(string $cardId, string $encryptCode, string $status)\n\n$status: 发报销状态\n\nINVOICE_REIMBURSE_INIT：发票初始状态，未锁定；\nINVOICE_REIMBURSE_LOCK：发票已锁定，无法重复提交报销;\nINVOICE_REIMBURSE_CLOSURE:发票已核销，从用户卡包中移除\n\n\n批量更新发票状态\nAPI：\nmixed batchUpdate(array $invoices, string $openid, string $status)\nExample：\n&lt;?php\n$invoices = [\n    [\"card_id\" =&gt; \"CARDID1\", \"encrypt_code\" =&gt; \"ENCRYPTCODE1\"],\n    [\"card_id\" =&gt; \"CARDID2\", \"encrypt_code\" =&gt; \"ENCRYPTCODE2\"]\n];\n\n$openid = 'oV-gpwSU3xlMXbq0PqqRp1xHu9O4';\n\n$status = 'INVOICE_REIMBURSE_CLOSURE';\n\n$work-&gt;invoice-&gt;batchUpdate($invoices, $openid, $status);","link":"/Components/WeChat2.x/work/invoice.html"},{"id":305,"title":"小程序","content":"小程序\n登录获取用户信息\n\n注意：需要关联小程序，并且使用关联后的小程序 AgentId 与 Secret。\n\n&lt;?php\n$config = [\n    // 企业微信后台的 企业 ID\n    'corpId' =&gt; 'xxxxxxxxxxxxxxxxx',\n\n    // 企业微信后台的 secret\n    'corpSecret' =&gt; 'xxxxxxxxxxxxxxxxx',\n\n    // 企业微信后台的 agentid\n    'agentId' =&gt; 100020, // 如果有 agentid 则填写\n];\n\n$miniProgram = new \\EasySwoole\\WeChat\\Work\\MiniProgram\\Application($config);\n\n$res = $miniProgram-&gt;auth-&gt;session(\"js-code\");","link":"/Components/WeChat2.x/work/miniProgram.html"},{"id":306,"title":"jssdk","content":"JS SDK\n企业微信 JSSDK 官方文档：https://open.work.weixin.qq.com/api/doc/90000/90136/90514\nAPI\n获取 config 接口配置\n$work-&gt;jssdk-&gt;buildConfig(string $url, array $apis, bool $debug = false, bool $beta = false, array $openTagList = []): string;\n返回 JSON 字符串，可以转成数组，然后直接使用到网页中。\n示例\n我们可以生成 js 配置文件：\n&lt;script src=\"https://res.wx.qq.com/open/js/jweixin-1.4.0.js\" type=\"text/javascript\" charset=\"utf-8\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\" charset=\"utf-8\"&gt;\n    wx.config(&lt;?php echo $work-&gt;jssdk-&gt;buildConfig('http://test.com', array('updateAppMessageShareData', 'updateTimelineShareData')) ?&gt;);\n&lt;/script&gt;\n结果如下：\n&lt;script src=\"https://res.wx.qq.com/open/js/jweixin-1.4.0.js\" type=\"text/javascript\" charset=\"utf-8\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\" charset=\"utf-8\"&gt;\nwx.config({\n    debug: true, // 请在上线前删除它\n    appId: 'wx3cf0f39249eb0e60',\n    timestamp: 1430009304,\n    nonceStr: 'qey94m021ik',\n    signature: '4F76593A4245644FAE4E1BC940F6422A0C3EC03E',\n    jsApiList: ['updateAppMessageShareData', 'updateTimelineShareData']\n});\n&lt;/script&gt;\n获取 agentConfig 接口配置\n调用 wx.agentConfig 之前，必须确保先成功调用 wx.config. 注意：从企业微信 3.0.24 及以后版本（可通过企业微信 UA 判断版本号），无须先调用 wx.config，可直接 wx.agentConfig。\n&lt;?php\n$work-&gt;jssdk-&gt;buildAgentConfig(\n    array $jsApiList, // 需要检测的JS接口列表\n    $agentId, // 应用id\n    bool $debug = false,\n    bool $beta = false,\n    bool $json = true,\n    array $openTagList = [],\n    string $url = null // 设置当前URL\n);\n前端示例\n&lt;script src=\"https://res.wx.qq.com/open/js/jweixin-1.4.0.js\" type=\"text/javascript\" charset=\"utf-8\"&gt;&lt;/script&gt;\n&lt;script src=\"https://open.work.weixin.qq.com/wwopen/js/jwxwork-1.0.0.js\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\" charset=\"utf-8\"&gt;\n    wx.config({\n        debug: true, // 请在上线前删除它\n        appId: 'wx3cf0f39249eb0e60',\n        timestamp: 1430009304,\n        nonceStr: 'qey94m021ik',\n        signature: '4F76593A4245644FAE4E1BC940F6422A0C3EC03E',\n        jsApiList: ['updateAppMessageShareData', 'updateTimelineShareData']\n    });\n    wx.ready(function () {\n        wx.agentConfig({ //调用agentConfig\n            corpid: '',\n            agentid: '',\n            timestamp: '',\n            nonceStr: '',\n            signature: '',\n            jsApiList: ['selectExternalContact'],\n            success: function (res) {\n                // 回调\n            },\n            fail: function (res) {\n                if (res.errMsg.indexOf('function not exist') &gt; -1) {\n                    alert('版本过低请升级')\n                }\n            }\n        });\n    });\n    wx.error(function (res) {\n        console.log('失败');\n    });\n&lt;/script&gt;","link":"/Components/WeChat2.x/work/jssdk.html"},{"id":307,"title":"群机器人","content":"群机器人\n使用说明\n使用前必须先在群组里面添加机器人，然后将 Webhook 地址 中的 key 取出来，作为示例中 $groupKey 的值。\n\n\nWebhook 地址 示例：https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=ab4f609a-3feb-427c-ae9d-b319ca712d36\n\n\n微信文档：https://work.weixin.qq.com/api/doc#90000/90136/91770\n\n\n发送文本类型消息\n\n快速发送文本消息\n\n&lt;?php\n// 获取 Messenger 实例\n$messenger = $work-&gt;group_robot_messenger;\n\n// 群组 key\n$groupKey = 'ab4f609a-3feb-427c-ae9d-b319ca712d36';\n\n$messenger-&gt;message('大家好，我是本群的\"喝水提醒小助手\"')-&gt;toGroup($groupKey)-&gt;send();\n// 或者写成\n$messenger-&gt;toGroup($groupKey)-&gt;send('大家好，我是本群的\"喝水提醒小助手\"');\n\n使用 Text 发送文本消息\n\n&lt;?php\n// 准备消息\n$text = new \\EasySwoole\\WeChat\\Work\\GroupRobot\\Messages\\Text('hello');\n\n// 发送\n$messenger-&gt;message($text)-&gt;toGroup($groupKey)-&gt;send();\n\n@某人：\n\n&lt;?php\n// 通过构造函数传参\n$text = new \\EasySwoole\\WeChat\\Work\\GroupRobot\\Messages\\Text('hello', 'her-cat', '18700000000');\n//$text = new Text('hello', ['her-cat', 'easyswoole'], ['18700000000', '18700000001']);\n\n// 通过 userId\n$text-&gt;mention('her-cat');\n//$text-&gt;mention(['her-cat', 'easyswoole']);\n\n// 通过手机号\n$text-&gt;mentionByMobile('18700000000');\n//$text-&gt;mentionByMobile(['18700000000', '18700000001']);\n\n// @所有人\n$text-&gt;mention('@all');\n//$text-&gt;mentionByMobile('@all');\n\n$messenger-&gt;message($text)-&gt;toGroup($groupKey)-&gt;send();\n发送 Markdown 类型消息\n&lt;?php\n$content = '\n# 标题一\n## 标题二\n&lt;font color=\"info\"&gt;绿色&lt;/font&gt;\n&lt;font color=\"comment\"&gt;灰色&lt;/font&gt;\n&lt;font color=\"warning\"&gt;橙红色&lt;/font&gt;\n&gt; 引用文字\n';\n\n$markdown = new \\EasySwoole\\WeChat\\Work\\GroupRobot\\Messages\\Markdown($content);\n\n$messenger-&gt;message($markdown)-&gt;toGroup($groupKey)-&gt;send();\n发送图片类型消息\n&lt;?php\n$img = file_get_contents('http://res.mail.qq.com/node/ww/wwopenmng/images/independent/doc/test_pic_msg1.png');\n\n$image = new \\EasySwoole\\WeChat\\Work\\GroupRobot\\Messages\\Image(base64_encode($img), md5($img));\n\n$result = $messenger-&gt;message($image)-&gt;toGroup($groupKey)-&gt;send();\n发送图文类型消息\n&lt;?php\n$items = [\n    new \\EasySwoole\\WeChat\\Work\\GroupRobot\\Messages\\NewsItem([\n        'title' =&gt; '中秋节礼品领取',\n        'description' =&gt; '今年中秋节公司有豪礼相送',\n        'url' =&gt; 'https://www.easyswoole.com',\n        'image' =&gt; 'http://res.mail.qq.com/node/ww/wwopenmng/images/independent/doc/test_pic_msg1.png',\n    ]),\n\n    //...\n];\n\n$news = new \\EasySwoole\\WeChat\\Work\\GroupRobot\\Messages\\News($items);\n\n$messenger-&gt;message($news)-&gt;toGroup($groupKey)-&gt;send();\n其他方式\n使用 group_robot 发送消息。\n$work-&gt;groupRobot-&gt;message('大家好，我是本群的\"喝水提醒小助手\"')-&gt;toGroup($groupKey)-&gt;send();","link":"/Components/WeChat2.x/work/groupRobot.html"},{"id":308,"title":"移动端","content":"移动端\n通过 code 获取用户信息\n通过 iOS 或 Android 应用授权登录，获取一次性 code，通过后端服务器换取用户的信息。\n&lt;?php\n$code = 'CODE';\n\n$work-&gt;mobile-&gt;getUser(string $code);","link":"/Components/WeChat2.x/work/mobile.html"},{"id":309,"title":"单例","content":"单例\n单例模式确保类在全局只能有一个实例，因为它的实例是由自己保存，在类的外部也无法对该类进行实例化。  \n作用\nPHP的单例模式是为了避免重复创建对象带来的资源消耗。\n用途\n实际项目中像数据库查询，日志输出，全局回调，统一校验等模块。这些模块功能单一，但需要多次访问，如果能够全局唯一，多次复用会大大提升性能。\n例子\n\nnamespace EasySwoole\\Component;\n\nclass MySingleton\n{\n    use Singleton;\n}\n\n$mySingleton = Mysingleton::getInstance();\n\n核心对象方法\n核心类：EasySwoole\\Component\\Singleton。\n获取对象\n\nmixed     $args     参数\n\nstatic function getInstance(...$args)","link":"/Components/Component/singleton.html"},{"id":310,"title":"协程单例","content":"协程单例\n为兼容协程环境下的单例模式安全 可以使用CoroutineSingleTon这个trait\n引用方法可以参考普通Singleton trait\nnamespace EasySwoole\\Component;\nuse Swoole\\Coroutine;\ntrait CoroutineSingleTon\n{\n    private static $instance = [];\n    static function getInstance(...$args)\n    {\n        $cid = Coroutine::getCid();\n        if(!isset(self::$instance[$cid])){\n            self::$instance[$cid] = new static(...$args);\n            /*\n             * 兼容非携程环境\n             */\n            if($cid &gt; 0){\n                Coroutine::defer(function ()use($cid){\n                    unset(self::$instance[$cid]);\n                });\n            }\n        }\n        return self::$instance[$cid];\n    }\n    function destroy(int $cid = null)\n    {\n        if($cid === null){\n            $cid = Coroutine::getCid();\n        }\n        unset(self::$instance[$cid]);\n    }\n} ","link":"/Components/Component/coroutineSingleton.html"},{"id":311,"title":"就绪等待","content":"ReadyScheduler\nEasyswoole 基础组件1.8.7版本起，提供了一个基于Swoole Table实现的就绪计划程序，用于解决主服务启动时，部分子服务未就绪问题。\n基础测试使用\nnamespace EasySwoole\\Component\\Tests;\n\nuse EasySwoole\\Component\\ReadyScheduler;\nuse PHPUnit\\Framework\\TestCase;\nuse Swoole\\Coroutine;\n\nclass ReadySchedulerTest extends TestCase\n{\n    function testNormal()\n    {\n        ReadyScheduler::getInstance()-&gt;addItem('worker');\n        ReadyScheduler::getInstance()-&gt;addItem('rpc');\n        ReadyScheduler::getInstance()-&gt;addItem('fastCache');\n\n        go(function (){\n            Coroutine::sleep(1);\n            ReadyScheduler::getInstance()-&gt;ready('worker');\n            ReadyScheduler::getInstance()-&gt;ready('rpc');\n        });\n        $this-&gt;assertEquals(false,ReadyScheduler::getInstance()-&gt;waitReady(['rpc','worker'],0.1));\n        $this-&gt;assertEquals(true,ReadyScheduler::getInstance()-&gt;waitReady('rpc'));\n        $this-&gt;assertEquals(true,ReadyScheduler::getInstance()-&gt;waitReady(['rpc','worker']));\n        $this-&gt;assertEquals(false,ReadyScheduler::getInstance()-&gt;waitReady(['rpc','worker','fastCache'],1.1));\n    }\n}\nEasySwoole服务中使用\n以Http服务作为基础例子\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\Component\\ReadyScheduler;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\nuse Swoole\\Coroutine;\n\nclass EasySwooleEvent implements Event\n{\n\n    public static function initialize()\n    {\n        // TODO: Implement initialize() method.\n        date_default_timezone_set('Asia/Shanghai');\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        /*\n         * 主进程初始化table\n         */\n        ReadyScheduler::getInstance();\n        /*\n         * 假设，服务启动的时候，依赖 serviceOne，serviceTwo 两个服务，例如链接第三方api等。\n         * 在服务未就绪的时候，我们不希望本机器开始对外服务\n         */\n        $register-&gt;add($register::onWorkerStart,function ($serv, $workerId){\n            if($workerId == 0){\n                /*\n                 * 若不是强制准备，请注意addItem,unready，ready实现方法\n                 */\n                Coroutine::sleep(3);\n                ReadyScheduler::getInstance()-&gt;ready('serviceOne',true);\n                var_dump('r1');\n            }else if($workerId == 1){\n                Coroutine::sleep(4);\n                ReadyScheduler::getInstance()-&gt;ready('serviceTwo',true);\n                var_dump('r2');\n            }\n        });\n    }\n\n    public static function onRequest(Request $request, Response $response): bool\n    {\n        /*\n         * 链接进来的时候，判断依赖的服务是否就绪,等待时间为1s (tcp，ws服务也同理)\n         * 在服务未就绪的时候，我们先拒绝服务\n        */\n        if(!ReadyScheduler::getInstance()-&gt;waitReady(['serviceOne','serviceTwo'],1.0)){\n            $response-&gt;write('not ready,try again');\n            return false;\n        }\n        return true;\n    }\n\n    public static function afterRequest(Request $request, Response $response): void\n    {\n\n    }\n}","link":"/Components/Component/readyScheduler.html"},{"id":312,"title":"协程执行器","content":"CoroutineRunner\n协程执行器 CoroutineRunner类似于Csp组件，但更加灵活，可以投递协程任务并限制最大同时执行数、最长执行时间、成功或失败回调\n简单示例\nuse co;\nuse EasySwoole\\Component\\CoroutineRunner\\Runner;\nuse EasySwoole\\Component\\CoroutineRunner\\Task;\n\n$runner = new Runner(10);\n$runner-&gt;setOnException(function(\\Throwable  $e, $task){\n    echo $e-&gt;getMessage();\n    echo PHP_EOL;\n});\n\n$max = 30;\n$allTask = [];\nwhile($max&gt;0){\n    $task = new Task(function() use ($max) {\n        echo $max .PHP_EOL;\n        co::sleep(1);\n        // 将设这是一个curl爬取任务 return 爬取结果 可以在外部获取\n        return 'ok';\n    });\n    $runner-&gt;addTask($task);\n    $allTask[] = $task;\n    $max--;\n}\n\n$runner-&gt;start(1);// 最长执行1秒  总共投递了30个 最大并发10个 需要3秒执行完，所以会有一部分将被丢弃  看下方参数说明列表\n\nforeach($allTask as $key =&gt; $task){\n    var_dump($task-&gt;getResult());\n}\n\n参数说明\nRunner构造函数\n可接收两个参数 __construct($concurrency = 64,$taskChannelSize = 1024)\n\nconcurrency 最大同时执行的协程数量\ntaskChannelSize 可投递的task队列长度\n\nRunner-&gt;setOnException\n设置异常回调 有两个参数 (\\Throwable $e, Task $task) \nRunner-&gt;start\n开启已经投递的task协程的执行，有一个参数\n\nfloat $waitTime = 30 最长执行时间，如果超过这个时间，剩余的task协程将被丢弃，不再执行。\n\nTask构造函数\n需要一个callable参数，用于调用执行，可以在闭包内return数据，外部使用 $task-&gt;getResult()获取\n\nreturn 不等于 false的数据将会触发onSuccess\nreturn false 将会触发 onFail\n\nTask-&gt;setOnSuccess\n需要一个callable参数\n【非必选】 task执行完成回调\nTask-&gt;setOnFail\n需要一个callable参数\n【非必选】 task执行失败回调\nTask-&gt;getResult\n获取call函数执行后return的数据","link":"/Components/Component/coroutineRunner.html"},{"id":313,"title":"swoole table","content":"TableManager\nEasySwoole\\Component\\TableManager\nEasySwoole对Swoole table进行了基础的封装,用于共享内存\n方法列表\ngetInstance()\n该方法用于获取TableManager管理器实例\nadd($name,array $columns,$size = 1024)\n该方法用于创建一个table\nget($name):?Table\n该方法用于获取已经创建好的table\n示例代码\nTableManager::getInstance()-&gt;add(\n    self::TABLE_NAME,\n    [\n        'currentNum'=&gt;['type'=&gt;Table::TYPE_INT,'size'=&gt;2],\n    ],\n    1024\n);\n注意事项：请勿在onRequest、OnReceive等回调位置创建swoole table,swoole table应该在服务启动前创建，比如在mainServerCreate事件中创建。","link":"/Components/Component/tableManager.html"},{"id":314,"title":"atomic 计数器","content":"Atomic\nswoole_atomic是swoole扩展提供的原子计数操作类，可以方便整数的无锁原子增减。\n\n\nswoole_atomic使用共享内存，可以在不同的进程之间操作计数\n\nswoole_atomic基于gcc提供的CPU原子指令，无需加锁\n\nswoole_atomic在服务器程序中必须在swoole_server-&gt;start前创建才能在Worker进程中使用\n\nswoole_atomic默认使用32位无符号类型，如需要64有符号整型，可使用Swoole\\Atomic\\Long\n\n\n注意：请勿在onReceive等回调函数中创建原子数，否则底层的GlobalMemory内存会持续增长，造成内存泄漏。\n使用\n初始化计数：\n\nint init_value 初始值\n\npublic function __construct($init_value)\n增加计数：\n\nint add_value 增加的值\n\npublic function add($add_value)\n减少计数：\n\nint sub_value 减少的值\n\npublic function sub($sub_value)\n获取当前计数的值：\npublic function get()\n将当前值设置为指定的数字：\n\nint value 计数值\n\npublic function set($value)\n如果当前数值等于参数1，则将当前数值设置为参数2：\n\nint cmp_value  被做比较的值\nint set_value  当前数值等于被做比较的值后被设置为指定的计数值\n\npublic function cmpset($cmp_value, $set_value)\n例子\n在EasySwooleEvent初始化函数注册atomic对象。\n// 注册一个atomic对象\nAtomicManager::getInstance()-&gt;add('second');\n从AtomicManager获取atomic对象并使用。\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: Tioncico\n * Date: 2019/3/18 0018\n * Time: 15:39\n */\n\nnamespace App\\HttpController;\n\nuse EasySwoole\\Component\\AtomicManager;\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\n\nclass Index extends Controller\n{\n    function index()\n    {\n\n        AtomicManager::getInstance()-&gt;add('second',0);\n        $atomic = AtomicManager::getInstance()-&gt;get('second');\n        $atomic-&gt;add(1);\n        $this-&gt;response()-&gt;write($atomic-&gt;get());\n        // TODO: Implement index() method.\n    }\n}","link":"/Components/Component/atomic.html"},{"id":315,"title":"channel lock协程锁","content":"channel Lock\n命名空间:\\EasySwoole\\Component\\ChannelLock.\nChannelLock 通过协程channel特性实现了关于协程级的锁机制.  \ngo(function (){\n    //加锁\n    $result = \\EasySwoole\\Component\\ChannelLock::getInstance()-&gt;lock('a');\n    var_dump($result);\n    co::sleep(1);\n    //解锁\n    $result = \\EasySwoole\\Component\\ChannelLock::getInstance()-&gt;unlock('a');\n    var_dump($result);\n});\nlock\n尝试锁住$lockName.\n方法原型:  function lock(string $lockName,float $timeout = -1):bool\n参数介绍:  \n\n$lockName 锁名\n$timeout 超时时间,-1为永久不超时\n当调用此函数后,会尝试锁住$lockName,成功将返回true,如果之前已经有其他协程锁住了此$lockName,将会阻塞,直到超时返回false(-1用不超时,代表永远阻塞)  \n\nunlock\n解锁\n方法原型:  function unlock(string $lockName,float $timeout = -1):bool\n参数介绍:  \n\n$lockName 锁名\n$timeout 超时时间,-1为永久不超时\n解锁$lockName. 成功后将返回true.  \n\ndeferLock\n尝试锁住$lockName,并在协程结束后自动解锁.\n方法原型:  deferLock(string $lockName,float $timeout = -1):bool\n参数介绍:  \n\n$lockName 锁名\n$timeout 超时时间,-1为永久不超时\n","link":"/Components/Component/channelLock.html"},{"id":316,"title":"atomic-limit","content":"AtomicLimit\nEasySwoole 提供了一个基于 Atomic 计数器的限流器。\n原理\n通过限制某一个时间周期内的总请求数，从而实现基础限流。举个例子，设置5秒内，允许的最大请求量为200，那么理论平均并发为40，峰值并发为200。\n组件要求\n\nphp: &gt;= 7.1.0\neasyswoole/component: ^2.0\n\n安装方法\n\ncomposer require easyswoole/atomic-limit\n\n仓库地址\neasy-swoole/atomic-limit\n在 EasySwoole 中使用\n首先在 EasySwoole 全局的 mainServerCreate 事件（即项目根目录的 EasySwooleEvent.php 的 mainServerCreate 函数） 中，进行限流器注册\n&lt;?php\n/**\n * This file is part of EasySwoole.\n *\n * @link https://www.easyswoole.com\n * @document https://www.easyswoole.com\n * @contact https://www.easyswoole.com/Preface/contact.html\n * @license https://github.com/easy-swoole/easyswoole/blob/3.x/LICENSE\n */\n\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\AtomicLimit\\AtomicLimit;\nuse EasySwoole\\Component\\Di;\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\n\nclass EasySwooleEvent implements Event\n{\n    public static function initialize()\n    {\n        date_default_timezone_set('Asia/Shanghai');\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        ###### 配置限流器 ######\n        $limit = new AtomicLimit();\n        /** 为方便测试，（全局的）限制设置为 10 */\n        $limit-&gt;setLimitQps(10);\n        $limit-&gt;attachServer(ServerManager::getInstance()-&gt;getSwooleServer());\n        Di::getInstance()-&gt;set('auto_limiter', $limit);\n    }\n}\n在 App\\HttpController\\Index.php 中调用限流器：\n&lt;?php\n/**\n * This file is part of EasySwoole.\n *\n * @link https://www.easyswoole.com\n * @document https://www.easyswoole.com\n * @contact https://www.easyswoole.com/Preface/contact.html\n * @license https://github.com/easy-swoole/easyswoole/blob/3.x/LICENSE\n */\n\nnamespace App\\HttpController;\n\nuse EasySwoole\\AtomicLimit\\AtomicLimit;\nuse EasySwoole\\Component\\Di;\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\n\nclass Index extends Controller\n{\n    /** @var AtomicLimit $autoLimiter */\n    private $autoLimiter;\n\n    protected function onRequest(?string $action): ?bool\n    {\n        $this-&gt;autoLimiter = Di::getInstance()-&gt;get('auto_limiter');\n\n        if ($action == 'test1') {\n            # 调用限流器对 http://127.0.0.1:9501/test1 请求限制流量\n            if ($this-&gt;autoLimiter-&gt;access($action, 1)) {\n                return true;\n            } else {\n                $this-&gt;writeJson(200, null, 'test1 refuse!');\n                return false;\n            }\n        } else if ($action == 'test2') {\n            # 调用限流器对 http://127.0.0.1:9501/test2 请求限制流量\n            if ($this-&gt;autoLimiter-&gt;access($action, 2)) {\n                return true;\n            } else {\n                $this-&gt;writeJson(200, null, 'test2 refuse!');\n                return false;\n            }\n        }\n\n        return parent::onRequest($action);\n    }\n\n    public function test1()\n    {\n        $this-&gt;writeJson(200, null, 'test1 success!');\n    }\n\n    public function test2()\n    {\n        $this-&gt;writeJson(200, null, 'test2 success!');\n    }\n}\n以上代码表示，index/test1 这个限流器在每秒内允许的最大流量为 1，而 index/test2 这个限流器的最大流量为 2。\n我们也可以在 EasySwoole 的 Base 控制器的 onRequest 方法中，进行请求拦截。例如在全局 onRequest 事件中，先进行流量检验，如果校验通过，则进行下一步操作。\n在 Swoole 中使用\n以经典的暴力 CC 攻击防护为例子。我们可以限制一个 ip-url 的 qps 访问。\n&lt;?php\n/**\n * This file is part of EasySwoole.\n *\n * @link https://www.easyswoole.com\n * @document https://www.easyswoole.com\n * @contact https://www.easyswoole.com/Preface/contact.html\n * @license https://github.com/easy-swoole/easyswoole/blob/3.x/LICENSE\n */\n\n// example url: http://127.0.0.1:9501/index.html?api=1\n\nrequire_once __DIR__ . '/vendor/autoload.php';\n\nuse EasySwoole\\AtomicLimit\\AtomicLimit;\n\n$http = new swoole_http_server(\"127.0.0.1\", 9501);\n\n###### 配置限流器 ######\n$limit = new AtomicLimit();\n/** 为方便测试，（全局的）限制设置为3 */\n$limit-&gt;setLimitQps(3);\n$limit-&gt;attachServer($http);\n\n$http-&gt;on(\"request\", function ($request, $response) use ($http, $limit) {\n    $ip = $http-&gt;getClientInfo($request-&gt;fd)['remote_ip'];\n    $requestUri = $request-&gt;server['request_uri'];\n    $token = $ip . $requestUri;\n    /** access 函数允许单独对某个 token 指定qps */\n    if ($limit-&gt;access($token)) {\n        $response-&gt;write('request accept');\n    } else {\n        $response-&gt;write('request refuse');\n    }\n    $response-&gt;end();\n});\n\n$http-&gt;start();\n注意，本例子是用一个自定义进程内加定时器来实现计数定时重置，实际上用一个进程来做这件事情有点不值得，因此实际生产可以指定一个 worker，设置定时器来实现。","link":"/Components/atomicLimit.html"},{"id":317,"title":"ip 限流案例","content":"\nSwoole 如何对 IP 限制访问频率\n在我们开发 API 的过程中，有的时候我们还需要考虑单个用户(IP)访问频率控制，避免被恶意调用。\n归根到底也就只有两个步骤：\n\n用户访问要统计次数\n执行操作逻辑之前要判断次数频率是否过高，过高则不执行\n\n\nEasySwoole 中实现 IP 访问频率限制\n本文举例的是在 EasySwoole 框架中实现的代码，在Swoole 原生中实现方式是一样的。\n只要在对应的回调事件做判断拦截处理即可。\n\n使用 Swoole\\Table，存储用户访问情况（也可以使用其他组件、方式存储）\n使用定时器，将前一周期的访问情况清空，统计下一周期\n\n实现 IP 访问统计类\n\n如以下 IpList 类，实现了 初始化 Table、统计 IP访问次数、获取一个周期内次数超过一定值的记录\n&lt;?php\n/**\n * Ip访问次数统计\n * User: Siam\n * Date: 2019/7/8 0008\n * Time: 下午 9:53\n */\n\nnamespace App;\n\nuse EasySwoole\\Component\\Singleton;\nuse EasySwoole\\Component\\TableManager;\nuse Swoole\\Table;\n\nclass IpList\n{\n    use Singleton;\n\n    /** @var Table */\n    protected $table;\n\n    public function __construct()\n    {\n        TableManager::getInstance()-&gt;add('ipList', [\n            'ip' =&gt; [\n                'type' =&gt; Table::TYPE_STRING,\n                'size' =&gt; 16\n            ],\n            'count' =&gt; [\n                'type' =&gt; Table::TYPE_INT,\n                'size' =&gt; 8\n            ],\n            'lastAccessTime' =&gt; [\n                'type' =&gt; Table::TYPE_INT,\n                'size' =&gt; 8\n            ]\n        ], 1024 * 128);\n        $this-&gt;table = TableManager::getInstance()-&gt;get('ipList');\n    }\n\n    public function access(string $ip): int\n    {\n        $key = substr(md5($ip), 8, 16);\n        $info = $this-&gt;table-&gt;get($key);\n\n        if ($info) {\n            $this-&gt;table-&gt;set($key, [\n                'lastAccessTime' =&gt; time(),\n                'count' =&gt; $info['count'] + 1,\n            ]);\n            return $info['count'] + 1;\n        } else {\n            $this-&gt;table-&gt;set($key, [\n                'ip' =&gt; $ip,\n                'lastAccessTime' =&gt; time(),\n                'count' =&gt; 1,\n            ]);\n            return 1;\n        }\n    }\n\n    public function clear()\n    {\n        foreach ($this-&gt;table as $key =&gt; $item) {\n            $this-&gt;table-&gt;del($key);\n        }\n    }\n\n    public function accessList($count = 10): array\n    {\n        $ret = [];\n        foreach ($this-&gt;table as $key =&gt; $item) {\n            if ($item['count'] &gt;= $count) {\n                $ret[] = $item;\n            }\n        }\n        return $ret;\n    }\n}\n初始化 IP 统计类 和访问统计定时器\n封装完 IP统计 的操作之后，我们就可以在 EasySwooleEvent.php 中的 mainServerCreate 回调事件中初始化 IpList 类和定时器，注册 IP 统计自定义进程\n&lt;?php\nuse App\\IpList;\nuse EasySwoole\\Component\\Process\\AbstractProcess;\nuse EasySwoole\\Component\\Process\\Manager;\n\npublic static function mainServerCreate(EventRegister $register)\n{\n    // 开启 IP 限流\n    IpList::getInstance();\n    $class = new class('IpAccessCount') extends AbstractProcess\n    {\n        protected function run($arg)\n        {\n            $this-&gt;addTick(10 * 1000, function () {\n                /**\n                 * 正常用户不会有一秒超过 6 次的api请求\n                 * 做列表记录并清空\n                 */\n                $list = IpList::getInstance()-&gt;accessList(30);\n                // var_dump($list);\n                IpList::getInstance()-&gt;clear();\n            });\n        }\n    };\n\n    // 注册 IP 限流自定义进程\n    $processConfig = new \\EasySwoole\\Component\\Process\\Config();\n    $processConfig-&gt;setProcessName('IP_LIST');// 设置进程名称\n    $processConfig-&gt;setProcessGroup('IP_LIST');// 设置进程组名称\n    $processConfig-&gt;setArg([]);// 传参\n    $processConfig-&gt;setRedirectStdinStdout(false);// 是否重定向标准io\n    $processConfig-&gt;setPipeType(\\EasySwoole\\Component\\Process\\Config::PIPE_TYPE_SOCK_DGRAM);// 设置管道类型\n    $processConfig-&gt;setEnableCoroutine(true);// 是否自动开启协程\n    $processConfig-&gt;setMaxExitWaitTime(3);// 最大退出等待时间\n    Manager::getInstance()-&gt;addProcess(new $class($processConfig));\n}\n实现对 IP 访问的限制\n在 EasySwooleEvent.php 中的 mainServerCreate 回调事件中\n接着我们在 EasySwooleEvent.php 中的 initialize 回调事件中注入 HTTP_GLOBAL_ON_REQUEST 全局事件，判断和统计 IP 的访问\n&lt;?php\n\nuse EasySwoole\\Component\\Di;\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\nuse App\\IpList;\n\npublic static function initialize()\n{\n    // TODO: Implement initialize() method.\n    date_default_timezone_set('Asia/Shanghai');\n\n    public static function initialize()\n    {\n        date_default_timezone_set('Asia/Shanghai');\n\n        Di::getInstance()-&gt;set('HTTP_GLOBAL_ON_REQUEST', function (Request $request, Response $response) {\n            $fd = $request-&gt;getSwooleRequest()-&gt;fd;\n            $ip = ServerManager::getInstance()-&gt;getSwooleServer()-&gt;getClientInfo($fd)['remote_ip'];\n\n            // 如果当前周期的访问频率已经超过设置的值，则拦截\n            // 测试的时候可以将 30 改小，比如 3\n            if (IpList::getInstance()-&gt;access($ip) &gt; 3) {\n                /**\n                 * 直接强制关闭连接\n                 */\n                ServerManager::getInstance()-&gt;getSwooleServer()-&gt;close($fd);\n                // 调试输出 可以做逻辑处理\n                echo '被拦截' . PHP_EOL;\n                return false;\n            }\n            // 调试输出 可以做逻辑处理\n            echo '正常访问' . PHP_EOL;\n            return true;\n        });\n    }\n}\n以上就实现了对同一 IP 访问频率的限制操作。具体还可以根据自身需求进行扩展，如对具体的某个接口再进行限流。\nEasySwoole 提供了一个基于 Atomic 计数器的限流器组件。可以直接使用，使用教程请移步查看限流器文档。","link":"/Components/ipLimit.html"},{"id":318,"title":"consul","content":"Consul 协程客户端\nEasySwoole 提供了一个协程安全的 Consul 协程版本客户端，方便用户做分布式的微服务开发。\n组件要求\n\neasyswoole/spl: ^1.1\neasyswoole/http-client: ^1.2.5\n\n安装方法\n\ncomposer require easyswoole/consul\n\n仓库地址\neasy-swoole/consul\n使用方式\n\n使用下面的接口方式，都需要先给 Consul 注入 Config 配置。\n接口只展示用法，具体的命名空间需要开发者自己引入\n\nuse EasySwoole\\Consul\\Config;\nuse EasySwoole\\Consul\\Consul;\n\n// config默认  127.0.0.1:8500/v1\n$config = new Config([\n    'IP'       =&gt; '127.0.0.1',\n    'port'     =&gt; '8500',\n    'version'  =&gt; 'v1',\n]);\n$consul = new Consul($config);\n\n// 两种写法，结果相同\n$config = new Config();\n$config-&gt;setIP('127.0.0.1');\n$config-&gt;setPort('8500');\n$config-&gt;setVersion('v1');    \n\n$consul = new Consul($config);\nACLs\n// Bootstrap ACLs\n$bootstrap = new Bootstrap();\n$this-&gt;consul-&gt;acl()-&gt;bootstrap($bootstrap);\n\n// Check ACL Replication\n$replication = new Replication();\n$this-&gt;consul-&gt;acl()-&gt;replication($replication);\n\n// Translate Rules\n// Translate a Legacy Token's Rules\n$translate = new Translate([\n    'accessor_id' =&gt; $accessor_id\n]);\n$this-&gt;consul-&gt;acl()-&gt;translate($translate);\n\n// Login to Auth Method\n$login = new Login([\n    \"authMethod\" =&gt; $authMethod,\n    \"bearerToken\" =&gt; $bearerToken\n]);\n$this-&gt;consul-&gt;acl()-&gt;login($login);\n\n// Logout from Auth Method\n$logout = new Logout([\n    'token' =&gt; $header['token']\n]);\n$this-&gt;consul-&gt;acl()-&gt;logout($logout);\nTokens\n// Create a Token\n$token = new Token([\n    \"description\" =&gt; \"Agent token for 'node1'\",\n    \"Policies\" =&gt; [\n        [\"ID\" =&gt; \"165d4317-e379-f732-ce70-86278c4558f7\"],\n        [\"Name\" =&gt; \"node-read\"],\n    ],\n    \"Local\" =&gt; false,\n]);\n$this-&gt;consul-&gt;acl()-&gt;token($token);\n\n// Read a Token\n$token = new Token([\n    \"AccessorID\" =&gt; \"6a1253d2-1785-24fd-91c2-f8e78c745511\"\n]);\n$this-&gt;consul-&gt;acl()-&gt;readToken($token);\n\n// Read Self Token\n$self = new Token\\GetSelf([\n    'token' =&gt; \"6a1253d2-1785-24fd-91c2-f8e78c745511\"\n]);\n$this-&gt;consul-&gt;acl()-&gt;self($self);\n\n// Update a Token\n$update = new Token([\n    'accessorID' =&gt; '6a1253d2-1785-24fd-91c2-f8e78c745511',\n    \"Description\" =&gt; \"Agent token for 'node1'\",\n    \"Policies\" =&gt; [],\n    \"local\" =&gt; false\n]);\n$this-&gt;consul-&gt;acl()-&gt;updateToken($update);\n\n// Clone a Token\n$clone = new Token\\CloneToken([\n    'accessorID' =&gt; '8f246b77-f3e1-ff88-5b48-8ec93abf3e05',\n    \"description\" =&gt; \"Clone of Agent token for 'node1'\",\n]);\n$this-&gt;consul-&gt;acl()-&gt;cloneToken($clone);\n\n// Delete a Token\n$delete = new Token([\n    'AccessorID' =&gt; '8f246b77-f3e1-ff88-5b48-8ec93abf3e05'\n]);\n$this-&gt;consul-&gt;acl()-&gt;delete($delete);\n\n// List Tokens\n$token = new Tokens();\n$this-&gt;consul-&gt;acl()-&gt;tokens($token);\nLegacy Tokens\n// Create ACL Token\n$create = new Create([\n    \"Name\" =&gt; \"my-app-token\",\n    \"Type\" =&gt; \"client\",\n    \"rules\" =&gt; \"a\"\n]);\n$this-&gt;consul-&gt;acl()-&gt;create($create);\n\n// Update ACL Token\n$update = new Update([\n    \"id\" =&gt; \"adf4238a-882b-9ddc-4a9d-5b6758e4159e\",\n    \"Name\" =&gt; \"my-app-token-updated\",\n    \"Type\" =&gt; \"client\",\n    \"Rules\" =&gt; \"# New Rules\",\n]);\n$this-&gt;consul-&gt;acl()-&gt;update($update);\n\n// Delete ACL Token\n$delete = new Destroy([\n    'uuid' =&gt; '8f246b77-f3e1-ff88-5b48-8ec93abf3e05'\n]);\n$this-&gt;consul-&gt;acl()-&gt;destroy($delete);\n\n// Read ACL Token\n$info = new Info([\n    'uuid' =&gt; '8f246b77-f3e1-ff88-5b48-8ec93abf3e05'\n]);\n$this-&gt;consul-&gt;acl()-&gt;info($info);\n\n// Clone ACL Token\n$cloneAclToken = new CloneACLToken([\n    'uuid' =&gt; '8f246b77-f3e1-ff88-5b48-8ec93abf3e05'\n]);\n$this-&gt;consul-&gt;acl()-&gt;cloneAclToken($cloneAclToken);\n\n// List ACLs\n$getList = new Lists();\n$this-&gt;consul-&gt;acl()-&gt;getList($getList);\n$this-&gt;assertEquals('x','x');\nPolicies\n// Create a Policy\n$policy = new Policy([\n    \"Name\" =&gt; \"node-read\",\n    \"Description\" =&gt; \"Grants read access to all node information\",\n    \"Rules\" =&gt; \"node_prefix \\\"\\\" { policy = \\\"read\\\"}\",\n    \"datacenters\" =&gt; [\"dc1\"]\n]);\n$this-&gt;consul-&gt;acl()-&gt;policy($policy);\n\n// Read a Policy\n$policy = new Policy([\n    'id' =&gt; 'c01a1f82-44be-41b0-a686-685fb6e0f485',\n]);\n$this-&gt;consul-&gt;acl()-&gt;readPolicy($policy);\n\n// Update a Policy\n$policy = new Policy([\n    \"ID\" =&gt; \"c01a1f82-44be-41b0-a686-685fb6e0f485\",\n    \"Name\" =&gt; \"register-app-service\",\n    \"Description\" =&gt; \"Grants write permissions necessary to register the 'app' service\",\n    \"Rules\" =&gt; \"service \\\"app\\\" { policy = \\\"write\\\"}\",\n]);\n$this-&gt;consul-&gt;acl()-&gt;updatePolicy($policy);\n\n// Delete a Policy\n$policy = new Policy([\n    'id' =&gt; 'c01a1f82-44be-41b0-a686-685fb6e0f485'\n]);\n$this-&gt;consul-&gt;acl()-&gt;deletePolicy($policy);\n\n// List Policies\n$policies = new Policies();\n$this-&gt;consul-&gt;acl()-&gt;policies($policies);\nRoles\n// Create a Role\n$role = new Role([\n    \"name\" =&gt; \"example-role\",\n    \"description\" =&gt; \"Showcases all input parameters\",\n]);\n$this-&gt;consul-&gt;acl()-&gt;role($role);\n\n// Read a Role\n$role = new Role([\n    'id' =&gt; 'aa770e5b-8b0b-7fcf-e5a1-8535fcc388b4'\n]);\n$this-&gt;consul-&gt;acl()-&gt;readRole($role);\n\n// Read a Role by Name\n$name = new Role([\n    'name' =&gt; 'example-role'\n]);\n$this-&gt;consul-&gt;acl()-&gt;readRoleByName($name);\n\n// Update a Role\n$role = new Role([\n    'id' =&gt; 'aa770e5b-8b0b-7fcf-e5a1-8535fcc388b4',\n    \"name\" =&gt; \"example-two\",\n]);\n$this-&gt;consul-&gt;acl()-&gt;updateRole($role);\n\n// Delete a Role\n$role = new Role([\n    'id' =&gt; 'aa770e5b-8b0b-7fcf-e5a1-8535fcc388b4'\n]);\n$this-&gt;consul-&gt;acl()-&gt;deleteRole($role);\n\n// List Roles\n$roles = new Roles();\n$this-&gt;consul-&gt;acl()-&gt;roles($roles);\nAuth Method\n// Create an Auth Method\n$method = new AuthMethod([\n    \"Name\" =&gt; \"minikube\",\n    \"Type\" =&gt; \"kubernetes\",\n    \"Description\" =&gt; \"dev minikube cluster\",\n    \"Config\" =&gt; [\n        \"Host\" =&gt; \"https://192.0.2.42:8443\",\n        \"CACert\" =&gt; \"-----BEGIN CERTIFICATE-----\\n...-----END CERTIFICATE-----\\n\",\n        \"ServiceAccountJWT\" =&gt; \"eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9...\"\n    ]\n]);\n$this-&gt;consul-&gt;acl()-&gt;authMethod($method);\n\n// Read an Auth Method\n$method = new AuthMethod([\n    'name' =&gt; 'minikube',\n]);\n$this-&gt;consul-&gt;acl()-&gt;readAuthMethod($method);\n\n// Update an Auth Method\n$method = new AuthMethod([\n    \"Name\" =&gt; \"minikube\",\n    \"Type\" =&gt; \"kubernetes\",\n    \"Description\" =&gt; \"dev minikube cluster\",\n    \"Config\" =&gt; [\n        \"Host\" =&gt; \"https://192.0.2.42:8443\",\n        \"CACert\" =&gt; \"-----BEGIN CERTIFICATE-----\\n...-----END CERTIFICATE-----\\n\",\n        \"ServiceAccountJWT\" =&gt; \"eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9...\"\n    ]\n]);\n$this-&gt;consul-&gt;acl()-&gt;updateAuthMethod($method);\n\n// Delete an Auth Method\n$method = new AuthMethod([\n    \"Name\" =&gt; \"minikube\",\n]);\n$this-&gt;consul-&gt;acl()-&gt;deleteAuthMethod($method);\n\n// List Auth Methods\n$method = new AuthMethods();\n$this-&gt;consul-&gt;acl()-&gt;authMethods($method);\nBinding Rules\n// Create a Binding Rule\n$bindingRule = new BindingRule([\n    \"description\" =&gt; \"example rule\",\n    \"authMethod\" =&gt; \"minikube\",\n    \"Selector\" =&gt; \"serviceaccount.namespace==default\",\n    \"BindType\" =&gt; \"service\",\n    \"BindName\" =&gt; \"{{ serviceaccount.name }}\"\n]);\n$this-&gt;consul-&gt;acl()-&gt;bindingRule($bindingRule);\n\n// Read a Binding Rule\n$bindingRule = new BindingRule([\n    'id' =&gt; '000ed53c-e2d3-e7e6-31a5-c19bc3518a3d',\n]);\n$this-&gt;consul-&gt;acl()-&gt;readBindingRule($bindingRule);\n\n// Update a Binding Rule\n$bindingRule = new BindingRule([\n    'id' =&gt; '000ed53c-e2d3-e7e6-31a5-c19bc3518a3d',\n    \"Description\" =&gt; \"updated rule\",\n    \"authMethod\" =&gt; \"minikube\",\n    \"Selector\" =&gt; \"serviceaccount.namespace=dev\",\n    \"BindType\" =&gt; \"role\",\n    \"BindName\" =&gt; \"{{ serviceaccount.name }}\",\n]);\n$this-&gt;consul-&gt;acl()-&gt;updateBindingRule($bindingRule);\n\n// Delete a Binding Rule\n$bindingRule = new BindingRule([\n    'id' =&gt; '000ed53c-e2d3-e7e6-31a5-c19bc3518a3d',\n]);\n$this-&gt;consul-&gt;acl()-&gt;deleteBindingRule($bindingRule);\n\n// List Binding Rules\n$bindingRules = new BindingRules();\n$this-&gt;consul-&gt;acl()-&gt;bindingRules($bindingRules);\nAgent\n// List Members\n$this-&gt;consul-&gt;agent()-&gt;members(new Members([\n    'wan' =&gt; 'a',\n    'segment' =&gt; 'b',\n]));\n\n// Read Configuration\n$self = new SelfParams();\n$this-&gt;consul-&gt;agent()-&gt;self($self);\n\n// Reload Agent\n$reload = new Reload();\n$this-&gt;consul-&gt;agent()-&gt;reload($reload);\n\n// Enable Maintenance Mode\n$maintenance = new Maintenance([\n    'enable' =&gt; true,\n    'reason' =&gt; 'whatever',\n]);\n$this-&gt;consul-&gt;agent()-&gt;maintenance($maintenance);\n\n// View Metrics\n$metrics = new Metrics([\n    'format' =&gt; 'prometheus',\n]);\n$this-&gt;consul-&gt;agent()-&gt;metrics($metrics);\n\n// Stream Logs\n$monitor = new Monitor([\n    'loglevel' =&gt; 'info',\n]);\n$this-&gt;consul-&gt;agent()-&gt;monitor($monitor);\n\n// Join Agent\n$join = new Join([\n    'address' =&gt; '1.2.3.4',\n    'wan' =&gt; false\n]);\n$this-&gt;consul-&gt;agent()-&gt;join($join);\n\n// Graceful Leave and Shutdown\n$leave = new Leave();\n$this-&gt;consul-&gt;agent()-&gt;leave($leave);\n\n// Force Leave and Shutdown\n$forceLeave = new ForceLeave([\n    'node' =&gt; 'consul'\n]);\n$this-&gt;consul-&gt;agent()-&gt;forceLeave($forceLeave);\n\n// Update ACL Tokens\n$token = new Token([\n    'action' =&gt; 'acl_agent_token',\n    'token' =&gt; 'token'\n]);\n$this-&gt;consul-&gt;agent()-&gt;token($token);\nChecks\n// List Checks\n$checks = new Checks([\n    'filter' =&gt; '',\n]);\n$this-&gt;consul-&gt;agent()-&gt;checks($checks);\n\n// Register Check\n$register = new Register([\n    'name' =&gt; 'Memory_utilization', // 不可以出现空格或者其他url中不允许出现的特殊字符，否则取消注册的check_id会报400 error\n    \"notes\" =&gt; \"Ensure we don't oversubscribe memory\",\n    \"DeregisterCriticalServiceAfter\" =&gt; \"90m\",\n    \"Args\" =&gt; [\"/usr/local/bin/check_mem.py\"],\n    \"DockerContainerID\" =&gt; \"f972c95ebf0e\",\n    \"Shell\" =&gt; \"/bin/bash\",\n    \"HTTP\" =&gt; \"https://example.com\",\n    \"Method\" =&gt; \"POST\",\n    \"Header\" =&gt; [\"x-foo\" =&gt; [\"bar\", \"baz\"]],\n    \"TCP\" =&gt; \"example.com:22\",\n    \"Interval\" =&gt; \"10s\",\n    \"TTL\" =&gt; \"15s\",\n    \"TLSSkipVerify\" =&gt; true,\n]);\n$this-&gt;consul-&gt;agent()-&gt;register($register);\n\n// Deregister Check\n$deRegister = new DeRegister([\n    'check_id' =&gt; 'Memory_utilization'\n]);\n$this-&gt;consul-&gt;agent()-&gt;deRegister($deRegister);\n\n// TTL Check Pass\n$pass = new Pass([\n    'check_id' =&gt; 'Memory_utilization',\n    'note' =&gt; 'consul',\n]);\n$this-&gt;consul-&gt;agent()-&gt;pass($pass);\n\n// TTL Check Warn\n$warn = new Warn([\n    'check_id' =&gt; 'Memory_utilization',\n    'note' =&gt; 'consul',\n]);\n$this-&gt;consul-&gt;agent()-&gt;warn($warn);\n\n// TTL Check Fail\n$fail = new Fail([\n    'check_id' =&gt; 'Memory_utilization',\n    'note' =&gt; 'consul',\n]);\n$this-&gt;consul-&gt;agent()-&gt;fail($fail);\n\n// TTL Check Update\n$update = new Update([\n    'check_id' =&gt; 'Memory_utilization',\n    'Status' =&gt; 'passing',\n    'Output' =&gt; 'update success'\n]);\n$this-&gt;consul-&gt;agent()-&gt;update($update);\nServices\n// List Services\n$services = new Services([\n    'filter' =&gt; '',\n]);\n$this-&gt;consul-&gt;agent()-&gt;services($services);\n\n// Get Service Configuration\n $service = new Service([\n    'service_id' =&gt; \"consul\"\n]);\n$this-&gt;consul-&gt;agent()-&gt;service($service);\n\n// Get local service health\n$name = new Name([\n    'service_name' =&gt; 'consul',\n    'format' =&gt; 'text',\n]);\n$this-&gt;consul-&gt;agent()-&gt;name($name);\n\n// Get local service health by its ID\n$id = new ID([\n    'service_id' =&gt; 'consul',\n    'format' =&gt; 'text',\n]);\n$this-&gt;consul-&gt;agent()-&gt;id($id);\n\n// Register Service\n $register = new Service\\Register([\n    \"ID\" =&gt; \"redis1\",\n    \"name\" =&gt; \"redis\",\n    \"Tags\" =&gt; [\n        \"primary\",\n        \"v1\"\n    ],\n    \"Address\" =&gt; \"127.0.0.1\",\n    \"Port\" =&gt; 8000,\n    \"meta\" =&gt; [\n        \"redis_version\" =&gt; \"4.0\",\n    ],\n    \"EnableTagOverride\" =&gt; false,\n    \"Check\" =&gt; [\n        \"DeregisterCriticalServiceAfter\" =&gt; \"90m\",\n    \"Args\" =&gt; [\"/usr/local/bin/check_redis.py\"],\n    \"HTTP\" =&gt; \"http://localhost:5000/health\",\n    \"Interval\" =&gt; \"10s\",\n    \"TTL\" =&gt; \"15s\"\n    ],\n    \"weights\" =&gt; [\n        \"Passing\" =&gt; 10,\n    \"Warning\" =&gt; 1\n    ]\n]);\n$this-&gt;consul-&gt;agent()-&gt;serviceRegister($register);\n\n// Deregister Service\n$deregister = new Service\\DeRegister([\n    'service_id' =&gt; 'consul',\n]);\n$this-&gt;consul-&gt;agent()-&gt;serviceDeregister($deregister);\n\n// Enable Maintenance Mode\n$maintenance= new Service\\Maintenance([\n    'service_id' =&gt; 'consul',\n    'enable' =&gt; true,\n    'reason' =&gt; ''\n]);\n$this-&gt;consul-&gt;agent()-&gt;serviceMaintenance($maintenance);\nConnect\n// Authorize\n$authorize = new Authorize([\n    \"target\" =&gt; \"db\",\n    \"clientCertURI\" =&gt; \"spiffe://dc1-7e567ac2-551d-463f-8497-f78972856fc1.consul/ns/default/dc/dc1/svc/web\",\n    \"clientCertSerial\" =&gt; \"04:00:00:00:00:01:15:4b:5a:c3:94\"\n]);\n$this-&gt;consul-&gt;agent()-&gt;authorize($authorize);\n\n// Certificate Authority (CA) Roots\n$roots = new Roots();\n$this-&gt;consul-&gt;agent()-&gt;roots($roots);\n\n// Service Leaf Certificate\n$leaf = new Leaf([\n    'service' =&gt; 'consul'\n]);\n$this-&gt;consul-&gt;agent()-&gt;leaf($leaf);\nCatalog\n// Register Entity\n$register = new Register([\n    \"datacenter\" =&gt; \"dc1\",\n    \"id\" =&gt; \"40e4a748-2192-161a-0510-9bf59fe950b5\",\n    \"node\" =&gt; \"foobar\",\n    \"Address\" =&gt; \"192.168.10.10\",\n    \"TaggedAddresses\" =&gt; [\n        \"lan\" =&gt; \"192.168.10.10\",\n    \"wan\" =&gt; \"10.0.10.10\"\n    ],\n    \"NodeMeta\" =&gt; [\n        \"somekey\" =&gt; \"somevalue\"\n    ],\n    \"Service\" =&gt; [\n        \"ID\" =&gt; \"redis1\",\n    \"Service\" =&gt; \"redis\",\n    \"Tags\" =&gt; [\n            \"primary\",\n            \"v1\"\n        ],\n    \"Address\" =&gt; \"127.0.0.1\",\n    \"TaggedAddresses\" =&gt; [\n            \"lan\" =&gt; [\n                \"address\" =&gt; \"127.0.0.1\",\n        \"port\" =&gt; 8000,\n      ],\n      \"wan\" =&gt; [\n                \"address\" =&gt; \"198.18.0.1\",\n        \"port\" =&gt; 80\n      ]\n    ],\n    \"Meta\" =&gt; [\n            \"redis_version\" =&gt; \"4.0\"\n    ],\n    \"Port\" =&gt; 8000\n    ],\n    \"Check\" =&gt; [\n        \"Node\" =&gt; \"foobar\",\n    \"CheckID\" =&gt; \"service:redis1\",\n    \"Name\" =&gt; \"Redis health check\",\n    \"Notes\" =&gt; \"Script based health check\",\n    \"Status\" =&gt; \"passing\",\n    \"ServiceID\" =&gt; \"redis1\",\n    \"Definition\" =&gt; [\n            \"TCP\" =&gt; \"localhost:8888\",\n      \"Interval\" =&gt; \"5s\",\n      \"Timeout\" =&gt; \"1s\",\n      \"DeregisterCriticalServiceAfter\" =&gt; \"30s\"\n    ]\n    ],\n    \"SkipNodeUpdate\" =&gt; false\n]);\n$this-&gt;consul-&gt;catalog()-&gt;register($register);\n\n// Deregister Entity\n$deregister = new Deregister([\n    \"datacenter\" =&gt; \"dc1\",\n    \"node\" =&gt; \"foobar\",\n    \"CheckID\" =&gt; \"service:redis1\",\n]);\n$this-&gt;consul-&gt;catalog()-&gt;deRegister($deregister);\n\n// List Datacenters\n$datacenters = new Datacenters();\n$this-&gt;consul-&gt;catalog()-&gt;dataCenters($datacenters);\n\n// List Nodes\n$nodes = new Nodes([\n    'dc' =&gt; 'dc1',\n    'node-meta' =&gt; '',\n    'near' =&gt; '',\n    'filter' =&gt; '',\n]);\n$this-&gt;consul-&gt;catalog()-&gt;nodes($nodes);\n\n// List Services\n$nodes = new Nodes([\n$services = new Services([\n    'dc' =&gt; 'dc1',\n    'node-meta' =&gt; '',\n]);\n$this-&gt;consul-&gt;catalog()-&gt;services($services);\n]);\n$this-&gt;consul-&gt;catalog()-&gt;nodes($nodes);\n\n// List Nodes for Service\n$services = new Services([\n    'dc' =&gt; 'a',\n    'node-meta' =&gt; 'b',\n]);\n$this-&gt;consul-&gt;catalog()-&gt;services($services);\n\n// List Nodes for Connect-capable Service\n$service = new Service([\n    'service' =&gt; 'consul',\n    'dc' =&gt; 'dc1',\n    'tag' =&gt; '',\n    'near' =&gt; '',\n    'node-meta' =&gt; '',\n    'filter' =&gt; '',\n]);\n$this-&gt;consul-&gt;catalog()-&gt;service($service);\n\n// List Services for Node\n$connect = new Connect([\n    'service' =&gt; 'consul',\n    'dc' =&gt; 'dc1',\n    'tag' =&gt; '',\n    'near' =&gt; '',\n    'node-meta' =&gt; '',\n    'filter' =&gt; '',\n]);\n$this-&gt;consul-&gt;catalog()-&gt;connect($connect);\n\n// List Services for Node\n$node = new Node([\n    'node' =&gt; '2eb87046a6fe',\n    'dc' =&gt; 'dc1',\n    'filter' =&gt; '',\n]);\n$this-&gt;consul-&gt;catalog()-&gt;node($node);\nConfig\n// Apply Configuration\n$config = new \\EasySwoole\\Consul\\Request\\Config([\n    'Kind' =&gt; 'service-defaults',\n    'Name' =&gt; 'web',\n    'Protocol' =&gt; 'Http'\n]);\n$this-&gt;consul-&gt;config()-&gt;config($config);\n\n// Get Configuration\n$config = new \\EasySwoole\\Consul\\Request\\Config([\n    'Kind' =&gt; 'service-defaults',\n    'name' =&gt; 'web',\n]);\n$this-&gt;consul-&gt;config()-&gt;getConfig($config);\n\n// List Configurations\n$config = new \\EasySwoole\\Consul\\Request\\Config([\n    'Kind' =&gt; 'service-defaults'\n]);\n$this-&gt;consul-&gt;config()-&gt;listConfig($config);\n\n// Delete Configuration\n$config = new \\EasySwoole\\Consul\\Request\\Config([\n    'Kind' =&gt; 'service-defaults',\n    'name' =&gt; 'web',\n]);\n$this-&gt;consul-&gt;config()-&gt;deleteConfig($config);\nConnect\nCertificate Authority (CA)\n// List CA Root Certificates\n$roots = new Roots();\n$this-&gt;consul-&gt;connect()-&gt;roots($roots);\n\n// Get CA Configuration\n$configuration = new Configuration();\n$this-&gt;consul-&gt;connect()-&gt;configuration($configuration);\n\n// Update CA Configuration\n$configuration = new Configuration([\n    'Provider' =&gt; 'consul',\n    'Config' =&gt; [\n        'LeafCertTTL' =&gt; '72h'\n    ]\n]);\n$this-&gt;consul-&gt;connect()-&gt;updateConfiguration($configuration);\nIntentions\n// Create Intention\n$intentions = new Intentions([\n    'SourceName' =&gt; 'web',\n    'DestinationName' =&gt; 'db',\n    'SourceType' =&gt; 'consul',\n    'action' =&gt; 'allow'\n]);\n$this-&gt;consul-&gt;connect()-&gt;intentions($intentions);\n\n// Read Specific Intention\n$intentions = new Intentions([\n    'uuid' =&gt; 'e9ebc19f-d481-42b1-4871-4d298d3acd5c',\n]);\n$this-&gt;consul-&gt;connect()-&gt;readIntention($intentions);\n\n// List Intentions\n$intentions = new Intentions();\n$this-&gt;consul-&gt;connect()-&gt;listIntention($intentions);\n\n// Update Intention\n$intentions = new Intentions([\n    'uuid' =&gt; 'b40faaf3-34aa-349f-3cf2-f5d720240662',\n    'description' =&gt; 'just a test description',\n    'SourceName' =&gt; '',\n    'DestinationName' =&gt; '',\n    'Action' =&gt; 'allow'\n]);\n$this-&gt;consul-&gt;connect()-&gt;updateIntention($intentions);\n\n// Delete Intention\n$intentions = new Intentions([\n    'uuid' =&gt; 'b40faaf3-34aa-349f-3cf2-f5d720240662',\n]);\n$this-&gt;consul-&gt;connect()-&gt;deleteIntention($intentions);\n\n// Check Intention Result\n$intentions = new Intentions\\Check([\n    'source' =&gt; 'web',\n    'destination' =&gt; 'db',\n]);\n$this-&gt;consul-&gt;connect()-&gt;check($intentions);\n\n// List Matching Intentions\n$intentions = new Intentions\\Match([\n    'by' =&gt; 'source',\n    'name' =&gt; 'web',\n]);\n$this-&gt;consul-&gt;connect()-&gt;match($intentions);\nCoordinate\n// Read WAN Coordinates\n$datacenters = new Datacenters();\n$this-&gt;consul-&gt;coordinates()-&gt;datacenters($datacenters);\n\n// Read LAN Coordinates for all nodes\n$nodes = new Nodes([]);\n$this-&gt;consul-&gt;coordinates()-&gt;nodes($nodes);\n\n// Read LAN Coordinates for a node\n$node = new Node([\n    'node' =&gt; '2456c2850382',\n]);\n$this-&gt;consul-&gt;coordinates()-&gt;node($node);\n\n// Update LAN Coordinates for a node\n$update = new Update([\n    'dc' =&gt; 'dc1',\n    'node' =&gt; '2456c2850382',\n    'Segment' =&gt; 'update',\n    \"Coord\" =&gt; [\n        \"Adjustment\" =&gt; 0,\n        \"Error\" =&gt; 1.5,\n        \"Height\" =&gt; 0,\n        \"Vec\" =&gt; [0, 0, 0, 0, 0, 0, 0, 0]\n    ]\n]);\n$this-&gt;consul-&gt;coordinates()-&gt;update($update);\nEvents\n// Fire Event\n$fire = new Fire([\n    'name' =&gt; 'consul',\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;event()-&gt;fire($fire);\n\n// List Events\n$listEvent = new ListEvent([\n    'name' =&gt; 'consul',\n]);\n$this-&gt;consul-&gt;event()-&gt;listEvent($listEvent);\nHealth\n// List Checks for Node\n$node = new Node([\n    'node' =&gt; '2456c2850382',\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;health()-&gt;node($node);\n\n// List Checks for Service\n$checks = new Checks([\n   'service' =&gt; 'consul',\n   'node_meta' =&gt; 'node-meta',\n]);\n$this-&gt;consul-&gt;health()-&gt;checks($checks);\n\n// List Nodes for Service\n$service = new Service([\n    'service' =&gt; 'consul',\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;health()-&gt;service($service);\n\n// List Nodes for Connect-capable Service\n$connect = new Connect([\n    'service' =&gt; 'consul'\n]);\n$this-&gt;consul-&gt;health()-&gt;connect($connect);\n\n// List Checks in State\n$state = new State([\n    'state' =&gt; 'passing'\n]);\n$this-&gt;consul-&gt;health()-&gt;state($state);\nKV Store\n// Read Key\n$kv = new Kv([\n    'key' =&gt; 'my-key',\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;kvStore()-&gt;kv($kv);\n\n// Create Key\n$create = new kv([\n    'key' =&gt; 'my-key',\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;kvStore()-&gt;create($create);\n\n// Update Key\n$update = new kv([\n    'key' =&gt; 'my-key',\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;kvStore()-&gt;update($update);\n\n// Delete Key\n$delete = new Kv([\n    'key' =&gt; 'my-key',\n    'recurse' =&gt; false,\n]);\n$this-&gt;consul-&gt;kvStore()-&gt;delete($delete);\nOperator\nArea\n// Create Network Area\n$area = new Area([\n    'PeerDatacenter' =&gt; 'dc1',\n    \"RetryJoin\" =&gt; [ \"10.1.2.3\", \"10.1.2.4\", \"10.1.2.5\" ],\n    \"UseTLS\" =&gt; false\n]);\n$this-&gt;consul-&gt;operator()-&gt;area($area);\n\n// List Network Areas\n$area = new Area([\n    'dc' =&gt; 'dc1',\n    'uuid' =&gt; '10275a2e-aa8f-2cf3-0adf-ff03d8950902',\n]);\n$this-&gt;consul-&gt;operator()-&gt;areaList($area);\n\n// List Specific Network Area\n$area = new Area([\n    'dc' =&gt; 'dc1',\n    'uuid' =&gt; '10275a2e-aa8f-2cf3-0adf-ff03d8950902',\n]);\n$this-&gt;consul-&gt;operator()-&gt;areaList($area);\n\n// Update Network Area\n$area = new Area([\n    'uuid' =&gt; '10275a2e-aa8f-2cf3-0adf-ff03d8950902',\n    'UseTLS' =&gt; true,\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;operator()-&gt;updateArea($area);\n\n// Delete Network Area\n$area = new Area([\n    'uuid' =&gt; '10275a2e-aa8f-2cf3-0adf-ff03d8950902',\n]);\n$this-&gt;consul-&gt;operator()-&gt;deleteArea($area);\n\n// Join Network Area\n$area = new Area([\n    'uuid' =&gt; '10275a2e-aa8f-2cf3-0adf-ff03d8950902',\n]);\n$this-&gt;consul-&gt;operator()-&gt;joinArea($area);\n\n// List Network Area Members\n$area = new Area([\n    'uuid' =&gt; '10275a2e-aa8f-2cf3-0adf-ff03d8950902'\n]);\n$this-&gt;consul-&gt;operator()-&gt;membersArea($area);\nAutopilot\n// Read Configuration\n$configuration = new Configuration([\n    'dc' =&gt; 'dc1',\n    'stale' =&gt; true,\n]);\n$this-&gt;consul-&gt;operator()-&gt;getConfiguration($configuration);\n\n// Update Configuration\n$configuration = new Configuration([\n    'dc' =&gt; 'dc1',\n    'stale' =&gt; true,\n    \"cleanupDeadServers\" =&gt; true,\n    \"lastContactThreshold\" =&gt; \"200ms\",\n    \"MaxTrailingLogs\" =&gt; 250,\n    \"ServerStabilizationTime\" =&gt; \"10s\",\n    \"RedundancyZoneTag\" =&gt; \"\",\n    \"DisableUpgradeMigration\" =&gt; false,\n    \"UpgradeVersionTag\" =&gt; \"\",\n\n]);\n$this-&gt;consul-&gt;operator()-&gt;updateConfiguration($configuration);\n\n// Read Health\n$health = new Health([\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;operator()-&gt;health($health);\nKeyring\n// List Gossip Encryption Keys\n$keyring = new Keyring();\n$keyring-&gt;setRelayFactor(0);\n$keyring-&gt;setLocalOnly(false);\n$this-&gt;consul-&gt;operator()-&gt;getKeyring($keyring);\n\n// Add New Gossip Encryption Key\n$keyring = new Keyring([\n    \"Key\" =&gt; \"3lg9DxVfKNzI8O+IQ5Ek+Q==\",\n    'relayFactor' =&gt; 1,\n]);\n$this-&gt;consul-&gt;operator()-&gt;addKeyring($keyring);\n\n// Change Primary Gossip Encryption Key\n$keyring = new Keyring([\n    \"Key\" =&gt; \"3lg9DxVfKNzI8O+IQ5Ek+Q==\",\n]);\n$this-&gt;consul-&gt;operator()-&gt;changeKeyring($keyring);\n\n// Delete Gossip Encryption Key\n$keyring = new Keyring([\n    \"Key\" =&gt; \"3lg9DxVfKNzI8O+IQ5Ek+Q==\",\n    \"relayFactor\" =&gt; 1\n]);\n$this-&gt;consul-&gt;operator()-&gt;deleteKeyring($keyring);\nLicense\n// Getting the Consul License\n$license = new License([\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;operator()-&gt;getLicense($license);\n\n// Updating the Consul License\n$license = new License([\n    'dc' =&gt; 'dc1'\n]);\n$this-&gt;consul-&gt;operator()-&gt;updateLicense($license);\n\n// Resetting the Consul License\n$license = new License([\n    'dc' =&gt; 'dc1'\n]);\n$this-&gt;consul-&gt;operator()-&gt;resetLicense($license);\nRaft\n// Read Configuration\n$raft = new \\EasySwoole\\Consul\\Request\\Operator\\Raft\\Configuration();\n$this-&gt;consul-&gt;operator()-&gt;getRaftConfiguration($raft);\n\n// Delete Raft Peer\n$peer = new Peer([\n    'address' =&gt; '172.17.0.18:8301',\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;operator()-&gt;peer($peer);\nSegment\n// List Network Segments\n$segment = new Segment();\n$this-&gt;consul-&gt;operator()-&gt;segment($segment);\nPrepared Query\n// Create Prepared Query\n$query = new Query([\n    \"name\" =&gt; \"my-query\",\n    \"Session\" =&gt; \"adf4238a-882b-9ddc-4a9d-5b6758e4159e\",\n    \"Token\" =&gt; \"11\",\n    \"Service\" =&gt; [\n        \"Service\" =&gt; \"redis\",\n        \"Failover\" =&gt; [\n            \"NearestN\" =&gt; 3,\n            \"Datacenters\" =&gt; [\"dc1\", \"dc2\"]\n         ],\n        \"Near\" =&gt; \"node1\",\n        \"OnlyPassing\" =&gt; false,\n        \"Tags\" =&gt; [\"primary\", \"!experimental\"],\n        \"NodeMeta\" =&gt; [\"instance_type\" =&gt; \"m3.large\"],\n        \"ServiceMeta\" =&gt; [\"environment\" =&gt; \"production\"]\n    ],\n    \"DNS\" =&gt; [\n        \"TTL\" =&gt; \"10s\"\n    ],\n]);\n$this-&gt;consul-&gt;query()-&gt;query($query);\n\n// Read Prepared Query\n$query = new Query([\n    'dc' =&gt; 'dc1'\n]);\n$this-&gt;consul-&gt;query()-&gt;readQuery($query);\n\n// Update Prepared Query\n$query = new Query([\n    'uuid' =&gt; '90dce5ca-5697-ae2f-09ae-51e9542ea58c',\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;query()-&gt;updateQuery($query);;\n\n// Read Prepared Query\n$query = new Query([\n    'dc' =&gt; 'dc1'\n]);\n$this-&gt;consul-&gt;query()-&gt;readQuery($query);\n\n// Delete Prepared Query\n$query = new Query([\n    'uuid' =&gt; '90dce5ca-5697-ae2f-09ae-51e9542ea58c'\n]);\n$this-&gt;consul-&gt;query()-&gt;deleteQuery($query);;\n\n// Execute Prepared Query\n$execute = new Query\\Execute([\n    'uuid' =&gt; '90dce5ca-5697-ae2f-09ae-51e9542ea58c',\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;query()-&gt;execute($execute);\n\n// Explain Prepared Query\n$execute = new Query\\Explain([\n    'uuid' =&gt; '90dce5ca-5697-ae2f-09ae-51e9542ea58c',\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;query()-&gt;explain($execute);\nSessions\n// Create Session\n$create = new Create([\n    'dc' =&gt; 'dc1',\n    \"LockDelay\" =&gt; \"15s\",\n    \"Name\" =&gt; \"my-service-lock\",\n    \"Node\" =&gt; \"foobar\",\n    \"Checks\" =&gt; [\"a\", \"b\", \"c\"],\n    \"Behavior\" =&gt; \"release\",\n    \"TTL\" =&gt; \"30s\",\n]);\n$this-&gt;consul-&gt;session()-&gt;create($create);\n\n// Delete Session\n$destroy = new Destroy([\n    'uuid' =&gt; 'f32a15b3-1baa-c047-bde9-bec3015ea013',\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;session()-&gt;destroy($destroy);\n\n// Read Session\n$info = new Info([\n    'uuid' =&gt; 'f32a15b3-1baa-c047-bde9-bec3015ea013',\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;session()-&gt;info($info);\n\n// List Sessions for Node\n$node = new Node([\n    'node' =&gt; '2456c2850382',\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;session()-&gt;node($node);\n\n// List Sessions\n$sessionList = new SessionList([\n    'dc' =&gt; 'dc1'\n]);\n$this-&gt;consul-&gt;session()-&gt;sessionList($sessionList);\n\n// Renew Session\n$renew = new Renew([\n    'uuid' =&gt; '4f6d1cf6-b60a-c929-eeb8-12f4d7eaff62',\n    'dc' =&gt; 'dc1'\n]);\n$this-&gt;consul-&gt;session()-&gt;renew($renew);\nSnapshots\n// Generate Snapshot\n$generate = new Snapshot([\n    'dc' =&gt; 'dc1',\n    'stale' =&gt; 'true',\n]);\n$this-&gt;consul-&gt;snapshot()-&gt;generate($generate);\n\n// Restore Snapshot\n$restore = new Snapshot();\n$this-&gt;consul-&gt;snapshot()-&gt;restore($restore);\nStatus\n// Get Raft Leader\n$leader = new Leader();\n$this-&gt;consul-&gt;status()-&gt;leader($leader);\n\n// List Raft Peers\n$peers = new Peers([\n    'dc' =&gt; 'dc1',\n]);\n$this-&gt;consul-&gt;status()-&gt;peers($peers);\nTransactions\n// Create Transaction\n$transaction = new Txn([]);\n$this-&gt;consul-&gt;transaction()-&gt;create($transaction);\n$node = new Node([\n    'node' =&gt; '44e4656a94cd',\n    'dc' =&gt; 'dc1',\n    'filter' =&gt; '',\n]);\n$consul-&gt;catalog()-&gt;node($node);\n","link":"/Components/consul.html"},{"id":319,"title":"apollo","content":"Apollo 协程客户端\nEasySwoole 实现了对 apollo 数据中心的支持，可根据该组件，进行同步配置\n组件要求\n\nphp: &gt;= 7.1.0\neasyswoole/spl: ^1.2\neasyswoole/http-client: ^1.3\n\n安装方法\n\ncomposer require easyswoole/apollo\n\n仓库地址\neasy-swoole/apollo\n使用\n&lt;?php\n/**\n * This file is part of EasySwoole.\n *\n * @link https://www.easyswoole.com\n * @document https://www.easyswoole.com\n * @contact https://www.easyswoole.com/Preface/contact.html\n * @license https://github.com/easy-swoole/easyswoole/blob/3.x/LICENSE\n */\n\nrequire_once __DIR__ . '/vendor/autoload.php';\n\ngo(function () {\n    // 配置 apollo 服务器信息\n    $server = new \\EasySwoole\\Apollo\\Server([\n        'server' =&gt; 'http://106.12.25.204:8080',\n        'appId' =&gt; 'easyswoole'\n    ]);\n    // 创建 apollo 客户端\n    $apollo = new \\EasySwoole\\Apollo\\Apollo($server);\n    // 第一次同步\n    var_dump($apollo-&gt;sync('mysql'));\n    // 第二次同步，若服务端没有改变，那么返回的结果，isModify 标记为 false，并带有 lastReleaseKey\n    var_dump($apollo-&gt;sync('mysql'));\n});\n开发者可以在服务中启动一个定时器或者自定义进程，实现自动定时更新。关于如何使用定时器或者自定义进程，请查看 定时器、自定义进程","link":"/Components/apollo.html"},{"id":320,"title":"tracker","content":"Tracker\nEasySwoole 提供了一个基础的追踪组件，方便用户实现基础的服务器状态监控，与调用链记录。\n组件要求\n\nphp: &gt;=7.1.0\next-swoole: ^4.4.0\neasyswoole/component: ^2.0\n\n安装方法\n\ncomposer require easyswoole/tracker\n\n仓库地址\neasyswoole/tracker\n调用链结构说明\nEasySwoole 的调用链跟踪是一个以类似有序的树状链表的解构实现的，解构如下：\nstruct Point{\n    struct Point* nextPoint;\n    struct Point[] subPoints;\n    const END_SUCCESS = 'success';\n    const END_FAIL = 'fail';\n    const END_UNKNOWN = 'unknown';\n    int startTime;\n    mixed startArg;\n    int endTime;\n    string pointName;\n    string endStatus = self::END_UNKNOWN;\n    mixed endArg;\n    string pointId;\n    string parentId;\n    int depth = 0;\n    bool isNext\n}\n基本使用\n&lt;?php\n/**\n * This file is part of EasySwoole.\n *\n * @link https://www.easyswoole.com\n * @document https://www.easyswoole.com\n * @contact https://www.easyswoole.com/Preface/contact.html\n * @license https://github.com/easy-swoole/easyswoole/blob/3.x/LICENSE\n */\n\nrequire_once __DIR__ . '/vendor/autoload.php';\n\nuse EasySwoole\\Tracker\\Point;\nuse EasySwoole\\Component\\WaitGroup;\nuse EasySwoole\\Tracker\\PointContext;\n\n/*\n * 假设我们的调用链是这样的\n * onRequest  -&gt;&gt; actionOne -&gt;&gt; actionOne call remote Api(1,2)  -&gt;&gt;  afterAction\n */\n\ngo(function (){\n    /*\n     * 创建入口\n     */\n    $onRequest = new Point('onRequest');\n    //记录请求参数，并模拟access log\n    \\co::sleep(0.01);\n    $onRequest-&gt;setStartArg([\n        'requestArg' =&gt; 'requestArgxxxxxxxx',\n        'accessLogId'=&gt;'logIdxxxxxxxxxx'\n    ]);\n    //onRequest完成\n    $onRequest-&gt;end();\n    //进入 next actionOne\n    $actionOne = $onRequest-&gt;next('actionOne');\n        //action one 进入子环节调用\n        $waitGroup = new WaitGroup();\n        //sub pointOne\n        $waitGroup-&gt;add();\n        $subOne = $actionOne-&gt;appendChild('subOne');\n        go(function ()use($subOne,$waitGroup){\n                \\co::sleep(0.1);\n                $subOne-&gt;end();\n                $waitGroup-&gt;done();\n        });\n        //sub pointTwo,并假设失败\n        $waitGroup-&gt;add();\n        $subTwo = $actionOne-&gt;appendChild('subTwo');\n            go(function ()use($subTwo,$waitGroup){\n                \\co::sleep(1);\n                $subTwo-&gt;end($subTwo::END_FAIL,['failMsg'=&gt;'timeout']);\n                $waitGroup-&gt;done();\n            });\n        $waitGroup-&gt;wait();\n    $actionOne-&gt;end();\n    //actionOne结束，进入afterAction\n    $afterAction = $actionOne-&gt;next('afterAction');\n    //模拟响应记录\n    \\co::sleep(0.01);\n    $afterAction-&gt;end($afterAction::END_SUCCESS,['log'=&gt;'success']);\n    /*\n     * 从入口开始打印调用链\n     */\n    echo Point::toString($onRequest);\n});\n// 以上代码等价于如下\ngo(function () {\n    PointContext::getInstance()-&gt;createStart('onRequest')-&gt;next('actionOne')-&gt;next('afterAction');\n    // 记录请求参数，并模拟access log\n    \\co::sleep(0.01);\n    PointContext::getInstance()-&gt;find('onRequest')-&gt;setStartArg([\n        'requestArg' =&gt; 'requestArgxxxxxxxx',\n        'accessLogId' =&gt; 'logIdxxxxxxxxxx'\n    ])-&gt;end();\n    $subOne = PointContext::getInstance()-&gt;find('actionOne')-&gt;appendChild('subOne');\n    $subTwo = PointContext::getInstance()-&gt;find('actionOne')-&gt;appendChild('subTwo');\n    $waitGroup = new WaitGroup();\n    $waitGroup-&gt;add();\n    go(function () use ($subOne, $waitGroup) {\n        \\co::sleep(0.1);\n        $subOne-&gt;end();\n        $waitGroup-&gt;done();\n    });\n    // sub pointTwo，并假设失败\n    $waitGroup-&gt;add();\n    go(function () use ($subTwo, $waitGroup) {\n        \\co::sleep(1);\n        $subTwo-&gt;end($subTwo::END_FAIL, ['failMsg' =&gt; 'timeout']);\n        $waitGroup-&gt;done();\n    });\n    $waitGroup-&gt;wait();\n    PointContext::getInstance()-&gt;find('actionOne')-&gt;end();\n    // 模拟响应记录\n    \\co::sleep(0.01);\n    PointContext::getInstance()-&gt;find('afterAction')-&gt;end(Point::END_SUCCESS, ['log' =&gt; 'success']);\n    /*\n     * 从入口开始打印调用链\n     */\n    echo Point::toString(PointContext::getInstance()-&gt;startPoint());\n});\n以上代码输出结果：\n##\nPointName:onRequest\nServiceName:default\nStatus:success\nPointId:df56bbcf-c1ce-f536-ab8f-31f243721d76\nParentId:\nDepth:0\nIsNext:false\nStart:1625313762.7221\nStartArg:{\"requestArg\":\"requestArgxxxxxxxx\",\"accessLogId\":\"logIdxxxxxxxxxx\"}\nEnd:1625313762.7352\nEndArg:null\nChildCount:0\nChildren:None\nNextPoint:\n    ##\n    PointName:actionOne\n    ServiceName:default\n    Status:success\n    PointId:c341da3e-809c-5a6b-e8c6-ab8aba29e336\n    ParentId:df56bbcf-c1ce-f536-ab8f-31f243721d76\n    Depth:0\n    IsNext:true\n    Start:1625313762.7352\n    StartArg:null\n    End:1625313763.7381\n    EndArg:null\n    ChildCount:2\n    Children:\n        ##\n        PointName:subOne\n        ServiceName:default\n        Status:success\n        PointId:4a66dc47-8c30-a4e4-bf8d-7b1fc334ce4b\n        ParentId:c341da3e-809c-5a6b-e8c6-ab8aba29e336\n        Depth:1\n        IsNext:false\n        Start:1625313762.7354\n        StartArg:null\n        End:1625313762.838\n        EndArg:null\n        ChildCount:0\n        Children:None\n        NextPoint:None\n        ##\n        PointName:subTwo\n        ServiceName:default\n        Status:fail\n        PointId:326ca214-155b-d9f9-ad7a-8d8cbd479cdf\n        ParentId:c341da3e-809c-5a6b-e8c6-ab8aba29e336\n        Depth:1\n        IsNext:false\n        Start:1625313762.7355\n        StartArg:null\n        End:1625313763.7381\n        EndArg:{\"failMsg\":\"timeout\"}\n        ChildCount:0\n        Children:None\n        NextPoint:None\n    NextPoint:\n        ##\n        PointName:afterAction\n        ServiceName:default\n        Status:success\n        PointId:2f6d29b9-a100-fc69-2f64-f51a28a870eb\n        ParentId:c341da3e-809c-5a6b-e8c6-ab8aba29e336\n        Depth:0\n        IsNext:true\n        Start:1625313763.7382\n        StartArg:null\n        End:1625313763.7502\n        EndArg:{\"log\":\"success\"}\n        ChildCount:0\n        Children:None\n        NextPoint:None\n如果想以自己的格式记录到数据库，可以具体查看 Point 实现的方法，每个 Point 都有自己的 Id。\n进阶使用\nHTTP API 请求追踪\n在 EasySwoole 全局事件（即项目根目录的 EasySwooleEvent.php）中注册 Tracker。\n在 EasySwoole 3.4.x 中注册示例代码如下：\n&lt;?php\n/**\n * This file is part of EasySwoole.\n *\n * @link https://www.easyswoole.com\n * @document https://www.easyswoole.com\n * @contact https://www.easyswoole.com/Preface/contact.html\n * @license https://github.com/easy-swoole/easyswoole/blob/3.x/LICENSE\n */\n\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\n\nclass EasySwooleEvent implements Event\n{\n    public static function initialize()\n    {\n        date_default_timezone_set('Asia/Shanghai');\n\n        \\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::HTTP_GLOBAL_ON_REQUEST, function (\\EasySwoole\\Http\\Request $request, \\EasySwoole\\Http\\Response $response): bool {\n            $point = \\EasySwoole\\Tracker\\PointContext::getInstance()-&gt;createStart('onRequest');\n            $point-&gt;setStartArg([\n                'uri' =&gt; $request-&gt;getUri()-&gt;__toString(),\n                'get' =&gt; $request-&gt;getQueryParams()\n            ]);\n            return true;\n        });\n\n        \\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::HTTP_GLOBAL_AFTER_REQUEST, function (\\EasySwoole\\Http\\Request $request, \\EasySwoole\\Http\\Response $response): void {\n            $point = \\EasySwoole\\Tracker\\PointContext::getInstance()-&gt;startPoint();\n            $point-&gt;end();\n            echo \\EasySwoole\\Tracker\\Point::toString($point);\n            $array = \\EasySwoole\\Tracker\\Point::toArray($point);\n        });\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n\n    }\n}\n如果 EasySwoole 框架版本低于 3.4.x时，请使用如下方式进行注册：\n&lt;?php\n/**\n * This file is part of EasySwoole.\n *\n * @link https://www.easyswoole.com\n * @document https://www.easyswoole.com\n * @contact https://www.easyswoole.com/Preface/contact.html\n * @license https://github.com/easy-swoole/easyswoole/blob/3.x/LICENSE\n */\n\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\n\nclass EasySwooleEvent implements Event\n{\n    public static function initialize()\n    {\n        // TODO: Implement initialize() method.\n        date_default_timezone_set('Asia/Shanghai');\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n\n    }\n\n    public static function onRequest(Request $request, Response $response): bool\n    {\n        $point = \\EasySwoole\\Tracker\\PointContext::getInstance()-&gt;createStart('onRequest');\n        $point-&gt;setStartArg([\n            'uri'=&gt;$request-&gt;getUri()-&gt;__toString(),\n            'get'=&gt;$request-&gt;getQueryParams()\n        ]);\n        return true;\n    }\n\n    public static function afterRequest(Request $request, Response $response): void\n    {\n        $point = \\EasySwoole\\Tracker\\PointContext::getInstance()-&gt;startPoint();\n        $point-&gt;end();\n        echo \\EasySwoole\\Tracker\\Point::toString($point);\n        $array = \\EasySwoole\\Tracker\\Point::toArray($point);\n    }\n}\n在 App\\HttpController\\Index.php 中：\n&lt;?php\n/**\n * This file is part of EasySwoole.\n *\n * @link https://www.easyswoole.com\n * @document https://www.easyswoole.com\n * @contact https://www.easyswoole.com/Preface/contact.html\n * @license https://github.com/easy-swoole/easyswoole/blob/3.x/LICENSE\n */\n\nnamespace App\\HttpController;\n\nuse EasySwoole\\Component\\WaitGroup;\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\nuse EasySwoole\\Tracker\\PointContext;\n\nclass Index extends Controller\n{\n    protected function onRequest(?string $action): ?bool\n    {\n        /*\n         * 调用关系  HttpRequest-&gt;OnRequest\n         */\n        $point = PointContext::getInstance()-&gt;next('ControllerOnRequest');\n        // 假设这里进行了权限验证，并模拟数据库耗时\n        \\co::sleep(0.01);\n        $point-&gt;setEndArg([\n            'userId'=&gt;'xxxxxxxxxxx'\n        ]);\n        $point-&gt;end();\n        return true;\n    }\n\n    function index()\n    {\n        // 模拟调用第三方Api，调用关系  OnRequest-&gt;sub(subApi1,subApi2)\n        $actionPoint = PointContext::getInstance()-&gt;next('indexAction');\n        $wait = new WaitGroup();\n        $subApi = $actionPoint-&gt;appendChild('subOne');\n        $wait-&gt;add();\n        go(function ()use($wait,$subApi){\n            \\co::sleep(1);\n            $subApi-&gt;end();\n            $wait-&gt;done();\n        });\n\n        $subApi = $actionPoint-&gt;appendChild('subTwo');\n        $wait-&gt;add();\n        go(function ()use($wait,$subApi){\n            \\co::sleep(0.3);\n            $subApi-&gt;end($subApi::END_FAIL);\n            $wait-&gt;done();\n        });\n\n        $wait-&gt;wait();\n\n        $actionPoint-&gt;end();\n        $this-&gt;response()-&gt;write('hello world');\n    }\n}\n以上每次请求会输出如下格式：\n##\nPointName:onRequest\nServiceName:default\nStatus:success\nPointId:2ea751d4-13a7-8a27-932e-6671da6d6586\nParentId:\nDepth:0\nIsNext:false\nStart:1625315058.3513\nStartArg:{\"uri\":\"http://192.168.1.107:9501/\",\"get\":[]}\nEnd:1625315059.3694\nEndArg:null\nChildCount:0\nChildren:None\nNextPoint:\n    ##\n    PointName:ControllerOnRequest\n    ServiceName:default\n    Status:success\n    PointId:13a0ccda-18ef-c90c-d9db-6e3a1cc70511\n    ParentId:2ea751d4-13a7-8a27-932e-6671da6d6586\n    Depth:0\n    IsNext:true\n    Start:1625315058.3535\n    StartArg:null\n    End:1625315058.3656\n    EndArg:{\"userId\":\"xxxxxxxxxxx\"}\n    ChildCount:0\n    Children:None\n    NextPoint:\n        ##\n        PointName:indexAction\n        ServiceName:default\n        Status:success\n        PointId:a0295b8f-c02c-7ef3-afae-da5dce2764d0\n        ParentId:13a0ccda-18ef-c90c-d9db-6e3a1cc70511\n        Depth:0\n        IsNext:true\n        Start:1625315058.3656\n        StartArg:null\n        End:1625315059.3694\n        EndArg:null\n        ChildCount:2\n        Children:\n            ##\n            PointName:subOne\n            ServiceName:default\n            Status:success\n            PointId:d06855e1-0571-c829-121e-3467f7309598\n            ParentId:a0295b8f-c02c-7ef3-afae-da5dce2764d0\n            Depth:1\n            IsNext:false\n            Start:1625315058.3658\n            StartArg:null\n            End:1625315059.3694\n            EndArg:null\n            ChildCount:0\n            Children:None\n            NextPoint:None\n            ##\n            PointName:subTwo\n            ServiceName:default\n            Status:fail\n            PointId:b47b32d6-f96f-9a00-1244-e16faab3d790\n            ParentId:a0295b8f-c02c-7ef3-afae-da5dce2764d0\n            Depth:1\n            IsNext:false\n            Start:1625315058.3658\n            StartArg:null\n            End:1625315058.6685\n            EndArg:null\n            ChildCount:0\n            Children:None\n            NextPoint:None\n        NextPoint:None\nApi 调用链记录\n$array = \\EasySwoole\\Tracker\\Point::toArray($point);\n可以把一个入口点转为一个数组。例如我们可以在 MYSQL 数据库中存储以下关键结构：\nCREATE TABLE `api_tracker_point_list` (\n  `pointd` varchar(18) NOT NULL,\n  `pointName` varchar(45) DEFAULT NULL,\n  `parentId` varchar(18) DEFAULT NULL,\n  `depth` int(11) NOT NULL DEFAULT '0',\n  `isNext` int(11) NOT NULL DEFAULT '0',\n  `startTime` varchar(14) NOT NULL,\n  `endTime` varchar(14) DEFAULT NULL,\n  `status` varchar(10) NOT NULL,\n  PRIMARY KEY (`pointd`),\n  UNIQUE KEY `trackerId_UNIQUE` (`pointd`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n其余请求参数可以自己记录。\n核心字段在 pointId、parentId、isNext、status 这四个字段，例如，我想得到哪次调用链超时，那么就是直接\nwhere status = fail\n如果想看哪次调用耗时多少，那么可以\nwhere spendTime &gt; 3\nspendTime 是通过 startTime 和 endTime 计算得出\n相关知识链接\nEasySwoole 之链路追踪 简单demo","link":"/Components/tracker.html"},{"id":321,"title":"安装和使用","content":"ElasticSearch 协程客户端组件\n协程版 ElasticSearch Client，对官方客户端的协程化移植\n组件要求\n\neasyswoole/spl: ^1.3\neasyswoole/http-client: ^1.3\neasyswoole/swoole-ide-helper: ^1.3\n\n安装方法\n\ncomposer require easyswoole/elasticsearch\n\n仓库地址\neasyswoole/elasticsearch\nClient 用法\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function () use ($elasticsearch) {\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Search();\n    $bean-&gt;setIndex('my_index');\n    $bean-&gt;setType('my_type');\n    $bean-&gt;setBody(['query' =&gt; ['matchAll' =&gt; []]]);\n    $response = $elasticsearch-&gt;client()-&gt;search($bean)-&gt;getBody();\n    var_dump(json_decode($response, true));\n});\nx-pack 验证\n当 elasticsearch 开启 x-pack 登录验证时，只需在 config 中再传入用户名密码即可\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host'     =&gt; '127.0.0.1',\n    'port'     =&gt; 9200,\n    'username' =&gt; 'elastic',\n    'password' =&gt; '123456'\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n修改 http 为 https\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host'     =&gt; '127.0.0.1',\n    'port'     =&gt; 9200,\n    'username' =&gt; 'elastic',\n    'password' =&gt; '123456',\n    'scheme'   =&gt; 'https'\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);","link":"/Components/ElasticSearch/install.html"},{"id":322,"title":"插入","content":"ElasticSearch 协程客户端 - 插入文档\n单条插入文档用法\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function () use ($elasticsearch) {\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Create();\n    $bean-&gt;setIndex('my_index');\n    $bean-&gt;setType('my_type');\n    $bean-&gt;setId('my_id');\n    $bean-&gt;setBody(['test_field' =&gt; 'test_data']);\n    $response = $elasticsearch-&gt;client()-&gt;create($bean)-&gt;getBody();\n    $response = json_decode($response, true);\n    var_dump($response['result']);\n});\n批量插入文档用法\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function () use ($elasticsearch) {\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Bulk();\n    $bean-&gt;setIndex('my_index');\n    $bean-&gt;setType('my_type');\n\n    $body = [];\n    for ($i = 1; $i &lt;= 5; $i++) {\n        $body[] = [\n            'create' =&gt; [\n                '_index' =&gt; 'my-index',\n                '_type' =&gt; 'my-type',\n                '_id' =&gt; $i * 1000\n            ]\n        ];\n        $body[] = [\n            'test-field' =&gt; 'test-data',\n        ];\n    }\n\n    $bean-&gt;setBody($body);\n    $response = $elasticsearch-&gt;client()-&gt;bulk($bean)-&gt;getBody();\n    $response = json_decode($response, true);\n    var_dump($response);\n});","link":"/Components/ElasticSearch/create.html"},{"id":323,"title":"删除","content":"ElasticSearch 协程客户端 - 删除文档\n根据 id 删除文档用法\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function () use ($elasticsearch) {\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Delete();\n    $time = time();\n    $bean-&gt;setIndex('my-index-' . $time);\n    $bean-&gt;setId('my-id-' . $time);\n    $response = $elasticsearch-&gt;client()-&gt;delete($bean)-&gt;getBody();\n    $response = json_decode($response, true);\n    var_dump($response);\n});\n根据 query 删除文档用法\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function () use ($elasticsearch) {\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\DeleteByQuery();\n    $time = time();\n    $bean-&gt;setIndex('my-index-' . $time);\n    $bean-&gt;setBody([\n        'query' =&gt; [\n            'match' =&gt; ['name' =&gt; '测试删除']\n        ]\n    ]);\n    $response = $elasticsearch-&gt;client()-&gt;deleteByQuery($bean)-&gt;getBody();\n    $response = json_decode($response, true);\n    var_dump($response);\n});","link":"/Components/ElasticSearch/delete.html"},{"id":324,"title":"修改","content":"ElasticSearch 协程客户端 - 修改文档\n根据 id 修改文档用法\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function () use ($elasticsearch) {\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Update();\n    $bean-&gt;setIndex('my-index');\n    $bean-&gt;setType('my-type');\n    $bean-&gt;setId('my-id');\n    $bean-&gt;setBody([\n        'doc' =&gt; [\n            'test-field' =&gt; 'abd'\n        ]\n    ]);\n    $response = $elasticsearch-&gt;client()-&gt;update($bean)-&gt;getBody();\n    $response = json_decode($response, true);\n    var_dump($response);\n});\n根据 query 修改文档用法\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function () use ($elasticsearch) {\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\UpdateByQuery();\n    $bean-&gt;setIndex('my-index');\n    $bean-&gt;setType('my-type');\n    $bean-&gt;setBody([\n        'query' =&gt; [\n            'match' =&gt; ['test-field' =&gt; 'abd']\n        ],\n        'script' =&gt; [\n            'source' =&gt; 'ctx._source[\"test-field\"]=\"testing\"'\n        ]\n    ]);\n    $response = $elasticsearch-&gt;client()-&gt;updateByQuery($bean)-&gt;getBody();\n    $response = json_decode($response, true);\n    var_dump($response);\n});\nReindex 用法\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function () use ($elasticsearch) {\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Reindex();\n    $bean-&gt;setBody([\n        'source' =&gt; [\n            'index' =&gt; 'my-index'\n        ],\n        'dest' =&gt; [\n            'index' =&gt; 'my-index-new'\n        ]\n    ]);\n    $response = $elasticsearch-&gt;client()-&gt;reindex($bean)-&gt;getBody();\n    $response = json_decode($response, true);\n    var_dump($response);\n});","link":"/Components/ElasticSearch/update.html"},{"id":325,"title":"查询","content":"ElasticSearch 协程客户端 - 查询文档\n查询\n根据 文档ID 查询 document 用法\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function () use ($elasticsearch) {\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Get();\n    $bean-&gt;setIndex('my-index');\n    $bean-&gt;setType('my-type');\n    $bean-&gt;setId('my-id');\n    $response = $elasticsearch-&gt;client()-&gt;get($bean)-&gt;getBody();\n    var_dump(json_decode($response, true));\n});\n根据 文档ID 批量查询 document 用法\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function () use ($elasticsearch) {\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Mget();\n    $bean-&gt;setIndex('my-index');\n    $bean-&gt;setType('my-type');\n    $bean-&gt;setBody(['ids' =&gt; ['my-id', '1']]);\n    $response = $elasticsearch-&gt;client()-&gt;mget($bean)-&gt;getBody();\n    var_dump(json_decode($response, true));\n});\n根据 文档ID 查询 source 用法\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function () use ($elasticsearch) {\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Get();\n    $bean-&gt;setIndex('my-index');\n    $bean-&gt;setType('my-type');\n    $bean-&gt;setId('my-id');\n    $response = $response = $elasticsearch-&gt;client()-&gt;getSource($bean)-&gt;getBody();\n    var_dump(json_decode($response, true));\n});\nquery 查询用法\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function () use ($elasticsearch) {\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Search();\n    $bean-&gt;setIndex('my-index');\n    $bean-&gt;setType('my-type');\n    $bean-&gt;setBody(['query' =&gt; ['match' =&gt; ['test-field' =&gt; 'ab']]]);\n    $response = $elasticsearch-&gt;client()-&gt;search($bean)-&gt;getBody();\n    var_dump(json_decode($response, true));\n});\n查询总数用法\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function () use ($elasticsearch) {\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Count();\n    $response = $elasticsearch-&gt;client()-&gt;count($bean)-&gt;getBody();\n    $response = json_decode($response, true);\n    var_dump($response['count']);\n});\nscroll 分页查询用法\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function () use ($elasticsearch) {\n    $sBean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Search();\n    $sBean-&gt;setIndex('my-index');\n    $sBean-&gt;setScroll('1m');\n    $sBean-&gt;setBody([\n        'query' =&gt; [\n            'match' =&gt; [\n                'test-field' =&gt; 'abd'\n            ]\n        ],\n        'sort' =&gt; ['_doc'],\n        'size' =&gt; 1\n    ]);\n    $sResponse = $elasticsearch-&gt;client()-&gt;search($sBean)-&gt;getBody();\n    $sResponse = json_decode($sResponse, true);\n\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Scroll();\n    $bean-&gt;setScrollId($sResponse['_scroll_id']);\n    $bean-&gt;setScroll('1m');\n    $response = $elasticsearch-&gt;client()-&gt;scroll($bean)-&gt;getBody();\n    var_dump(json_decode($response, true));\n});\ntemplate 查询用法\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function () use ($elasticsearch) {\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\SearchTemplate();\n    $bean-&gt;setIndex('my-index');\n    $bean-&gt;setType('my-type');\n    $bean-&gt;setBody([\n        'inline' =&gt;\n            [\n                'query' =&gt;\n                    [\n                        'match' =&gt; [\"{{field}}\" =&gt; \"{{value}}\"]\n                    ]\n            ],\n        'params' =&gt;\n            [\n                'field' =&gt; 'test-field',\n                'value' =&gt; '博客'\n            ]\n    ]);\n    $response = $elasticsearch-&gt;client()-&gt;searchTemplate($bean)-&gt;getBody();\n    var_dump(json_decode($response, true));\n});\ntermVectors 用法\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function () use ($elasticsearch) {\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\TermVectors();\n    $bean-&gt;setIndex('my-index');\n    $bean-&gt;setType('my-type');\n    $bean-&gt;setId('my-id');\n    $bean-&gt;setPretty(true);\n    $bean-&gt;setBody([\n        'fields' =&gt; ['test-field'],\n        'offsets' =&gt; true,\n        'payloads' =&gt; true,\n        'positions' =&gt; true,\n        \"term_statistics\" =&gt; true,\n        \"field_statistics\" =&gt; true\n    ]);\n    $response = $elasticsearch-&gt;client()-&gt;termvectors($bean)-&gt;getBody();\n    var_dump(json_decode($response, true));\n});\n分片信息查询用法\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function () use ($elasticsearch) {\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\SearchShards();\n    $bean-&gt;setIndex('my-index');\n    $response = $elasticsearch-&gt;client()-&gt;searchShards($bean)-&gt;getBody();\n    $response = json_decode($response, true);\n    var_dump($response);\n});\n节点状态获取用法\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function () use ($elasticsearch) {\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Info();\n    $response = $elasticsearch-&gt;client()-&gt;info($bean)-&gt;getBody();\n    $response = json_decode($response, true);\n    var_dump($response);\n});","link":"/Components/ElasticSearch/search.html"},{"id":326,"title":"分析","content":"ElasticSearch 协程客户端 - 分析文档\n分析\nfield 分析用法\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function () use ($elasticsearch) {\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\FieldCaps();\n    $bean-&gt;setIndex('my-index');\n    $bean-&gt;setFields('test-field');\n\n    $response = $elasticsearch-&gt;client()-&gt;fieldCaps($bean)-&gt;getBody();\n    $response = json_decode($response, true);\n    var_dump($response);\n});\nquery 分析用法\n&lt;?php\n$config = new \\EasySwoole\\ElasticSearch\\Config([\n    'host' =&gt; '127.0.0.1',\n    'port' =&gt; 9200\n]);\n\n$elasticsearch = new \\EasySwoole\\ElasticSearch\\ElasticSearch($config);\n\ngo(function () use ($elasticsearch) {\n    $bean = new \\EasySwoole\\ElasticSearch\\RequestBean\\Explain();\n    $bean-&gt;setIndex('my-index');\n    $bean-&gt;setId('my-id');\n    $bean-&gt;setBody([\n        'query' =&gt; [\n            'bool' =&gt; [\n                'must' =&gt; [\n                    ['match' =&gt;\n                        [\n                            'test-field' =&gt; 'abd'\n                        ]\n                    ]\n                ]\n\n            ]\n        ]\n    ]);\n    $response = $elasticsearch-&gt;client()-&gt;explain($bean)-&gt;getBody();\n    $response = json_decode($response, true);\n    var_dump($response);\n});","link":"/Components/ElasticSearch/analysis.html"},{"id":327,"title":"splarray","content":"SplArray\n用于处理数组封装的基础工具\n相关class位置\n\nSplArray\n\n\nnamespace: EasySwoole\\Spl\\SplArray\n\n\n\n\nSplArray相关方法\n方法列表\n\n\n\n方法名称\n参数\n说明\n备注\n\n\n\n\nset\n$key,$value\n设置参数\n\n\n\nget\n$key\n获取参数\n\n\n\n__toString\n\n转字符\n\n\n\ngetArrayCopy\n\n数组赋值\n\n\n\nunset\n$key\n销毁数组元素\n\n\n\ndelete\n$key\n去除某个数据项\n\n\n\nunique\n\n数组值唯一\n\n\n\nmultiple\n\n获取数组中重复的值\n\n\n\nasort\n\n进行排序并保持索引关系\n\n\n\nksort\n\n按照键名排序\n\n\n\nsort\n$sort_flags = SORT_REGULAR\n自定义排序\n\n\n\ncolumn\n$key\n取得某一列\n\n\n\nflip\n\n交换数组中的键和值\n\n\n\nfilter\n$key,[$key2....],$bool\n过滤数组数据\n\n\n\nkeys\n$key\n获取数组索引\n\n\n\nvalues\n\n获取数组中所有的值\n\n\n\nflush\n\n清空数据\n\n\n\nloadArray\n$data\n重新加载数据\n\n\n\ntoXML\n\n转化成xml\n\n\n\n\n基本使用\n/**\n *\n * User: LuffyQAQ\n * Date: 2019/10/16 16:02\n * Email: &lt;1769360227@qq.com&gt;\n */\ninclude \"./vendor/autoload.php\";\n\n$data = [\n    'fruit' =&gt; [\n        'apple' =&gt; 2,\n        'orange' =&gt; 1,\n        'grape' =&gt; 4\n    ],\n    'color' =&gt; [\n        'red' =&gt; 12,\n        'blue' =&gt; 8,\n        'green' =&gt; 6\n    ],\n    'name' =&gt; [\n        'name1' =&gt; '北溟有鱼QAQ',\n        'name2' =&gt; '北溟有鱼QAQ'\n    ]\n];\n$splArray = new \\EasySwoole\\Spl\\SplArray($data);\n\n$splArray-&gt;set('fruit.apple', 3);\n\nvar_dump($splArray);\n\nvar_dump($splArray-&gt;get('fruit.apple'));\n\nvar_dump($splArray-&gt;__toString());\n\nvar_dump($splArray-&gt;getArrayCopy());\n\nvar_dump($splArray-&gt;unset('color'));\n\nvar_dump($splArray-&gt;delete('fruit.apple'));\n\nvar_dump($splArray-&gt;unique()-&gt;getArrayCopy());\n\nvar_dump($splArray-&gt;multiple()-&gt;getArrayCopy());\n\nvar_dump($splArray-&gt;asort()-&gt;getArrayCopy());\n\nvar_dump($splArray-&gt;ksort()-&gt;getArrayCopy());\n\nvar_dump($splArray-&gt;sort()-&gt;getArrayCopy());\n\nvar_dump($splArray-&gt;column('name')-&gt;getArrayCopy());\n\n$splArrays = new \\EasySwoole\\Spl\\SplArray(['es' =&gt; 'easyswoole']);\n\nvar_dump($splArrays-&gt;flip()-&gt;getArrayCopy());\n\nvar_dump($splArray-&gt;filter('green,grape', false)-&gt;getArrayCopy());\n\nvar_dump($splArray-&gt;filter('green,grape', true)-&gt;getArrayCopy());\n\nvar_dump($splArray-&gt;keys('name'));\n\nvar_dump($splArray-&gt;values()-&gt;getArrayCopy());\n\nvar_dump($splArray-&gt;flush()-&gt;getArrayCopy());\n\nvar_dump($splArray-&gt;loadArray(['name' =&gt; 'easyswoole'])-&gt;getArrayCopy());\n\nvar_dump($splArray-&gt;toXML());\n","link":"/Components/Spl/splArray.html"},{"id":328,"title":"splbean","content":"SplBean\n用于定义表结构，过滤掉无效字段数据。\n相关class位置\n\nSplBean\n\n\nnamespace: EasySwoole\\Spl\\SplBean\n\n\n\n\nSplBean相关方法\n方法列表\n\n\n\n方法名称\n参数\n说明\n备注\n\n\n\n\n__construct\narray $data = null,$autoCreateProperty = false\n构造函数，初始化bean数据\n\n\n\nallProperty\n\n过滤并转换成数组数据\n\n\n\ntoArray\narray $columns = null,$filter = null\n转字符\n\n\n\ntoArrayWithMapping\narray $columns = null,$filter = null\n获取过滤后带有字段别名的数组数据\n\n\n\narrayToBean\narray $data,$autoCreateProperty = false\n设置类属性\n\n\n\naddProperty\n$name,$value = null\n设置类成员变量\n\n\n\ngetProperty\n$name\n获取类成员变量值\n\n\n\njsonSerialize\n\n获取类成员变量集合\n\n\n\ninitialize\n\n初始化操作\n\n\n\nsetKeyMapping\n\n设置keyMapping关系，也就是字段别名\n\n\n\nsetClassMapping\n\n设置classMapping关系，也就是关联类\n\n\n\nrestore\narray $data = [], $autoCreateProperty = false\n重新初始化bean数据\n\n\n\nclassMap\n\n绑定关联类\n\n\n\n\n基本使用\n\n/**\n *\n * User: LuffyQAQ\n * Date: 2019/10/16 16:45\n * Email: &lt;1769360227@qq.com&gt;\n */\ninclude \"./vendor/autoload.php\";\nuse EasySwoole\\Spl\\SplBean;\n\nclass TestBean extends SplBean\n{\n    public $a = 2;\n    protected $b;\n    private $c;\n    protected $d_d;\n\n    protected function setKeyMapping(): array\n    {\n        return [\n            'd-d' =&gt; \"d_d\"\n        ];\n    }\n}\n\n$bean = new TestBean([\n    'a'=&gt;'a',\n    'b'=&gt;'b',\n    'c'=&gt;'c',\n    'd_d'=&gt;'d_d'\n]);\n\nvar_dump($bean-&gt;allProperty());\n\n$data = $bean-&gt;toArray(null, function ($a) {\n    if (in_array($a, ['d_d'])) {\n        return $a;\n    }\n});\n\n$bean = new TestBean([\n    'a'=&gt;1,\n    'b'=&gt;2,\n    'c'=&gt;3,\n    'd_d'=&gt;4\n]);\n$data = $bean-&gt;toArrayWithMapping(['a', 'b', 'd-d'], function ($val) {\n    return $val;\n});\n\nvar_dump($data);\n\nvar_dump($bean-&gt;toArrayWithMapping(['a','d-d']));\n\n$bean = new TestBean();\n$bean-&gt;addProperty('a', 'es');\n$bean-&gt;addProperty('b', 'es');\n$bean-&gt;addProperty('d_d', 'es');\n\nvar_dump($bean-&gt;toArray());\n\nvar_dump($bean-&gt;getProperty('a'));\n\nvar_dump( $bean-&gt;jsonSerialize());\n\nvar_dump($bean-&gt;restore()-&gt;toArray());\n","link":"/Components/Spl/splBean.html"},{"id":329,"title":"splenum","content":"SplEnum\n用于定义枚举一个集合，规范化枚举数据。\n相关class位置\n\nSplEnum\n\n\nnamespace: EasySwoole\\Spl\\SplEnum\n\n\n\n\nSplEnum相关方法\n方法列表\n\n\n\n方法名称\n参数\n说明\n备注\n\n\n\n\n__construct\n$val\n构造函数\n\n\n\ngetName\n\n获取定义常量的键\n\n\n\ngetValue\n\n获取定义常量\n\n\n\nisValidName\nstring $name\n查找常量的键值是否有效\n\n\n\nisValidValue\n$val\n查找常量的值是否有效\n\n\n\ngetEnumList\n\n获取枚举集合\n\n\n\ngetConstants\n\n获取枚举集合\n\n\n\n\n基本使用\n/**\n *\n * User: luffyQAQ\n * Date: 2019/10/16 17:08\n * Email: &lt;1769360227@qq.com&gt;\n */\n\ninclude \"./vendor/autoload.php\";\n\nclass Month extends \\EasySwoole\\Spl\\SplEnum {\n    const JANUARY = 1;\n    const FEBRUARY = 2;\n    const MARCH = 3;\n    const APRIL = 4;\n    const MAY = 5;\n    const JUNE = 6;\n    const JULY = 7;\n    const AUGUST = 8;\n    const SEPTEMBER = 9;\n    const OCTOBER = 10;\n    const NOVEMBER = 11;\n    const DECEMBER = 12;\n}\n$month = new Month(1);\n\nvar_dump($month-&gt;getName());\n\nvar_dump($month-&gt;getValue());\n\nvar_dump(Month::isValidName('JANUARY'));\n\nvar_dump(Month::isValidValue(1));\n\nvar_dump( Month::getEnumList());\n","link":"/Components/Spl/splEnum.html"},{"id":330,"title":"splstream","content":"SplStream\n资源流数据操作\n相关class位置\n\nSplStream\n\n\nnamespace: EasySwoole\\Spl\\SplStream\n\n\n\n\nSplStream相关方法\n\n\n\n方法名称\n参数\n说明\n\n\n\n\n__construct\n$resource = '',$mode = 'r+'\n初始化资源和读写操作\n\n\n__toString\n\n输出资源\n\n\nclose\n\n关闭一个打开的文件指针\n\n\ndetach\n\n获取资源并重置资源对象\n\n\ngetSize\n获取资源大小\n编码转换\n\n\ntell\n\n返回文件指针读/写的位置\n\n\neof\n\n文件指针是否到了文件结束的位置\n\n\nisSeekable\n\n获取是否可以在当前流中定位\n\n\nseek\n$offset, $whence = SEEK_SET\n在文件指针中定位\n\n\nrewind\n\n倒回文件指针的位置\n\n\nisWritable\n\n是否可写\n\n\nwrite\n$string\n写入内容\n\n\nisReadable\n\n是否可读\n\n\nread\n$length\n读取内容\n\n\nlength\n\n获取字符串长度\n\n\ngetContents\n\n读取资源流到一个字符串\n\n\ngetMetadata\n$key = null\n从封装协议文件指针中取得报头／元数据\n\n\ngetStreamResource\n\n获取资源\n\n\ntruncate\n$size = 0\n将文件截断到给定的长度\n\n\n\n基本使用\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-7-2\n * Time: 上午10:25\n */\n\nrequire_once 'vendor/autoload.php';\n\n//初始化资源和读写操作\n$resource = fopen('./test.txt', 'ab+');\n$stream = new \\EasySwoole\\Spl\\SplStream($resource);\nvar_dump($stream-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(10) \"Easyswoole\"\n */\n\n//输出资源\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\nvar_dump($stream-&gt;__toString());\n/**\n * 输出结果过：\n * string(10) \"Easyswoole\"\n */\n\n//关闭一个打开的文件指针\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$stream-&gt;close();\nvar_dump($stream-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(0) \"\"\n */\n\n//获取资源并重置资源对象\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$stream-&gt;detach();\nvar_dump($stream-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(0) \"\"\n */\n\n//获取资源大小\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$size = $stream-&gt;getSize();\nvar_dump($size);\n\n/**\n * 输出结果过：\n * int(10)\n */\n\n//返回文件指针读/写的位置\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$position = $stream-&gt;tell();\nvar_dump($position);\n\n/**\n * 输出结果过：\n * int(10)\n */\n\n//文件指针是否到了文件结束的位置\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$eof = $stream-&gt;eof();\nvar_dump($eof);\n$stream-&gt;detach();\n$eof = $stream-&gt;eof();\nvar_dump($eof);\n\n/**\n * 输出结果过：\n * bool(false)\n * bool(true)\n */\n\n//获取是否可以在当前流中定位\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$seekable = $stream-&gt;isSeekable();\nvar_dump($seekable);\n\n/**\n * 输出结果过：\n * bool(true)\n */\n\n//在文件指针中定位\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$stream-&gt;seek(2);\n$position = $stream-&gt;tell();\nvar_dump($position);\n\n/**\n * 输出结果过：\n * int(2)\n */\n\n//倒回文件指针的位置\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$stream-&gt;rewind();\n$position = $stream-&gt;tell();\nvar_dump($position);\n\n/**\n * 输出结果过：\n * int(0)\n */\n\n//是否可写\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$writeAble = $stream-&gt;isWritable();\nvar_dump($writeAble);\n\n/**\n * 输出结果过：\n * bool(true)\n */\n\n//写入内容\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$stream-&gt;write(', 666');\nvar_dump($stream-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(15) \"Easyswoole, 666\"\n */\n\n//是否可读\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$readAble = $stream-&gt;isReadable();\nvar_dump($readAble);\n\n/**\n * 输出结果过：\n * bool(true)\n */\n\n//读取内容\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$stream-&gt;rewind();\n$string = $stream-&gt;read(4);\nvar_dump($string);\n\n/**\n * 输出结果过：\n * string(4) \"Easy\"\n */\n\n//读取资源流到一个字符串\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$stream-&gt;rewind();\n$string = $stream-&gt;getContents();\nvar_dump($string);\n\n/**\n * 输出结果过：\n * string(10) \"Easyswoole\"\n */\n\n//从封装协议文件指针中取得报头／元数据\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$meta = $stream-&gt;getMetadata();\nvar_dump($meta['stream_type']);\n\n/**\n * 输出结果过：\n * string(6) \"MEMORY\"\n */\n\n//获取资源\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$resource = $stream-&gt;getStreamResource();\nfseek($resource, 0, SEEK_SET);\nvar_dump(stream_get_contents($resource));\n\n/**\n * 输出结果过：\n * string(10) \"Easyswoole\"\n */\n\n//将文件截断到给定的长度\n$stream = new \\EasySwoole\\Spl\\SplStream('Easyswoole');\n$stream-&gt;truncate(4);\nvar_dump($stream-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(4) \"Easy\"\n */\n\nps: 资源和资源流是有区别的,这里说的资源也就是数据或是变量,资源流是一种文件流。","link":"/Components/Spl/splStream.html"},{"id":331,"title":"splfilestream","content":"SplFileStream\n文件资源流数据操作\n相关class位置\n\nSplFileStream\n\n\nnamespace: EasySwoole\\Spl\\SplFileStream\n\n\n\n\nSplFileStream相关方法\n\n\n\n方法名称\n参数\n说明\n\n\n\n\n__construct\n$file,$mode = 'c+'\n初始化资源和读写操作\n\n\nlock\n$mode = LOCK_EX\n文件锁定\n\n\nunlock\n$mode = LOCK_UN\n释放锁定\n\n\n\nSplFileStream类继承SplStream，其他相关方法参考SplStream。\n基本使用\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-7-2\n * Time: 上午10:25\n */\n\nrequire_once 'vendor/autoload.php';\n\n$fileStream = new \\EasySwoole\\Spl\\SplFileStream('./test.txt');\n$type = $fileStream-&gt;getMetadata('stream_type');\nvar_dump($type);\n\n/**\n * 输出结果过：\n * string(5) \"STDIO\"\n */\n\n$fileStream = new \\EasySwoole\\Spl\\SplFileStream('./test.txt');\n$lock = $fileStream-&gt;lock();\nvar_dump($lock);\n\n/**\n * 输出结果过：\n * bool(true)\n */\n\n$fileStream = new \\EasySwoole\\Spl\\SplFileStream('./test.txt');\n$unlock = $fileStream-&gt;unlock();\nvar_dump($unlock);\n\n/**\n * 输出结果过：\n * bool(true)\n */\n","link":"/Components/Spl/splFileStream.html"},{"id":332,"title":"splstring","content":"SplString\n用于处理字符串。\n相关class位置\n\nSplString\n\n\nnamespace: EasySwoole\\Spl\\SplString\n\n\n\n\nSplString相关方法\n\n\n\n方法名称\n参数\n说明\n\n\n\n\nsetString\nstring $string\n设置字符串\n\n\nsplit\nint $length = 1\n按长度分割字符串\n\n\nexplode\nstring $delimiter\n按分隔符分割字符串\n\n\nsubString\nint $start, int $length\n截取字符串\n\n\nencodingConvert\nstring $desEncoding, $detectList = ['UTF-8', 'ASCII', 'GBK',...]\n编码转换\n\n\nutf8\n\n转成utf\n\n\nunicodeToUtf8\n\n将unicode编码转成utf-8\n\n\ntoUnicode\n\n转成unicode编码(秒)\n\n\ncompare\nstring $str, int $ignoreCase = 0\n二进制字符串比较\n\n\nlTrim\nstring $charList = &quot; \\t\\n\\r\\0\\x0B&quot;\n删除字符串开头的空白字符（或其他字符）\n\n\nrTrim\nstring $charList = &quot; \\t\\n\\r\\0\\x0B&quot;\n删除字符串末端的空白字符（或者其他字符）\n\n\ntrim\nstring $charList = &quot; \\t\\n\\r\\0\\x0B&quot;\n去除字符串首尾处的空白字符（或者其他字符）\n\n\npad\nint $length, string $padString = null, int $pad_type = STR_PAD_RIGHT\n使用另一个字符串填充字符串为指定长度\n\n\nrepeat\nint $times\n重复一个字符串\n\n\nlength\n\n获取字符串长度\n\n\nupper\n\n将字符串转化为大写\n\n\nlower\n\n将字符串转化为小写\n\n\nstripTags\nstring $allowable_tags = null\n从字符串中去除 HTML 和 PHP 标记1\n\n\nreplace\nstring $find, string $replaceTo\n子字符串替换\n\n\nbetween\nstring $startStr, string $endStr\n获取指定目标的中间字符串\n\n\nregex\n$regex, bool $rawReturn = false\n按照正则规则查找字符串\n\n\nexist\nstring $find, bool $ignoreCase = true\n是否存在指定字符串\n\n\nkebab\n\n转换为烤串\n\n\nsnake\nstring $delimiter = '_'\n转为蛇的样子\n\n\nstudly\n\n驼峰\n\n\ncamel\n\n小驼峰\n\n\nreplaceArray\nstring $search, array $replace\n依次替换字符串\n\n\nreplaceFirst\nstring $search, string $replace\n替换字符串中给定值的第一次出现\n\n\nreplaceLast\nstring $search, string $replace\n替换字符串中给定值的最后一次出现\n\n\nstart\nstring $prefix\n以一个给定值的单一实例开始一个字符串\n\n\nafter\nstring $search\n在给定的值之后返回字符串的其余部分\n\n\nbefore\nstring $search\n在给定的值之前获取字符串的一部分\n\n\nendsWith\n$needles\n确定给定的字符串是否以给定的子字符串结束\n\n\nstartsWith\n$needles\n确定给定的字符串是否从给定的子字符串开始\n\n\n\n基础使用\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 上午10:10\n */\n\nrequire './vendor/autoload.php';\n\n//设置字符串\n$string = new \\EasySwoole\\Spl\\SplString();\nvar_dump($string-&gt;setString('Hello, EasySwoole')-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(17) \"Hello, EasySwoole\"\n */\n\n//设置数组中某项的值\n$string = new \\EasySwoole\\Spl\\SplString('Hello, EasySwoole');\nvar_dump($string-&gt;split(5)-&gt;getArrayCopy());\n\n/**\n * 输出结果过：\n * array(4) {\n *   [0]=&gt;\n *   string(5) \"Hello\"\n *   [1]=&gt;\n *   string(5) \", Eas\"\n *   [2]=&gt;\n *   string(5) \"ySwoo\"\n *   [3]=&gt;\n *   string(2) \"le\"\n * }\n */\n\n//分割字符串\n$string = new \\EasySwoole\\Spl\\SplString('Hello, EasySwoole');\nvar_dump($string-&gt;explode(',')-&gt;getArrayCopy());\n\n/**\n * 输出结果过：\n * array(2) {\n *   [0]=&gt;\n *   string(5) \"Hello\"\n *   [1]=&gt;\n *   string(11) \" EasySwoole\"\n * }\n */\n\n//截取字符串\n$string = new \\EasySwoole\\Spl\\SplString('Hello, EasySwoole');\nvar_dump($string-&gt;subString(0, 5)-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(5) \"Hello\"\n */\n\n//编码转换\n$string = new \\EasySwoole\\Spl\\SplString('Hello, EasySwoole');\nvar_dump($string-&gt;encodingConvert('UTF-8')-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(17) \"Hello, EasySwoole\"\n }\n\n */\n\n//转成utf-8\n$string = new \\EasySwoole\\Spl\\SplString('Hello, EasySwoole');\nvar_dump($string-&gt;utf8()-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(17) \"Hello, EasySwoole\"\n }\n\n */\n\n//将unicode编码转成utf-8\n$str = '\\u4e2d';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;unicodeToUtf8()-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(3) \"中\"\n */\n\n//转成unicode编码\n$str = '中';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;toUnicode()-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(6) \"\\U4E2D\"\n */\n\n//二进制字符串比较\n$str = 'test';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;compare('apple'));\n\n/**\n * 输出结果过：\n * int(19)\n */\n\n//删除字符串开头的空白字符（或其他字符）\n$str = '  test';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;lTrim()-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(4) \"test\"\n */\n\n//删除字符串末端的空白字符（或者其他字符）\n$str = 'test  ';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;rTrim()-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(4) \"test\"\n */\n\n//去除字符串首尾处的空白字符（或者其他字符）\n$str = '  test  ';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;trim()-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(4) \"test\"\n */\n\n//使用另一个字符串填充字符串为指定长度\n$str = 'test';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;pad(5, 'game')-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(5) \"testg\"\n */\n\n//重复一个字符串\n$str = 'test';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;repeat(2)-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(8) \"testtest\"\n */\n\n//获取字符串长度\n$str = 'test';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;length());\n\n/**\n * 输出结果过：\n * int(4)\n */\n\n//将字符串转化为大写\n$str = 'test';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;upper()-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(4) \"TEST\"\n */\n\n//将字符串转化为小写\n$str = 'test';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;lower()-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(4) \"test\"\n */\n\n//从字符串中去除 HTML 和 PHP 标记\n$str = '&lt;a&gt;test&lt;/a&gt;';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;stripTags()-&gt;__toString());\n\n/**\n* 输出结果过：\n * string(4) \"test\"\n */\n\n//字符串替换\n$str = 'test';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;replace('t', 's')-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(4) \"sess\"\n */\n\n//获取指定目标的中间字符串\n$str = 'easyswoole';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;between('easy', 'le')-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(4) \"swoo\"\n */\n\n//按照正则规则查找字符串\n$str = 'easyswoole';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;regex('/swoole/'));\n\n/**\n * 输出结果过：\n * string(6) \"swoole\"\n */\n\n//是否存在指定字符串\n$str = 'easyswoole';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;exist('Swoole', true));\n\n/**\n * 输出结果过：\n * bool(true)\n */\n\n//转换为-连接的字符串\n$str = 'EasySwoole';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;kebab()-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(11) \"easy-swoole\"\n */\n\n//转为蛇的样子\n$str = 'EasySwoole';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;snake()-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(11) \"easy_swoole\"\n */\n\n//转换为驼峰\n$str = 'easy_swoole';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;studly()-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(10) \"EasySwoole\"\n */\n\n//转换为小驼峰\n$str = 'easy_swoole';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;camel()-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(10) \"easySwoole\"\n */\n\n//给数组每个元素替换字符串\n$str = 'easy_swoole';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;replaceArray('easy', ['as', 'bs', 'cs'])-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(9) \"as_swoole\"\n */\n\n//替换字符串中给定值的第一次出现\n$str = 'easy_swoole_easy';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;replaceFirst('easy', 'as')-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(14) \"as_swoole_easy\"\n */\n\n//替换字符串中给定值的最后一次出现\n$str = 'easy_swoole_easy';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;replaceLast('easy', 'as')-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(14) \"easy_swoole_as\"\n */\n\n//以一个给定值的单一实例开始一个字符串\n$str = 'EasySwoole';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;start('Hello,')-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(16) \"Hello,EasySwoole\"\n */\n\n//在给定的值之后返回字符串的其余部分\n$str = 'EasySwoole';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;after('Easy')-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(6) \"Swoole\"\n */\n\n//在给定的值之前获取字符串的一部分\n$str = 'EasySwoole';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;before('Swoole')-&gt;__toString());\n\n/**\n * 输出结果过：\n * string(4) \"Easy\"\n */\n\n//确定给定的字符串是否以给定的子字符串结束\n$str = 'EasySwoole';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;endsWith('Swoole'));\n\n/**\n * 输出结果过：\n * bool(true)\n */\n\n//确定给定的字符串是否从给定的子字符串开始\n$str = 'EasySwoole';\n$string = new \\EasySwoole\\Spl\\SplString($str);\nvar_dump($string-&gt;startsWith('Easy'));\n\n/**\n * 输出结果过：\n * bool(true)\n */\n","link":"/Components/Spl/splString.html"},{"id":333,"title":"连接池","content":"通用连接池\nEasySwoole通用的协程连接池管理。\n组件要求\n\nphp: &gt;=7.1.0\next-json: *\neasyswoole/component: ^2.2.1\neasyswoole/spl: ^1.3\neasyswoole/utility: ^1.1\n\n安装方法\n\ncomposer require easyswoole/pool\n\n仓库地址\neasyswoole/pool\n池配置\n在实例化一个连接池对象时,需要传入一个连接池配置对象EasySwoole\\Pool\\Config,该对象的属性如下:\n\n\n\n配置项\n默认值\n说明\n备注\n\n\n\n\n$intervalCheckTime\n30*1000\n定时器执行频率\n用于定时执行连接池对象回收,创建操作\n\n\n$maxIdleTime\n15\n连接池对象最大闲置时间(秒)\n超过这个时间未使用的对象将会被定时器回收\n\n\n$maxObjectNum\n20\n连接池最大数量\n每个进程最多会创建$maxObjectNum连接池对象,如果对象都在使用,则会返回空,或者等待连接空闲\n\n\n$minObjectNum\n5\n连接池最小数量(热启动)\n当连接池对象总数低于$minObjectNum时,会自动创建连接,保持连接的活跃性,让控制器能够尽快的获取连接\n\n\n$getObjectTimeout\n3.0\n获取连接池的超时时间\n当连接池为空时,会等待$getObjectTimeout秒,如果期间有连接空闲,则会返回连接对象,否则返回null\n\n\n$extraConf\n\n额外配置信息\n在实例化连接池前,可把一些额外配置放到这里,例如数据库配置信息,redis配置等等\n\n\n$loadAverageTime\n0.001\n负载阈值\n并发来临时，连接池内对象达到 maxObejctNum，此时并未达到 intervaklCheckTime 周期检测，因此设定一个 5s 负载检测，当 5s 内，取出总时间/取出连接总次数，会得到一个平均取出时间，如果小于此阈值，说明此次并发峰值非持续性，将回收 5% 的连接\n\n\n\n池管理器\n池管理器可以做全局的连接池管理,例如在EasySwooleEvent.php中的initialize中注册,然后可以在控制器中获取连接池进行获取连接:\npublic static function initialize()\n{\n    // TODO: Implement initialize() method.\n    date_default_timezone_set('Asia/Shanghai');\n\n    $config = new \\EasySwoole\\Pool\\Config();\n\n    $redisConfig1 = new \\EasySwoole\\Redis\\Config\\RedisConfig(Config::getInstance()-&gt;getConf('REDIS1'));\n    $redisConfig2 = new \\EasySwoole\\Redis\\Config\\RedisConfig(Config::getInstance()-&gt;getConf('REDIS2'));\n    //注册连接池管理对象\n    \\EasySwoole\\Pool\\Manager::getInstance()-&gt;register(new \\App\\Pool\\RedisPool($config,$redisConfig1),'redis1');\n    \\EasySwoole\\Pool\\Manager::getInstance()-&gt;register(new \\App\\Pool\\RedisPool($config,$redisConfig2),'redis2');\n\n}\n控制器获取连接池连接:\npublic function index()\n{\n    //取出连接池管理对象,并getObj\n\n    $redis1=\\EasySwoole\\Pool\\Manager::getInstance()-&gt;get('redis1')-&gt;getObj();\n    $redis2=\\EasySwoole\\Pool\\Manager::getInstance()-&gt;get('redis1')-&gt;getObj();\n\n    $redis1-&gt;set('name','仙士可');\n    var_dump($redis1-&gt;get('name'));\n\n    $redis2-&gt;set('name','仙士可2号');\n    var_dump($redis2-&gt;get('name'));\n\n    //回收对象\n    \\EasySwoole\\Pool\\Manager::getInstance()-&gt;get('redis1')-&gt;recycleObj($redis1);\n    \\EasySwoole\\Pool\\Manager::getInstance()-&gt;get('redis2')-&gt;recycleObj($redis2);\n}\n池对象方法\n\n\n\n方法名称\n参数\n说明\n备注\n\n\n\n\ncreateObject\n\n抽象方法,创建连接对象\n\n\n\nrecycleObj\n$obj\n回收一个连接\n\n\n\ngetObj\nfloat $timeout = null, int $tryTimes = 3\n获取一个连接,超时时间$timeout,尝试获取$tryTimes次\n\n\n\nunsetObj\n$obj\n直接释放一个连接\n\n\n\nidleCheck\nint $idleTime\n回收超过$idleTime未出队使用的连接\n\n\n\nitemIntervalCheck\nObjectInterface $item\n判断当前客户端是否还可用\n\n\n\nintervalCheck\n\n回收连接,以及热启动方法,允许外部调用热启动\n\n\n\nkeepMin\n?int $num = null\n保持最小连接(热启动)\n\n\n\ngetConfig\n\n获取连接池的配置信息\n\n\n\nstatus\n\n获取连接池状态信息\n获取当前连接池已创建,已使用,最大创建,最小创建数据\n\n\nisPoolObject\n$obj\n查看$obj对象是否由该连接池创建\n\n\n\nisInPool\n$obj\n获取当前连接是否在连接池内未使用\n\n\n\ndestroy\n\n销毁该连接池\n\n\n\nreset\n\n重置该连接池\n\n\n\ninvoke\ncallable $call,float $timeout = null\n获取一个连接,传入到$call回调函数中进行处理,回调结束后自动回收连接\n\n\n\ndefer\nfloat $timeout = null\n获取一个连接,协程结束后自动回收\n\n\n\n\ngetObj\n获取一个连接池的对象:\ngo(function (){\n    $redisPool = new \\App\\Pool\\RedisPool(new \\EasySwoole\\Pool\\Config(), new \\EasySwoole\\Redis\\Config\\RedisConfig(\\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf('REDIS')));\n    $redis = $redisPool-&gt;getObj();\n    var_dump($redis-&gt;echo('仙士可'));\n    $redisPool-&gt;recycleObj($redis);\n});\n通过getObj方法获取的对象,都必须调用unsetObj或者recycleObj进行回收,否则连接池对象会越来越少\nunsetObj\n直接释放一个连接池对象,其他协程不能再获取这个连接,而是会重新创建一个连接\n释放之后,并不会立即销毁该对象,而是会在作用域结束之后销毁\nrecycleObj\n回收一个连接对象,回收之后,其他协程可以正常获取这个连接.\n回收之后,其他协程可以正常获取这个连接,但在此时,该连接还处于当前协程中,如果再次调用该连接进行数据操作,将会协程混乱,所以需要开发人员自行约束,当recycleObj不能再操作这个对象\ninvoke\n获取一个连接,传入到$call回调函数中进行处理,回调结束后自动回收连接:\ngo(function (){\n    $redisPool = new \\App\\Pool\\RedisPool(new \\EasySwoole\\Pool\\Config(), new \\EasySwoole\\Redis\\Config\\RedisConfig(\\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf('REDIS')));\n    $redisPool-&gt;invoke(function (\\EasySwoole\\Redis\\Redis $redis){\n        var_dump($redis-&gt;echo('仙士可'));\n    });\n});\n\n通过该方法无需手动回收连接,在回调函数结束后,则自动回收\ndefer\n获取一个连接,协程结束后自动回收\ngo(function () {\n    $redisPool = new \\App\\Pool\\RedisPool(new \\EasySwoole\\Pool\\Config(), new \\EasySwoole\\Redis\\Config\\RedisConfig(\\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf('REDIS')));\n    $redis = $redisPool-&gt;defer();\n    var_dump($redis-&gt;echo('仙士可'));\n});\n通过该方法无需手动回收连接,在协程结束后,则自动回收\n需要注意的事,defer方法是协程结束后才回收,如果你当前协程运行时间过长,则会一直无法回收,直到协程结束\nkeepMin\n保持最小连接(热启动)\n由于easyswoole/pool的\n当一启动服务,出现过大的并发时,可能会突然需要几十上百个连接,这个时候为了使创建连接的时间分散,可以通过调用keepMin进行预热启动连接\n调用此方法后,将会预先创建n个连接,用于服务启动之后的控制器直接获取连接:\n在EasySwooleEvent.php中的mainServerCreate中,当worker进程启动后,热启动连接\n\npublic static function mainServerCreate(EventRegister $register)\n{\n    $register-&gt;add($register::onWorkerStart,function (\\swoole_server $server,int $workerId){\n        if ($server-&gt;taskworker == false) {\n            //每个worker进程都预创建连接\n            \\EasySwoole\\Pool\\Manager::getInstance()-&gt;get('redis')-&gt;keepMin(10);\n            var_dump(\\EasySwoole\\Pool\\Manager::getInstance()-&gt;get('redis')-&gt;status());\n        }\n    });\n\n    // TODO: Implement mainServerCreate() method.\n}\n将会输出:\narray(4) {\n  [\"created\"]=&gt;\n  int(10)\n  [\"inuse\"]=&gt;\n  int(0)\n  [\"max\"]=&gt;\n  int(20)\n  [\"min\"]=&gt;\n  int(5)\n}\nkeepMin是根据不同进程,创建不同的连接的,比如你有10个worker进程,将会输出10次,总共创建10*10=100个连接\ngetConfig\n获取连接池的配置:\n    $redisPool = new \\App\\Pool\\RedisPool(new \\EasySwoole\\Pool\\Config(), new \\EasySwoole\\Redis\\Config\\RedisConfig(\\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf('REDIS')));\n    var_dump($redisPool-&gt;getConfig());\n\ndestroyPool\n销毁连接池\n调用之后,连接池剩余的所有链接都会unsetObj,并且将关闭连接队列,调用之后getObj等方法都将失效:\ngo(function (){\n    $redisPool = new \\App\\Pool\\RedisPool(new \\EasySwoole\\Pool\\Config(), new \\EasySwoole\\Redis\\Config\\RedisConfig(\\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf('REDIS')));\n    var_dump($redisPool-&gt;getObj());\n    $redisPool-&gt;destroyPool();\n    var_dump($redisPool-&gt;getObj());\n});\nreset\n重置连接池,调用reset之后,会自动调用destroyPool销毁连接池,并在下一次getObj时重新初始化该连接池:\ngo(function (){\n    $redisPool = new \\App\\Pool\\RedisPool(new \\EasySwoole\\Pool\\Config(), new \\EasySwoole\\Redis\\Config\\RedisConfig(\\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf('REDIS')));\n    var_dump($redisPool-&gt;getObj());\n    $redisPool-&gt;reset();\n    var_dump($redisPool-&gt;getObj());\n});\nstatus\n获取连接池当前状态,调用之后将输出:\narray(4) {\n  [\"created\"]=&gt;\n  int(10)\n  [\"inuse\"]=&gt;\n  int(0)\n  [\"max\"]=&gt;\n  int(20)\n  [\"min\"]=&gt;\n  int(5)\n}\nidleCheck\n回收空闲超时的连接\nintervalCheck\n调用此方法后,将调用idleCheck和keepMin方法,用于手动回收空闲连接和手动热启动连接\npublic function intervalCheck()\n{\n    $this-&gt;idleCheck($this-&gt;getConfig()-&gt;getMaxIdleTime());\n    $this-&gt;keepMin($this-&gt;getConfig()-&gt;getMinObjectNum());\n}\nitemIntervalCheck\n在内部定时器丢弃超时客户端（闲置了超过指定时间，就先断开）时，会触发itemIntervalCheck函数，并将客户端传入，可以实现用户自己的判断客户端是否可用的逻辑。\n该函数如果返回true代表可用（默认情况） 返回false将会导致该客户端直接丢弃。\n可用于：维持客户端心跳等。如orm中对其使用场景如下：维持mysql连接，减少mysql掉线 gone away的几率\n    /**\n     * @param MysqliClient $item\n     * @return bool\n     */\n    public function itemIntervalCheck($item): bool\n    {\n        /*\n         * 如果最后一次使用时间超过autoPing间隔\n         */\n        /** @var Config $config */\n        $config = $this-&gt;getConfig();\n        if($config-&gt;getAutoPing() &gt; 0 &amp;&amp; (time() - $item-&gt;__lastUseTime &gt; $config-&gt;getAutoPing())){\n            try{\n                //执行一个sql触发活跃信息\n                $item-&gt;rawQuery('select 1');\n                //标记使用时间，避免被再次gc\n                $item-&gt;__lastUseTime = time();\n                return true;\n            }catch (\\Throwable $throwable){\n                //异常说明该链接出错了，return 进行回收\n                return false;\n            }\n        }else{\n            return true;\n        }\n    }\n基本使用\n定义池对象\nclass Std implements \\EasySwoole\\Pool\\ObjectInterface {\n    function gc()\n    {\n        /*\n         * 本对象被pool执行unset的时候\n         */\n    }\n\n    function objectRestore()\n    {\n        /*\n         * 回归到连接池的时候\n         */\n    }\n\n    function beforeUse(): ?bool\n    {\n        /*\n         * 取出连接池的时候，若返回false，则当前对象被弃用回收\n         */\n        return true;\n    }\n\n    public function who()\n    {\n        return spl_object_id($this);\n    }\n}\n定义池\n\nclass StdPool extends \\EasySwoole\\Pool\\AbstractPool{\n\n    protected function createObject()\n    {\n        return new Std();\n    }\n}\n\n\n不一定非要创建返回 EasySwoole\\Pool\\ObjectInterface 对象，任意类型对象均可\n\n在pool组件版本&gt;= 1.0.2后，提供了魔术池支持，可以快速进行定义池\nuse \\EasySwoole\\Pool\\MagicPool;\n$magic = new MagicPool(function (){\n    return new \\stdClass(); // 示例，可以返回实现了 ObjectInterface 的对象\n});\n\n// 注册后获取\n$test = $magic-&gt;getObj();\n// 归还\n$magic-&gt;recycleObj($test);\n魔术池构造方法的第二个参数，可以接收一个 config（EasySwoole\\Pool\\Config类），用于定义池数量等配置。\n简单示例\n\n$config = new \\EasySwoole\\Pool\\Config();\n$pool = new StdPool($config);\n\ngo(function ()use($pool){\n    $obj = $pool-&gt;getObj();\n    $obj2 = $pool-&gt;getObj();\n    var_dump($obj-&gt;who());\n    var_dump($obj2-&gt;who());\n});\n进阶使用\n基于pool实现的redis连接池\n[基于pool实现的mysql连接池]()\n相关仓库\neasyswoole/redis-pool","link":"/Components/Pool/introduction.html"},{"id":334,"title":"为什么使用连接池","content":"什么是连接池\n\n连接池是创建和管理一个连接的缓冲池的技术，这些连接准备好被任何需要它们的线程使用。\n\n简单来说，就是创建一个容器，并且把资源提前准备好放在里面，比如我们常用的redis连接、mysql连接。\n连接池的优点\n计算机是由许多零件组装而成，比如CPU、内存、硬盘等等。\n当我们进行网络连接、请求的时候，就需要在不同组件中传递和返回各种信号、数据\n比如在CPU、内存、网卡中，数据的传递，请求，获取。\n如果在短时间内进行一万次mysql的连接，就需要在这个往返过程循环，在路上浪费了很多时间、性能消耗。\n如果我们先把连接连接好，并且放在连接池中，程序中需要使用就从池中获取，执行操作。\n就省去了反复创建连接、断开连接的操作。\n可以减少I/O操作，提高资源利用率。\n连接池数量如何设置\n那么一个池需要设置多少数量比较合适呢？是不是越多越好？\n连接数量需要根据并发数,以及数据库的处理情况来决定的,\n比如你的数据库最大只能处理500个连接,那你设置700个,数据库照样处理不过来,设置过多并没有什么用处,反而可能会让数据库宕机\n所以,一般情况下,连接池总数设置为100-200左右就够了(相当于200的并发)\n这里的连接池数量,说的是总数量,在easyswoole中,需要根据进程来看,每个进程*连接池配置数量=总数量,比如easyswoole中worker进程为8,那你设置20个,那就是20*8=160的总数\neasyswoole中为什么会pool empty\n这个问题有好几个可能性。\n\n连接信息错误，导致一个资源都没有\n程序有问题，把资源拿出去，没有归还到池内，后续就拿到空了\n并发高，池的数量少，需要检查资源占用率，如果占用率没问题，则提高池内的数量\n\n连接错误\n如果我们的mysql配置信息错误，在easyswoole框架启动之后，就会去初始化连接池。\n此时一直连接失败，也就没有产生资源，也没有将资源放在池内\n当你在后续程序获取池内资源的时候。自然就报了空池的错误提示。\n程序问题\n先来一个连接池的伪代码  \n&lt;?php\n\nclass Pool{\n    public static function getIn(){\n        // 单例模式\n    }\n    /**\n     * 初始化\n     */\n    public function init()\n    {\n        // pool准备好就填充指定的资源 比如10个连接\n        $this-&gt;pool = $array;\n    }\n\n    public function get(){\n        return array_pop($this-&gt;pool);\n    }   \n    public function push($obj)\n    {\n        $this-&gt;pool[] = $obj;\n    }\n}\n如果我们的程序有这样子的使用场景\n&lt;?php\n\n    $db = Pool::getIn()-&gt;get();\n    $res = $db-&gt;query('sql语句');\n然后没有进行push 归还操作，那么池内资源一旦拿完，就没有资源可用了。\n在easyswoole框架中，有提供以下方法获取资源（以mysql-pool为例）\n$db = MysqlPool::defer();\n$db-&gt;rawQuery('select version()');\n$data = MysqlPool::invoker(function (MysqlConnection $db){\n    return $db-&gt;rawQuery('select version()');\n});\n$db = PoolManager::getInstance()-&gt;getPool(MysqlPool::class)-&gt;getObj();\n$data = $db-&gt;get('test');\n//使用完毕需要回收\nPoolManager::getInstance()-&gt;getPool(MysqlPool::class)-&gt;recycleObj($db);\ndefer方法将会在本次请求协程退出的时候自动回收\ninvoker是闭包函数方式  一次运行完马上自动回收\nget方式 就是我们伪代码的方式 需要自己回收  使用这种方式就需要特别注意啦~！！！\n\n两种自动回收方式怎么选择  请接着往下看！\n\n并发高  资源占用率\n上面说到两种自动回收资源的方式，defer和invoker\n首先我们来看一个点，defer是在协程退出时自动回收，正常来说，在一个请求到达的时候，swoole会自动创建一个协程给他，比如我们一个http api的请求，就需要整个api跑完，这个协程才会退出\n（相当于我们传统fpm php中  一个脚本全部执行完）\n这个时候问题来了，如果我们的业务是这样子的\n&lt;?php\n\n    $db = MysqlPool::defer();\n    $db-&gt;rawQuery('select version()');\n\n    // 执行好mysql了  做其他任务\n\n    // 耗时1.5s 完成其他\n\n实际上使用到mysql资源的可能只有0.1s不到，但是其他运算占用了脚本大量执行时间，要等全部执行完，协程退出了，资源才会回收，这个时候就比较浪费资源的利用率了。占用率比较低。\n！\n如果可以的话 ，我们推荐使用invoker   执行一条 马上回收资源\n此时要注意一个点，如果程序有比较多执行语句，要么在一个invoker里执行，要么合理使用invoker\n不然就会把性能消耗转移到不断get  recycle上了\n如果以上排查都没问题，并且确认你的用户量比较多，并发高，就可以适当提高pool的number ","link":"/Components/Pool/whyUsePool.html"},{"id":335,"title":"httpclient","content":"HttpClient\n协程Http客户端，基于\\Swoole\\Http\\Client实现，在协程内快速发起http请求。\n安装\n\ncomposer require easyswoole/http-client\n\n请求\n需要在协程环境内发起请求。\n请求实例\n$client = new \\EasySwoole\\HttpClient\\HttpClient('http://easyswoole.com');\n设置Url\n可在实例化的时候，传入Url，或者如下：\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setUrl('http://easyswoole.com');\n设置query\n通过url传入.\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setUrl('http://easyswoole.com?a=1');\n通过方法传入.\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setQuery(['a' =&gt; 1]);\n注意：\nsetQuery方法将你原本url的参数也带过来.\n设置Ssl\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setEnableSSL(true);\n设置等待超时时间\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setTimeout(5);\n设置连接超时时间\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setConnectTimeout(10);\n设置Header\n设置单项：\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setHeader('test','test');\n设置多项：\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setHeaders(['test' =&gt; 'test']);\n参数：\n\n\n$isMerge 默认：true，false清空原有Header重新赋值。\n\n$strtolower 默认：true，false不进行小写转换。\n\n设置Cookie\n设置单项：\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;addCookie('test','test');\n设置多项：\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;addCookies(['test' =&gt; 'test']);\n参数：\n\n\n$isMerge 默认：true，false清空原有Cookie重新赋值。\n\n设置XMLHttpRequest\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setXMLHttpRequest();\n设置ContentType\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setContentType($client::CONTENT_TYPE_APPLICATION_XML);\njson：\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setContentTypeJson();\nxml：\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setContentTypeXml();\nfrom-data：\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setContentTypeFormData();\nfrom-urlencode：\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setContentTypeFormUrlencoded();\n设置BasicAuth\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setBasicAuth('admin','admin');\n设置KeepAlive\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setKeepAlive(true);\n设置客户端配置\n单个设置：\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setClientSetting('bind_address','127.0.0.1');\n批量设置：\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setClientSettings([\n    'bind_address'=&gt;'127.0.0.1',\n    'bind_port'=&gt;'8090'\n]);\n设置FollowLocation\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;enableFollowLocation(5);\n参数：\n\n\n$maxRedirect 默认5，表示最多根据30x状态码进行的重定向次数。0 为关闭。\n\n设置允许自签证书\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setSslVerifyPeer(true,true);\n设置服务器主机名称\n与ssl_verify_peer配置配合使用\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setSslHostName('');\n设置验证用的Ssl证书\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setSslCafile('');\n设置Ssl证书目录\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setSslCapath('');\n设置Ssl证书文件\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setSslCertFile('');\n设置Ssl证书私钥文件\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setSslKeyFile('');\n设置代理\nhttp代理：\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setProxyHttp('127.0.0.1','1087','user','pass');\nsocks5代理：\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setProxySocks5('127.0.0.1','1086','user','pass');\n设置端口绑定\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;setSocketBind('127.0.0.1','8090');\nGET\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;get();\n参数：\n\n\n$headers 设置Header\n\n\nHEAD\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;head();\nDELETE\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;delete();\n参数：\n\n\n$headers 设置Header\n\n\nPUT\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;put();\n参数：\n\n\n$data 请求的数据\n\n$headers 设置Header\n\n\nPOST\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;post();\npost-xml：\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;postXml();\npost-json：\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;postJson();\n参数：\n\n\n$data 请求的数据\n\n$headers 设置Header\n\n\nPATCH\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;patch();\n参数：\n\n\n$data 请求的数据\n\n$headers 设置Header\n\n\nOPTIONS\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;options();\n参数：\n\n\n$data 请求的数据\n\n$headers 设置Header\n\n\nDownload\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;download('./test.png');\n参数：\n\n\n$filename 保存路径\n\n$offset 写入偏移量\n\n$httpMethod 请求方法\n\n$rawData 请求数据\n\n$contentType 设置ContentType\n\n\n上传文件\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;post([\n    'file' =&gt; new \\CURLFile(__FILE__)\n]);\n分片上传：\n\n$file = new EasySwoole\\HttpClient\\Bean\\CURLFile('file',__FILE__);\n\n// 设置表单的名称\n$file-&gt;setName('file');\n\n// 设置要文件的路径\n\n$file-&gt;setPath(__FILE__);\n\n// 设置文件总大小\n$file-&gt;setLength(filesize(__FILE__));\n\n// 设置offset（分片上传的关键）\n$file-&gt;setOffset(0);\n\n// 设置文件类型\n$file-&gt;setType('image/png');\n\n/** @var \\EasySwoole\\HttpClient\\HttpClient $client **/\n$client-&gt;post([\n    'file' =&gt; $file\n]);\n响应\n以上快速发起http请求成功后，如（GET，POST），将会返回EasySwoole\\HttpClient\\Bean\\Response。\n获取响应体\n/** @var \\EasySwoole\\HttpClient\\Bean\\Response $response **/\n$response-&gt;getBody();\n当响应体为json，解析：\n/** @var \\EasySwoole\\HttpClient\\Bean\\Response $response **/\n$response-&gt;json();\n参数：\n\n\n$assoc 默认false，false为object，true为数组。\n\n当响应体为jsonp，解析：\n/** @var \\EasySwoole\\HttpClient\\Bean\\Response $response **/\n$response-&gt;jsonp();\n参数：\n\n\n$assoc 默认false，false为object，true为数组。\n\n当响应体为xml，解析：\n/** @var \\EasySwoole\\HttpClient\\Bean\\Response $response **/\n$response-&gt;xml();\n参数：\n\n\n$assoc 默认false，false为object，true为数组。\n\n获取错误码\n/** @var \\EasySwoole\\HttpClient\\Bean\\Response $response **/\n$response-&gt;getErrCode();\n获取错误信息\n/** @var \\EasySwoole\\HttpClient\\Bean\\Response $response **/\n$response-&gt;getErrMsg();\n获取响应状态码\n/** @var \\EasySwoole\\HttpClient\\Bean\\Response $response **/\n$response-&gt;getStatusCode();\n获取响应头及设置的Cookie\n/** @var \\EasySwoole\\HttpClient\\Bean\\Response $response **/\n$response-&gt;getSetCookieHeaders();\n获取请求的Cookie及响应头\n/** @var \\EasySwoole\\HttpClient\\Bean\\Response $response **/\n$response-&gt;getCookies();\nWebSocket-Client\n$client = new \\EasySwoole\\HttpClient\\HttpClient('127.0.0.1:9501');\n$upgradeResult = $client-&gt;upgrade(true);\n$frame = new \\Swoole\\WebSocket\\Frame();\n//设置发送的消息帧\n$frame-&gt;data = json_encode(['action' =&gt; 'hello','content'=&gt;['a'=&gt;1]]);\n$pushResult = $client-&gt;push($frame);\n$recvFrame = $client-&gt;recv();\n//将返回bool或一个消息帧，可自行判断\nvar_dump($recvFrame);\n\nrecv只会接收一次服务器的消息，如果需要一直接收，请增加while(1)死循环。\n","link":"/Components/httpClient.html"},{"id":336,"title":"smtp","content":"Smtp\n电子邮件是—种用电子手段提供信息交换的通信方式，是互联网应用最广的服务。电子邮件几乎是每个web应用程序不可或缺的，无论是时事通讯还是订单确认。本库采用swoole协程客户端实现了电子邮件的发送。\n组件要求\n\nphp: &gt;=7.1.0\next-swoole: ^4.2.6\neasyswoole/spl: ^1.1\neasyswoole/utility: ^1.0\n\n安装方法\n\ncomposer require easyswoole/smtp\n\n仓库地址\neasyswoole/smtp\n基本使用\n邮件配置\nset\n设置服务器地址\npublic function setServer(string $server): void\n设置服务器端口\npublic function setPort(int $port): void\n设置ssl\npublic function setSsl(bool $ssl): void\n设置用户名\npublic function setUsername(string $username): void\n设置密码\npublic function setPassword(string $password): void\n设置邮件发送方\npublic function setMailFrom(string $mailFrom): void\n设置超时时间\npublic function setTimeout(float $timeout): void\n设置邮件大小\npublic function setMaxPackage(int $maxPackage)\nget\n获取服务地址\npublic function getServer(): string\n获取服务端口\npublic function getPort(): int\n是否设置了ssl\npublic function isSsl(): bool\n获取用户名\npublic function getUsername(): string\n获取密码\npublic function getPassword(): string\n获取邮件发送方\npublic function getMailFrom(): string\n获取超时时间\npublic function getTimeout(): float\n获取邮件大小\npublic function getMaxPackage()\n内容配置\nset\n设置协议版本\npublic function setMimeVersion($mimeVersion): void\n设置contentType\npublic function setContentType($contentType): void\n设置字符\npublic function setCharset($charset): void\n设置编码\npublic function setContentTransferEncoding($contentTransferEncoding): void\n设置主题\npublic function setSubject($subject): void\n设置邮件内容\npublic function setBody($body): void\n添加附件\npublic function addAttachment($attachment)\nget\n获取协议版本\npublic function getMimeVersion()\n获取contenttype\npublic function getContentType()\n获取字符\npublic function getCharset()\n获取编码\npublic function getContentTransferEncoding()\n获取主题\npublic function getSubject()\n获取邮件内容\npublic function getBody()\n获取附件\npublic function getAttachments()\n使用示例\nuse EasySwoole\\Smtp\\Mailer;\nuse EasySwoole\\Smtp\\MailerConfig;\nuse EasySwoole\\Smtp\\Message\\Html;\nuse EasySwoole\\Smtp\\Message\\Attach;\n// 必须用go\ngo(function (){\n    $config = new MailerConfig();\n    $config-&gt;setServer('smtp.163.com');\n    $config-&gt;setSsl(false);\n    $config-&gt;setUsername('huizhang');\n    $config-&gt;setPassword('*******');\n    $config-&gt;setMailFrom('xx@163.com');\n    $config-&gt;setTimeout(10);//设置客户端连接超时时间\n    $config-&gt;setMaxPackage(1024*1024*5);//设置包发送的大小：5M\n\n    //设置文本或者html格式\n    $mimeBean = new Html();\n    $mimeBean-&gt;setSubject('Hello Word!');\n    $mimeBean-&gt;setBody('&lt;h1&gt;Hello Word&lt;/h1&gt;');\n\n    //添加附件\n    $mimeBean-&gt;addAttachment(Attach::create('./test.txt'));\n\n    $mailer = new Mailer($config);\n    $mailer-&gt;sendTo('xx@qq.com', $mimeBean);\n});\n\n进阶使用\n邮件内容支持文本和html两种类型\n文本\n示例\n$mimeBean = new \\EasySwoole\\Smtp\\Message\\Text();\n$mimeBean-&gt;setSubject('Hello Word!');\n$mimeBean-&gt;setBody('&lt;h1&gt;Hello Word&lt;/h1&gt;');\n效果\n \nHtml\n$mimeBean = new \\EasySwoole\\Smtp\\Message\\Html();\n$mimeBean-&gt;setSubject('Hello Word!');\n$mimeBean-&gt;setBody('&lt;h1&gt;Hello Word&lt;/h1&gt;');\n效果\n \n附件\n$mimeBean = new \\EasySwoole\\Smtp\\Message\\Text();\n//$mimeBean = new \\EasySwoole\\Smtp\\Message\\Html();\n\n...\n\n// 创建附件\n$createAttachment = Attach::create('./test.txt');\n\n// 添加附件\n$mimeBean-&gt;addAttachment($createAttachment);\n\n...","link":"/Components/Stmp/smtp.html"},{"id":337,"title":"actor组件","content":"Actor\n提供Actor模式支持，助力游戏行业开发。EasySwoole的Actor采用自定义Process作为存储载体，以协程作为最小调度单位，利用协程Channel做mail box，而客户端与Process之间的通讯，采用UnixSocket实现，并且借助TCP实现分布式的ActorClient，超高并发下也能轻松应对。\n工作流程\n一般来说有两种策略用来在并发线程中进行通信：共享数据和消息传递。使用共享数据方式的并发编程面临的最大的一个问题就是数据条件竞争，当两个实例需要访问同一个数据时，为了保证数据的一致性，通常需要为数据加锁，而Actor模型采用消息传递机制来避免数据竞争，无需复杂的加锁操作，各个实例只需要关注自身的状态以及处理收到的消息。\nActor是完全面向对象、无锁、异步、实例隔离、分布式的并发开发模式。Actor实例之间互相隔离，Actor实例拥有自己独立的状态，各个Actor之间不能直接访问对方的状态，需要通过消息投递机制来通知对方改变状态。由于每个实例的状态是独立的，没有数据被共享，所以不会发生数据竞争，从而避免了并发下的加锁问题。\n举一个游戏场景的例子，在一个游戏房间中，有5个玩家，每个玩家都是一个PlayerActor，拥有自己的属性，比如角色ID，昵称，当前血量，攻击力等。游戏房间本身也是一个RoomActor，房间也拥有属性，比如当前在线的玩家，当前场景的怪物数量，怪物血量等。此时玩家A攻击某个怪物，则PlayerActor-A向RoomActor发送一个攻击怪物的指令，RoomActor经过计算，得出玩家A对怪物的伤害值，并给房间内的所有PlayerActor发送一个消息（玩家A攻击怪物A，造成175点伤害，怪物A剩余血量1200点），类似此过程，每个PlayerActor都可以得知房间内发生了什么事情，但又不会造成同时访问怪物A的属性，导致的共享加锁问题。\n安装\nActor并没有作为内置组件，需要先引入包并进行基础配置才能够使用。\n\ncomposer require easyswoole/actor\n\n使用\n建立一个Actor\n每一种对象（玩家、房间、甚至是日志服务也可以作为一种Actor对象）都建立一个Actor来进行管理，一个对象可以拥有多个实例（Client）并且可以互相通过信箱发送消息来处理业务。\n&lt;?php\n\nnamespace App\\Player;\n\nuse EasySwoole\\Actor\\AbstractActor;\nuse EasySwoole\\Actor\\ActorConfig;\n\n/**\n * 玩家Actor\n * Class PlayerActor\n * @package App\\Player\n */\nclass PlayerActor extends AbstractActor\n{\n    /**\n     * 配置当前的Actor\n     * @param ActorConfig $actorConfig\n     */\n    public static function configure(ActorConfig $actorConfig)\n    {\n        $actorConfig-&gt;setActorName('PlayerActor');\n        $actorConfig-&gt;setWorkerNum(3);\n    }\n\n    /**\n     * Actor首次启动时\n     */\n    protected function onStart()\n    {\n        $actorId = $this-&gt;actorId();\n        echo \"Player Actor {$actorId} onStart\\n\";\n    }\n\n    /**\n     * Actor收到消息时\n     * @param $msg\n     */\n    protected function onMessage($msg)\n    {\n        $actorId = $this-&gt;actorId();\n        echo \"Player Actor {$actorId} onMessage\\n\";\n    }\n\n    /**\n     * Actor即将退出前\n     * @param $arg\n     */\n    protected function onExit($arg)\n    {\n        $actorId = $this-&gt;actorId();\n        echo \"Player Actor {$actorId} onExit\\n\";\n    }\n\n    /**\n     * Actor发生异常时\n     * @param \\Throwable $throwable\n     */\n    protected function onException(\\Throwable $throwable)\n    {\n        $actorId = $this-&gt;actorId();\n        echo \"Player Actor {$actorId} onException\\n\";\n    }\n\n}\n注册Actor服务\n可以使用setListenAddress和setListenPort指定本机对外监听的端口，其他机器可以通过该端口向本机的Actor发送消息。\n\npublic static function mainServerCreate(EventRegister $register) {\n\n    // 注册Actor管理器\n    $server = \\EasySwoole\\EasySwoole\\ServerManager::getInstance()-&gt;getSwooleServer();\n    \\EasySwoole\\Actor\\Actor::getInstance()-&gt;register(PlayerActor::class);\n    \\EasySwoole\\Actor\\Actor::getInstance()-&gt;setTempDir(EASYSWOOLE_TEMP_DIR)\n        -&gt;setListenAddress('0.0.0.0')-&gt;setListenPort('9900')-&gt;attachServer($server);\n\n}\nActor实例管理\n服务启动后就可以进行Actor的操作，管理本机的Client实例，则不需要给client传入$node参数，默认的node为本机，管理其他机器时需要传入。\n\n    // 管理本机的Actor则不需要声明节点\n    $node = new \\EasySwoole\\Actor\\ActorNode();\n    $node-&gt;setIp('127.0.0.1');\n    $node-&gt;setListenPort(9900);\n\n    // 启动一个Actor并得到ActorId 后续操作需要依赖ActorId\n    $actorId = PlayerActor::client($node)-&gt;create(['time' =&gt; time()]);   // 00101000000000000000001\n    // 给某个Actor发消息\n    PlayerActor::client($node)-&gt;send($actorId, ['data' =&gt; 'data']);\n    // 给该类型的全部Actor发消息\n    PlayerActor::client($node)-&gt;sendAll(['data' =&gt; 'data']);\n    // 退出某个Actor\n    PlayerActor::client($node)-&gt;exit($actorId, ['arg' =&gt; 'arg']);\n    // 退出全部Actor\n    PlayerActor::client($node)-&gt;exitAll(['arg' =&gt; 'arg']);\n\n架构解读\nActor\n应该叫ActorManager更确切点，它用来注册Actor启动Proxy和ActorWorker进程。\n当你在业务逻辑里定义了几种Actor，比如RoomActor、PlayerActor，需要在SwooleServer启动时注册它们。\n具体就是在EasySwooleEvent.mainServerCreate方法中添加如下代码。\n$actor = Actor::getInstance();\n$actor-&gt;register(RoomActor::class);\n$actor-&gt;register(PlayerActor::class);\n$actorConf = Config::getInstance()-&gt;getConf('ACTOR_SERVER');\n$actor-&gt;setMachineId($actorConf['MACHINE_ID'])\n    -&gt;setListenAddress($actorConf['LISTEN_ADDRESS'])\n    -&gt;setListenPort($actorConf['PORT'])\n    -&gt;attachServer($server);\n其中ListenAddress、ListenPort为Proxy进程的监听地址端口，MachineId为ActorWorker进程的机器码。\nMachineId和IP:PORT对应。\nattachServer将开启相应数量的Proxy进程，以及前边register的ActorWorker进程。\n工作原理\nProxy进程做消息中转，Worker进程做消息分发推送。来看个具体的例子：\n游戏中玩家P请求进入房间R，抽象成Actor模型就是PlayerActor需要往RoomActor发送请求加入的命令。\n那么这时候需要这样写：\n\\EasySwoole\\Actor\\Test\\RoomActor::client($node)-&gt;send($roomActorId, [\n    'user_actor_id' =&gt; $userActorId,\n    'data'  =&gt; '其他进入房间的参数'\n])\n其中$roomActorId和$userActorId是事先xxActor::client()-&gt;create()出来的。\n上面那段代码的意思就是往$roomActorId的RoomActor实例推送了一条$userActorId玩家的UserActor实例要加入房间的消息。\n参数$node用来寻址Proxy，它由目标Actor实例的Worker.MachineId决定，在本例中就是$roomActorId被创建在了哪个MachineId的WorkerProcess。\n通过$roomActorId中的机器码找到IP:PORT，生成$node。\nsend时会创建一个协程TcpClient，将消息发送给Proxy，然后Proxy将消息转发（UnixClient）至本机WorkerProcess，WorkerProcess收到消息，推送到具体的Actor实例。\n这样就完成了从PlayerActor到RoomActor的请求通讯，RoomActor收到请求消息并处理完成后，向PlayerActor回发处理结果，用的是同样的通讯流程。\n如果是单机部署，可以忽略$node参数，因为所有通讯都是在本机进行。\n多机的话，需要自己根据业务来实现Actor如何分布和定位。\n主要属性\nmachineId 机器码\nproxyNum 启动几个ProxyProcess\nlistenPort 监听port\nlistenAddress 监听ip\nAbstractActor\nActor实例的基类，所有业务中用到的Actor都将继承于`AbstractActor。例如游戏场景中的房间，你可以：\nclass RoomActor extends AbstractActor\n工作原理\n每个Actor实例都维护一份独立的数据和状态，当一个Actor实例通过client()-&gt;create()后，会开启协程循环，接收mailbox pop的消息，进而处理业务逻辑，更新自己的数据及状态。具体实现就是__run()这个方法。\n静态方法 configure\n用来配置ActorConfig，只需要在具体的Actor（如RoomActor）去重写这个方法就行。\n关于ActorConfig具体属性可以看下边ActorConfig部分。\n几个虚拟方法\n以下几个虚拟方法需要在Actor子类中实现，这几个方法被用在__run()中来完成Actor的运行周期。\nonStart() 在协程开启前执行，你可以在此进行Actor初始化的一些操作，比如获取房间的基础属性等。\nonMessage() 当接收到消息时执行，一个Actor实例的生命周期基本上就是在收消息-处理-发消息，你需要在这里对消息进行解析处理。\nonExit() 当接收到退出命令时执行。比如你希望在一个Actor实例退出的时候，同时通知某些关联的其他Actor，可以在此处理。\n其它\nexit() 用于实例自己退出操作，会向自己发一条退出的命令。\ntick()、after() 两个定时器，用于Actor实例的定时任务，比如游戏房间的定时刷怪（tick）；掉线后多长时间自动踢出（after）。\nstatic client() 用于创建一个ActorClient来进行对应Actor（实例）的通讯。\nActorClient\nActor通讯客户端，调用xxActor::client()来创建一个ActorClient进行Actor通讯。\n上边已经大概讲过了Actor的通讯流程，本质就是TcpClient-&gt;ProxyProcess-&gt;UnixClient-&gt;ActorWorkerProcess-&gt;xxActor。\n看下它实现了哪些方法：\ncreate() 创建一个xxActor实例，返回actorId，在之后你可以使用这个actorId与此实例进行通讯。\nsend() 指定actorId，向其发送消息。\nexit() 通知xxActor退出指定actorId的实例。\nsendAll() 向所有的xxActor实例发送消息。\nexitAll() 退出所有xxActor实例。\nexist() 当前是否存在指定actorId的xxActor实例。\nstatus() 当前ActorWorker下xxActor的分布状态。\nActorConfig\n具体Actor的配置项，比如RoomActor、PlayerActor都有自己的配置。\nactorName 一般用类名就可以，注意在同一个服务中这个是不能重复的。\nactorClass 在Actor-&gt;register()会将对应的类名写入。\nworkerNum 为Actor开启几个进程，Actor-&gt;attachServer()时会根据这个参数为相应Actor启动WorkerNum个Worker进程。\nActorNode\n上边提到过，xxActor::client($node)，这个$node就是ActorNode对象，属性为Ip和Port，用于寻址Proxy。\nWorkerConfig\nWorkerProcess的配置项，WorkerProcess启动时用到。\nworkerId worker进程Id，create Actor的时候用于生成actorId\nmachineId worker进程机器码，create Actor的时候用于生成actorId\ntrigger 异常触发处理接口\nWorkerProcess\nActor的重点在这里，每个注册的Actor（类）会启动相应数量的WorkerProcess。\n比如你注册了RoomActor、PlayerActor，workerNum都配置的是3，那么系统将启动3个RoomActor的Worker进程和3个PlayerActor的Worker进程。\n每个WorkerProcess维护一个ActorList，你通过client()-&gt;create()的Actor将分布在不同Worker进程里，由它的ActorList进行管理。\nWorkerProcess通过协程接收client（这个client就是Proxy做转发时的UnixClient）消息，区分消息类型，然后分发给对应的Actor实例。\n请仔细阅读下WorkerProcess的源码，它继承于AbstractUnixProcess。\nUnixClient\nUnixStream Socket，自行了解。Proxy转发消息给本机Actor所使用的Client。\nProtocol\n数据封包协议。\nProxyCommand\n消息命令对象，Actor2将不同类型的消息封装成格式化的命令，最终传给WorkerProcess。\n你可以在ActorClient中了解一下方法和命令的对应关系，但这个不需要在业务层去更改。\nProxyConfig\n消息代理的配置项。\nactorList 注册的actor列表。\nmachineId 机器码\ntempDir 临时目录\ntrigger 错误触发处理接口 \nProxyProcess\nActor-&gt;attachServer()会启动proxyNum个ProxyProcess。\n用于在Actor实例和WorkerProcess做消息中转。","link":"/Components/actor.html"},{"id":338,"title":"whoops","content":"Whoops\nEasyswoole 提供了Whoops驱动，用于开发阶段，友好的排除HTTP业务的错误与异常。\n\n切勿用于生产阶段，否则造成代码泄露EasySwoole不负任何责任！！！\n组件要求\n\neasyswoole/component: ^2.0\neasyswoole/spl: ^1.1\neasyswoole/template: ^1.0\neasyswoole/utility: ^1.0\npsr/log: ^1.0.1\n\n安装方法\n\ncomposer require easyswoole/easy-whoops=3.x\n\n仓库地址\neasyswoole/easy-whoops=3.x\n基本使用\n直接在 EasySwoole 全局事件中进行注册\n&lt;?php\n\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\n\nclass EasySwooleEvent implements Event\n{\n    public static function initialize()\n    {\n        // TODO: Implement initialize() method.\n        date_default_timezone_set('Asia/Shanghai');\n\n        \\EasySwoole\\Component\\Di::getInstance()-&gt;set(\\EasySwoole\\EasySwoole\\SysConst::HTTP_GLOBAL_ON_REQUEST, function (\\EasySwoole\\Http\\Request $request, \\EasySwoole\\Http\\Response $response): bool {\n            // 拦截请求\n            if (\\EasySwoole\\EasySwoole\\Core::getInstance()-&gt;runMode() == 'dev') {\n                \\EasySwoole\\Whoops\\Run::attachRequest($request, $response);\n            }\n            return true;\n        });\n\n        if (\\EasySwoole\\EasySwoole\\Core::getInstance()-&gt;runMode() == 'dev') {\n            $whoops = new \\EasySwoole\\Whoops\\Run();\n            $whoops-&gt;pushHandler(new \\EasySwoole\\Whoops\\Handler\\PrettyPageHandler());  // 输出一个漂亮的页面\n            $whoops-&gt;pushHandler(new \\EasySwoole\\Whoops\\Handler\\CallbackHandler(function ($exception, $inspector, $run, $handle) {\n                // 可以推进多个Handle 支持回调做更多后续处理\n            }));\n            $whoops-&gt;register();\n        }\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        if (\\EasySwoole\\EasySwoole\\Core::getInstance()-&gt;runMode() == 'dev') {\n            \\EasySwoole\\Whoops\\Run::attachTemplateRender(ServerManager::getInstance()-&gt;getSwooleServer());\n        }\n    }\n}\n经过上面配置完成之后，就可以在框架抛出异常时，输出一个漂亮的异常页面。","link":"/Components/whoops.html"},{"id":339,"title":"安装","content":"SyncInvoker 组件\n使用场景\nSwoole4.x 后，提供了非常强大的协程能力，让我们可以更好地压榨服务器性能，提高并发。然而，目前 PHP 在 Swoole 协程生态上，并不是很完善，比如：没有协程版本的 MonogoDB 客户端，而为了避免在 Worker 进程中调用了同步阻塞的 Api，例如在 Http 回调中使用了同步的 MonogoDB 客户端，导致 Worker 进程退化为同步阻塞，导致无法完全地发挥协程的优势。所以 EasySwoole 提供了一个同步程序协程调用转化驱动。\n设计原理\n启动自定义进程监听 UnixSocket，然后在 Worker 进程中调用协程客户端发送命令到自定义进程并处理，然后把处理结果返回给 Worker进程中的协程客户端。\n组件要求\n\nphp: &gt;= 7.1.0\next-swoole: &gt;= 4.4.23\neasyswoole/component: ^2.0\nopis/closure: ^3.5\n\n安装方法\n\ncomposer require easyswoole/sync-invoker\n\n仓库地址\neasyswoole/sync-invoker\n基本使用\n首先定义一个驱动工作实例（可以定义多个），示例代码如下：\n&lt;?php\n\nnamespace App\\Utility;\n\nuse EasySwoole\\SyncInvoker\\AbstractDriver;\n\nclass MyInvokerDriver extends AbstractDriver\n{\n    private $stdclass;\n\n    function __construct()\n    {\n        $this-&gt;stdclass = new \\stdClass();\n        parent::__construct();\n    }\n\n    public function test($a, $b)\n    {\n        $this-&gt;response($a + $b);\n    }\n\n    public function a()\n    {\n        $this-&gt;response('this is a');\n    }\n\n    public function getStdClass()\n    {\n        return $this-&gt;stdclass;\n    }\n}\n然后注册一个对应的调用器，示例代码如下：\n&lt;?php\n\nnamespace App\\Utility;\n\nuse EasySwoole\\Component\\Singleton;\nuse EasySwoole\\SyncInvoker\\SyncInvoker;\n\n// 注册一个对应的调用器\nclass MyInvoker extends SyncInvoker\n{\n    use Singleton;\n}\n最后在 EasySwoole全局事件 中 的 mainServerCreate 事件中进行注册\n&lt;?php\n\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\n\nclass EasySwooleEvent implements Event\n{\n    public static function initialize()\n    {\n        // TODO: Implement initialize() method.\n        date_default_timezone_set('Asia/Shanghai');\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        $invokerConfig = \\App\\Utility\\MyInvoker::getInstance()-&gt;getConfig();\n\n        // 以下这些配置都是可选的，可以使用组件默认的配置\n        /*\n        $invokerConfig-&gt;setServerName('EasySwoole'); // 设置服务名称，默认为 'EasySwoole'\n        $invokerConfig-&gt;setWorkerNum(3); // 设置 Worker 进程数，默认为 3\n        $invokerConfig-&gt;setTempDir(EASYSWOOLE_ROOT . '/Temp'); // 设置 unixSocket 存放目录，默认为 系统临时文件存放目录('/tmp')\n        $invokerConfig-&gt;setMaxPackageSize(2 * 1024 * 1024); // 设置最大允许发送数据大小，默认为 2M\n        $invokerConfig-&gt;setTimeout(3.0); // 设置服务调用超时时间，默认为 3.0 秒\n        $invokerConfig-&gt;setAsyncAccept(true); // 设置异步接收数据，默认为 异步接收(不建议修改)\n        $invokerConfig-&gt;setOnWorkerStart(function (\\EasySwoole\\SyncInvoker\\Worker $worker) {\n            var_dump('worker start at Id ' . $worker-&gt;getArg()['workerIndex']);\n        }); // 设置服务启动时执行的事件回调\n        */\n\n        $invokerConfig-&gt;setDriver(new \\App\\Utility\\MyInvokerDriver()); // 设置驱动工作实例【必须配置】\n\n        // 注册 Invoker\n        \\App\\Utility\\MyInvoker::getInstance()-&gt;attachServer(ServerManager::getInstance()-&gt;getSwooleServer());\n    }\n}\n在框架服务启动后，即可在框架的任意位置调用 Invoker 服务了，使用示例如下：\n例如在控制器中进行调用：\n&lt;?php\n\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\n\nclass Index extends Controller\n{\n    public function index()\n    {\n        $ret = \\App\\Utility\\MyInvoker::getInstance()-&gt;invoke()-&gt;test(1, 2);\n        var_dump($ret);\n        var_dump(\\App\\Utility\\MyInvoker::getInstance()-&gt;invoke()-&gt;a());\n        $ret = \\App\\Utility\\MyInvoker::getInstance()-&gt;invoke()-&gt;callback(function (\\App\\Utility\\MyInvokerDriver $driver) {\n            $std = $driver-&gt;getStdClass();\n            if (isset($std-&gt;time)) {\n                return $driver-&gt;response($std-&gt;time);\n            } else {\n                $std-&gt;time = time();\n                return $driver-&gt;response('new set time');\n            }\n        });\n        var_dump($ret);\n    }\n}\n\n/**\n * 输出结果：\n * int(3)\n * string(9) \"this is a\"\n * string(12) \"new set time\"\n * int(3)\n * string(9) \"this is a\"\n * int(1611071672)\n */\n注意事项\n\n尽量使用函数名调用方式，闭包方式调用会存在部分闭包函数序列化失败问题\n传递参数，返回结果尽量用数组或者字符串传递，资源对象无法序列化\n","link":"/Components/SyncInvoker/syncInvoker.html"},{"id":340,"title":"mongodb 客户端案例","content":"MongoDB\n目前，MongoDB 并没有提供协程版本的 php 客户端，只有同步阻塞版本。\nEasySwoole 的协程版客户端已经在排期内。\n在实际生产中，直接创建原生的 MongoDB客户端 来进行数据交互，也不是不可。\n若希望将同步调用转为协程调用，可以用 Easyswoole 提供的 sync-invoker 组件。\n将 MongoDB客户端 的同步调用转为协程调用具体使用如下：\n定义驱动\n&lt;?php\n\nnamespace App\\MongoDb;\n\nuse EasySwoole\\EasySwoole\\Trigger;\nuse EasySwoole\\SyncInvoker\\AbstractDriver;\nuse MongoDB\\Client;\n\nclass Driver extends AbstractDriver\n{\n    private $db;\n\n    // 【建议使用】\n    // 使用 mongodb/mongodb composer组件包封装的 MongoDB 客户端调用类，作为客户端调用驱动\n    // 【前提：需要先使用 `composer require mongodb/mongodb` 安装 mongodb/mongodb composer组件包】\n    function getDb(): Client\n    {\n        if ($this-&gt;db == null) {\n            // 这里为要连接的 mongodb 的服务端地址【前提是必须先有服务端，且安装 php-mongodb 扩展才可使用】\n            $mongoUrl = \"mongodb://127.0.0.1:27017\";\n            $this-&gt;db = new Client($mongoUrl);\n        }\n        return $this-&gt;db;\n    }\n\n    // 仅使用 php-mongodb 扩展内置类(不使用composer组件包的)，作为客户端调用驱动\n    /*\n    function getDb(): \\MongoDB\\Driver\\Manager\n    {\n        if ($this-&gt;db == null) {\n            // 这里为要连接的 mongodb 的服务端地址【前提是必须先有服务端，且安装 php-mongodb 扩展才可使用】\n            $mongoUrl = \"mongodb://127.0.0.1:27017\";\n            $this-&gt;db = new \\MongoDB\\Driver\\Manager($mongoUrl);\n\n        }\n        return $this-&gt;db;\n    }\n    */\n\n    protected function onException(\\Throwable $throwable)\n    {\n        Trigger::getInstance()-&gt;throwable($throwable);\n        return null;\n    }\n}\n客户端调用类定义\n&lt;?php\n\nnamespace App\\MongoDb;\n\nuse EasySwoole\\Component\\Singleton;\nuse EasySwoole\\SyncInvoker\\SyncInvoker;\n\nclass MongoClient extends SyncInvoker\n{\n    use Singleton;\n}\n注册 Invoker 服务\n在 EasySwoole 全局事件 的 mainServerCreate 事件 中进行服务注册\n&lt;?php\n\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\n\nclass EasySwooleEvent implements Event\n{\n    public static function initialize()\n    {\n        // TODO: Implement initialize() method.\n        date_default_timezone_set('Asia/Shanghai');\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        // 配置 Invoker\n        $invokerConfig = \\App\\MongoDb\\MongoClient::getInstance()-&gt;getConfig();\n        $invokerConfig-&gt;setDriver(new \\App\\MongoDb\\Driver()); // 配置 MongoDB 客户端协程调用驱动\n\n        // 以下这些配置都是可选的，可以使用组件默认的配置\n        /*\n        $invokerConfig-&gt;setMaxPackageSize(2 * 1024 * 1024); // 设置最大允许发送数据大小，默认为 2M【注意：当使用 MongoDB 客户端查询大于 2M 的数据时，可以修改此参数】\n        $invokerConfig-&gt;setTimeout(3.0); // 设置 MongoDB 客户端操作超时时间，默认为 3.0 秒;\n        */\n\n        // 注册 Invoker\n        \\App\\MongoDb\\MongoClient::getInstance()-&gt;attachServer(ServerManager::getInstance()-&gt;getSwooleServer());\n    }\n}\n在框架中使用 MongoDB 客户端(协程调用)\n&lt;?php\n\nnamespace App\\HttpController;\n\nuse App\\MongoDb\\Driver;\nuse App\\MongoDb\\MongoClient;\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\nuse EasySwoole\\Utility\\Random;\n\nclass Index extends Controller\n{\n    public function index()\n    {\n        // 使用 mongodb/mongodb composer组件包【建议使用，需要先使用composer安装】\n        $ret = MongoClient::getInstance()-&gt;invoke()-&gt;callback(function (Driver $driver) {\n            $ret = $driver-&gt;getDb()-&gt;user-&gt;list-&gt;insertOne([\n                'name' =&gt; Random::character(8),\n                'sex' =&gt; 'man',\n            ]);\n            if (!$ret) {\n                $driver-&gt;response(false);\n            }\n            $driver-&gt;response($ret-&gt;getInsertedId());\n        });\n        var_dump($ret);\n\n        $ret = MongoClient::getInstance()-&gt;invoke()-&gt;callback(function (Driver $driver) {\n            $ret = [];\n            $collections = $driver-&gt;getDb()-&gt;user-&gt;listCollections();\n            foreach ($collections as $collection) {\n                $ret[] = (array)$collection;\n            }\n            $driver-&gt;response($ret);\n        });\n        var_dump($ret);\n        /**\n         * 输出结果：\n         * object(MongoDB\\BSON\\ObjectId)#109 (1) {\n             [\"oid\"]=&gt;\n             string(24) \"600da377004c82305a02fb52\"\n           }\n         * array(1) {\n             [0]=&gt;\n             array(1) {\n               [\"MongoDB\\Model\\CollectionInfoinfo\"]=&gt;\n               array(5) {\n                 [\"name\"]=&gt;\n                 string(4) \"list\"\n                 [\"type\"]=&gt;\n                 string(10) \"collection\"\n                 [\"options\"]=&gt;\n                 array(0) {\n                 }\n                 [\"info\"]=&gt;\n                 array(2) {\n                   [\"readOnly\"]=&gt;\n                   bool(false)\n                   [\"uuid\"]=&gt;\n                   object(MongoDB\\BSON\\Binary)#110 (2) {\n                     [\"data\"]=&gt;\n                     string(16) \"EasySwoole\"\n                     [\"type\"]=&gt;\n                     int(4)\n                   }\n                 }\n                 [\"idIndex\"]=&gt;\n                 array(4) {\n                   [\"v\"]=&gt;\n                   int(2)\n                   [\"key\"]=&gt;\n                   array(1) {\n                     [\"_id\"]=&gt;\n                     int(1)\n                   }\n                   [\"name\"]=&gt;\n                   string(4) \"_id_\"\n                   [\"ns\"]=&gt;\n                   string(9) \"user.list\"\n                 }\n               }\n             }\n           } \n        */\n\n        // 使用 php-mongodb 扩展时(不使用 mongodb/mongodb composer组件包)\n        /*\n        // 插入数据\n        $rets = MongoClient::getInstance()-&gt;invoke()-&gt;callback(function (Driver $driver) {\n            $bulk = new \\MongoDB\\Driver\\BulkWrite();\n\n            $bulk-&gt;insert([\n                'name' =&gt; Random::character(8),\n                'sex' =&gt; 'man',\n            ]);\n\n            $bulk-&gt;insert(['_id' =&gt; 1, 'x' =&gt; 1]);\n            $bulk-&gt;insert(['_id' =&gt; 2, 'x' =&gt; 2]);\n\n            $bulk-&gt;update(['x' =&gt; 2], ['$set' =&gt; ['x' =&gt; 1]], ['multi' =&gt; false, 'upsert' =&gt; false]);\n            $bulk-&gt;update(['x' =&gt; 3], ['$set' =&gt; ['x' =&gt; 3]], ['multi' =&gt; false, 'upsert' =&gt; true]);\n            $bulk-&gt;update(['_id' =&gt; 3], ['$set' =&gt; ['x' =&gt; 3]], ['multi' =&gt; false, 'upsert' =&gt; true]);\n\n            $bulk-&gt;insert(['_id' =&gt; 4, 'x' =&gt; 2]);\n\n            $bulk-&gt;delete(['x' =&gt; 1], ['limit' =&gt; 1]);\n\n            $manager = $driver-&gt;getDb();\n            $writeConcern = new \\MongoDB\\Driver\\WriteConcern(\\MongoDB\\Driver\\WriteConcern::MAJORITY, 100);\n            // 查到 user 库的 list 集合中\n            $ret = $manager-&gt;executeBulkWrite('user.list', $bulk, $writeConcern);\n\n            printf(\"Inserted %d document(s)\\n\", $ret-&gt;getInsertedCount()); // 插入条数\n            printf(\"Matched  %d document(s)\\n\", $ret-&gt;getMatchedCount()); // 匹配条数\n            printf(\"Updated  %d document(s)\\n\", $ret-&gt;getModifiedCount()); // 修改条数\n            printf(\"Upserted %d document(s)\\n\", $ret-&gt;getUpsertedCount()); // 修改插入条数\n            printf(\"Deleted  %d document(s)\\n\", $ret-&gt;getDeletedCount()); // 删除条数\n\n            foreach ($ret-&gt;getUpsertedIds() as $index =&gt; $id) {\n                printf('upsertedId[%d]: ', $index);\n                var_dump($id);\n            }\n\n            if (!$ret) {\n                return false;\n            }\n\n            return true;\n        });\n\n        // 查询数据\n        $rets = MongoClient::getInstance()-&gt;invoke()-&gt;callback(function (Driver $driver) {\n            $filter = ['x' =&gt; ['$gt' =&gt; 1]];\n            $options = [\n                'projection' =&gt; ['_id' =&gt; 0],\n                'sort' =&gt; ['x' =&gt; -1],\n            ];\n\n// 查询数据\n            $query = new \\MongoDB\\Driver\\Query($filter, $options);\n            $cursor = $driver-&gt;getDb()-&gt;executeQuery('user.list', $query);\n            foreach ($cursor as $document) {\n                print_r($document);\n            }\n        });\n        */\n\n    }\n}","link":"/Components/SyncInvoker/mongoDb.html"},{"id":341,"title":"热重载","content":"hot-reload\n用于开发过程中的代码热重载\n组件要求\n\neasyswoole/component: ^2.0\neasyswoole/spl: ^1.3\neasyswoole/utility: ^1.1\n\n安装方法\n\ncomposer require easyswoole/hot-reload\n\n仓库地址\neasyswoole/hot-reload\n基本使用\n单独使用\n// 创建一个服务\nrequire_once 'vendor/autoload.php';\n$server = new \\Swoole\\Server('0.0.0.0', '9801');\n$server-&gt;on('receive', function () {});\n\n// 设置监视器的选项\n$hotReloadOptions = new \\EasySwoole\\HotReload\\HotReloadOptions;\n// 虚拟机中可以关闭Inotify检测\n$hotReloadOptions-&gt;disableInotify(true);\n// 可以设置多个监控目录的绝对路径\n$hotReloadOptions-&gt;setMonitorFolder([dirname(__FILE__)]);\n// 忽略某些后缀名不去检测\n$hotReloadOptions-&gt;setIgnoreSuffix(['php', 'txt']);\n// 自定义检测到变更后的事件\n$hotReloadOptions-&gt;setReloadCallback(function (\\Swoole\\Server $server) {\n    echo \"File change event triggered\";  // 可以执行如清理临时目录等逻辑\n    $server-&gt;reload();  // 接管变更事件 需要自己执行重启\n});\n\n$hotReload = new \\EasySwoole\\HotReload\\HotReload($hotReloadOptions);\n$hotReload-&gt;attachToServer($server);\n$server-&gt;start();\nEasySwoole框架中使用\n请在全局事件(EasySwooleEvent)的mainServerCreate方法中进行注册\nclass EasySwooleEvent {\n\n    // 省略部分代码 ...\n\n    /**\n     * 服务启动时\n     * @param EventRegister $register\n     * @throws Exception\n     */\n    public static function mainServerCreate(EventRegister $register)\n    {\n        // 配置同上别忘了添加要检视的目录\n        $hotReloadOptions = new \\EasySwoole\\HotReload\\HotReloadOptions;\n        $hotReload = new \\EasySwoole\\HotReload\\HotReload($hotReloadOptions);\n        $hotReloadOptions-&gt;setMonitorFolder([EASYSWOOLE_ROOT . '/App']);\n\n        $server = ServerManager::getInstance()-&gt;getSwooleServer();\n        $hotReload-&gt;attachToServer($server);\n    }\n\n    // 省略部分代码 ...\n\n}\n注意\n方便的热重载组件，在Linux环境下使用Inotify，其他环境或虚拟机内使用iNode脏检测扫描实现开发过程中的代码热重载，可自定义重载处理逻辑，由于可以自定义，也可以作为一个方便的文件变更事件触发器使用，在文件变更时执行一些逻辑\n!!!警告!!! 仅供开发使用，请勿在生产环境使用，以免意外重启造成逻辑异常","link":"/Components/hotReload.html"},{"id":342,"title":"linuxdash","content":"LinuxDash\nlinuxDash封装了很多直接获取linux信息的命令,可以查看相关信息\n组件要求\n\nphp: &gt;=7.1.0\next-swoole: ^4.4.0\neasyswoole/spl: ^1.3\n\n安装方法\n\ncomposer require easyswoole/linux-dash \n\n仓库地址\neasyswoole/linux-dash\n基本使用\n\n$run = new \\Swoole\\Coroutine\\Scheduler();\n$run-&gt;add(function () {\n    //获取ip地址网卡缓冲信息\n    $data = LinuxDash::arpCache();\n    var_dump($data);\n    //获取当前带宽数据\n    $data = LinuxDash::bandWidth();\n    var_dump($data);\n    //获取cpu进程占用排行信息\n    $data = LinuxDash::cpuIntensiveProcesses();\n    var_dump($data);\n    //获取磁盘分区信息\n    $data = LinuxDash::diskPartitions();\n    var_dump($data);\n    //获取当前内存使用信息\n    $data = LinuxDash::currentRam();\n    var_dump($data);\n    //获取cpu信息\n    $data = LinuxDash::cpuInfo();\n    var_dump($data);\n    //获取当前系统信息\n    $data = LinuxDash::generalInfo();\n    var_dump($data);\n    //获取当前磁盘io统计\n    $data = LinuxDash::ioStats();\n    var_dump($data);\n    //获取ip地址\n    $data = LinuxDash::ipAddresses();\n    var_dump($data);\n    //CPU负载信息\n    $data = LinuxDash::loadAvg();\n    var_dump($data);\n    //获取内存详细信息\n    $data = LinuxDash::memoryInfo();\n    var_dump($data);\n    //获取进程占用内存排行信息\n    $data = LinuxDash::ramIntensiveProcesses();\n    var_dump($data);\n    //获取swap交换空间信息\n    $data = LinuxDash::swap();\n    var_dump($data);\n    //获取当前用户名信息\n    $data = LinuxDash::userAccounts();\n    var_dump($data);\n\n});\n$run-&gt;start();\n注意，mac环境不兼容。但是可以用docker测试","link":"/Components/linuxDash.html"},{"id":343,"title":"filewatcher","content":"File-Watcher 组件\n用于在 EasySwoole 中实现热重启，让开发变得更简便。\n组件要求\n\neasyswoole/spl: ^1.3\neasyswoole/component: ^2.2\n\n安装方法\n\ncomposer require easyswoole/file-watcher\n\n仓库地址\neasyswoole/file-watcher\nWatchRule\n监控目录:\n$watchRule = new \\EasySwoole\\FileWatcher\\WatchRule(EASYSWOOLE_ROOT.\"/App\");\n指定忽略目录：\n/**@var \\EasySwoole\\FileWatcher\\WatchRule $watchRule **/\n$watchRule-&gt;setIgnorePaths([EASYSWOOLE_ROOT.\"/App/Api\", EASYSWOOLE_ROOT.\"/App/Admin\"]);\n指定忽略文件：\n/**@var \\EasySwoole\\FileWatcher\\WatchRule $watchRule **/\n$watchRule-&gt;setIgnoreFiles([EASYSWOOLE_ROOT.\"/App/Api/Teacher.php\", EASYSWOOLE_ROOT.\"/App/Admin/Teacher.php\"]);\n指定匹配后缀：\n/**@var \\EasySwoole\\FileWatcher\\WatchRule $watchRule **/\n$watchRule-&gt;setType($watchRule::SCAN_TYPE_SUFFIX_MATCH);\n//$watchRule-&gt;setType($watchRule::SCAN_TYPE_IGNORE_SUFFIX);\n$watchRule-&gt;setSuffix(['php']);\ntype为SCAN_TYPE_SUFFIX_MATCH时，只匹配后缀必须在suffix规则数组的文件。 type为SCAN_TYPE_IGNORE_SUFFIX时，会忽略掉后缀在suffix规则数组的文件。\nFileWatcher\n设置监控程序:\n$fileWatcher = new \\EasySwoole\\FileWatcher\\FileWatcher();\n$fileWatcher-&gt;setScannerDriver(\\EasySwoole\\FileWatcher\\Scanner\\Inotify::class);\n$fileWatcher-&gt;setScannerDriver(\\EasySwoole\\FileWatcher\\Scanner\\FileScanner::class);\n二选一 不调用此方法 存在inotify扩展默认为Inotify::class反之FileScanner::class\n增加监控规则：\n/**@var \\EasySwoole\\FileWatcher\\FileWatcher $fileWatcher **/\n$fileWatcher-&gt;addRule(new \\EasySwoole\\FileWatcher\\WatchRule(__DIR__));\n$fileWatcher-&gt;addRule(new \\EasySwoole\\FileWatcher\\WatchRule(EASYSWOOLE_ROOT. '/App'));\n可进行多次调用 对不同目录设置不同的规则\n设置异常回调：\n/**@var \\EasySwoole\\FileWatcher\\FileWatcher $fileWatcher **/\n$fileWatcher-&gt;setOnException(function (\\Throwable $throwable){\n\n});\n设置检测周期(默认1000ms)：\n/**@var \\EasySwoole\\FileWatcher\\FileWatcher $fileWatcher **/\n$fileWatcher-&gt;setCheckInterval(1000);\n设置触发回调(文件有变化)：\n/**@var \\EasySwoole\\FileWatcher\\FileWatcher $fileWatcher **/\n$fileWatcher-&gt;setOnChange(function (array $list, \\EasySwoole\\FileWatcher\\WatchRule $rule){\n    // list为变化的文件列表\n});\n启动(swoole服务中使用)：\n/**@var \\EasySwoole\\FileWatcher\\FileWatcher $fileWatcher **/\n/**@var \\Swoole\\Server $server **/\n$fileWatcher-&gt;attachServer($server);\nEasySwoole 中用于热重启\n例如在 EasySwoole 开发模式中，我们希望当有代码变动的时候，实现 Server 重启，只需要在 EasySwoole 的全局事件 EasySwooleEvent 中注册一下即可实现。 示例代码如下：\n&lt;?php\n\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\nuse EasySwoole\\FileWatcher\\FileWatcher;\nuse EasySwoole\\FileWatcher\\WatchRule;\n\nclass EasySwooleEvent implements Event\n{\n    public static function initialize()\n    {\n        date_default_timezone_set('Asia/Shanghai');\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        $watcher = new FileWatcher();\n        $rule = new WatchRule(EASYSWOOLE_ROOT . \"/App\"); // 设置监控规则和监控目录\n        $watcher-&gt;addRule($rule);\n        $watcher-&gt;setOnChange(function () {\n            Logger::getInstance()-&gt;info('file change ,reload!!!');\n            ServerManager::getInstance()-&gt;getSwooleServer()-&gt;reload();\n        });\n        $watcher-&gt;attachServer(ServerManager::getInstance()-&gt;getSwooleServer());\n    }\n}\n注意，reload 仅仅针对 Worker进程 加载的代码有效。","link":"/Components/fileWatcher.html"},{"id":344,"title":"arraytotexttable","content":"ArrayToTextTable\n功能介绍\n用于把数组数据转为表格输出。\n相关Class位置\n\nArrayToTextTable\n\n\nnamespace: EasySwoole\\Utility\\ArrayToTextTable\n\n\n\n\n核心对象方法\ngetTable\n获取表格\n\nmixed $data 表格数据\n\npublic function getTable($data = null)\nsetIndentation\n设置表格缩进\n\nmixed $indentation 设置缩进\n\npublic function setIndentation($indentation)\nisDisplayHeader\n设置表格头部\n\nbool $displayHeader 是否需要表格头部\n\npublic function isDisplayHeader(bool $displayHeader)\nsetKeysAlignment\n设置表格头部对齐方式\n\nmixed $keysAlignment 表格头部对齐方式\n\npublic function setKeysAlignment($keysAlignment)\nsetValuesAlignment\n设置表格数据对齐方式\n\nmixed $keysAlignment 表格头部对齐方式\n\npublic function setValuesAlignment($valuesAlignment)\nsetFormatter\n处理表格数据格式\n\nmixed $formatter 数据方式\n\npublic function setFormatter($formatter)\n基本使用\n创建核心类的对象\n$data = [\n    [\n        'name' =&gt; 'James',\n        'age' =&gt; '20',\n        'sex'=&gt;'男'\n    ],\n    [\n        'name' =&gt; 'Tony',\n        'age' =&gt; 50,\n        'email' =&gt; '291323003@qq.com',\n    ],\n];\n//创建核心类的对象，并带入了数据参数  $data\n$renderer = new \\EasySwoole\\Utility\\ArrayToTextTable($data);\n//设置表格缩进\n$renderer-&gt;setIndentation(\"\\t\");\n//设置表格头部\n$renderer-&gt;isDisplayHeader(true);\n//设置表格头部对齐方式\n$renderer-&gt;setKeysAlignment(\\EasySwoole\\Utility\\ArrayToTextTable::AlignLeft);\n//设置表格数据对齐方式\n$renderer-&gt;setValuesAlignment(\\EasySwoole\\Utility\\ArrayToTextTable::AlignLeft);\n//处理表格数据格式\n$renderer-&gt;setFormatter(function (&amp;$value,$key){\n    if($key == 'sex'){\n        if(empty($value)){\n            $value = '未知性别';\n        }\n    }else if($key == 'email'){\n        if(empty($value)){\n            $value = '未知邮箱';\n        }\n    }\n});\n\n$table =  $renderer-&gt;getTable();\n\necho $renderer;\n​       ps: 执行的时候请用命令行的模式运行；如若遇到表格的外框线没有对齐，请检查中文字体和英文的字体所占用的空间比是否为2：1。","link":"/Components/Help/arrayToTextTable.html"},{"id":345,"title":"file","content":"File\n功能介绍\n用于操作文件或目录。\n相关class位置\n\nFile\n\n\nnamespace: EasySwoole\\Utility\\File\n\n\n\n\n核心对象方法\ncreateDirectory\n创建目录：\n\nstring $dirPath 目录路径\nstring $permissions 目录权限\n\nstatic function createDirectory($dirPath, $permissions = 0755):bool\ncleanDirectory\n清空目录：\n\nstring $dirPath 目录路径\nstring $keepStructure 是否保持目录结构\n\nstatic function cleanDirectory($dirPath, $keepStructure = false):bool\ndeleteDirectory\n删除目录：\n\nstring $dirPath 目录路径\n\nstatic function deleteDirectory($dirPath):bool\ncopyDirectory\n复制目录：\n\nstring $source 源位置\nstring $target 目标位置\nbool $overwrite 是否覆盖\n\nstatic function copyDirectory($source, $target, $overwrite = true):bool\nmoveDirectory\n移动目录：\n\nstring $source 源位置\nstring $target 目标位置\nbool $overwrite 是否覆盖\n\nstatic function moveDirectory($source, $target ,$overwrite = true):bool\ncopyFile\n复制文件：\n\nstring $source 源位置\nstring $target 目标位置\nbool $overwrite 是否覆盖\n\nstatic function copyFile($source, $target, $overwrite = true):bool\ntouchFile\n创建空文件：\n\nstring $filePath 文件名\nbool $overwrite 是否覆盖\n\nstatic function touchFile($filePath, $overwrite = true):bool\ncreateFile\n创建有内容文件：\n\nstring $filePath 文件名\nstring $content 内容\nbool $overwrite 是否覆盖\n\nstatic function createFile($filePath, $content, $overwrite = true):bool\nmoveFile\n移动文件：\n\nstring $source 源位置\nstring $target 目标位置\nbool $overwrite 是否覆盖\n\nstatic function moveFile($source, $target, $overwrite = true):bool\n\nscanDirectory\n获得文件目录或目录文件数组：\n\nstring $dirPath 目录路径\n\nstatic function scanDirectory($dirPath)","link":"/Components/Help/file.html"},{"id":346,"title":"hash","content":"Hash\n功能介绍\n用于快速处理哈希密码以及数据完整性校验等场景\n相关class位置\n\nHash\n\n\nnamespace: EasySwoole\\Utility\\Hash\n\n\n\n\n核心对象方法\nmakePasswordHash\n从一个明文值生产哈希\n\nmixed $value 需要生产哈希的原文\nmixed $cost 递归的层数\n\nstatic function makePasswordHash($value, $cost = 10)\nvalidatePasswordHash\n校验明文值与哈希是否匹配\n\nmixed $value 原文\nmixed $cost 哈希加密文\n\nstatic function validatePasswordHash($value, $hashValue)\n基本使用\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 上午10:10\n */\n\nrequire './vendor/autoload.php';\n\n$password = 123456;\n$hash = \\EasySwoole\\Utility\\Hash::makePasswordHash($password);\nvar_dump($hash);\nvar_dump(\\EasySwoole\\Utility\\Hash::validatePasswordHash($password, $hash));\n\n/**\n * 输出结果:\n * string(60) \"$2y$10$ESx0z8TGSJpMI3Hgr6nJJOdbretS2TBqv4d5L0XjlTkSjSiCiq/f6\"\n * bool(true) \n */","link":"/Components/Help/hash.html"},{"id":347,"title":"random","content":"Random\n功能介绍\n用于生成随机验证码,随机字符串等等\n相关class位置\n\nRandom\n\n\nnamespace: EasySwoole\\Utility\\Random\n\n\n\n\n核心对象方法\ncharacter\n字符串随机生成：\n\nint $length 生成长度\nstring $alphabet 自定义生成字符集\n\nstatic function character($length = 6, $alphabet = 'AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz0123456789')\nnumber\n纯数字字符串随机生成：\n\nint $length 生成长度\n\nstatic function number(length = 6)\narrayRandOne\n从集合里面随机产生一个个体：\n\narray $length 数组集合\n\nstatic function arrayRandOne(array $data)\n基本使用\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 上午10:10\n */\n\nrequire './vendor/autoload.php';\n\nvar_dump(\\EasySwoole\\Utility\\Random::character());\nvar_dump(\\EasySwoole\\Utility\\Random::number());\nvar_dump(\\EasySwoole\\Utility\\Random::arrayRandOne(['one', 'two', 'three']));\n\n/**\n * 输出结果:\n * string(6) \"W94ohx\"\n * string(6) \"986543\"\n * string(3) \"two\"\n */","link":"/Components/Help/random.html"},{"id":348,"title":"snowflake","content":"雪花算法\n功能介绍\n生成唯一编号\n相关class位置\n\nSnowFlake\n\n\nnamespace: EasySwoole\\Utility\\SnowFlake\n\n\n\n\n核心对象方法\nmake\n生成基于雪花算法的随机编号\n\nmixed $dataCenterID 数据中心\nmixed $workerID 任务进程\n\nstatic function make($dataCenterID = 0, $workerID = 0)\nunmake\n反向解析雪花算法生成的编号\n\nmixed $snowFlakeId 编号\n\nstatic function unmake($snowFlakeId)\n基本使用\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 上午10:10\n */\n\nrequire './vendor/autoload.php';\n\n$str = \\EasySwoole\\Utility\\SnowFlake::make(1,1);//传入数据中心id(0-31),任务进程id(0-31)\nvar_dump($str);\nvar_dump(\\EasySwoole\\Utility\\SnowFlake::unmake($str));\n\n/**\n * 输出结果:\n * int(194470364728922112)\n * object(stdClass)#3 (4) {\n *   [\"timestamp\"]=&gt;\n *   int(1532127766018)\n *   [\"dataCenterID\"]=&gt;\n *   int(1)\n *   [\"workerID\"]=&gt;\n *   int(1)\n *   [\"sequence\"]=&gt;\n *   int(0)\n * }\n */","link":"/Components/Help/snowFlake.html"},{"id":349,"title":"str","content":"Str\n功能介绍\nStr字符串助手\n相关class位置\n\nStr\n\n\nnamespace: EasySwoole\\Utility\\Str\n\n\n\n\n核心对象方法\ncontains\n检查字符串中是否包含另一字符串\n\nmixed $haystack 被检查的字符串\nmixed $needles 需要包含的字符串\nmixed $strict 是否区分大小写\n\nstatic function contains($haystack, $needles, $strict = true)\nstartsWith\n检查字符串是否以某个字符串开头\n\nmixed $haystack 被检查的字符串\nmixed $needles 需要包含的字符串\nmixed $strict 是否区分大小写\n\nstatic function startsWith($haystack, $needles, $strict = true)\nendsWith\n检查字符串是否以某个字符串结尾\n\nmixed $haystack 被检查的字符串\nmixed $needles 需要包含的字符串\nmixed $strict 是否区分大小写\n\nstatic function endsWith($haystack, $needles, $strict = true)\nsnake\n驼峰转下划线\n\nmixed $value 待处理字符串\nmixed $delimiter 分隔符\n\nstatic function snake($value, $delimiter = '_')\ncamel\n下划线转驼峰 (首字母小写)\n\nmixed $value 待处理字符串\n\nstatic function camel($value)\nstudly\n下划线转驼峰 (首字母大写)\n\nmixed $value 待处理字符串\n\nstatic function studly($value)\n基本使用\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 上午10:10\n */\n\nrequire './vendor/autoload.php';\n\nvar_dump(\\EasySwoole\\Utility\\Str::contains('hello, easyswoole', 'Swoole', false));\n\n/**\n * 输出结果:\n * bool(true)\n */\n\nvar_dump(\\EasySwoole\\Utility\\Str::startsWith('hello, easyswoole', 'Hello', false));\n\n/**\n * 输出结果:\n * bool(true)\n */\n\nvar_dump(\\EasySwoole\\Utility\\Str::endsWith('hello, easyswoole', 'Swoole', false));\n\n/**\n * 输出结果:\n * bool(true)\n */\n\nvar_dump(\\EasySwoole\\Utility\\Str::snake('EasySwoole'));\n\n/**\n * 输出结果:\n * string(11) \"easy_swoole\"\n */\n\nvar_dump(\\EasySwoole\\Utility\\Str::camel('easy_swoole'));\n\n/**\n * 输出结果:\n * string(10) \"easySwoole\"\n */\n\nvar_dump(\\EasySwoole\\Utility\\Str::studly('easy_swoole'));\n\n/**\n * 输出结果:\n * string(10) \"EasySwoole\"\n */","link":"/Components/Help/str.html"},{"id":350,"title":"time","content":"Time\n功能介绍\n时间戳助手\n相关class位置\n\nTime\n\n\nnamespace: EasySwoole\\Utility\\Time\n\n\n\n\n核心对象方法\nstartTimestamp\n返回某一天开始的时间戳\n\nmixed $date 字符串日期或时间戳\n\nstatic function startTimestamp($date = '')\nendTimestamp\n返回某一天结束的时间戳\n\nmixed $date 字符串日期或时间戳\n\nstatic function endTimestamp($date = '')\nendTimestamp\n从字符串创建出 Datetime 对象\n\nmixed $datetime 传入文本日期或者时间戳\n\nstatic function createDateTimeClass($datetime = '')\nparserDateTime\n从DateTime对象中获取年月日时分秒\n\nmixed $datetime 传入文本日期或者时间戳\n\nstatic function parserDateTime($dateTime)\n基本使用\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: root\n * Date: 19-1-9\n * Time: 上午10:10\n */\n\nrequire './vendor/autoload.php';\n\nvar_dump(\\EasySwoole\\Utility\\Time::startTimestamp('2019-4-15'));\n\n/**\n * 输出结果:\n * int(1555286400)\n */\n\nvar_dump(\\EasySwoole\\Utility\\Time::endTimestamp('2019-4-15'));\n\n/**\n * 输出结果:\n * int(1555372799)\n */\n\nvar_dump(\\EasySwoole\\Utility\\Time::createDateTimeClass('2019-4-15'));\n\n/**\n * 输出结果:\n * object(DateTime)#3 (3) {\n *   [\"date\"]=&gt;\n *   string(26) \"2019-04-15 00:00:00.000000\"\n *   [\"timezone_type\"]=&gt;\n *   int(1)\n *   [\"timezone\"]=&gt;\n *   string(6) \"+00:00\"\n * }\n */\n\nvar_dump(\\EasySwoole\\Utility\\Time::parserDateTime('2019-4-15'));\n\n/**\n * 输出结果:\n * array(6) {\n *   [0]=&gt;\n *   string(2) \"00\"\n *   [1]=&gt;\n *   string(2) \"00\"\n *   [2]=&gt;\n *   string(2) \"00\"\n *   [3]=&gt;\n *   string(1) \"4\"\n *   [4]=&gt;\n *   string(2) \"15\"\n *   [5]=&gt;\n *   string(4) \"2019\"\n * }\n */","link":"/Components/Help/time.html"},{"id":351,"title":"intstr","content":"IntStr\n功能介绍\n用于 整数(需要转换的整数必须在 0 ~ 9223372036854775668 范围之内) 和 字符串 的相互转换，即：可以把一个字符串转换成一个数字，反之，通过这个数字，我们可以得到之前的字符串。\n可用于生成 url 短链接。\n相关class位置\n\nIntStr\n\n\nnamespace: EasySwoole\\Utility\\IntStr \n\n\n\n核心对象方法\ntoAlpha\n生成基于 整数 对应的 字符串\n\nint $number 要生成字符串的数字\n\npublic static function toAlpha(int $number): string\ntoNum\n反向解析 字符串 对应的 数字\n\nstring $string 待解析的字符串\n\npublic static function toNum(string $string): int\n基本使用\n&lt;?php\nrequire __DIR__ . '/vendor/autoload.php';\n\n// 传入小于 9223372036854775668 的整数，得到一个字符串，通过此字符串可以反向解析成对应的数组\n$str = \\EasySwoole\\Utility\\IntStr::toAlpha(122407155078249761);\nvar_dump($str);\n\n// 传入字符串得到对应的数字\n$num = \\EasySwoole\\Utility\\IntStr::toNum('EasySwoole');\nvar_dump($num);\n\n// 用于生成短链接\n$domain_prefix = 'https://easyswoole.com';\n$path1 = \\EasySwoole\\Utility\\IntStr::toNum('Preface');\n$path2 = \\EasySwoole\\Utility\\IntStr::toNum('intro');\n$new_short_url = \"{$domain_prefix}/{$path1}/{$path2}\";\nvar_dump($new_short_url); // 生成的短链接\n\n$real_path1 = \\EasySwoole\\Utility\\IntStr::toAlpha($path1);\n$real_path2 = \\EasySwoole\\Utility\\IntStr::toAlpha($path2);\n$real_url = \"{$domain_prefix}/{$real_path1}/{$real_path2}\";\nvar_dump($real_url); // 真实的请求地址\n\n/**\n * 输出结果:\n * string(10) \"EasySwoole\"\n * int(122407155078249761) \n * string(46) \"https://easyswoole.com/1793938716421/272803253\"\n * string(36) \"https://easyswoole.com/Preface/intro\"\n */","link":"/Components/Help/intStr.html"},{"id":352,"title":"jwt令牌","content":"JWT\nJSON Web Token（JWT）是目前最流行的跨域身份验证解决方案。\n随着技术的发展，分布式web应用的普及，通过session管理用户登录状态成本越来越高，因此慢慢发展成为token的方式做登录身份校验，然后通过token去取redis中的缓存的用户信息，随着之后jwt的出现，校验方式更加简单便捷化，无需通过redis缓存，而是直接根据token取出保存的用户信息，以及对token可用性校验，单点登录更为简单。\n\n建议阅读一下\n组件要求\n\nphp: &gt;=7.1.0\next-openssl: &gt;=1.0.0\neasyswoole/spl: ^1.2\neasyswoole/utility: ^1.1\n\n安装方法\n\ncomposer require easyswoole/jwt \n\n仓库地址\neasyswoole/jwt\n核心类库方法\n编码相关\n设置加密方式，默认HMACSHA256\n    function algMethod(string $method):Jwt\n设置秘钥，默认Easyswoole\n    function setSecretKey(string $key):Jwt\n初始化一个没有附带信息的token的JwtObject\n    public function publish():JwtObject\n设置加密方式, 默认HMACSHA256\n    public function setAlg($alg): self\n设置用户\n    public function setAud($aud): self\n设置过期时间\n    public function setExp($exp): self\n设置发布时间\n    public function setIat($iat): self\n设置发行人\n    public function setIss(string $iss): self\n设置jwt-id，用于标识该jwt\n    public function setJti($jti): self\n在此之前不可用\n    public function setNbf($nbf): self\n设置主题\n    public function setSub($sub): self\n设置其他数据\n    public function setData($data): self\n获取token\n    function __toString()\n解码相关\n解码\n    public function decode(?string $raw):?JwtObject\n获取解码状态, 1:通过, -1:无效, -2:token过期\n    public function getStatus(): int\n获取加密方式\n    public function getAlg()\n获取用户\n    public function getAud()\n获取过期时间\n    public function getExp()\n获取发布时间\n    public function getIat()\n获取发行人\n    public function getIss(): string\n获取jwt-id\n    public function getJti()\n获取生效时间\n    public function setNbf($nbf): void\n获取主题\n    public function getSub()\n获取自定义数据\n    public function getData()\n获取签名\n    public function getSignature()\n通过key获取相关数据\n    final public function getProperty($name)\n基本使用\n生成token\nuse EasySwoole\\Jwt\\Jwt;\n\n$jwtObject = Jwt::getInstance()\n    -&gt;setSecretKey('easyswoole') // 秘钥\n    -&gt;publish();\n\n$jwtObject-&gt;setAlg('HMACSHA256'); // 加密方式\n$jwtObject-&gt;setAud('user'); // 用户\n$jwtObject-&gt;setExp(time()+3600); // 过期时间\n$jwtObject-&gt;setIat(time()); // 发布时间\n$jwtObject-&gt;setIss('easyswoole'); // 发行人\n$jwtObject-&gt;setJti(md5(time())); // jwt id 用于标识该jwt\n$jwtObject-&gt;setNbf(time()+60*5); // 在此之前不可用\n$jwtObject-&gt;setSub('主题'); // 主题\n\n// 自定义数据\n$jwtObject-&gt;setData([\n    'other_info'\n]);\n\n// 最终生成的token\n$token = $jwtObject-&gt;__toString();\n解析token\nuse EasySwoole\\Jwt\\Jwt;\n\n$token = \"eyJhbGciOiJITUFDU0hBMjU2IiwiaXNzIjoiZWFzeXN3b29sZSIsImV4cCI6MTU3MzgzNTIxMSwic3ViIjoi5Li76aKYIiwibmJmIjoxNTczODMxOTExLCJhdWQiOiJ1c2VyIiwiaWF0IjoxNTczODMxNjExLCJqdGkiOiJjYWJhZmNiMWIxZTkxNTU3YzIxMDUxYTZiYTQ0MTliMiIsInNpZ25hdHVyZSI6IjZlNTI1ZjJkOTFjZGYzMjBmODE1NmEwMzE1MDhiNmU0ZDQ0YzhkNGFhYzZjNmU1YzMzMTNjMDIyMGJjYjJhZjQiLCJzdGF0dXMiOjEsImRhdGEiOlsib3RoZXJfaW5mbyJdfQ%3D%3D\";\n\ntry {\n    $jwtObject = Jwt::getInstance()-&gt;decode($token);\n\n    $status = $jwtObject-&gt;getStatus();\n\n    // 如果encode设置了秘钥,decode 的时候要指定\n    // $status = $jwt-&gt;setSecretKey('easyswoole')-&gt;decode($token)\n\n    switch ($status)\n    {\n        case  1:\n            echo '验证通过';\n            $jwtObject-&gt;getAlg();\n            $jwtObject-&gt;getAud();\n            $jwtObject-&gt;getData();\n            $jwtObject-&gt;getExp();\n            $jwtObject-&gt;getIat();\n            $jwtObject-&gt;getIss();\n            $jwtObject-&gt;getNbf();\n            $jwtObject-&gt;getJti();\n            $jwtObject-&gt;getSub();\n            $jwtObject-&gt;getSignature();\n            $jwtObject-&gt;getProperty('alg');\n            break;\n        case  -1:\n            echo '无效';\n            break;\n        case  -2:\n            echo 'token过期';\n        break;\n    }\n} catch (\\EasySwoole\\Jwt\\Exception $e) {\n\n}","link":"/Components/jwt.html"},{"id":353,"title":"policy","content":"Policy\nPolicy（即策略）是在特定模型或者资源中组织授权逻辑的类，用来处理用户授权动作。\n组件要求\n\nphp: ^7.1\next-json: &gt;=1.0\neasyswoole/spl: ^1.1\n\n安装\n\ncomposer require easyswoole/policy\n\n仓库地址\neasyswlle/policy\n使用方法\n\nuse EasySwoole\\Policy\\PolicyNode;\nuse EasySwoole\\Policy\\Policy;\n\n//授权动作\n//PolicyNode::EFFECT_ALLOW   允许\n//PolicyNode::EFFECT_DENY    拒绝\n//PolicyNode::EFFECT_UNKNOWN 未知\n\n$policy = new Policy();\n//添加节点授权   \n$policy-&gt;addPath('/user/add',PolicyNode::EFFECT_ALLOW);\n$policy-&gt;addPath('/user/update',PolicyNode::EFFECT_ALLOW);\n$policy-&gt;addPath('/user/delete',PolicyNode::EFFECT_DENY);\n$policy-&gt;addPath('/user/*',PolicyNode::EFFECT_DENY);\n\n//验证节点权限\nvar_dump($policy-&gt;check('user/asdasd'));//deny\nvar_dump($policy-&gt;check('user/add'));   //allow\nvar_dump($policy-&gt;check('user/update'));//allow\n\n/*\n * 允许/api/*,但是唯独拒绝/api/order/charge,/api/order/info,/api/sys/*\n */\n\n$policy-&gt;addPath('/api/*',PolicyNode::EFFECT_ALLOW);\n$policy-&gt;addPath('/api/order/charge',PolicyNode::EFFECT_DENY);\n$policy-&gt;addPath('/api/order/info',PolicyNode::EFFECT_DENY);\n$policy-&gt;addPath('/api/sys/*',PolicyNode::EFFECT_DENY);\n\nvar_dump($policy-&gt;check('/api/whatever'));\nvar_dump($policy-&gt;check('/api/order/charge'));\nvar_dump($policy-&gt;check('/api/order/info'));\nvar_dump($policy-&gt;check('/api/sys/whatever'));\n\n//对象添加\n$root = new PolicyNode('*');\n$userChild = $root-&gt;addChild('user');\n$userAddChild = $userChild-&gt;addChild('add');\n$userAddChild-&gt;addChild('aaaaaa')-&gt;setAllow(PolicyNode::EFFECT_ALLOW);\n$userChild-&gt;addChild('update')-&gt;setAllow(PolicyNode::EFFECT_DENY);\n$userChild-&gt;addChild('*')-&gt;setAllow(PolicyNode::EFFECT_ALLOW);\n\n$apiChild = $root-&gt;addChild('charge');\n$apiChild-&gt;addChild('*');\n\n$node = $root-&gt;search('/user/add/aaaa');\nif ($node) {\n    var_dump($node-&gt;isAllow());\n}\n\n相关仓库\n基于Policy组件的后台权限管理demo easyswoole_admin","link":"/Components/policy.html"},{"id":354,"title":"安装","content":"words-match\nwords-match组件是基于字典树(DFA)并利用UnixSock通讯和自定义进程实现，开发本组件的目的是帮小伙伴们快速部署内容检测服务。\n使用场景\n\n\n跟文字内容相关的产品都有应用场景。\n\n\n博客类的文章，评论的检测\n\n\n聊天内容的检测\n\n\n对垃圾内容的屏蔽\n\n\n组件要求\nNone\n安装方法\n\ncomposer require easyswoole/words-match\n\n仓库地址\neasyswoole/words-match\n基本使用\n准备词库\n服务启动的时候会一行一行将数据读出来，每一行的第一列为敏感词，其它列为附属信息\nphp※是世界上※最好的语言\njava\ngolang\n程序员\n代码\n逻辑\n服务注册\n&lt;?php\n\nnamespace EasySwoole\\EasySwoole;\n\nuse EasySwoole\\Component\\Di;\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\nuse EasySwoole\\WordsMatch\\WMServer;\n\nclass EasySwooleEvent implements Event\n{\n    public static function initialize()\n    {\n        date_default_timezone_set('Asia/Shanghai');\n\n        Di::getInstance()-&gt;set(SysConst::HTTP_GLOBAL_ON_REQUEST, function (Request $request, Response $response): bool {\n            // TODO: Implement onRequest() method.\n            return true;\n        });\n\n        Di::getInstance()-&gt;set(SysConst::HTTP_GLOBAL_AFTER_REQUEST, function (Request $request, Response $response): void {\n            // TODO: Implement onRequest() method.\n        });\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n        // 配置 words-match\n        $wdConfig = new \\EasySwoole\\WordsMatch\\Config();\n        $wdConfig-&gt;setDict(__DIR__ . '/dictionary.txt'); // 配置 词库地址\n        $wdConfig-&gt;setMaxMEM(1024); // 配置 每个进程最大占用内存(M)，默认为 512 M\n        $wdConfig-&gt;setTimeout(3.0); // 配置 内容检测超时时间。默认为 3.0 s\n        $wdConfig-&gt;setWorkerNum(3); // 配置 进程数\n        // $wdConfig-&gt;setSockDIR(sys_get_temp_dir()); // (不建议修改)配置 socket 存放地址，默认为 sys_get_temp_dir()，即 '/tmp'\n\n        // 注册服务\n        WMServer::getInstance($wdConfig)-&gt;attachServer(ServerManager::getInstance()-&gt;getSwooleServer());\n    }\n}\n客户端使用\n&lt;?php\n\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\nuse EasySwoole\\WordsMatch\\WMServer;\n\nclass Index extends Controller\n{\n    function detect()\n    {\n        // 需要检测的内容敏感词\n        $content = 'php是世界上最好的语言';\n        // 检测结果（返回 -1 表示检测超时，匹配检测到时返回检测到的敏感词内容）\n        $result = WMServer::getInstance()-&gt;detect($content, 3);\n        var_dump($result);\n        /**\n         * 输出结果：\n         * array(1) {\n            [0]=&gt;\n            object(EasySwoole\\WordsMatch\\Dictionary\\DetectResult)#96 (5) {\n            [\"word\"]=&gt;\n            string(30) \"php是世界上最好的语言\"\n            [\"location\"]=&gt;\n            array(1) {\n              [0]=&gt;\n              array(3) {\n                [\"word\"]=&gt;\n                string(30) \"php是世界上最好的语言\"\n                [\"length\"]=&gt;\n                int(12)\n                [\"location\"]=&gt;\n                array(1) {\n                  [0]=&gt;\n                  int(0)\n                }\n              }\n            }\n            [\"count\"]=&gt;\n            int(1)\n            [\"remark\"]=&gt;\n            string(0) \"\"\n            [\"type\"]=&gt;\n            int(1)\n            }\n         * }\n         */\n    }\n}\n压测结果\n对此组件分别进行1.5万、13万等级的词库测试，服务默认开启3个进程。\n仅做参考，具体还以线上验证\n电脑配置\nMacBook Air (13-inch, 2017)\n处理器 1.8 GHz Intel Core i5\n内存 8 GB 1600 MHz DDR3\n1.5万词\n并发10总请求数100\n10 100\nConcurrency Level:      10\nTime taken for tests:   0.067 seconds\nComplete requests:      100\nFailed requests:        0\nNon-2xx responses:      100\nTotal transferred:      17300 bytes\nHTML transferred:       2600 bytes\nRequests per second:    1492.49 [#/sec] (mean)\nTime per request:       6.700 [ms] (mean)\nTime per request:       0.670 [ms] (mean, across all concurrent requests)\nTransfer rate:          252.15 [Kbytes/sec] received\n并发100总请求数1000\nConcurrency Level:      100\nTime taken for tests:   0.239 seconds\nComplete requests:      1000\nFailed requests:        0\nNon-2xx responses:      1000\nTotal transferred:      173000 bytes\nHTML transferred:       26000 bytes\nRequests per second:    4189.17 [#/sec] (mean)\nTime per request:       23.871 [ms] (mean)\nTime per request:       0.239 [ms] (mean, across all concurrent requests)\nTransfer rate:          707.74 [Kbytes/sec] received\n13万词\n并发10总请求数100\nConcurrency Level:      10\nTime taken for tests:   0.057 seconds\nComplete requests:      100\nFailed requests:        0\nNon-2xx responses:      100\nTotal transferred:      17300 bytes\nHTML transferred:       2600 bytes\nRequests per second:    1751.71 [#/sec] (mean)\nTime per request:       5.709 [ms] (mean)\nTime per request:       0.571 [ms] (mean, across all concurrent requests)\nTransfer rate:          295.94 [Kbytes/sec] received\n并发100总请求数1000\nConcurrency Level:      100\nTime taken for tests:   0.225 seconds\nComplete requests:      1000\nFailed requests:        0\nNon-2xx responses:      1000\nTotal transferred:      173000 bytes\nHTML transferred:       26000 bytes\nRequests per second:    4444.84 [#/sec] (mean)\nTime per request:       22.498 [ms] (mean)\nTime per request:       0.225 [ms] (mean, across all concurrent requests)\nTransfer rate:          750.93 [Kbytes/sec] received","link":"/Components/WordsMatch/introduction.html"},{"id":355,"title":"常见问题","content":"实时添加、移除的词，服务停止后怎么办？\n\n1.x 版本服务停止时会将正在运行中的所有词落地到文件，2.x移除了这一特性\n我们更倾向于用户自己处理这些词。举个例子：比如你所有的词都存在db中，在线添加移除词时可相应更新db，\n然后定时去刷新词库文件。\n\n如何做到游戏中&quot;香词&quot;变*？\n\n检测结果中会有命中词在文章的具体位置，然后你再根据词的长度做相应的替换，或者你干脆直接替换命中的词，根据这个思路\n可以实现更多好玩的事情。\n\nQQ会根据聊天内容下表情雨，这是怎么做到的？\n\n检测聊天内容，命中相应关键词，拉取对应的表情扔到你屏幕上。\n\n","link":"/Components/WordsMatch/problem.html"},{"id":356,"title":"使用","content":"Spider\nSpider组件可以方便用户快速搭建分布式多协程爬虫，用户只需关心product和consume，product对dom的解析推荐使用Querylist\n安装\ncomposer require easyswoole/spider\n快速使用\n以百度搜索为例，根据搜索关键词爬出每次检索结果前几页的特定数据\n纯属教学目的，如有冒犯贵公司还请及时通知，会及时调整\nProduct\n&lt;?php\nnamespace App\\Spider;\n\nuse EasySwoole\\HttpClient\\HttpClient;\nuse EasySwoole\\Spider\\Config\\ProductConfig;\nuse EasySwoole\\Spider\\Hole\\ProductAbstract;\nuse EasySwoole\\Spider\\ProductResult;\nuse QL\\QueryList;\nuse EasySwoole\\FastCache\\Cache;\n\nclass ProductTest extends ProductAbstract\n{\n\n    public function product():ProductResult\n    {\n        // TODO: Implement product() method.\n        // 请求地址数据\n        $httpClient = new HttpClient($this-&gt;productConfig-&gt;getUrl());\n        $httpClient-&gt;setHeader('User-Agent', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.116 Safari/537.36');\n        $body = $httpClient-&gt;get()-&gt;getBody();\n\n        // 先将每个搜索结果的a标签内容拿到\n        $rules = [\n            'search_result' =&gt; ['.c-container .t', 'text', 'a']\n        ];\n        $searchResult = QueryList::rules($rules)-&gt;html($body)-&gt;query()-&gt;getData();\n\n        $data = [];\n        foreach ($searchResult as $result) {\n            $item = [\n                'href' =&gt; QueryList::html($result['search_result'])-&gt;find('a')-&gt;attr('href'),\n                'text' =&gt; QueryList::html($result['search_result'])-&gt;find('a')-&gt;text()\n            ];\n            $data[] = $item;\n        }\n\n        $productJobOtherInfo = $this-&gt;productConfig-&gt;getOtherInfo();\n\n        // 下一批任务\n        $productJobConfigs = [];\n        if ($productJobOtherInfo['page'] === 1) {\n            for($i=1;$i&lt;5;$i++) {\n                $pn = $i*10;\n                $productJobConfig = [\n                    'url' =&gt; \"https://www.baidu.com/s?wd={$productJobOtherInfo['word']}&amp;pn={$pn}\",\n                    'otherInfo' =&gt; [\n                        'word' =&gt; $productJobOtherInfo['word'],\n                        'page' =&gt; $i+1\n                    ]\n                ];\n                $productJobConfigs[] = $productJobConfig;\n            }\n\n            $word = Cache::getInstance()-&gt;deQueue(self::SEARCH_WORDS);\n            if (!empty($word)) {\n                $productJobConfigs[] = [\n                    'url' =&gt; \"https://www.baidu.com/s?wd={$word}&amp;pn=0\",\n                    'otherInfo' =&gt; [\n                        'word' =&gt; $word,\n                        'page' =&gt; 1\n                    ]\n                ];\n            }\n\n        }\n\n        $result = new ProductResult();\n        $result-&gt;setProductJobConfigs($productJobConfigs)-&gt;setConsumeData($data);\n        return $result;\n    }\n\n}\nConsume\n我这里直接存文件了，可按照需求自己定制\n&lt;?php\nnamespace App\\Spider;\n\nuse EasySwoole\\Spider\\ConsumeJob;\nuse EasySwoole\\Spider\\Hole\\ConsumeAbstract;\n\nclass ConsumeTest extends ConsumeAbstract\n{\n\n    public function consume()\n    {\n        // TODO: Implement consume() method.\n        $data = $this-&gt;getJobData();\n\n        $items = '';\n        foreach ($data as $item) {\n            $items .= implode(\"\\t\", $item).\"\\n\";\n        }\n\n        file_put_contents('baidu.txt', $items, FILE_APPEND);\n    }\n}\n注册爬虫组件\npublic static function mainServerCreate(EventRegister $register)\n{\n        $spiderConfig = [\n            'product' =&gt; ProductTest::class, // 必须\n            'consume' =&gt; ConsumeTest::class, // 必须\n            'queueType' =&gt; SpiderConfig::QUEUE_TYPE_FAST_CACHE, // 通信类型默认是fast-cache不支持分布式，如需分布式可使用SpiderConfig::QUEUE_TYPE_REDIS，或者自行实现通信队列\n            'queue' =&gt; '自定义队列，如使用组件自带则不需要', // 自定义通信队列\n            'queueConfig' =&gt; '自定义队列配置，目前只有SpiderConfig::QUEUE_TYPE_REDIS需要',\n            'maxCurrency' =&gt; 128 // 最大协程并发数(单台机器)\n        ];\n        SpiderServer::getInstance()\n            -&gt;setSpiderConfig($spiderConfig)\n            -&gt;attachProcess(ServerManager::getInstance()-&gt;getSwooleServer());\n}\n投递任务\n$words = [\n    'php',\n    'java',\n    'go'\n];\n\nforeach ($words as $word) {\n    Cache::getInstance()-&gt;enQueue('SEARCH_WORDS', $word);\n}\n\n$wd = Cache::getInstance()-&gt;deQueue('SEARCH_WORDS');\n\nSpiderClient::getInstance()-&gt;addJob(\n                'https://www.baidu.com/s?wd=php&amp;pn=0',\n                [\n                    'page' =&gt; 1,\n                    'word' =&gt; $wd\n                ]\n);","link":"/Components/Spider/use.html"},{"id":357,"title":"product","content":"Product\n注意事项\n\nproduct方法返回必须返回ProductResult对象，因为ProductResult包含此次任务新产生的一批任务配置和一个消费任务数据\n\n回调方法\npublic function product():ProductResult\n{\n    // TODO: Implement product() method.\n\n    // productConfig存的就是当前任务的配置信息[\n             'url' =&gt; '',\n             'otherInfo' =&gt; '其它信息'\n         ]\n\n    $this-&gt;productConfig;\n\n    $data = '爬出来的数据';\n\n    // 下一批任务配置\n    $productJobConfigs = [\n        [\n            'url' =&gt; '',\n            'otherInfo' =&gt; '其它信息'\n        ],\n        [\n            'url' =&gt; '',\n            'otherInfo' =&gt; '其它信息'\n        ],\n    ];\n\n    $result = new ProductResult();\n    $result-&gt;setProductJobConfigs($productJobConfigs)-&gt;setConsumeData($data);\n    return $result;\n}","link":"/Components/Spider/product.html"},{"id":358,"title":"consume","content":"Consume\nproduct 生产出来的数据，会投递consume任务数据在jobData中\n&lt;?php\nnamespace App\\Spider;\n\nuse EasySwoole\\Spider\\ConsumeJob;\nuse EasySwoole\\Spider\\Hole\\ConsumeAbstract;\n\nclass ConsumeTest extends ConsumeAbstract\n{\n\n    public function consume()\n    {\n        // TODO: Implement consume() method.\n        $data = $this-&gt;getJobData();\n\n        $items = '';\n        foreach ($data as $item) {\n            $items .= implode(\"\\t\", $item).\"\\n\";\n        }\n\n        file_put_contents('baidu.txt', $items, FILE_APPEND);\n    }\n}","link":"/Components/Spider/consume.html"},{"id":359,"title":"客户端","content":"Spider客户端\n通过客户端可以向Spider服务添加要爬取的任务信息\nSpiderClient::getInstance()-&gt;addJob('https://xxxxx','其它信息’);\n支持的方法\n添加job\n    public function addJob($url, $otherInfo)\n批量添加job\n    public function addJobs(array $jobsConfig)\n    $jobsConfig = [\n      [\n        'url' =&gt; xxx,\n        'otherInfo =&gt; xxx\n      ],\n      [\n        'url' =&gt; xxx,\n        'otherInfo =&gt; xxx\n      ],\n      [\n        'url' =&gt; xxx,\n        'otherInfo =&gt; xxx\n      ]\n    ];","link":"/Components/Spider/client.html"},{"id":360,"title":"自定义通信队列","content":"自定义队列\n实现EasySwoole\\Queue\\QueueDriverInterface;接口，以组件默认的fast-cache queue为例\nnamespace EasySwoole\\Spider\\Queue;\n\nuse EasySwoole\\FastCache\\Cache;\nuse EasySwoole\\Queue\\QueueDriverInterface;\nuse EasySwoole\\Queue\\Job;\n\nclass FastCacheQueue implements QueueDriverInterface\n{\n\n    private const FASTCACHE_JOB_QUEUE_KEY='FASTCACHE_JOB_QUEUE_KEY';\n\n    function pop(float $timeout = 3):?Job\n    {\n        // TODO: Implement pop() method.\n        $job =  Cache::getInstance()-&gt;deQueue(self::FASTCACHE_JOB_QUEUE_KEY);\n        if (empty($job)) {\n            return null;\n        }\n        $job = unserialize($job);\n        if (empty($job)) {\n            return null;\n        }\n        return $job;\n    }\n\n    function push(Job $job):bool\n    {\n        // TODO: Implement push() method.\n        $res = Cache::getInstance()-&gt;enQueue(self::FASTCACHE_JOB_QUEUE_KEY, serialize($job));\n        if (empty($res)) {\n            return false;\n        }\n        return true;\n    }\n\n    public function size(): ?int\n    {\n        // TODO: Implement size() method.\n    }\n}\n\n分布式\n使用组件自带的redis通信或自定义通信方式，即可实现","link":"/Components/Spider/consumequeue.html"},{"id":361,"title":"使用","content":"u-editor(百度编辑器)组件\n一个用 EasySwoole 实现的百度富文本编辑器组件，开箱即用，用户使用几行简单的代码就可以轻松使用富文本编辑器。 \n组件要求\n\nphp: &gt;= 7.1\neasyswoole/http-client: ^1.3\n\n安装\n\ncomposer require easyswoole/u-editor\n\n仓库地址\neasyswoole/u-editor\n基本使用方法\n新增一个控制器，继承 EasySwoole\\UEditor\\UEditorController。\n&lt;?php\nnamespace App\\HttpController;\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\nuse EasySwoole\\UEditor\\UEditorController;\n\nclass UEditor extends UEditorController\n{\n\n}\n\n该控制器请求地址为:/UEditor  \n\n修改百度编辑器 ueditor.config.js =&gt; window.UEDITOR_CONFIG =&gt; serverUrl = URL + \"/UEditor\"\n如图\n即可直接使用。\n补充说明\n百度编辑器前端初始化后，会通过 ueditor.config.js 获取配置，通过获取到的服务器路径，前端就可以去请求，请求格式为：服务器路径 + &quot;?action=操作方法&quot;。\n前端请求路径示例：http://127.0.0.1:9501/UEditor?action=config&amp;&amp;noCache=1587973402520   \n前端请求之后，将通过 UEditorController 的 index 方法进行识别 action，转发到不同的请求逻辑上，实现百度编辑器的后端接口。\n自定义使用方法\n在 EasySwoole\\UEditor\\UEditorController 控制器中，有默认的实现方法，如果你需要修改配置，可以通过重写控制器方法进行修改，实现自定义配置。\n保存路径\n默认保存路径为 EASYSWOOLE_ROOT . '/Static'。可通过属性继承 $rootPath 来修改默认的保存路径。\n权限控制实现\n本组件默认控制器的实现是继承 EasySwoole\\Http\\AbstractInterface\\Controller，如果你有需要登录用户上传等权限验证的需求，可以直接复制 EasySwoole\\UEditor\\UEditorController 里面的代码，然后重新实现自定义控制器并继承 EasySwoole\\Http\\AbstractInterface\\Controller，然后重写控制器的方法，即可实现权限控制。","link":"/Components/uEditor.html"},{"id":362,"title":"使用","content":"code-generation 2.x (代码生成组件)\nEasySwoole 代码生成组件，使用命令行就可以一键生成业务通用代码，支持生成的代码如下：\n\n一键生成 项目初始化 baseController、baseModel、baseUnitTest；\n一键生成 表 Model，自带属性注释；\n一键生成 表 curd 控制器，自带 5 个 curd 方法；\n一键生成 控制器单元测试用例，测试 5 个 curd 方法。\n\n组件版本说明\ncode-generation 组件当前最新稳定版本为 2.x，code-generation 2.x 相对于 1.x 版本，兼容了 EasySwoole 的最新注解组件，支持了新的 EasySwoole 文档自动生成，以及最新的 phpunit 版本，同时完善了 Model-&gt;getList 返回参数，以及控制器 getOne、getList 的 response 参数注解。\n\n注：code-generation 1.x 版本组件文档详见 code-generation 1.x\n\n组件要求\n\neasyswoole/trigger: ^1.0\neasyswoole/socket: ^1.0\neasyswoole/orm: ^1.4\nnette/php-generator: ^3.2\neasyswoole/http-annotation: ^1.4\nphp-curl-class/php-curl-class: ^8.5\neasyswoole/command: ^1.1\n\n安装方法\n\ncomposer require easyswoole/code-generation=2.x\n\n仓库地址\neasyswoole/code-generation 2.x\n基本使用\n配置文件 dev.php 配置如下：\n&lt;?php\nreturn [\n    'SERVER_NAME' =&gt; \"EasySwoole\",\n    'MAIN_SERVER' =&gt; [\n        'LISTEN_ADDRESS' =&gt; '0.0.0.0',\n        'PORT' =&gt; 9501,\n        'SERVER_TYPE' =&gt; EASYSWOOLE_WEB_SERVER, //可选为 EASYSWOOLE_SERVER  EASYSWOOLE_WEB_SERVER EASYSWOOLE_WEB_SOCKET_SERVER\n        'SOCK_TYPE' =&gt; SWOOLE_TCP,\n        'RUN_MODEL' =&gt; SWOOLE_PROCESS,\n        'SETTING' =&gt; [\n            'worker_num' =&gt; 8,\n            'reload_async' =&gt; true,\n            'max_wait_time' =&gt; 3\n        ],\n        'TASK' =&gt; [\n            'workerNum' =&gt; 4,\n            'maxRunningNum' =&gt; 128,\n            'timeout' =&gt; 15\n        ]\n    ],\n    'TEMP_DIR' =&gt; null,\n    'LOG_DIR' =&gt; null,\n    'MYSQL' =&gt; [\n        'host'          =&gt; '127.0.0.1',\n        'port'          =&gt; 3306,\n        'user'          =&gt; 'easyswoole',\n        'timeout'       =&gt; 5,\n        'charset'       =&gt; 'utf8mb4',\n        'password'      =&gt; 'easyswoole100%',\n        'database'      =&gt; 'easyswoole',\n        'maxObjectNum'  =&gt; 20,\n        'minObjectNum'  =&gt; 5,\n        'getObjectTimeout'  =&gt; 3.0,\n    ]\n];\n在项目根目录新建一个 TestCodeGeneration.php，代码内容如下：\n&lt;?php\n\ninclude __DIR__ . \"/vendor/autoload.php\";\n\n\\EasySwoole\\EasySwoole\\Core::getInstance()-&gt;initialize();\n\ngo(function () {\n    // 生成基础类\n    $generation = new \\EasySwoole\\CodeGeneration\\InitBaseClass\\Controller\\ControllerGeneration();\n    $generation-&gt;generate();\n    $generation = new \\EasySwoole\\CodeGeneration\\InitBaseClass\\UnitTest\\UnitTestGeneration();\n    $generation-&gt;generate();\n    $generation = new \\EasySwoole\\CodeGeneration\\InitBaseClass\\Model\\ModelGeneration();\n    $generation-&gt;generate();\n\n    // 获取 dev.php 中的 MYSQL 配置文件，配置文件具体说明请看：https://www.easyswoole.com/QuickStart/config.html\n    $mysqlConfig = new \\EasySwoole\\ORM\\Db\\Config(\\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf('MYSQL'));\n\n    // 获取数据库连接\n    $connection = new \\EasySwoole\\ORM\\Db\\Connection($mysqlConfig);\n\n    // 指定表名(这里以 user_list 表作为示例表，表结构请看下文)\n    $tableName = 'user_list';\n    $codeGeneration = new EasySwoole\\CodeGeneration\\CodeGeneration($tableName, $connection);\n\n    // 生成 model (默认生成模型的路径前缀为 App\\Model 目录，例如：如下生成的模型文件为 User模型【\\App\\Model\\User\\UserModel.php】 和 基础模型【\\App\\Model\\User\\BaseModel.php】)\n    $codeGeneration-&gt;generationModel(\"\\\\User\");\n\n    // 生成 controller (默认生成控制器的路径前缀为 App\\HttpController 目录，例如：如下生成的控制器文件为 User控制器【\\App\\Model\\Api\\User\\User.php】 和 基础控制器【\\App\\HttpController\\Api\\Base.php】)\n    $codeGeneration-&gt;generationController(\"\\\\Api\\\\User\", null);\n\n    // 生成 unitTest (默认生成 unitTest 的路径前缀为项目根目录的 UnitTest 目录，例如：如下生成的单元测试用例为 UserTest【UnitTest\\Api\\User\\UserTest.php】 和 基础单元测试用例【UnitTest\\BaseTest.php】)\n    $codeGeneration-&gt;generationUnitTest(\"\\\\Api\\\\User\", null);\n});\n\\Swoole\\Timer::clearAll();\n在配置好数据库和数据库配置文件之后，然后在项目根目录运行 TestCodeGeneration.php(php TestCodeGeneration.php)，即可看到自动生成的模型、控制器和单元测试用例。\nEasySwoole\\CodeGeneration\\CodeGeneration 方法可自行查看，代码很简单。\n示例表结构(user_list)\nCREATE TABLE `user_list` (\n  `id` int(11) NOT NULL,\n  `name` varchar(50) DEFAULT NULL,\n  `age` int(11) DEFAULT NULL,\n  `email` varchar(100) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n命令行使用\n由于命令行特殊的特性，命令行功能支持并不完善，如果想要体验全部功能，请使用 \\EasySwoole\\CodeGeneration\\CodeGeneration 生成，或参考 \\EasySwoole\\CodeGeneration\\CodeGeneration 代码生成。\n注册命令\n配置数据库配置文件 dev.php，配置文件内容详见上文。\n在 EasySwoole 项目根目录中的 bootstrap.php(即 bootstrap事件) 中使用 Di 注入配置项:\n&lt;?php\n// 全局bootstrap事件\ndate_default_timezone_set('Asia/Shanghai');\n\n\\EasySwoole\\EasySwoole\\Core::getInstance()-&gt;initialize();\n\n## 1 直接注入 mysql 连接\n// 获取 dev.php 中的 MYSQL 配置文件，配置文件具体说明请看：https://www.easyswoole.com/QuickStart/config.html\n$mysqlConfig = new \\EasySwoole\\ORM\\Db\\Config(\\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf('MYSQL'));\n// 获取连接\n$connection = new \\EasySwoole\\ORM\\Db\\Connection($mysqlConfig);\n\\EasySwoole\\Component\\Di::getInstance()-&gt;set('CodeGeneration.connection', $connection);\n\n## 2 直接注入 mysql 配置对象\n//   $mysqlConfig = new \\EasySwoole\\ORM\\Db\\Config(\\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf('MYSQL'));\n//   \\EasySwoole\\Component\\Di::getInstance()-&gt;set('CodeGeneration.connection', $mysqlConfig);\n\n## 3 直接注入 mysql 配置项\n//   \\EasySwoole\\Component\\Di::getInstance()-&gt;set('CodeGeneration.connection',\\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf('MYSQL'));\n\n// 以上 3 种注入 mysql 连接的方式均可，用户可以任选 1 种进行注入 mysql\n\n// 注入执行目录项，后面的为默认值，initClass 不能通过注入改变目录\n\\EasySwoole\\Component\\Di::getInstance()-&gt;set('CodeGeneration.modelBaseNameSpace', \"App\\\\Model\");\n\\EasySwoole\\Component\\Di::getInstance()-&gt;set('CodeGeneration.controllerBaseNameSpace', \"App\\\\HttpController\");\n\\EasySwoole\\Component\\Di::getInstance()-&gt;set('CodeGeneration.unitTestBaseNameSpace', \"UnitTest\");\n\\EasySwoole\\Component\\Di::getInstance()-&gt;set('CodeGeneration.rootPath', getcwd());\n然后即可使用命令实现自动生成代码，具体使用命令如下（使用如下命令前提：必须先在 bootstrap事件 中使用 Di 注册上述说明的配置项）：\nphp ./vendor/bin/code-generator\n ______                          _____                              _\n|  ____|                        / ____|                            | |\n| |__      __ _   ___   _   _  | (___   __      __   ___     ___   | |   ___\n|  __|    / _` | / __| | | | |  \\___ \\  \\ \\ /\\ / /  / _ \\   / _ \\  | |  / _ \\\n| |____  | (_| | \\__ \\ | |_| |  ____) |  \\ V  V /  | (_) | | (_) | | | |  __/\n|______|  \\__,_| |___/  \\__, | |_____/    \\_/\\_/    \\___/   \\___/  |_|  \\___|\n                         __/ |\n                        |___/\n\nCode auto generation tool\nUsage:\n  ./vendor/bin/code-generator ACTION [--opts ...]\nActions:\n  init  initialization\n  all   specify build\nOptions:\n  --tableName       specify table name\n  --modelPath       specify model path\n  --controllerPath  specify controller path\n  --unitTestPath    specify unit-test path\n\nphp ./vendor/bin/code-generator all --tableName=\"tableName\" --modelPath=\"生成的模型所在目录\" [--controllerPath=\"生成的控制器所在目录\"] [--unitTestPath=\"生成的单元测试用例所在目录\"]\n\n// 生成基础模型(BaseModel)、基础控制器(BaseController)、基础单元测试用例(BaseUnitTest)\nphp ./vendor/bin/code-generator init\n\n// 自动生成指定的模型、控制器、单元测试用例和 基础模型、基础控制器、基础单元测试用例\nphp vendor/bin/code-generator all --tableName=\"user_list\" --modelPath=\"\\\\User\" --controllerPath=\"\\\\Api\\\\User\" --unitTestPath=\"\\\\User\"\n执行结果示例如下：\n[root@localhost es-code-generation]# php ./vendor/bin/code-generator init\n┌────────────┬─────────────────────────────────────────────────────────────────────┐\n│ className  │                              filePath                               │\n├────────────┼─────────────────────────────────────────────────────────────────────┤\n│ Model      │ /www/wwwroot/easyswoole-code-generation/App/Model/BaseModel.php     │\n├────────────┼─────────────────────────────────────────────────────────────────────┤\n│ Controller │ /www/wwwroot/easyswoole-code-generation/App/HttpController/Base.php │\n├────────────┼─────────────────────────────────────────────────────────────────────┤\n│ UnitTest   │ /www/wwwroot/easyswoole-code-generation/UnitTest/BaseTest.php       │\n└────────────┴─────────────────────────────────────────────────────────────────────┘\n\n[root@localhost es-code-generation]# php ./vendor/bin/code-generator all --tableName=\"user_list\" --modelPath=\"\\\\User\" --controllerPath=\"\\\\Api\\\\User\" --unitTestPath=\"\\\\User\"\n┌────────────┬──────────────────────────────────────────────────────────────────────────────┐\n│ className  │                                   filePath                                   │\n├────────────┼──────────────────────────────────────────────────────────────────────────────┤\n│ Model      │ /www/wwwroot/easyswoole-code-generation/App/Model/User/UserModel.php         │\n├────────────┼──────────────────────────────────────────────────────────────────────────────┤\n│ Controller │ /www/wwwroot/easyswoole-code-generation/App/HttpController/Api/User/User.php │\n├────────────┼──────────────────────────────────────────────────────────────────────────────┤\n│ UnitTest   │ /www/wwwroot/easyswoole-code-generation/UnitTest/User/UserTest.php           │\n└────────────┴──────────────────────────────────────────────────────────────────────────────┘\n\n独立使用\n生成器流程说明\n\n通过 \\EasySwoole\\ORM\\Utility\\TableObjectGeneration，传入 \\EasySwoole\\ORM\\Db\\Connection 连接对象，通过 generationTable 方法获取表结构对象；\n实例化类生成器配置，配置命名空间、生成文件路径、类名等(详情看下面)；\n实例化生成器对象，调用 generate方法生成。\n\n生成器基础配置项\n\n\nextendClass 继承类，默认为\\EasySwoole\\ORM\\AbstractModel::class\n\ndirectory 生成路径,生成路径默认为 rootPath+namespace对应路径,namespace路径将自动通过composer.json-&gt;(autoload/autoload-dev)['psr-4'] 配置目录生成,如果没有则默认为根目录\nnamespace 命名空间配置.\nclassName 类名\nrootPath 项目根目录,默认为执行目录.\n\n获取数据表结构\n所有生成器都依赖于数据表结构对象EasySwoole\\ORM\\Utility\\Schema\\Table\n&lt;?php\n$mysqlConfig = new \\EasySwoole\\ORM\\Db\\Config(\\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf('MYSQL'));\n//获取连接\n$connection = new \\EasySwoole\\ORM\\Db\\Connection($mysqlConfig);\n$tableName = 'user_list';\n//获取数据表结构对象\n$tableObjectGeneration = new \\EasySwoole\\ORM\\Utility\\TableObjectGeneration($connection, $tableName);\n$schemaInfo = $tableObjectGeneration-&gt;generationTable();\n\nModel生成\nModel配置项说明\n\nextendClass 继承类,默认为\\EasySwoole\\ORM\\AbstractModel::class\n\ndirectory 生成路径,生成路径默认为 rootPath+namespace对应路径,namespace路径将自动通过composer.json-&gt;(autoload/autoload-dev)['psr-4'] 配置目录生成,如果没有则默认为根目录\nnamespace 命名空间配置.默认为 App\\Model\n\nclassName 类名,Model配置无效,强制为realTableName+fileSuffix\n\nrootPath 项目根目录,默认为执行目录.\ntablePre 表前缀,如果有配置,es_user 表=&gt; UserModel\ntable 表结构对象\nrealTableName 真实表名,通过下划线形式转为大驼峰,自动转化.用于生成最后的类名和文件名.\nfileSuffix 文件后缀,默认为Model,用于生成最后的类名和文件名.\nignoreString 默认为['list', 'log'], //生成时忽略表名存在的字符,例如user_list将生成=&gt;UserModel\n\nModel生成示例:\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: tioncico\n * Date: 2020-05-20\n * Time: 10:26\n */\ninclude \"./vendor/autoload.php\";\n\n\\EasySwoole\\EasySwoole\\Core::getInstance()-&gt;initialize();\n\ngo(function () {\n    $mysqlConfig = new \\EasySwoole\\ORM\\Db\\Config(\\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf('MYSQL'));\n    //获取连接\n    $connection = new \\EasySwoole\\ORM\\Db\\Connection($mysqlConfig);\n    $tableName = 'user_list';\n    //获取数据表结构对象\n    $tableObjectGeneration = new \\EasySwoole\\ORM\\Utility\\TableObjectGeneration($connection, $tableName);\n    $schemaInfo = $tableObjectGeneration-&gt;generationTable();\n\n    $tablePre = '';//表前缀\n    $path = \"App\\\\Model\";\n    $extendClass = \\EasySwoole\\ORM\\AbstractModel::class;\n    $modelConfig = new \\EasySwoole\\CodeGeneration\\ModelGeneration\\ModelConfig($schemaInfo, $tablePre, \"{$path}\", $extendClass);\n    $modelConfig-&gt;setRootPath(EASYSWOOLE_ROOT);//设置项目运行目录,默认为当前执行脚本目录.\n    $modelConfig-&gt;setIgnoreString(['list', 'log']);//生成时忽略表名存在的字符,例如user_list将生成=&gt;UserModel\n\n    $modelGeneration = new \\EasySwoole\\CodeGeneration\\ModelGeneration\\ModelGeneration($modelConfig);\n    $result = $modelGeneration-&gt;generate();\n    var_dump($result);//生成成功返回生成文件路径,否则返回false\n});\n\\Swoole\\Timer::clearAll();\nModel方法\nModel方法默认生成一个GetList方法,用于获取列表.\n&lt;?php\npublic function getList(int $page = 1, int $pageSize = 10, string $field = '*'): array\n{\n    $list = $this\n        -&gt;withTotalCount()\n        -&gt;order($this-&gt;schemaInfo()-&gt;getPkFiledName(), 'DESC')\n        -&gt;field($field)\n        -&gt;page($page, $pageSize)\n        -&gt;all();\n    $total = $this-&gt;lastQueryResult()-&gt;getTotalCount();;\n    return ['total' =&gt; $total, 'list' =&gt; $list];\n}\n\n可参考EasySwoole\\CodeGeneration\\ModelGeneration\\Method\\GetList自定义其他方法.再进行注入即可.\n","link":"/Components/codeGeneration_2.x.html"},{"id":363,"title":"使用","content":"Oauth\nOAuth在&quot;客户端&quot;与&quot;服务提供商&quot;之间，设置了一个授权层（authorization layer）。&quot;客户端&quot;不能直接登录&quot;服务提供商&quot;，只能登录授权层，以此将用户与客户端区分开来。&quot;客户端&quot;登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。\n需要用户自行补充oauth的认证流程，方便自己更加快速的接入。\n安装\n请在EasySwoole根目录下执行以下命令\n\ncomposer require easyswoole/o-auth\n\n详情\n根据Oauth协议，分别有如下调用方法。\n\n\ngetAuthUrl() 获取授权地址\n\ngetAccessToken($storeState = null, $state = null, $code = null) 获取AccessToken（只返回access_token）\n\ngetAccessTokenResult() 执行getAccessToken方法后，此方法获取原结果\n\ngetUserInfo(string $accessToken) 获取用户信息\n\nvalidateAccessToken(string $accessToken) 验证token是否有效\n\nrefreshToken(string $refreshToken = null) 刷新token 返回bool\n\n\ngetRefreshTokenResult() 执行refreshToken方法后，此方法获取原结果\n\n示例代码\n微信\nclass WeiXin extends \\EasySwoole\\Http\\AbstractInterface\\Controller\n{\n    public function index()\n    {\n        $config = new \\EasySwoole\\OAuth\\WeiXin\\Config();\n        $config-&gt;setAppId('appid');\n        $config-&gt;setState('easyswoole');\n        $config-&gt;setRedirectUri('redirect_uri');\n\n        $oauth = new \\EasySwoole\\OAuth\\WeiXin\\OAuth($config);\n        $url = $oauth-&gt;getAuthUrl();\n\n        return $this-&gt;response()-&gt;redirect($url);\n    }\n\n    public function callback()\n    {\n        $params = $this-&gt;request()-&gt;getQueryParams();\n\n        $config = new \\EasySwoole\\OAuth\\WeiXin\\Config();\n        $config-&gt;setAppId('appid');\n        $config-&gt;setSecret('secret');\n        $config-&gt;setOpenIdMode(\\EasySwoole\\OAuth\\WeiXin\\Config::OPEN_ID); // 可设置UNION_ID 默认为OPEN_ID\n\n        $oauth = new \\EasySwoole\\OAuth\\WeiXin\\OAuth($config);\n        $accessToken = $oauth-&gt;getAccessToken('easyswoole', $params['state'], $params['code']);\n        $refreshToken = $oauth-&gt;getAccessTokenResult()['refresh_token'];\n\n        $userInfo = $oauth-&gt;getUserInfo($accessToken);\n        var_dump($userInfo);\n\n        if (!$oauth-&gt;validateAccessToken($accessToken)) echo 'access_token 验证失败！' . PHP_EOL;\n\n        if (!$oauth-&gt;refreshToken($refreshToken)) echo 'access_token 续期失败！' . PHP_EOL;\n\n    }\n}\nQQ\nclass QQ extends \\EasySwoole\\Http\\AbstractInterface\\Controller\n{\n    public function index()\n    {\n        $config = new \\EasySwoole\\OAuth\\QQ\\Config();\n        $config-&gt;setAppId('appid');\n        $config-&gt;setState('easyswoole');\n        $config-&gt;setRedirectUri('redirect_uri');\n\n        $oauth = new \\EasySwoole\\OAuth\\QQ\\OAuth($config);\n        $url = $oauth-&gt;getAuthUrl();\n\n        return $this-&gt;response()-&gt;redirect($url);\n    }\n\n    public function callback()\n    {\n        $params = $this-&gt;request()-&gt;getQueryParams();\n\n        $config = new \\EasySwoole\\OAuth\\QQ\\Config();\n        $config-&gt;setAppId('appid');\n        $config-&gt;setAppKey('appkey');\n        $config-&gt;setRedirectUri('redirect_uri');\n        $config-&gt;setOpenIdMode(\\EasySwoole\\OAuth\\QQ\\Config::OPEN_ID); // 可设置UNION_ID 默认为OPEN_ID\n\n        $oauth = new \\EasySwoole\\OAuth\\QQ\\OAuth($config);\n        $accessToken = $oauth-&gt;getAccessToken('easyswoole', $params['state'], $params['code']);\n        $refreshToken = $oauth-&gt;getAccessTokenResult()['refresh_token'];\n\n        $userInfo = $oauth-&gt;getUserInfo($accessToken);\n        var_dump($userInfo);\n\n        if (!$oauth-&gt;validateAccessToken($accessToken)) echo 'access_token 验证失败！' . PHP_EOL;\n\n        if (!$oauth-&gt;refreshToken($refreshToken)) echo 'access_token 续期失败！' . PHP_EOL;\n\n    }\n}\n微博\nclass Weibo extends \\EasySwoole\\Http\\AbstractInterface\\Controller\n{\n    public function index()\n    {\n        $config = new \\EasySwoole\\OAuth\\Weibo\\Config();\n        $config-&gt;setClientId('clientid');\n        $config-&gt;setState('easyswoole');\n        $config-&gt;setRedirectUri('redirect_uri');\n\n        $oauth = new \\EasySwoole\\OAuth\\Weibo\\OAuth($config);\n        $url = $oauth-&gt;getAuthUrl();\n\n        return $this-&gt;response()-&gt;redirect($url);\n    }\n\n    public function callback()\n    {\n        $params = $this-&gt;request()-&gt;getQueryParams();\n\n        $config = new \\EasySwoole\\OAuth\\Weibo\\Config();\n        $config-&gt;setClientId('clientid');\n        $config-&gt;setClientSecret('secret');\n        $config-&gt;setRedirectUri('redirect_uri');\n\n        $oauth = new \\EasySwoole\\OAuth\\Weibo\\OAuth($config);\n        $accessToken = $oauth-&gt;getAccessToken('easyswoole', $params['state'], $params['code']);\n\n        $userInfo = $oauth-&gt;getUserInfo($accessToken);\n        var_dump($userInfo);\n\n        if (!$oauth-&gt;validateAccessToken($accessToken)) echo 'access_token 验证失败！' . PHP_EOL;\n    }\n}\n支付宝\nclass AliPay extends \\EasySwoole\\Http\\AbstractInterface\\Controller\n{\n    public function index()\n    {\n        $config = new \\EasySwoole\\OAuth\\AliPay\\Config();\n        $config-&gt;setState('easyswoole');\n        $config-&gt;setAppId('appid');\n        $config-&gt;setRedirectUri('redirect_uri');\n\n        // 使用沙箱环境测试开发的时候 把OAuth的源码文件里面的 API_DOMAIN 和 AUTH_DOMAIN 进行修改\n        $oauth = new \\EasySwoole\\OAuth\\AliPay\\OAuth($config);\n        $url = $oauth-&gt;getAuthUrl();\n        return $this-&gt;response()-&gt;redirect($url);\n    }\n\n    public function callback()\n    {\n        $params = $this-&gt;request()-&gt;getQueryParams();\n\n        $config = new \\EasySwoole\\OAuth\\AliPay\\Config();\n        $config-&gt;setAppId('appid');\n//        $config-&gt;setAppPrivateKey('私钥');\n        $config-&gt;setAppPrivateKeyFile('私钥文件'); // 私钥文件(非远程) 此方法与上个方法二选一\n\n        $oauth = new \\EasySwoole\\OAuth\\AliPay\\OAuth($config);\n        $accessToken = $oauth-&gt;getAccessToken('easyswoole', $params['state'], $params['auth_code']);\n        $refreshToken = $oauth-&gt;getAccessTokenResult()['alipay_system_oauth_token_response']['refresh_token'];\n\n        $userInfo = $oauth-&gt;getUserInfo($accessToken);\n        var_dump($userInfo);\n\n        if (!$oauth-&gt;validateAccessToken($accessToken)) echo 'access_token 验证失败！' . PHP_EOL;\n        var_dump($oauth-&gt;getAccessTokenResult());\n\n        if (!$oauth-&gt;refreshToken($refreshToken)) echo 'access_token 续期失败！' . PHP_EOL;\n        var_dump($oauth-&gt;getRefreshTokenResult());\n    }\n}\nGithub\nclass Github extends \\EasySwoole\\Http\\AbstractInterface\\Controller\n{\n    public function index()\n    {\n        $config = new \\EasySwoole\\OAuth\\Github\\Config();\n        $config-&gt;setClientId('clientid');\n        $config-&gt;setRedirectUri('redirect_uri');\n        $config-&gt;setState('easyswoole');\n        $oauth = new \\EasySwoole\\OAuth\\Github\\OAuth($config);\n        $this-&gt;response()-&gt;redirect($oauth-&gt;getAuthUrl());\n    }\n\n    public function callback()\n    {\n        $params = $this-&gt;request()-&gt;getQueryParams();\n        $config = new \\EasySwoole\\OAuth\\Github\\Config();\n        $config-&gt;setClientId('clientid');\n        $config-&gt;setClientSecret('secret');\n        $config-&gt;setRedirectUri('redirect_uri');\n\n        $oauth = new \\EasySwoole\\OAuth\\Github\\OAuth($config);\n        $accessToken = $oauth-&gt;getAccessToken('easyswoole', $params['state'], $params['code']);\n        $userInfo = $oauth-&gt;getUserInfo($accessToken);\n        var_dump($userInfo);\n\n        if (!$oauth-&gt;validateAccessToken($accessToken)) echo 'access_token 验证失败！' . PHP_EOL;\n    }\n}\nGitee\nclass Gitee extends \\EasySwoole\\Http\\AbstractInterface\\Controller\n{\n    public function index()\n    {\n        $config = new \\EasySwoole\\OAuth\\Gitee\\Config();\n        $config-&gt;setState('easyswoole');\n        $config-&gt;setClientId('clientid');\n        $config-&gt;setRedirectUri('redirect_uri');\n        $oauth = new \\EasySwoole\\OAuth\\Gitee\\OAuth($config);\n        $this-&gt;response()-&gt;redirect($oauth-&gt;getAuthUrl());\n    }\n\n    public function callback()\n    {\n        $params = $this-&gt;request()-&gt;getQueryParams();\n\n        $config = new \\EasySwoole\\OAuth\\Gitee\\Config();\n        $config-&gt;setClientId('client_id');\n        $config-&gt;setClientSecret('secret');\n        $config-&gt;setRedirectUri('redirect_uri');\n\n        $oauth = new \\EasySwoole\\OAuth\\Gitee\\OAuth($config);\n        $accessToken = $oauth-&gt;getAccessToken('easyswoole', $params['state'], $params['code']);\n        $userInfo = $oauth-&gt;getUserInfo($accessToken);\n        var_dump($userInfo);\n\n        if (!$oauth-&gt;validateAccessToken($accessToken)) echo 'access_token 验证失败！' . PHP_EOL;\n        var_dump($oauth-&gt;getAccessTokenResult());\n    }\n}","link":"/Components/oauth.html"},{"id":364,"title":"使用","content":"OSS云存储\n安装\n\ncomposer require easyswoole/oss\n\n阿里云调用\n根据阿里云官方sdk修改,全部方法都一致,走通了所有官方的client请求类单元测试,全部调用方法都和阿里云一致\n文档可查看阿里云官方文档:https://help.aliyun.com/document_detail/32099.html?spm=a2c4g.11186623.2.17.de715d26YNLCah#concept-32099-zh\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: Tioncico\n * Date: 2019/11/20 0020\n * Time: 15:28\n */\ninclude \"./vendor/autoload.php\";\ninclude \"./phpunit.php\";\n\ngo(function (){\n\n    $config = new \\EasySwoole\\Oss\\AliYun\\Config([\n        'accessKeyId'     =&gt; ACCESS_KEY_ID,\n        'accessKeySecret' =&gt; ACCESS_KEY_SECRET,\n        'endpoint'        =&gt; END_POINT,\n    ]);\n    $client = new \\EasySwoole\\Oss\\AliYun\\OssClient($config);\n    $data = $client-&gt;putObject('tioncicoxyz','test',__FILE__);\n    var_dump($data);\n});\n部分方法没走通单元测试\n由于有些方法可能是测试环境问题,未走通,可能出现问题(一般不会有问题),需要大家注意\n列出走不通单元测试的方法,以供大家参考:\n\naddBucketCname 提示: NoSuchCnameInRecord: No such cname be found in record\ntestDeleteCname 提示: CnameDenied: The cname belongs to another user.\n\n以下2个方法为callback走不通,应该不影响\n\n\\EasySwoole\\Oss\\Tests\\AliYun\\CallbackTest::testMultipartUploadCallbackNormal 提示: CallbackFailed: Response body is not valid json format.\n\\EasySwoole\\Oss\\Tests\\AliYun\\CallbackTest::testPutObjectCallbackNormal 走不通 \n\nSymlink 类方法全走不通,应该不影响,提示: bucket is not allowed empty或者The specified key does not exist.\n七牛云调用\n根据七牛云官方sdk修改,走通了oss的大部分单元测试,用法和七牛云oss完全一致\n操作文档可直接查看七牛云官方文档 https://developer.qiniu.com/kodo/sdk/1241/php\ninclude \"../../vendor/autoload.php\";\ninclude \"../../phpunit.php\";\ngo(function (){\n\n    $auth = new \\EasySwoole\\Oss\\QiNiu\\Auth(QINIU_ACCESS_KEY,QINIU_SECRET_KEY);\n\n    $key = 'formPutFileTest';\n    $token = $auth-&gt;uploadToken('tioncico', $key);\n    $upManager = new \\EasySwoole\\Oss\\QiNiu\\Storage\\UploadManager();\n    list($ret, $error) = $upManager-&gt;putFile($token, $key, __file__, null, 'text/plain', null);\n    var_dump($ret,$error);\n});\n部分方法没走通单元测试\n由于某些可能是测试环境问题,有部分方法未走通单元测试,需要大家注意,列出走不通的单元测试的方法,以供大家参考\n\n\\EasySwoole\\Oss\\Tests\\QiNiu\\BucketTest::testPrefetch 未走通,提示:{&quot;error&quot;:&quot;bucket source not set&quot;}\nPfopTest 类方法未走通,提示{&quot;error&quot;:&quot;no such bucket&quot;} \n\\EasySwoole\\Oss\\Tests\\QiNiu\\ResumeUpTest::test4ML2 方法未走通,一直卡住,不建议使用该方法上传文件,请使用 \\EasySwoole\\Oss\\Tests\\QiNiu\\ResumeUpTest::test4ML  方法上传\n\n七牛云设置超时\n官方sdk没有设置超时的逻辑,在本组件中新增加了,设置方法如下:\n\\EasySwoole\\Oss\\QiNiu\\Config::setTimeout(3);\n\\EasySwoole\\Oss\\QiNiu\\Config::setConnectTimeout(5);\n腾讯云调用\n腾讯云调用和原来的方法基本一致,操作文档可直接查看腾讯云官方文档:https://cloud.tencent.com/document/product/436/12266\n&lt;?php\ninclude \"../../vendor/autoload.php\";\ninclude \"../../phpunit2.php\";\ngo(function (){\n//config配置\n    $config = new \\EasySwoole\\Oss\\Tencent\\Config([\n        'appId'     =&gt; TX_APP_ID,\n        'secretId'  =&gt; TX_SECRETID,\n        'secretKey' =&gt; TX_SECRETKEY,\n        'region'    =&gt; TX_REGION,\n        'bucket'    =&gt; TX_BUCKET,\n    ]);\n    //new客户端\n    $cosClient = new \\EasySwoole\\Oss\\Tencent\\OssClient($config);\n\n    $key = '你好111.txt';\n    //生成一个文件数据\n    $body = generateRandomString(2 * 1024  + 1023);\n    //上传\n    $cosClient-&gt;upload($bucket = TX_BUCKET,\n        $key = $key,\n        $body = $body,\n        $options = ['PartSize' =&gt; 1024 + 1]\n    );\n    //获取文件内容\n    $rt = $cosClient-&gt;getObject(['Bucket' =&gt; TX_BUCKET, 'Key' =&gt; $key]);\n    var_dump($rt['Body']-&gt;__toString());\n});\n\nfunction generateRandomString($length = 10)\n{\n    $characters = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n    $randomString = '';\n    for ($i = 0; $i &lt; $length; $i++) {\n        $randomString .= $characters[rand(0, strlen($characters) - 1)];\n    }\n    return $randomString;\n}\n补充\n大部分方法已经兼容,使用方法和腾讯云官方完全一致,但还有些注意事项:\n\n上传文件使用了SplStream 作为流文件管理\n下载文件使用了SplStream 作为流文件管理(上面的$rt['Body']就是SplStream对象)\n\n部分方法没走通单元测试\n由于腾讯云sdk使用了guzzle 库,改动非常麻烦,所以有部分单元测试没通过,具体方法如下,希望大家注意:\n\nPutBucketAcl 方法,相关的单元测试全部提示Access Denied.(官方sdk也这个提示)\ncopy 方法,小文件提示You have no authority to read the source file  大文件直接无法走通无法使用(官方sdk也走不通)\n","link":"/Components/oss.html"},{"id":365,"title":"安装","content":"微信 SDK EasySwoole WeChat 1.2.x\nEasySwoole WeChat 是一个基于 Swoole 4.x 全协程 支持的微信 SDK 库，告别同步阻塞，轻松编写高性能的微信公众号/小程序/开放平台业务接口。\n组件要求\n\nphp &gt;= 7.1.0\neasyswoole/component &gt;= 1.0\neasyswoole/spl &gt;= 1.3.7\neasyswoole/http-client ^1.0\neasyswoole/utility&quot; ^1.0\n\n安装方法\n\ncomposer require easyswoole/wechat=1.2.x\n\n仓库地址\neasyswoole/wechat=1.2.x","link":"/Components/WeChat/install.html"},{"id":366,"title":"小程序","content":"微信小程序组件 1.2.x\n获取小程序对象\n$wxa = new \\EasySwoole\\WeChat\\MiniProgram\\MiniProgram;\n$wxa-&gt;getConfig()-&gt;setAppId('your appid')-&gt;setAppSecret('your appsecret');\n获取小程序session\n详细信息请参阅 微信小程序登陆\n$code = '';\n$session = $wxa-&gt;auth()-&gt;session($code);\n你会返回一个包含下面文档中提到的参数的数组\ncode2Session\n创建二维码\n参阅文档documentation\n我们可以使用一下三种方式创建二维码\n    /** 二维码 - 永久小程序码 Api: $wxa-&gt;qrCode()-&gt;getWxaCode()\n     * @param $path             扫码进入的小程序页面路径，最大长度 128 字节\n     * @param int $width        二维码的宽度\n     * @param bool $autoColor   自动配置线条颜色\n     * @param null $lineColor   auto_color 为 false 时生效，使用 rgb 设置颜色 例如 {\"r\":\"xxx\",\"g\":\"xxx\",\"b\":\"xxx\"} 十进制表示\n     * @param bool $isHyaline   是否需要透明底色\n     */\n    function getWxaCode($path, $width = 430, $autoColor = false, $lineColor = null, $isHyaline = false)\n\n     /**\n     * 二维码 - 临时小程序码 Api: $wxa-&gt;qrCode()-&gt;getWxaCodeUnLimit()\n     * @param $path             已经发布的小程序存在的页面\n     * @param $scene            最大32个可见字符\n     * @param int $width        二维码的宽度\n     * @param bool $autoColor   自动配置线条颜色\n     * @param null $lineColor   auto_color 为 false 时生效，使用 rgb 设置颜色 例如 {\"r\":\"xxx\",\"g\":\"xxx\",\"b\":\"xxx\"} 十进制表示\n     * @param bool $isHyaline   是否需要透明底色\n     */\n     function getWxaCodeUnLimit($path, $scene, $width = 430, $autoColor = false, $lineColor = null, $isHyaline = false)\n\n     /**\n     * 二维码 - 永久二维码 Api:  $wxa-&gt;qrCode()-&gt;createWxaQrCode()\n     * @param $path             扫码进入的小程序页面路径，最大长度 128 字节\n     * @param int $width        二维码的宽度\n     */\n      function createWxaQrCode($path, $width = 430)\n\n获取帐号下已存在的模板列表\n$wxa-&gt;templateMsg()-&gt;getTemplateList(int $offset, int $count)\n获取模板库某个模板标题下关键词库\n$wxa-&gt;templateMsg()-&gt;getTemplateLibraryById(string $id)\n组合模板并添加至帐号下的个人模板库\n$wxa-&gt;templateMsg()-&gt;addTemplate(string $id, array $keywordIdList)\n删除帐号下的某个模板\n$wxa-&gt;templateMsg()-&gt;deleteTemplate(string $templateId)\n获取小程序模板库标题列表\n$wxa-&gt;templateMsg()-&gt;getTemplateLibraryList(int $offset, int $count)\n发送模板消息\n//要传递的参数数组，下面实际方法中是传入Bean\n$templateMsg = [\n    'touser' =&gt; 'user-openid',\n    'template_id' =&gt; 'template-id',\n    'page' =&gt; 'index',\n    'form_id' =&gt; 'form-id',\n    'data' =&gt; [\n        'keyword1' =&gt; 'VALUE',\n        'keyword2' =&gt; 'VALUE2',\n    ],\n];\n\n$wxa-&gt;templateMsg()-&gt;send(TemplateMsgBean $templateMsg)\n\n微信小程序消息解密(获取电话等功能，信息是加密的，需要解密)\n$wxa-&gt;encryptor()-&gt;decryptData(string $sessionKey, string $iv, string $encryptedData)\n检查一段文本是否含有违法违规内容\n$wxa-&gt;checkFile()-&gt;msgSecCheck(string $content)\n校验一张图片是否含有违法违规内容\n$wxa-&gt;checkFile()-&gt;imgSecCheck(ImgUploadBean $imgUpload)\n异步校验图片/音频是否含有违法违规内容\n$wxa-&gt;checkFile()-&gt;mediaCheckAsync(string $mediaUrl ,int $mediaType)\n物流助手(小程序)\n/**\n * 绑定、解绑物流账号 Api: $wxa-&gt;logisticsProgram()-&gt;bindAccount()\n * @param BindAccount $bindAccount\n */\nfunction bindAccount(BindAccount $bindAccount)\n\n//例子\n//要传递的参数数组，下面实际方法中是传入Bean\n$bindAccount = [\n    'type'          =&gt; 'bind',  //bind表示绑定，unbind表示解除绑定\n    'biz_id'        =&gt; '1',     //快递公司客户编码\n    'delivery_id'   =&gt;  '1',     //快递公司ID\n    'password'      =&gt;  '***',     //快递公司客户密码\n    'remark_content'=&gt;  '测试'      //备注内容（提交EMS审核需要）\n];\n\n$wxa-&gt;logisticsProgram()-&gt;bindAccount($bindAccount);\n\n /**获取所有绑定的物流账号 Api: $wxa-&gt;logisticsProgram()-&gt;getAllAccount()\n  *\n  */\n function getAllAccount()\n\n /**\n * 获取电子面单余额。仅在使用加盟类快递公司时，才可以调用。 Api: $wxa-&gt;logisticsProgram()-&gt;getQuota()\n * @param string $deliveryId    快递公司ID  \n * @param string $bizId         快递公司客户编码\n */\nfunction getQuota(string $deliveryId ,string $bizId)\n\n/**\n * 生成运单 Api: $wxa-&gt;logisticsProgram()-&gt;addOrder()\n * @param AddOrder $addOrder\n * 具体参数请参考文档： https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/express/by-business/logistics.addOrder.html\n */\nfunction addOrder(AddOrder $addOrder)\n\n/**\n * 取消运单 Api: $wxa-&gt;logisticsProgram()-&gt;cancelOrder()\n * @param string $orderId       订单 ID，需保证全局唯一\n * @param string $openid        用户openid，当add_source=2时无需填写（不发送物流服务通知）\n * @param string $deliveryId    快递公司ID\n * @param string $waybillId     运单ID\n */\nfunction cancelOrder(string $orderId ,string $openid ,string $deliveryId ,string $waybillId)\n\n/**\n * 获取支持的快递公司列表 Api: $wxa-&gt;logisticsProgram()-&gt;getAllDelivery()\n */\nfunction getAllDelivery()\n\n/* 获取运单数据 Api:  $wxa-&gt;logisticsProgram()-&gt;getOrder()\n * @param string $orderId       订单 ID，需保证全局唯一\n * @param string $openid        用户openid，当add_source=2时无需填写（不发送物流服务通知）\n * @param string $deliveryId    快递公司ID\n * @param string $waybillId     运单ID\n */\nfunction getOrder(string $orderId ,string $openid ,string $deliveryId ,string $waybillId)\n\n/* 查询运单轨迹 Api:  $wxa-&gt;logisticsProgram()-&gt;getPath()\n * @param string $orderId       订单 ID，需保证全局唯一\n * @param string $openid        用户openid，当add_source=2时无需填写（不发送物流服务通知）\n * @param string $deliveryId    快递公司ID\n * @param string $waybillId     运单ID\n */\n function getPath(string $orderId ,string $openid ,string $deliveryId ,string $waybillId)\n\n//获取打印员。若需要使用微信打单 PC 软件，才需要调用。 Api: $wxa-&gt;logisticsProgram()-&gt;getPrinter()\n function getPrinter()\n\n /**\n * 配置面单打印员,若需要使用微信打单 PC 软件，才需要调用。 Api: $wxa-&gt;logisticsProgram()-&gt;updatePrinter()\n * @param string $openid        打印员 openid\n * @param string $updateType    更新类型\n * @param string $tagidList     用于平台型小程序设置入驻方的打印员面单打印权限，同一打印员最多支持10个tagid，使用逗号分隔，如填写123，456，表示该打印员可以拉取到tagid为123和456的下的单，非平台型小程序无需填写该字段\n */\n function updatePrinter(string $openid ,string $updateType ,string $tagidList)\n\n物流助手(服务端)\n/**\n * 获取面单联系人信息 Api: $wxa-&gt;logisticsService()-&gt;getContact()\n * @param string $tokens        商户侧下单事件中推送的 Token 字段\n * @param string $waybillId     运单 ID\n */\nfunction getContact(string $tokens ,string $waybillId)\n\n /**\n * 预览面单模板。用于调试面单模板使用。 Api:  $wxa-&gt;logisticsService()-&gt;previewTemplate()\n * @param string $waybillId         运单 ID\n * @param string $waybillTemplate   面单 HTML 模板内容（需经 Base64 编码）\n * @param string $waybillData       面单数据\n * @param AddOrder $addOrder        商户下单数据\n * 具体参数文档地址：https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/express/by-provider/logistics.previewTemplate.html\n */\n  function previewTemplate(string $waybillId ,string $waybillTemplate ,string $waybillData,AddOrder $addOrder)\n\n/**\n * 更新商户审核结果 Api:  $wxa-&gt;logisticsService()-&gt;updateBusiness()\n * @param string $shopAppId     商户的小程序AppID\n * @param string $bizId         商户账户\n * @param int $resultCode       审核结果，0 表示审核通过，其他表示审核失败\n * @param string $resultMsg     审核错误原因，仅 result_code 不等于 0 时需要设置\n */\nfunction updateBusiness(string $shopAppId ,string $bizId ,int $resultCode ,string $resultMsg)\n\n/**\n     * 更新运单轨迹 Api: $wxa-&gt;logisticsService()-&gt;updatePath()\n     * @param UpdatePath $updatePath\n     * 具体参数文档地址：https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/express/by-provider/logistics.updatePath.html\n     */\n    function updatePath(UpdatePath $updatePath)\n\n生物认证\n/**\n     * SOTER 生物认证秘钥签名验证 Api: $wxa-&gt;attest()-&gt;verifySignature()\n     * @param string $openid        用户 openid\n     * @param string $jsonString    通过 wx.startSoterAuthentication 成功回调获得的 resultJSON 字段\n     * @param string $jsonSignature 通过 wx.startSoterAuthentication 成功回调获得的 resultJSONSignature 字段\n     */\n    function verifySignature(string $openid ,string $jsonString ,string $jsonSignature)\n\n插件管理\n/**\n *向插件开发者发起使用插件的申请 Api: $wxa-&gt;plugin()-&gt;applyPlugin()\n * @param string $action        此接口下填写 \"apply\"\n * @param string $pluginAppid   插件 appId\n * @param string $reason        申请使用理由\n */\nfunction applyPlugin(string $action = 'apply' ,string $pluginAppid ,string $reason = '')\n\n/**\n * 获取当前所有插件使用方（供插件开发者调用）Api: $wxa-&gt;plugin()-&gt;getPluginDevApplyList()\n * @param string $action    此接口下填写 \"dev_apply_list\"\n * @param int $page         要拉取第几页的数据\n * @param int $num          每页的记录数\n */\nfunction getPluginDevApplyList(string $action = 'dev_apply_list' ,int $page = 1 ,int $num = 10)\n\n/**\n * 查询已添加的插件 Api: $wxa-&gt;plugin()-&gt;getPluginList()\n * @param string $action    此接口下填写 \"list\"\n */\nfunction getPluginList(string $action = 'list')\n\n/**\n * 修改插件使用申请的状态（供插件开发者调用）Api: $wxa-&gt;plugin()-&gt;setDevPluginApplyStatus()\n * @param string $action    修改操作\n * @param string $appid     使用者的 appid。同意申请时填写。    \n * @param string $reason    拒绝理由。拒绝申请时填写\n */\nfunction setDevPluginApplyStatus(string $action ,string $appid = '' ,string $reason = '')\n\n/**\n * 删除已添加的插件 Api:  $wxa-&gt;plugin()-&gt;unbindPlugin()\n * @param string $action        此接口下填写 \"unbind\"\n * @param string $pluginAppid   插件 appId\n */\nfunction unbindPlugin(string $action = 'unbind' ,string $pluginAppid)\n\n附近的小程序\n/**\n * 添加地点 Api: $wxa-&gt;program()-&gt;add()\n * @param ProgramBean $program\n * 参数文档： https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/nearby-poi/nearbyPoi.add.html\n */\nfunction add(ProgramBean $program)\n\n//例子\n\n$program = [\n    'kf_info' =&gt; '{\"open_kf\":true,\"kf_headimg\":\"http://mmbiz.qpic.cn/mmbiz_jpg/kKMgNtnEfQzDKpLXYhgo3W3Gndl34gITqmP914zSwhajIEJzUPpx40P7R8fRe1QmicneQMhFzpZNhSLjrvU1pIA/0?wx_fmt=jpeg\",\"kf_name\":\"Harden\"}',\n    'pic_list' =&gt; '{\"list\":[\"http://mmbiz.qpic.cn/mmbiz_jpg/kKMgNtnEfQzDKpLXYhgo3W3Gndl34gITqmP914zSwhajIEJzUPpx40P7R8fRe1QmicneQMhFzpZNhSLjrvU1pIA/0?wx_fmt=jpeg\",\"http://mmbiz.qpic.cn/mmbiz_jpg/kKMgNtnEfQzDKpLXYhgo3W3Gndl34gITRneE5FS9uYruXGMmrtmhsBySwddEWUGOibG8Ze2NT5E3Dyt79I0htNg/0?wx_fmt=jpeg\"]}',\n    'service_infos' =&gt; '{\"service_infos\":[{\"id\":2,\"type\":1,\"name\":\"快递\",\"appid\":\"wx1373169e494e0c39\",\"path\":\"index\"},{\"id\":0,\"type\":2,\"name\":\"测试\",\"appid\":\"wx1373169e494e0c39\",\"path\":\"index\"}]}',\n    'store_name' =&gt; '测试测试',\n    'contract_phone' =&gt; '1769360227',\n    'hour' =&gt; '00:00-11:11',\n    'company_name' =&gt; '测试数据啊',\n    'credential' =&gt; '13082741523645',\n    'address' =&gt; 'xxxxxxxx',\n    'qualification_list' =&gt; '3LaLzqiTrQcD20DlX_o-OV1-nlYMu7sdVAL7SV2PrxVyjZFZZmB3O6LPGaYXlZWq',\n];\n\n$wxa-&gt;program()-&gt;add($program);\n /**\n * 删除地点 Api: $wxa-&gt;program()-&gt;delete()\n * @param string $poiId 附近地点 ID\n */\nfunction delete(string  $poiId)\n\n/**\n * 查看地点列表 Api:  $wxa-&gt;program()-&gt;getList()\n * @param int $page     起始页id（从1开始计数）\n * @param int $pageRows 每页展示个数（最多1000个）\n */\nfunction getList(int $page = 1 ,int $pageRows)\n\n/**\n * 展示/取消展示附近小程序 Api: $wxa-&gt;program()-&gt;setShowStatus()\n * @param string $poiId 附近地点 ID\n * @param int $status   是否展示 0: 不展示，1：展示\n */\nfunction setShowStatus(string $poiId ,int $status)\n","link":"/Components/WeChat/miniProgram.html"},{"id":367,"title":"安装","content":"EasySwoole Pay\nEasySwoole Pay 是一个基于 Swoole 4.x 全协程支持的支付SDK库，告别同步阻塞。\n组件要求\n\next-json &gt;= 1.0\next-openssl &gt;= 1.0\next-bcmath: *\neasyswoole/http &gt;= ^1.2\neasyswoole/spl &gt;= ^1.1\neasyswoole/http-client &gt;= ^1.2.5\neasyswoole/utility &gt;= ^1.0\n\n\n注意：请务必检查你的 php 环境有没有安装 php-bcmath 扩展，没有安装 php-bcmath 扩展时安装的 pay 组件的版本是 1.2.17 之前的版本(不是最新)。想要使用最新稳定版 pay 组件的功能，请先安装 php-bcmath 扩展，php 安装此扩展的方法请自行查询。\n\n安装方法\n\ncomposer require easyswoole/pay\n\n仓库地址\neasyswoole/pay","link":"/Components/Pay/install.html"},{"id":368,"title":"微信","content":"协程支付网关(微信支付)\n组件安装方法和说明\n\n注意：请务必检查你的 php 环境有没有安装 php-bcmath 扩展，没有安装 php-bcmath 扩展时安装的 pay 组件的版本是 1.2.17 之前的版本(不是最新)。想要使用最新稳定版 pay 组件的功能，请先安装 php-bcmath 扩展，php 安装此扩展的方法请自行查询。\n\ncomposer require easyswoole/pay\n微信支付方法\n微信支付目前支持 6 种支付方法，对应的支付 method 如下：\n\n\n\nmethod\n说明\n参数\n返回值\n\n\n\n\nwap\n手机网站支付\nRequest\nResponse\n\n\nofficialAccount\n公众号支付\nRequest\nResponse\n\n\nscan\n扫码支付\nRequest\nResponse\n\n\nminiProgram\n小程序支付\nRequest\nResponse\n\n\nbarCode\n条码当面支付\nRequest\nResponse\n\n\nApp\nApp支付\nRequest\nResponse\n\n\n\n微信参数配置\n$wechatConfig = new Config();\n$wechatConfig-&gt;setAppId('xxxxxx');      // 除了小程序以外使用该APPID\n$wechatConfig-&gt;setMiniAppId('xxxxxx');  // 小程序使用该APPID\n$wechatConfig-&gt;setMchId('xxxxxx');\n$wechatConfig-&gt;setKey('xxxxxx');\n$wechatConfig-&gt;setNotifyUrl('xxxxx');\n$wechatConfig-&gt;setApiClientCert('xxxxxxx');//客户端证书\n$wechatConfig-&gt;setApiClientKey('xxxxxxx'); //客户端证书秘钥\n\n由于小程序拥有独立的APPID，只需要在配置里同时配置上AppId和MiniAppId两个配置项，在支付的时候会自动选择对应的APPID来发起支付\n\n公众号支付\n$officialAccount = new OfficialAccount();\n$officialAccount-&gt;setOpenid('xxxxxxx');\n$officialAccount-&gt;setOutTradeNo('CN' . date('YmdHis') . rand(1000, 9999));\n$officialAccount-&gt;setBody('xxxxx-测试' . $outTradeNo);\n$officialAccount-&gt;setTotalFee(1);\n$officialAccount-&gt;setSpbillCreateIp('xxxxx');\n$pay = new \\EasySwoole\\Pay\\Pay();\n$params = $pay-&gt;weChat($wechatConfig)-&gt;officialAccount($officialAccount);\n可以参考demo/wechat/index.php \n\n在使用微信支付时，商品名称中如果出现特殊字符，如 &amp; 请自行使用urlencode在生成签名传参时进行编码\n\nH5支付\n$wap = new \\EasySwoole\\Pay\\WeChat\\RequestBean\\Wap();\n$wap-&gt;setOutTradeNo('CN' . date('YmdHis') . rand(1000, 9999));\n$wap-&gt;setBody('xxxxx-WAP测试' . $outTradeNo);\n$wap-&gt;setTotalFee(1);\n$wap-&gt;setSpbillCreateIp('xxxxx');\n$pay = new \\EasySwoole\\Pay\\Pay();\n$params = $pay-&gt;weChat($wechatConfig)-&gt;wap($wap);\n小程序支付\n$bean = new \\EasySwoole\\Pay\\WeChat\\RequestBean\\MiniProgram();\n$bean-&gt;setOpenid('xxxxxxxxx');\n$bean-&gt;setOutTradeNo('CN' . date('YmdHis') . rand(1000, 9999));\n$bean-&gt;setBody('xxxx-测试' . $outTradeNo);\n$bean-&gt;setTotalFee(1);\n$bean-&gt;setSpbillCreateIp($this-&gt;request()-&gt;getHeader('x-real-ip')[0]);\n$pay = new \\EasySwoole\\Pay\\Pay();\n$params = $pay-&gt;weChat($this-&gt;wechatConfig)-&gt;miniProgram($bean);\nApp支付\n$app = new App();\n$app-&gt;setNonceStr('xxxxx');\n$app-&gt;setSign('xxxxx');\n$app-&gt;setBody('app支付测试');\n$app-&gt;setOutTradeNo(date(YmdHis).rand(1000,999));\n$app-&gt;setTotalFee(1);\n$app-&gt;setSpbillCreateIp('xxxx');\n\n$pay = new \\EasySwoole\\Pay\\Pay();\n$result = $pay-&gt;weChat($wechatConfig)-&gt;app($app);\n扫码支付\n模式一\n生成扫码链接 然后生成二维码 具体请查看demo/wechat/index.php\n$biz = new Biz();\n$biz-&gt;setProductId('123456789');\n$biz-&gt;setTimeStamp(time());\n$biz-&gt;setAppId($wechatConfig-&gt;getAppId());\n$biz-&gt;setMchId($wechatConfig-&gt;getMchid());\n$data = $biz-&gt;toArray();\n$u = new Utility($wechatConfig);\n$sign = $u-&gt;generateSign($data);\n$biz-&gt;setSign($sign);\n$url1 = \"weixin://wxpay/bizpayurl?\" . $this-&gt;ToUrlParams($biz-&gt;toArray());\n扫码回调地址（ps:公众号平台设置）\n $xml = $this-&gt;request()-&gt;getBody()-&gt;__toString();\n$pay = new Pay();\n$data = $pay-&gt;weChat($this-&gt;wechatConfig)-&gt;verify($xml);\n$bean = new \\EasySwoole\\Pay\\WeChat\\RequestBean\\Scan();\n$bean-&gt;setOutTradeNo('CN' . date('YmdHis') . rand(1000, 9999));\n$bean-&gt;setOpenid('xxxxxx');\n$bean-&gt;setProductId($data['product_id']);\n$bean-&gt;setBody('xxxxxx-SCAN测试' . $outTradeNo);\n$bean-&gt;setTotalFee(1);\n$bean-&gt;setSpbillCreateIp($this-&gt;request()-&gt;getHeader('x-real-ip')[0]);\n$response = $pay-&gt;weChat($this-&gt;wechatConfig)-&gt;scan($bean);\n$nativeResponse = new NativeResponse([\n    'appid' =&gt; $this-&gt;wechatConfig-&gt;getAppId(),\n    'mch_id' =&gt; $this-&gt;wechatConfig-&gt;getMchId(),\n    'prepay_id' =&gt; $response-&gt;getPrepayId(),\n    'nonce_str' =&gt; $response-&gt;getNonceStr()]);\n$u = new Utility($this-&gt;wechatConfig);\n$nativeResponse-&gt;setSign($u-&gt;generateSign($nativeResponse-&gt;toArray()));\n$xml = (new SplArray($nativeResponse-&gt;toArray()))-&gt;toXML();\n$this-&gt;response()-&gt;write($xml);\n模式二\n$bean = new \\EasySwoole\\Pay\\WeChat\\RequestBean\\Scan();\n$bean-&gt;setOutTradeNo($outTradeNo);\n$bean-&gt;setProductId('123456789');\n$bean-&gt;setBody('xxxx-SCAN2测试' . $outTradeNo);\n$bean-&gt;setTotalFee(1);\n$bean-&gt;setSpbillCreateIp($this-&gt;request()-&gt;getHeader('x-real-ip')[0]);\n$pay = new Pay();\n$data = $pay-&gt;weChat($this-&gt;wechatConfig)-&gt;scan($bean);\n$url2 = $data-&gt;getCodeUrl();\n订单查询\ngo(function () use ($wechatConfig) {\n    $orderFind = new \\EasySwoole\\Pay\\WeChat\\RequestBean\\OrderFind();\n    $orderFind-&gt;setOutTradeNo('CN201903181044383609');\n    $pay = new \\EasySwoole\\Pay\\Pay();\n    $info = $pay-&gt;weChat($wechatConfig)-&gt;orderFind($orderFind);\n    print_r((array)$info);\n});\n申请退款\ngo(function () use ($wechatConfig) {\n    $refund = new \\EasySwoole\\Pay\\WeChat\\RequestBean\\Refund();\n    $refund-&gt;setOutTradeNo('CN201903181111275823');\n    $refund-&gt;setOutRefundNo('TK' . date('YmdHis') . rand(1000, 9999));\n    $refund-&gt;setTotalFee(1);\n    $refund-&gt;setRefundFee(1);\n    $refund-&gt;setNotifyUrl('xxxxx');\n    $pay = new \\EasySwoole\\Pay\\Pay();\n    $info = $pay-&gt;weChat($wechatConfig)-&gt;refund($refund);\n    print_r($info);\n});\n退款查询\ngo(function () use ($wechatConfig) {\n    $refundFind = new \\EasySwoole\\Pay\\WeChat\\RequestBean\\RefundFind();\n    $refundFind-&gt;setOutTradeNo('CN201903181044383609');\n    $pay = new \\EasySwoole\\Pay\\Pay();\n    $info = $pay-&gt;weChat($wechatConfig)-&gt;refundFind($refundFind);\n    print_r((array)$info);\n});\n关闭订单\ngo(function () use ($wechatConfig) {\n    $close = new \\EasySwoole\\Pay\\WeChat\\RequestBean\\Close();\n    $close-&gt;setOutTradeNo('CN201903151343107239');\n    $pay = new \\EasySwoole\\Pay\\Pay();\n    $info = $pay-&gt;weChat($wechatConfig)-&gt;close($close);\n    print_r((array)$info);\n});\n下载对账单\ngo(function () use ($wechatConfig) {\n    $download = new \\EasySwoole\\Pay\\WeChat\\RequestBean\\Download();\n    $download-&gt;setBillDate('20190312');\n    $download-&gt;setBillType('ALL');//这个参数必传\n    $pay = new \\EasySwoole\\Pay\\Pay();\n    $info = $pay-&gt;weChat($wechatConfig)-&gt;download($download);\n    echo htmlspecialchars($info, ENT_QUOTES);\n});\n下载资金对账单\ngo(function () use ($wechatConfig) {\n    $download = new \\EasySwoole\\Pay\\WeChat\\RequestBean\\DownloadFundFlow();\n    $download-&gt;setBillDate('20190312');\n    $download-&gt;setAccountType('Basic');\n    $pay = new \\EasySwoole\\Pay\\Pay();\n    $info = $pay-&gt;weChat($wechatConfig)-&gt;downloadFundFlow($download);\n    echo htmlspecialchars($info, ENT_QUOTES);\n});\n验证签名\n$pay = new \\EasySwoole\\Pay\\Pay();\n$content = '';//content为xml原始数据,在easyswoole中可通过$this-&gt;request()-&gt;getBody()-&gt;__toString()取出\n$data = $pay-&gt;weChat($wechatConfig)-&gt;verify($content  )\n服务器确认收到异步通知字符串获取\n\\EasySwoole\\Pay\\WeChat\\WeChat::success();//成功响应\n\\EasySwoole\\Pay\\WeChat\\WeChat::fail();//失败响应","link":"/Components/Pay/wechat.html"},{"id":369,"title":"支付宝","content":"协程支付网关(支付宝支付)\n组件安装方法和说明\n\n注意：请务必检查你的 php 环境有没有安装 php-bcmath 扩展，没有安装 php-bcmath 扩展时安装的 pay 组件的版本是 1.2.17 之前的版本(不是最新)。想要使用最新稳定版 pay 组件的功能，请先安装 php-bcmath 扩展，php 安装此扩展的方法请自行查询。\n\ncomposer require easyswoole/pay\n支付宝\n支付方法\n支付宝支付目前支持 7 种支付方法，对应的支付 method 如下：\n\n\n\nmethod\n说明\n参数\n返回值\n\n\n\n\nweb\n电脑支付\nRequest\nResponse\n\n\nwap\n手机网站支付\nRequest\nResponse\n\n\napp\nAPP 支付\nRequest\nResponse\n\n\npos\n刷卡支付\nRequest\nResponse\n\n\nscan\n扫码支付\nRequest\nResponse\n\n\ntransfer\n账户转账\nRequest\nResponse\n\n\nmini\n小程序支付\nRequest\nResponse\n\n\nbarCode\n条码当面支付\nRequest\nResponse\n\n\n\n注意，easyswoole/pay 支付宝支付组件的默认签名为 RSA2 普通公钥方式签名，也支持 RSA2 公钥证书的签名方式。放置应用公私钥证书、支付宝证书路径、支付宝根证书路径的时候切记核对。\n电脑支付\n统一收单下单并支付页面接口\n/**\n * 普通公钥方式生成密钥验签(签名和验签方式)\n */\n// 设置支付配置\n$aliConfig = new \\EasySwoole\\Pay\\AliPay\\Config();\n### 配置支付公共请求参数\n// (必须)设置 支付宝分配给开发者的应用ID\n$aliConfig-&gt;setAppId('2017082000295641');\n// (必须)设置 请求网关(默认为 沙箱模式)\n$aliConfig-&gt;setGateWay(\\EasySwoole\\Pay\\AliPay\\GateWay::NORMAL);\n// 设置 参数格式(默认为 'JSON'，可选参数)，不建议修改\n//   $aliConfig-&gt;setFormat('JSON');\n// 设置 return_url(默认为 null，可选参数)\n//   $aliConfig-&gt;setReturnUrl(null);\n// 设置 请求使用的编码格式，如utf-8、gbk、gb2312等(默认为 'utf-8')\n//   $aliConfig-&gt;setCharset('utf-8');\n// 设置 商户生成签名字符串所使用的签名算法类型，目前支持 RSA2 和 RSA，推荐使用 RSA2(默认为 'RSA2')\n$aliConfig-&gt;setSignType('RSA2');\n// 设置 调用的接口版本(默认为 '1.0')\n//   $aliConfig-&gt;setApiVersion('1.0');\n// 设置 支付宝服务器主动通知商户服务器里指定的页面http/https路径，即支付回调地址(默认为 null，可选参数)\n//   $aliConfig-&gt;setNotifyUrl(null);\n// 设置 应用授权参数(默认为 null，可选参数)，详细请看(https://opendocs.alipay.com/open/common/105193)\n//   $aliConfig-&gt;setAppAuthToken(null);\n// 设置 阿里应用公钥(支持 .pem 结尾的格式，默认为 PKCS1 格式)，用于支付回调时验证签名\n$aliConfig-&gt;setPublicKey('阿里应用公钥字符串'); // 示例应用公钥字符串\n// 设置 阿里应用私钥(支持 .pem 结尾的格式，默认为 PKCS1 格式)，用于生成签名\n$aliConfig-&gt;setPrivateKey('阿里应用私钥字符串'); // 示例应用私钥字符串\n\n/**\n * 公钥证书方式生成密钥验签(签名和验签方式)\n */\n/*\n$aliConfig = new \\EasySwoole\\Pay\\AliPay\\Config();\n### 配置支付公共请求参数\n// (必须)设置 支付宝分配给开发者的应用ID\n$aliConfig-&gt;setAppId('2017082000295641');\n// (必须)设置 请求网关(默认为 沙箱模式)\n$aliConfig-&gt;setGateWay(\\EasySwoole\\Pay\\AliPay\\GateWay::NORMAL);\n// 设置 参数格式(默认为 'JSON'，可选参数)，不建议修改\n//   $aliConfig-&gt;setFormat('JSON');\n// 设置 return_url(默认为 null，可选参数)\n//   $aliConfig-&gt;setReturnUrl(null);\n// 设置 请求使用的编码格式，如utf-8、gbk、gb2312等(默认为 'utf-8')\n//   $aliConfig-&gt;setCharset('utf-8');\n// 设置 商户生成签名字符串所使用的签名算法类型，目前支持 RSA2 和 RSA，推荐使用 RSA2(默认为 'RSA2')\n$aliConfig-&gt;setSignType('RSA2');\n// 设置 调用的接口版本(默认为 '1.0')\n//   $aliConfig-&gt;setApiVersion('1.0');\n// 设置 支付宝服务器主动通知商户服务器里指定的页面http/https路径，即支付回调地址(默认为 null，可选参数)\n//   $aliConfig-&gt;setNotifyUrl(null);\n// 设置 应用授权参数(默认为 null，可选参数)，详细请看(https://opendocs.alipay.com/open/common/105193)\n//   $aliConfig-&gt;setAppAuthToken(null);\n\n// (必须)设置 使用公钥证书方式生密钥延签(签名和验签方式)\n$aliConfig-&gt;setCertMode(true);\n// (必须)设置 支付宝公钥文件路径\n$aliConfig-&gt;setCertPath(__DIR__ . '/cert/alipayCertPublicKey_RSA2.crt'); // 示例支付宝公钥文件路径\n// (必须)设置 支付宝根证书文件路径\n$aliConfig-&gt;setRootCertPath(__DIR__ . '/cert/alipayRootCert.crt'); // 示例支付宝公钥根证书文件路径\n// (必须)设置 阿里应用公钥证书文件路径\n$aliConfig-&gt;setMerchantCertPath(__DIR__ . '/cert/appCertPublicKey_2016091800538780.crt');\n// (必须)设置 阿里应用私钥(支持 .pem 结尾的格式，默认为 PKCS1 格式)，用于生成签名\n$aliConfig-&gt;setPrivateKey('阿里应用私钥字符串'); // 示例应用私钥字符串\n*/\n\n// 以上【普通公钥方式】 和 【公钥证书方式】 生成密钥验签(签名和验签方式) 这 2 种方式，用户可自行选择一种】\n\n$pay = new \\EasySwoole\\Pay\\Pay();\n\n## (面向对象风格)设置请求参数 biz_content，组件自动帮你组装成对应的格式\n$order = new \\EasySwoole\\Pay\\AliPay\\RequestBean\\Web();\n// (必须)设置 商户订单号(商户订单号。64 个字符以内的大小，仅支持字母、数字、下划线。需保证该参数在商户端不重复。)\n$order-&gt;setOutTradeNo(time() . '123456'); // 示例订单号(仅供参考)\n// (必须)设置 订单总金额\n$order-&gt;setTotalAmount('0.01'); // 示例订单总金额，单位：元(仅供参考)\n// (必须)设置 商品标题/交易标题/订单标题/订单关键字等。注意：不可使用特殊字符，如 /，=，&amp; 等。\n$order-&gt;setSubject('测试'); // 示例商品标题(仅供参考)\n// (可选)设置 订单描述，默认为 null\n//   $order-&gt;setBody(null);\n// (可选)设置 在订单中设置支付宝服务器主动通知商户服务器里指定的页面http/https路径，即支付回调地址(默认为 null，可选参数)\n//   $order-&gt;setNotifyUrl(null); // 等价于在配置中设置 支付回调地址，两者中只要设置一次即可\n// (可选)设置 return_url(默认为 null，可选参数)\n//   $order-&gt;setReturnUrl(null); // 等价于在配置中设置 return_url，两者中只要设置一次即可\n// 本库只预置了常用的请求参数，没预置的参数请求使用：$order-&gt;addProperty('其他字段','其他字段值');\n// 支付其他可选参数（详细请看支付宝接口的可选参数，支付宝接口对应地址请看下文）\n\n## (数组风格)设置请求参数 biz_content，组件自动帮你组装成对应的格式\n/*\n$order = new \\EasySwoole\\Pay\\AliPay\\RequestBean\\Web([\n    'out_trade_no' =&gt; time() . '123456', // 示例订单号(仅供参考)\n    'total_amount' =&gt; '0.01', // 示例订单总金额，单位：元(仅供参考)\n    'subject' =&gt; '测试', // 示例商品标题(仅供参考)\n    '额外的字段键值' =&gt; '额外字段值', // 示例支付其他可选参数（详细请看支付宝接口的可选参数，支付宝接口对应地址请看下文）\n], true);\n*/\n\n// 以上 2 种风格设置请求参数，用户可根据个人需要，选其一即可\n\n// 获取构造请求参数对象\n$res = $pay-&gt;aliPay($aliConfig)-&gt;web($order);\n// 将所有请求参数转为数组\nvar_dump($res-&gt;toArray());\n\n// 构造请求表单(buildPayHtml 该方法的实现请看下文)  \n$html = buildPayHtml(\\EasySwoole\\Pay\\AliPay\\GateWay::NORMAL, $res-&gt;toArray());\nfile_put_contents('test.html', $html); \n订单配置参数\n所有订单配置中，对于客观非必选参数，用户可以自行选择是否进行配置，也可以不进行配置，扩展包已经为您自动处理了，比如，product_code 等参数。\n所有订单配置参数和官方无任何差别，兼容所有功能，所有参数请参考 这里，查看「请求参数」一栏。\n参数查询：https://opendocs.alipay.com/apis/api_1/alipay.trade.page.pay\n生成支付的跳转 html 示例\nfunction buildPayHtml($endpoint, $payload)\n{\n    $sHtml = \"&lt;form id='alipaysubmit' name='alipaysubmit' action='\".$endpoint.\"' method='POST'&gt;\";\n    foreach ($payload as $key =&gt; $val) {\n        $val = str_replace(\"'\", '&amp;apos;', $val);\n        $sHtml .= \"&lt;input type='hidden' name='\".$key.\"' value='\".$val.\"'/&gt;\";\n    }\n    $sHtml .= \"&lt;input type='submit' value='ok' style='display:none;'&gt;&lt;/form&gt;\";\n    $sHtml .= \"&lt;script&gt;document.forms['alipaysubmit'].submit();&lt;/script&gt;\";\n    return $sHtml;\n}\n手机网站支付接口 2.0\n/**\n * 普通公钥方式生成密钥验签(签名和验签方式)\n */\n// 设置支付配置\n$aliConfig = new \\EasySwoole\\Pay\\AliPay\\Config();\n### 配置支付公共请求参数\n// (必须)设置 支付宝分配给开发者的应用ID\n$aliConfig-&gt;setAppId('2017082000295641');\n// (必须)设置 请求网关(默认为 沙箱模式)\n$aliConfig-&gt;setGateWay(\\EasySwoole\\Pay\\AliPay\\GateWay::NORMAL);\n// 设置 参数格式(默认为 'JSON'，可选参数)，不建议修改\n//   $aliConfig-&gt;setFormat('JSON');\n// 设置 return_url(默认为 null，可选参数)\n//   $aliConfig-&gt;setReturnUrl(null);\n// 设置 请求使用的编码格式，如utf-8、gbk、gb2312等(默认为 'utf-8')\n//   $aliConfig-&gt;setCharset('utf-8');\n// 设置 商户生成签名字符串所使用的签名算法类型，目前支持 RSA2 和 RSA，推荐使用 RSA2(默认为 'RSA2')\n$aliConfig-&gt;setSignType('RSA2');\n// 设置 调用的接口版本(默认为 '1.0')\n//   $aliConfig-&gt;setApiVersion('1.0');\n// 设置 支付宝服务器主动通知商户服务器里指定的页面http/https路径，即支付回调地址(默认为 null，可选参数)\n//   $aliConfig-&gt;setNotifyUrl(null);\n// 设置 应用授权参数(默认为 null，可选参数)，详细请看(https://opendocs.alipay.com/open/common/105193)\n//   $aliConfig-&gt;setAppAuthToken(null);\n// 设置 阿里应用公钥(支持 .pem 结尾的格式，默认为 PKCS1 格式)，用于支付回调时验证签名\n$aliConfig-&gt;setPublicKey('阿里应用公钥字符串'); // 示例应用公钥字符串\n// 设置 阿里应用私钥(支持 .pem 结尾的格式，默认为 PKCS1 格式)，用于生成签名\n$aliConfig-&gt;setPrivateKey('阿里应用私钥字符串'); // 示例应用私钥\n\n/**\n * 公钥证书方式生成密钥验签(签名和验签方式)\n */\n/*\n$aliConfig = new \\EasySwoole\\Pay\\AliPay\\Config();\n### 配置支付公共请求参数\n// (必须)设置 支付宝分配给开发者的应用ID\n$aliConfig-&gt;setAppId('2017082000295641');\n// (必须)设置 请求网关(默认为 沙箱模式)\n$aliConfig-&gt;setGateWay(\\EasySwoole\\Pay\\AliPay\\GateWay::NORMAL);\n// 设置 参数格式(默认为 'JSON'，可选参数)，不建议修改\n//   $aliConfig-&gt;setFormat('JSON');\n// 设置 return_url(默认为 null，可选参数)\n//   $aliConfig-&gt;setReturnUrl(null);\n// 设置 请求使用的编码格式，如utf-8、gbk、gb2312等(默认为 'utf-8')\n//   $aliConfig-&gt;setCharset('utf-8');\n// 设置 商户生成签名字符串所使用的签名算法类型，目前支持 RSA2 和 RSA，推荐使用 RSA2(默认为 'RSA2')\n$aliConfig-&gt;setSignType('RSA2');\n// 设置 调用的接口版本(默认为 '1.0')\n//   $aliConfig-&gt;setApiVersion('1.0');\n// 设置 支付宝服务器主动通知商户服务器里指定的页面http/https路径，即支付回调地址(默认为 null，可选参数)\n//   $aliConfig-&gt;setNotifyUrl(null);\n// 设置 应用授权参数(默认为 null，可选参数)，详细请看(https://opendocs.alipay.com/open/common/105193)\n//   $aliConfig-&gt;setAppAuthToken(null);\n\n// (必须)设置 使用公钥证书方式生密钥延签(签名和验签方式)\n$aliConfig-&gt;setCertMode(true);\n// (必须)设置 支付宝公钥文件路径\n$aliConfig-&gt;setCertPath(__DIR__ . '/cert/alipayCertPublicKey_RSA2.crt'); // 示例支付宝公钥文件路径\n// (必须)设置 支付宝根证书文件路径\n$aliConfig-&gt;setRootCertPath(__DIR__ . '/cert/alipayRootCert.crt'); // 示例支付宝公钥根证书文件路径\n// (必须)设置 阿里应用公钥证书文件路径\n$aliConfig-&gt;setMerchantCertPath(__DIR__ . '/cert/appCertPublicKey_2016091800538780.crt');\n// (必须)设置 阿里应用私钥(支持 .pem 结尾的格式，默认为 PKCS1 格式)，用于生成签名\n$aliConfig-&gt;setPrivateKey('阿里应用私钥字符串');\n*/\n\n// 以上【普通公钥方式】 和 【公钥证书方式】 生成密钥验签(签名和验签方式) 这 2 种方式，用户可自行选择一种】\n\n$pay = new \\EasySwoole\\Pay\\Pay();\n\n## (面向对象风格)设置请求参数 biz_content，组件自动帮你组装成对应的格式\n$order = new \\EasySwoole\\Pay\\AliPay\\RequestBean\\Wap();\n// (必须)设置 商品标题/交易标题/订单标题/订单关键字等。注意：不可使用特殊字符，如 /，=，&amp; 等。\n$order-&gt;setSubject('测试'); // 示例商品标题(仅供参考)\n// (必须)设置 商户订单号(商户订单号。64 个字符以内的大小，仅支持字母、数字、下划线。需保证该参数在商户端不重复。)\n$order-&gt;setOutTradeNo(time() . '123456'); // 示例订单号(仅供参考)\n// (必须)设置 订单总金额\n$order-&gt;setTotalAmount('0.01'); // 示例订单总金额，单位：元(仅供参考)\n// (必须)设置 用户付款中途退出返回商户网站的地址\n$order-&gt;addProperty('quit_url', 'http://www.easyswoole.com'); // 示例中途退出返回商户网站的地址(仅供参考)\n\n// (可选)设置 订单描述，默认为 null\n//   $order-&gt;setBody(null);\n// (可选)设置 在订单中设置支付宝服务器主动通知商户服务器里指定的页面http/https路径，即支付回调地址(默认为 null，可选参数)\n//   $order-&gt;setNotifyUrl(null); // 等价于在配置中设置 支付回调地址，两者中只要设置一次即可\n// (可选)设置 return_url(默认为 null，可选参数)\n//   $order-&gt;setReturnUrl(null); // 等价于在配置中设置 return_url，两者中只要设置一次即可\n// 本库只预置了常用的请求参数，没预置的参数请求使用：$order-&gt;addProperty('其他字段','其他字段值');\n// 支付其他可选参数（详细请看支付宝接口的可选参数，支付宝接口对应地址请看下文）\n\n## (数组风格)设置请求参数 biz_content，组件自动帮你组装成对应的格式\n/*\n$order = new \\EasySwoole\\Pay\\AliPay\\RequestBean\\Wap([\n    'out_trade_no' =&gt; time() . '123456', // 示例订单号(仅供参考)\n    'total_amount' =&gt; '0.01', // 示例订单总金额，单位：元(仅供参考)\n    'subject' =&gt; '测试', // 示例商品标题(仅供参考)\n    'quit_url' =&gt; 'http://www.easyswoole.com', // 示例中途退出返回商户网站的地址(仅供参考)\n    '额外的字段键值' =&gt; '额外字段值', // 示例支付其他可选参数（详细请看支付宝接口的可选参数，支付宝接口对应地址请看下文）\n], true);\n*/\n\n// 以上 2 种风格设置请求参数，用户可根据个人需要，选其一即可\n\n// 获取构造请求参数对象\n$res = $pay-&gt;aliPay($aliConfig)-&gt;wap($order);\n// 将所有请求参数转为数组\nvar_dump($res-&gt;toArray());\n\n// 构造请求表单(buildPayHtml 该方法的实现请看上文)  \n$html = buildPayHtml(\\EasySwoole\\Pay\\AliPay\\GateWay::NORMAL, $res-&gt;toArray());\nfile_put_contents('test.html', $html);\n订单配置参数\n所有订单配置中，对于客观非必选参数，用户可以自行选择是否进行配置，也可以不进行配置，扩展包已经为您自动处理了，比如，product_code 等参数。\n所有订单配置参数和官方无任何差别，兼容所有功能，所有参数请参考 这里，查看「请求参数」一栏。\n参数查询：https://opendocs.alipay.com/apis/api_1/alipay.trade.wap.pay\nAPP支付接口 2.0\n/**\n * 普通公钥方式生成密钥验签(签名和验签方式)\n */\n// 设置支付配置\n$aliConfig = new \\EasySwoole\\Pay\\AliPay\\Config();\n### 配置支付公共请求参数\n// (必须)设置 支付宝分配给开发者的应用ID\n$aliConfig-&gt;setAppId('2017082000295641');\n// (必须)设置 请求网关(默认为 沙箱模式)\n$aliConfig-&gt;setGateWay(\\EasySwoole\\Pay\\AliPay\\GateWay::NORMAL);\n// 设置 参数格式(默认为 'JSON'，可选参数)，不建议修改\n//   $aliConfig-&gt;setFormat('JSON');\n// 设置 return_url(默认为 null，可选参数)\n//   $aliConfig-&gt;setReturnUrl(null);\n// 设置 请求使用的编码格式，如utf-8、gbk、gb2312等(默认为 'utf-8')\n//   $aliConfig-&gt;setCharset('utf-8');\n// 设置 商户生成签名字符串所使用的签名算法类型，目前支持 RSA2 和 RSA，推荐使用 RSA2(默认为 'RSA2')\n$aliConfig-&gt;setSignType('RSA2');\n// 设置 调用的接口版本(默认为 '1.0')\n//   $aliConfig-&gt;setApiVersion('1.0');\n// 设置 支付宝服务器主动通知商户服务器里指定的页面http/https路径，即支付回调地址(默认为 null，可选参数)\n//   $aliConfig-&gt;setNotifyUrl(null);\n// 设置 应用授权参数(默认为 null，可选参数)，详细请看(https://opendocs.alipay.com/open/common/105193)\n//   $aliConfig-&gt;setAppAuthToken(null);\n// 设置 阿里应用公钥(支持 .pem 结尾的格式，默认为 PKCS1 格式)，用于支付回调时验证签名\n$aliConfig-&gt;setPublicKey('阿里应用公钥字符串'); // 示例应用公钥字符串\n// 设置 阿里应用私钥(支持 .pem 结尾的格式，默认为 PKCS1 格式)，用于生成签名\n$aliConfig-&gt;setPrivateKey('阿里应用私钥字符串'); // 示例应用私钥\n\n/**\n * 公钥证书方式生成密钥验签(签名和验签方式)\n */\n/*\n$aliConfig = new \\EasySwoole\\Pay\\AliPay\\Config();\n### 配置支付公共请求参数\n// (必须)设置 支付宝分配给开发者的应用ID\n$aliConfig-&gt;setAppId('2017082000295641');\n// (必须)设置 请求网关(默认为 沙箱模式)\n$aliConfig-&gt;setGateWay(\\EasySwoole\\Pay\\AliPay\\GateWay::NORMAL);\n// 设置 参数格式(默认为 'JSON'，可选参数)，不建议修改\n//   $aliConfig-&gt;setFormat('JSON');\n// 设置 return_url(默认为 null，可选参数)\n//   $aliConfig-&gt;setReturnUrl(null);\n// 设置 请求使用的编码格式，如utf-8、gbk、gb2312等(默认为 'utf-8')\n//   $aliConfig-&gt;setCharset('utf-8');\n// 设置 商户生成签名字符串所使用的签名算法类型，目前支持 RSA2 和 RSA，推荐使用 RSA2(默认为 'RSA2')\n$aliConfig-&gt;setSignType('RSA2');\n// 设置 调用的接口版本(默认为 '1.0')\n//   $aliConfig-&gt;setApiVersion('1.0');\n// 设置 支付宝服务器主动通知商户服务器里指定的页面http/https路径，即支付回调地址(默认为 null，可选参数)\n//   $aliConfig-&gt;setNotifyUrl(null);\n// 设置 应用授权参数(默认为 null，可选参数)，详细请看(https://opendocs.alipay.com/open/common/105193)\n//   $aliConfig-&gt;setAppAuthToken(null);\n\n// (必须)设置 使用公钥证书方式生密钥延签(签名和验签方式)\n$aliConfig-&gt;setCertMode(true);\n// (必须)设置 支付宝公钥文件路径\n$aliConfig-&gt;setCertPath(__DIR__ . '/cert/alipayCertPublicKey_RSA2.crt'); // 示例支付宝公钥文件路径\n// (必须)设置 支付宝根证书文件路径\n$aliConfig-&gt;setRootCertPath(__DIR__ . '/cert/alipayRootCert.crt'); // 示例支付宝公钥根证书文件路径\n// (必须)设置 阿里应用公钥证书文件路径\n$aliConfig-&gt;setMerchantCertPath(__DIR__ . '/cert/appCertPublicKey_2016091800538780.crt');\n// (必须)设置 阿里应用私钥(支持 .pem 结尾的格式，默认为 PKCS1 格式)，用于生成签名\n$aliConfig-&gt;setPrivateKey('阿里应用私钥字符串');\n*/\n\n// 以上【普通公钥方式】 和 【公钥证书方式】 生成密钥验签(签名和验签方式) 这 2 种方式，用户可自行选择一种】\n\n$pay = new \\EasySwoole\\Pay\\Pay();\n\n## (面向对象风格)设置请求参数 biz_content，组件自动帮你组装成对应的格式\n$order = new \\EasySwoole\\Pay\\AliPay\\RequestBean\\App();\n// (必须)设置 订单总金额\n$order-&gt;setTotalAmount('0.01'); // 示例订单总金额，单位：元(仅供参考)\n// (必须)设置 商品标题/交易标题/订单标题/订单关键字等。注意：不可使用特殊字符，如 /，=，&amp; 等。\n$order-&gt;setSubject('测试'); // 示例商品标题(仅供参考)\n// (必须)设置 商户订单号(商户订单号。64 个字符以内的大小，仅支持字母、数字、下划线。需保证该参数在商户端不重复。)\n$order-&gt;setOutTradeNo(time() . '123456'); // 示例订单号(仅供参考)\n// (可选)设置 销售产品码，商家和支付宝签约的产品码，默认为 QUICK_MSECURITY_PAY（App支付）。\n//   $order-&gt;addProperty('product_code', 'QUICK_MSECURITY_PAY'); // 示例销售产品码(仅供参考)\n// (可选)设置 订单描述，默认为 null\n//   $order-&gt;setBody(null);\n// (可选)设置 在订单中设置支付宝服务器主动通知商户服务器里指定的页面http/https路径，即支付回调地址(默认为 null，可选参数)\n//   $order-&gt;setNotifyUrl(null); // 等价于在配置中设置 支付回调地址，两者中只要设置一次即可\n// (可选)设置 return_url(默认为 null，可选参数)\n//   $order-&gt;setReturnUrl(null); // 等价于在配置中设置 return_url，两者中只要设置一次即可\n// 本库只预置了常用的请求参数，没预置的参数请求使用：$order-&gt;addProperty('其他字段','其他字段值');\n// 支付其他可选参数（详细请看支付宝接口的可选参数，支付宝接口对应地址请看下文）\n\n## (数组风格)设置请求参数 biz_content，组件自动帮你组装成对应的格式\n/*\n$order = new \\EasySwoole\\Pay\\AliPay\\RequestBean\\Wap([\n    'out_trade_no' =&gt; time() . '123456', // 示例订单号(仅供参考)\n    'total_amount' =&gt; '0.01', // 示例订单总金额，单位：元(仅供参考)\n    'subject' =&gt; '测试', // 示例商品标题(仅供参考)\n    '额外的字段键值' =&gt; '额外字段值', // 示例支付其他可选参数（详细请看支付宝接口的可选参数，支付宝接口对应地址请看下文）\n], true);\n*/\n\n// 以上 2 种风格设置请求参数，用户可根据个人需要，选其一即可\n\n// 获取构造请求参数对象\n$res = $pay-&gt;aliPay($aliConfig)-&gt;app($order);\n// 将所有请求参数转为数组\nvar_dump($res-&gt;toArray());\n订单配置参数\n所有订单配置中，对于客观非必选参数，用户可以自行选择是否进行配置，也可以不进行配置，扩展包已经为您自动处理了，比如，product_code 等参数。\n所有订单配置参数和官方无任何差别，兼容所有功能，所有参数请参考 这里，查看「请求参数」一栏。\n参数查询：https://opendocs.alipay.com/apis/api_1/alipay.trade.app.pay\n刷卡支付\n/**\n * 普通公钥方式生成密钥验签(签名和验签方式)\n */\n// 设置支付配置\n$aliConfig = new \\EasySwoole\\Pay\\AliPay\\Config();\n### 配置支付公共请求参数\n// (必须)设置 支付宝分配给开发者的应用ID\n$aliConfig-&gt;setAppId('2017082000295641');\n// (必须)设置 请求网关(默认为 沙箱模式)\n$aliConfig-&gt;setGateWay(\\EasySwoole\\Pay\\AliPay\\GateWay::NORMAL);\n// 设置 参数格式(默认为 'JSON'，可选参数)，不建议修改\n//   $aliConfig-&gt;setFormat('JSON');\n// 设置 请求使用的编码格式，如utf-8、gbk、gb2312等(默认为 'utf-8')\n//   $aliConfig-&gt;setCharset('utf-8');\n// 设置 商户生成签名字符串所使用的签名算法类型，目前支持 RSA2 和 RSA，推荐使用 RSA2(默认为 'RSA2')\n$aliConfig-&gt;setSignType('RSA2');\n// 设置 调用的接口版本(默认为 '1.0')\n//   $aliConfig-&gt;setApiVersion('1.0');\n// 设置 支付宝服务器主动通知商户服务器里指定的页面http/https路径，即支付回调地址(默认为 null，可选参数)\n//   $aliConfig-&gt;setNotifyUrl(null);\n// 设置 应用授权参数(默认为 null，可选参数)，详细请看(https://opendocs.alipay.com/open/common/105193)\n//   $aliConfig-&gt;setAppAuthToken(null);\n// 设置 阿里应用公钥(支持 .pem 结尾的格式，默认为 PKCS1 格式)，用于支付回调时验证签名\n$aliConfig-&gt;setPublicKey('阿里应用公钥字符串'); // 示例应用公钥字符串\n// 设置 阿里应用私钥(支持 .pem 结尾的格式，默认为 PKCS1 格式)，用于生成签名\n$aliConfig-&gt;setPrivateKey('阿里应用私钥字符串'); // 示例应用私钥\n\n/**\n * 公钥证书方式生成密钥验签(签名和验签方式)\n */\n/*\n$aliConfig = new \\EasySwoole\\Pay\\AliPay\\Config();\n### 配置支付公共请求参数\n// (必须)设置 支付宝分配给开发者的应用ID\n$aliConfig-&gt;setAppId('2017082000295641');\n// (必须)设置 请求网关(默认为 沙箱模式)\n$aliConfig-&gt;setGateWay(\\EasySwoole\\Pay\\AliPay\\GateWay::NORMAL);\n// 设置 参数格式(默认为 'JSON'，可选参数)，不建议修改\n//   $aliConfig-&gt;setFormat('JSON');\n// 设置 请求使用的编码格式，如utf-8、gbk、gb2312等(默认为 'utf-8')\n//   $aliConfig-&gt;setCharset('utf-8');\n// 设置 商户生成签名字符串所使用的签名算法类型，目前支持 RSA2 和 RSA，推荐使用 RSA2(默认为 'RSA2')\n$aliConfig-&gt;setSignType('RSA2');\n// 设置 调用的接口版本(默认为 '1.0')\n//   $aliConfig-&gt;setApiVersion('1.0');\n// 设置 支付宝服务器主动通知商户服务器里指定的页面http/https路径，即支付回调地址(默认为 null，可选参数)\n//   $aliConfig-&gt;setNotifyUrl(null);\n// 设置 应用授权参数(默认为 null，可选参数)，详细请看(https://opendocs.alipay.com/open/common/105193)\n//   $aliConfig-&gt;setAppAuthToken(null);\n\n// (必须)设置 使用公钥证书方式生密钥延签(签名和验签方式)\n$aliConfig-&gt;setCertMode(true);\n// (必须)设置 支付宝公钥文件路径\n$aliConfig-&gt;setCertPath(__DIR__ . '/cert/alipayCertPublicKey_RSA2.crt'); // 示例支付宝公钥文件路径\n// (必须)设置 支付宝根证书文件路径\n$aliConfig-&gt;setRootCertPath(__DIR__ . '/cert/alipayRootCert.crt'); // 示例支付宝公钥根证书文件路径\n// (必须)设置 阿里应用公钥证书文件路径\n$aliConfig-&gt;setMerchantCertPath(__DIR__ . '/cert/appCertPublicKey_2016091800538780.crt');\n// (必须)设置 阿里应用私钥(支持 .pem 结尾的格式，默认为 PKCS1 格式)，用于生成签名\n$aliConfig-&gt;setPrivateKey('阿里应用私钥字符串');\n*/\n\n// 以上【普通公钥方式】 和 【公钥证书方式】 生成密钥验签(签名和验签方式) 这 2 种方式，用户可自行选择一种】\n\n$pay = new \\EasySwoole\\Pay\\Pay();\n\n## (面向对象风格)设置请求参数 biz_content，组件自动帮你组装成对应的格式\n$order = new \\EasySwoole\\Pay\\AliPay\\RequestBean\\Pos();\n// (必须)设置 商户订单号(商户订单号。64 个字符以内的大小，仅支持字母、数字、下划线。需保证该参数在商户端不重复。)\n$order-&gt;setOutTradeNo(time() . '123456'); // 示例订单号(仅供参考)\n// (必须)设置 支付授权码(详细说明请看支付宝官网文档：https://opendocs.alipay.com/apis/api_1/alipay.trade.pay?scene=common)\n$order-&gt;setAuthCode('289756915257123456'); // 示例支付授权码(仅供参考)\n// (必须)设置 商品标题/交易标题/订单标题/订单关键字等。注意：不可使用特殊字符，如 /，=，&amp; 等。\n$order-&gt;setSubject('测试'); // 示例商品标题(仅供参考)\n// (可选)设置 支付场景，（默认为 'bar_code'）\n//   $order-&gt;addProperty('scene', 'bar_code');\n// (可选)设置 产品码，默认为 'FACE_TO_FACE_PAYMENT'（当面付）\n//   $order-&gt;addProperty('product_code', 'FACE_TO_FACE_PAYMENT');\n// (可选)设置 订单描述，默认为 null\n//   $order-&gt;setBody(null);\n// (可选)设置 在订单中设置支付宝服务器主动通知商户服务器里指定的页面http/https路径，即支付回调地址(默认为 null，可选参数)\n//   $order-&gt;setNotifyUrl(null); // 等价于在配置中设置 支付回调地址，两者中只要设置一次即可\n// 本库只预置了常用的请求参数，没预置的参数请求使用：$order-&gt;addProperty('其他字段','其他字段值');\n// 支付其他可选参数（详细请看支付宝接口的可选参数，支付宝接口对应地址请看下文）\n\n## (数组风格)设置请求参数 biz_content，组件自动帮你组装成对应的格式\n/*\n$order = new \\EasySwoole\\Pay\\AliPay\\RequestBean\\Wap([\n    'out_trade_no' =&gt; time() . '123456', // 示例订单号(仅供参考)\n    'auth_code' =&gt; '289756915257123456', // 示例支付授权码(仅供参考)\n    'product_code' =&gt; 'FACE_TO_FACE_PAYMENT', // 示例产品码，默认为 'FACE_TO_FACE_PAYMENT'（当面付）\n    'subject' =&gt; '测试', // 示例商品标题(仅供参考)\n    '额外的字段键值' =&gt; '额外字段值', // 示例支付其他可选参数（详细请看支付宝接口的可选参数，支付宝接口对应地址请看下文）\n], true);\n*/\n\n// 以上 2 种风格设置请求参数，用户可根据个人需要，选其一即可\n\n// 获取构造请求参数对象\n$res = $pay-&gt;aliPay($aliConfig)-&gt;pos($order);\n// 将所有请求参数转为数组\n$data = $res-&gt;toArray();\n订单配置参数\n所有订单配置中，对于客观非必选参数，用户可以自行选择是否进行配置，也可以不进行配置，扩展包已经为您自动处理了，比如，product_code、auth_code、scene等参数。\n所有订单配置参数和官方无任何差别，兼容所有功能，所有参数请参考 这里，查看「请求参数」一栏。\n参数查询：https://opendocs.alipay.com/apis/api_1/alipay.trade.pay\n扫码支付\n$aliConfig = new \\EasySwoole\\Pay\\AliPay\\Config();\n$aliConfig-&gt;setGateWay(\\EasySwoole\\Pay\\AliPay\\GateWay::SANDBOX);\n$aliConfig-&gt;setAppId('2016091800538339');\n$aliConfig-&gt;setPublicKey('阿里公钥');\n$aliConfig-&gt;setPrivateKey('阿里私钥');\n\n$pay = new \\EasySwoole\\Pay\\Pay();\n\n$pay = new \\EasySwoole\\Pay\\Pay();\n$order = new \\EasySwoole\\Pay\\AliPay\\RequestBean\\Scan();\n$order-&gt;setSubject('测试');\n$order-&gt;setTotalAmount('0.01');\n$order-&gt;setOutTradeNo(time());\n\n$aliPay = $pay-&gt;aliPay($aliConfig);\n$data = $aliPay-&gt;scan($order)-&gt;toArray();\n$response = $aliPay-&gt;preQuest($data);\nvar_dump($response);\n// qr_code 当前预下单请求生成的二维码码串，可以用二维码生成工具根据该码串值生成对应的二维码  https://qr.alipay.com/bavh4wjlxf12tper3a\n订单配置参数\n所有订单配置中，客观参数均不用配置，扩展包已经为大家自动处理了，比如，product_code 等参数。\n所有订单配置参数和官方无任何差别，兼容所有功能，所有参数请参考这里，查看「请求参数」一栏。\n参考参数：https://docs.open.alipay.com/api_1/alipay.trade.precreate\n单笔转账到支付宝账户接口\n$aliConfig = new \\EasySwoole\\Pay\\AliPay\\Config();\n$aliConfig-&gt;setGateWay(\\EasySwoole\\Pay\\AliPay\\GateWay::SANDBOX);\n$aliConfig-&gt;setAppId('2016091800538339');\n$aliConfig-&gt;setPublicKey('阿里公钥');\n$aliConfig-&gt;setPrivateKey('阿里私钥');\n\n$pay = new \\EasySwoole\\Pay\\Pay();\n\n$order = new \\EasySwoole\\Pay\\AliPay\\RequestBean\\Transfer();\n$order-&gt;setSubject('测试');\n$order-&gt;setAmount('0.01');\n/*\n    收款方账户类型。可取值：\n    1、ALIPAY_USERID：支付宝账号对应的支付宝唯一用户号。以2088开头的16位纯数字组成。\n    2、ALIPAY_LOGONID：支付宝登录号，支持邮箱和手机号格式。\n*/\n$order-&gt;setPayeeType('ALIPAY_LOGONID');\n$order-&gt;setPayeeAccount('hcihsn8174@sandbox.com');\n\n$aliPay = $pay-&gt;aliPay($aliConfig);\n$data = $aliPay-&gt;transfer($order)-&gt;toArray();\n$aliPay-&gt;preQuest($data);\nvar_dump($data);\n\n本接口用的是老版本的 https://docs.open.alipay.com/309/alipay.fund.trans.toaccount.transfer\n\n订单配置参数\n所有订单配置中，客观参数均不用配置，扩展包已经为大家自动处理了，比如，product_code 等参数。\n所有订单配置参数和官方无任何差别，兼容所有功能，所有参数请参考这里，查看「请求参数」一栏。\n参数查询：https://docs.open.alipay.com/api_28/alipay.fund.trans.toaccount.transfer\n小程序支付\n$aliConfig = new \\EasySwoole\\Pay\\AliPay\\Config();\n$aliConfig-&gt;setGateWay(\\EasySwoole\\Pay\\AliPay\\GateWay::SANDBOX);\n$aliConfig-&gt;setAppId('2016091800538339');\n$aliConfig-&gt;setPublicKey('阿里公钥');\n$aliConfig-&gt;setPrivateKey('阿里私钥');\n\n$pay = new \\EasySwoole\\Pay\\Pay();\n\n$order = new \\EasySwoole\\Pay\\AliPay\\RequestBean\\MiniProgram();\n$order-&gt;setSubject('测试');\n$order-&gt;setOutTradeNo(time().'123456');\n$order-&gt;setTotalAmount('0.01');\n$order-&gt;setBuyerId('hcihsn8174@sandbox.com');\n\n$aliPay = $pay-&gt;aliPay($aliConfig);\n$data = $aliPay-&gt;miniProgram($order)-&gt;toArray();\nvar_dump($data);\n订单配置参数\n所有订单配置中，客观参数均不用配置，扩展包已经为大家自动处理了，比如，product_code 等参数。\n所有订单配置参数和官方无任何差别，兼容所有功能，所有参数请参考这里，查看「请求参数」一栏。\n小程序支付接入文档：https://docs.alipay.com/mini/introduce/pay。\n参数查询：\n订单查询\n$aliConfig = new \\EasySwoole\\Pay\\AliPay\\Config();\n$aliConfig-&gt;setGateWay(\\EasySwoole\\Pay\\AliPay\\GateWay::SANDBOX);\n$aliConfig-&gt;setAppId('2016091800538339');\n$aliConfig-&gt;setPublicKey('阿里公钥');\n$aliConfig-&gt;setPrivateKey('阿里私钥');\n$pay = new \\EasySwoole\\Pay\\Pay();\n$order = new \\EasySwoole\\Pay\\AliPay\\RequestBean\\OrderFind();\n$order-&gt;setOutTradeNo(time().'123456');\n$aliPay = $pay-&gt;aliPay($aliConfig);\n\nvar_dump($aliPay-&gt;orderFind($order)-&gt;toArray());\n官方参数查询：https://docs.open.alipay.com/api_1/alipay.trade.fastpay.refund.query\n退款查询\n$aliConfig = new \\EasySwoole\\Pay\\AliPay\\Config();\n$aliConfig-&gt;setGateWay(\\EasySwoole\\Pay\\AliPay\\GateWay::SANDBOX);\n$aliConfig-&gt;setAppId('2016091800538339');\n$aliConfig-&gt;setPublicKey('阿里公钥');\n$aliConfig-&gt;setPrivateKey('阿里私钥');\n$pay = new \\EasySwoole\\Pay\\Pay();\n$order = new \\EasySwoole\\Pay\\AliPay\\RequestBean\\RefundFind();\n$order-&gt;setOutTradeNo('20150320010101001');\n$order-&gt;setOutRequestNo(time().'2014112611001004680073956707');\n$aliPay = $pay-&gt;aliPay($aliConfig);\n$data = $aliPay-&gt;refundFind($order)-&gt;toArray();\nvar_dump($aliPay-&gt;preQuest($data));\n官方参数查询：https://docs.open.alipay.com/api_1/alipay.trade.refund\n查询转账订单接口\n$aliConfig = new \\EasySwoole\\Pay\\AliPay\\Config();\n$aliConfig-&gt;setGateWay(\\EasySwoole\\Pay\\AliPay\\GateWay::SANDBOX);\n$aliConfig-&gt;setAppId('2016091800538339');\n$aliConfig-&gt;setPublicKey('阿里公钥');\n$aliConfig-&gt;setPrivateKey('阿里私钥');\n$pay = new \\EasySwoole\\Pay\\Pay();\n$order = new \\EasySwoole\\Pay\\AliPay\\RequestBean\\TransferFind();\n$order-&gt;setOutBizNo('3142321423432');\n// 二选一\n//  $order-&gt;setOrderId('20160627110070001502260006780837');\n$aliPay = $pay-&gt;aliPay($aliConfig);\n$data = $aliPay-&gt;transferFind($order)-&gt;toArray();\nvar_dump($aliPay-&gt;preQuest($data));\n官方参数查询：https://docs.open.alipay.com/api_28/alipay.fund.trans.order.query\n交易撤销接口\n$aliConfig = new \\EasySwoole\\Pay\\AliPay\\Config();\n$aliConfig-&gt;setGateWay(\\EasySwoole\\Pay\\AliPay\\GateWay::SANDBOX);\n$aliConfig-&gt;setAppId('2016091800538339');\n$aliConfig-&gt;setPublicKey('阿里公钥');\n$aliConfig-&gt;setPrivateKey('阿里私钥');\n$pay = new \\EasySwoole\\Pay\\Pay();\n$order = new \\EasySwoole\\Pay\\AliPay\\RequestBean\\Cancel();\n$order-&gt;setOutTradeNo('20150320010101001');\n$aliPay = $pay-&gt;aliPay($aliConfig);\n$data = $aliPay-&gt;cancel($order)-&gt;toArray();\nvar_dump($aliPay-&gt;preQuest($data));\n官方参数查询：https://docs.open.alipay.com/api_1/alipay.trade.cancel\n交易关闭接口\n$aliConfig = new \\EasySwoole\\Pay\\AliPay\\Config();\n$aliConfig-&gt;setGateWay(\\EasySwoole\\Pay\\AliPay\\GateWay::SANDBOX);\n$aliConfig-&gt;setAppId('2016091800538339');\n$aliConfig-&gt;setPublicKey('阿里公钥');\n$aliConfig-&gt;setPrivateKey('阿里私钥');\n$pay = new \\EasySwoole\\Pay\\Pay();\n$order = new \\EasySwoole\\Pay\\AliPay\\RequestBean\\Close();\n$order-&gt;setOutTradeNo(time().'123456');\n$aliPay = $pay-&gt;aliPay($aliConfig);\n$data = $aliPay-&gt;close($order)-&gt;toArray();\nvar_dump($aliPay-&gt;preQuest($data));\n官方参数查询：https://docs.open.alipay.com/api_1/alipay.trade.close\n查询对账单下载地址\n$aliConfig = new \\EasySwoole\\Pay\\AliPay\\Config();\n$aliConfig-&gt;setGateWay(\\EasySwoole\\Pay\\AliPay\\GateWay::SANDBOX);\n$aliConfig-&gt;setAppId('2016091800538339');\n$aliConfig-&gt;setPublicKey('阿里公钥');\n$aliConfig-&gt;setPrivateKey('阿里私钥');\n$pay = new \\EasySwoole\\Pay\\Pay();\n$order = new \\EasySwoole\\Pay\\AliPay\\RequestBean\\Download();\n$order-&gt;setBillType('trade');\n$order-&gt;setBillDate('2016-04-05');\n$aliPay = $pay-&gt;aliPay($aliConfig);\n$data = $aliPay-&gt;download($order)-&gt;toArray();\nvar_dump($aliPay-&gt;preQuest($data));\n官方参数查询：https://docs.open.alipay.com/api_15/alipay.data.dataservice.bill.downloadurl.query\n验证服务器数据\n$aliConfig = new \\EasySwoole\\Pay\\AliPay\\Config();\n$aliConfig-&gt;setGateWay(\\EasySwoole\\Pay\\AliPay\\GateWay::SANDBOX);\n$aliConfig-&gt;setAppId('2016091800538339');\n$aliConfig-&gt;setPublicKey('阿里公钥');\n$aliConfig-&gt;setPrivateKey('阿里私钥');\n$pay = new \\EasySwoole\\Pay\\Pay();\n\n$param = [];//伪代码,post数据\nunset($param['sign_type']);//需要忽略sign_type组装\n$order = new \\EasySwoole\\Pay\\AliPay\\RequestBean\\NotifyRequest($param,true);\n$aliPay = $pay-&gt;aliPay($aliConfig);\n$result = $aliPay-&gt;verify($order);\nvar_dump($result);\n服务器确认收到异步通知字符串获取\n可通过调用如下方法得到响应支付宝的异步通知字符串：'success'/'failure'\n\\EasySwoole\\Pay\\AliPay\\AliPay::success(); // 成功响应\n\\EasySwoole\\Pay\\AliPay\\AliPay::fail(); // 失败响应","link":"/Components/Pay/ali.html"},{"id":370,"title":"加密原理","content":"这是一个很笨的加密器\n我们可以经常在某些经过加密文件的php文件代码格式大体如下：\nxxx_loader_lable\n&lt;?php\nif(!function_exists(\"xxx_loader\")){\n   die('xxx_loader not install');\n}\n//encrypt part\nxxxxxxxxxxx\n我们就以swoole_loader为例子，它加密后的文件格式大体如下\nSWOOLEC&lt;?php extension_loaded('swoole_loader') or die(' Loader ext not installed');?&gt;\n//encrypt part\nxxxxxxxxxxxxxxxxxxxxx\n这个文件。正常情况下,php是无法解析的。但是呢，zend_vm的一些接口，允许我们载入某些文件的时候，对文件进行预处理。因此我的拓展需要做的事情就是，如果遇到这样格式的文件，那么我把他解析为以下两部分：\n\n部分1\n&lt;?php\nif(!function_exists(\"xxx_loader\")){\ndie('xxx_loader not install');\n}\n\n部分2\n//encrypt part\nxxxxxxxxxxx\n\n\n因此，code就是我经过加密后的目标字符串，显然，我们需要完成的一个步骤就是、字符串到代码的转变。而这个时候，如果有敏感的同学，就会想到一个东西，那就是\neval()。因此以上代码等价于：\n&lt;?php\nif(!function_exists(\"xxx_loader\")){\n   die('xxx_loader not install');\n}\neval(encrypt part);\n但是实际上，并没有这么简单，如果我需要实现对机器授权的限制，那么应该是这样的。\n$info = xxx_loader-&gt;decode(encrypPart);\n$license = $info-&gt;licenseCheck();\nif($license){\n    eval($info-&gt;realyCode);\n}\n因此，如何保护我这个xxx_loader的实现逻辑，或者是加密秘钥，成为了代码加解密的关键。但是用php的话，容易出现，被逆向比如目前场景的php混淆，很容易破解。\n因此就有人提出想法，如果我把这个加密的函数协程php拓展编译成so动态库文件，然后so在做加壳混淆，不就完美的解决了吗。毕竟、so加壳混淆的方案，可是非常成熟的。","link":"/Components/CodeEncrypt/intro.html"},{"id":371,"title":"使用","content":"使用\n环境要求\n\n保证 PHP 版本大于等于 7.1\n\n使用 Linux / FreeBSD / MacOS 这三类操作系统\n使用 Composer 作为依赖管理工具\n\n安装拓展\n\n克隆仓库 https://github.com/easy-swoole/compiler\n\nphpize\n./configure\nmake install\nphp.ini加入extension=easy_compiler.so\n\n\n\n注意swoole4.x的library hook也用到了此技术，请在swoole.so后引入easy_compiler.so。另外，swoole加密器也可能用到了该方式，因此可能会有冲突\n\n修改默认加密密钥\n在/src/config.h文件中可以修改自己的密钥。\ncomposer助手脚本\ncomposer require easyswoole/compiler=dev-master\n对任意文件加密\n php vendor/easyswoole/compiler/bin/easy-compiler App/HttpController/Index.php \n\n会自动替换文件，并生成App/HttpController/Index.php.bak\n\n效果如下\n","link":"/Components/CodeEncrypt/usage.html"},{"id":372,"title":"代码实现","content":"实现原理\n\n在拓展层实现代码加密，生成新代码\n在拓展层解密代码\n\nhook校验\nopcode混淆\n\n\n在拓展层执行解密后代码\n\n知识储备\n首先，对于一个php文件的执行，我们需要知道其大概的步骤：\n\n基础环境初始化\n调用zend_compile_file解析文件生成opcode\n调用zend_execute执行生成的opcode\n\n相关函数\nstatic zend_op_array *(*zend_compile_string)(zval *source_string, char *filename TSRMLS_DC);\nstatic zend_op_array *(*zend_compile_string)(zval *source_string, char *filename TSRMLS_DC);\nstatic void zend_execute(zend_op_array *op_array,zval *return_value);\n替换PHP默认方法\nPHP_MINIT_FUNCTION(decrypt_code)\n{\n    zend_compile_file = decrypt_compile_file;\n    orig_compile_string = zend_compile_string;\n    zend_compile_string = decrypt_compile_string;\n    return SUCCESS;\n}\n\nPHP_MSHUTDOWN_FUNCTION(myShut)\n{\n    zend_compile_string = orig_compile_string;\n    return SUCCESS;\n}\n我们在php加载拓展的时候，替换了php默认的 zend_compile_file和orig_compile_string。当然，在Easyswoole中实现的执行代码的方式，\n不会被这两个函数hook，这个两个可以用来破解纯php层的混淆加密。相关安全问题在注意事项章节讲解。\n定义加密方法\nPHP_FUNCTION(easy_compiler_encrypt) {\n    unsigned char *raw_string;\n    size_t *raw_string_len;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &amp;raw_string, &amp;raw_string_len) == FAILURE) {\n        RETURN_NULL();\n    }\n    unsigned char *pkcs7 = (unsigned char *)malloc(sizeof(unsigned char*)*PKCS7_MAX_LEN);\n    memcpy(pkcs7,raw_string,raw_string_len);\n    size_t after_padding_len = PKCS7Padding(pkcs7,raw_string_len);\n\n    struct AES_ctx ctx;\n    AES_init_ctx_iv(&amp;ctx, AES_KEY, AES_IV_KEY);\n    AES_CBC_encrypt_buffer(&amp;ctx,pkcs7,after_padding_len);\n    zend_string *zend_encode_string = zend_string_init(pkcs7,after_padding_len,0);\n    zend_string *base64;\n    base64 = php_base64_encode((const unsigned char*)ZSTR_VAL(zend_encode_string),ZSTR_LEN(zend_encode_string));\n    char *res = ZSTR_VAL(base64);\n    zend_string_release(base64);\n    zend_string_release(zend_encode_string);\n    free(pkcs7);\n    RETURN_STRING(res);\n};\n定义解密方法\nPHP_FUNCTION(easy_compiler_decrypt) {\n    unsigned char *base64;\n    size_t *base64_len;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &amp;base64, &amp;base64_len) == FAILURE) {\n        RETURN_NULL();\n    }\n    zend_string *encrypt_z_str;\n    encrypt_z_str = php_base64_decode(base64,base64_len);\n    size_t encrypt_len = NULL;\n    encrypt_len = ZSTR_LEN(encrypt_z_str);\n    unsigned char *pkcs7 = (unsigned char *)malloc(sizeof(unsigned char*)*PKCS7_MAX_LEN);\n    memcpy(pkcs7,(const char*)ZSTR_VAL(encrypt_z_str),encrypt_len);\n    struct AES_ctx ctx;\n    AES_init_ctx_iv(&amp;ctx, AES_KEY, AES_IV_KEY);\n    AES_CBC_decrypt_buffer(&amp;ctx,pkcs7,encrypt_len);\n    encrypt_len = PKCS7Cutting(pkcs7,encrypt_len);\n    zend_string *eval_string = zend_string_init(pkcs7,encrypt_len,0);\n    zval z_str;\n    ZVAL_STR(&amp;z_str,eval_string);\n    zend_op_array *new_op_array;\n    char *filename = zend_get_executed_filename(TSRMLS_C);\n    new_op_array =  easy_compiler_compile_string(&amp;z_str, filename TSRMLS_C);\n    if(new_op_array){\n        zend_try {\n            zend_execute(new_op_array,return_value);\n        } zend_catch {\n\n        } zend_end_try();\n        destroy_op_array(new_op_array);\n        efree(new_op_array);\n    }\n    zend_string_release(encrypt_z_str);\n    zend_string_release(eval_string);\n    zval_ptr_dtor(&amp;z_str);\n    free(pkcs7);\n};\n\n就是在这一步解析加密后的代码，并执行对应的opcode\n\n更多细节源码\nEasySwoole Compiler","link":"/Components/CodeEncrypt/achieve.html"},{"id":373,"title":"注意事项","content":"注意！！！！！\n首先世界上没有绝对的安全，只有破解代价与利益是否等价\n别说啥PHP不安全，其他语言安全。例子：\n\nwindows牛逼不，被破解了\nphotoshop牛逼不，被破解了\n等等等\n\n默认加密方式\n目前默认加密方式是AES_CBC,用的TINY-AES-C实现。编译的时候，可以修改自己的密钥。在源码中的：\n/src/config.h\n未处理项目\n文件校验\n目前加密的文件数据，仅有代码数据。为了安全用户可以加上自己的校验数据。例如以下结构体\nstruct {\n    char *ip\n    char *mac\n    char *phpCode\n    int expire\n}\n从而实现，机器的ip、mac地址、还有过期时间限制\n未完善\nmixed_opcode\nstatic void mixed_opcode(zend_op_array* opline) {\n  if (NULL != opline) {\n    for (size_t i = 0; i &lt; opline-&gt;last; i++) {\n      zend_op* orig_opline = &amp;(opline-&gt;opcodes[i]);\n      if (orig_opline-&gt;opcode == ZEND_IS_EQUAL) {\n        orig_opline-&gt;opcode = ZEND_IS_IDENTICAL;\n        zend_vm_set_opcode_handler(orig_opline);\n      } else if (orig_opline-&gt;opcode == ZEND_IS_NOT_EQUAL) {\n        orig_opline-&gt;opcode = ZEND_IS_NOT_IDENTICAL;\n        zend_vm_set_opcode_handler(orig_opline);\n      }\n    }\n  }\n}\n目前，对zend_op_array的混淆，仅仅做了简单处理。这一步是为了防止有人从op code逆向出代码(编译原理AST语法树相关知识)。\nzend_execute等hook\n讲道理，用户可以修改编译自己的php,从而从关键位置拿到数据，也就是拿内存数据。为此，\n一些关键函数，例如zend_execute等，一定要加入例如Easyswoole Compiler实例代码中compile_string函数的hook校验\nso文件加壳\nso文件加壳是避免你加密方法，还有加密文件泄漏的重要方式！！！！至于加壳方法，百度一大堆，本文不再讲述\n弊端\nPHP的加密之所以困难，原因在于、PHP是开源的，无论你再怎么编译加密，最终都需要去执行opcode。问题在于，我php是开源的，因此、、、我可以在zen_execute等对应的方法修改源码，打印出来opcode数据进行逆向。为此。。如果需要避免这种方式，那就是我调用自己声明的库。\n因此我们可以看到，类似swoole_loader，需要分php版本下载，很大一部分原因，就如我们实现的原理一样，我把php对应版本zend目录下的核心文件，提前引入，防止hook\n结束语\n讲真，写这个文章来讲解原理，也不是为了拆台，zend的加密器都能被破解，你写的再牛逼，无非就是利益够不够的问题。这是为了帮助大家，更了解深入PHP源码的加密。不论什么语言，真想破解，一定是有办法的。因此，最好的方式那就是核心API放自己的服务器，以SASS方式提供服务。\n当然，加密也并不是意义全无、至少、、、心里都会权衡一下，看你是要自己开发划算、还是破解我的划算。","link":"/Components/CodeEncrypt/caution.html"},{"id":374,"title":"安装","content":"EasySwoole 易联云打印 (Printer) 组件\nEasySwoole 提供了全协程支持的云打印机 SDK，易于使用的操作接口和风格，轻松推送海量任务至云打印机。\n\n目前仅支持易联云，欢迎 fork 本项目贡献您的力量\n\n组件要求\n\nphp: &gt;= 7.1\next-swoole: &gt;= 4.4.23\neasyswoole/spl: ^1.4\neasyswoole/http-client: ^1.5\npsr/simple-cache: 1.0\neasyswoole/utility: ^1.2\next-json: *\n\n安装方法\n\ncomposer require easyswoole/easy-printer\n\n仓库地址\neasyswoole/easy-printer\n基本使用\n&lt;?php\n\nuse EasySwoole\\EasyPrinter\\Commands\\YiLinkCloud\\PrintText;\nuse EasySwoole\\EasyPrinter\\EasyPrinter;\nuse EasySwoole\\Utility\\FileSystem;\nuse EasySwoole\\Utility\\File;\n\nrequire_once __DIR__ . '/vendor/autoload.php';\n\nclass CacheConfig\n{\n    protected $driver;\n    protected $dir;\n    protected $prefix;\n\n    public function setDriver(string $driver)\n    {\n        $this-&gt;driver = $driver;\n    }\n\n    public function getDriver()\n    {\n        return $this-&gt;driver;\n    }\n\n    public function setDir(string $dir)\n    {\n        $this-&gt;dir = $dir;\n    }\n\n    public function getDir()\n    {\n        return $this-&gt;dir;\n    }\n\n    public function setPrefix(string $prefix)\n    {\n        $this-&gt;prefix = $prefix;\n    }\n\n    public function getPrefix()\n    {\n        return $this-&gt;prefix;\n    }\n}\n\n/**\n * 文件缓存\n * Class FileDriver\n */\nclass FileDriver implements \\Psr\\SimpleCache\\CacheInterface\n{\n    /** @var string $dir */\n    protected $dir;\n    /** @var FileSystem $fileSystem */\n    protected $fileSystem;\n    /** @var string $prefix */\n    protected $prefix;\n\n    public function __construct($dir, $prefix)\n    {\n        if (empty($dir)) {\n            $this-&gt;dir = sys_get_temp_dir();\n        }\n        if (empty($prefix)) {\n            $this-&gt;prefix = 'easyswoole_cache:';\n        }\n        $this-&gt;fileSystem = new FileSystem();\n        File::createDirectory($this-&gt;dir);\n    }\n\n    /**\n     * @return string\n     */\n    protected function getPrefix(): string\n    {\n        return $this-&gt;dir . DIRECTORY_SEPARATOR . $this-&gt;prefix;\n    }\n\n    /**\n     * 获取缓存的 key\n     * @param string $key\n     * @return string\n     */\n    public function getCacheKey(string $key)\n    {\n        return $this-&gt;getPrefix() . $key . '.cache';\n    }\n\n    /**\n     * 设置缓存\n     * @param string $key\n     * @param mixed $value\n     * @param null $ttl\n     * @return bool\n     */\n    public function set($key, $value, $ttl = null)\n    {\n        $file = $this-&gt;getCacheKey($key);\n        $data = serialize($value);\n        $this-&gt;fileSystem-&gt;put($file, $data);\n        if ($ttl &lt; time()) {\n            $ttl = $this-&gt;getTtlTime($ttl);\n        }\n        return touch($file, $ttl);\n    }\n\n    /**\n     * 获取缓存\n     * @param string $key\n     * @param null $default\n     * @return mixed|null\n     * @throws Exception\n     */\n    public function get($key, $default = null)\n    {\n        $file = $this-&gt;getCacheKey($key);\n        if ($this-&gt;fileSystem-&gt;missing($file)) {\n            return $default;\n        }\n        if ($this-&gt;fileSystem-&gt;lastModified($file) &lt; time()) {\n            return $default;\n        }\n        return unserialize($this-&gt;fileSystem-&gt;get($file));\n    }\n\n    /**\n     * 获取缓存过期时间\n     * @param null $ttl\n     * @return float|int|null\n     */\n    public function getTtlTime($ttl = null)\n    {\n        // 如果不设置时间 默认 100 年\n        if (is_null($ttl)) {\n            $ttl = 3600 * 24 * 30 * 12 * 100;\n        }\n        $ttl = $ttl + time();\n        return $ttl;\n    }\n\n    /**\n     * 删除缓存\n     * @param string $key\n     * @return bool\n     */\n    public function delete($key)\n    {\n        $file = $this-&gt;getCacheKey($key);\n        return $this-&gt;fileSystem-&gt;delete($file);\n    }\n\n    /**\n     * 清空缓存\n     * @return bool|void\n     */\n    public function clear()\n    {\n        $files = glob($this-&gt;getPrefix() . '*');\n        foreach ($files as $file) {\n            if (is_dir($file)) {\n                continue;\n            }\n            unlink($file);\n        }\n    }\n\n    /**\n     * 批量读取缓存\n     * @param iterable $keys\n     * @param null $default\n     * @return array|iterable\n     * @throws Exception\n     */\n    public function getMultiple($keys, $default = null)\n    {\n        if (!is_array($keys)) {\n            $keys = [$keys];\n        }\n        $result = [];\n        foreach ($keys as $i =&gt; $key) {\n            $result[$key] = $this-&gt;get($key, $default);\n        }\n        return $result;\n    }\n\n    /**\n     * 批量设置缓存\n     * @param iterable $values\n     * @param null $ttl\n     * @return bool&gt;\n     */\n    public function setMultiple($values, $ttl = null)\n    {\n        if (!is_array($values)) {\n            $values = [$values];\n        }\n\n        $ttl = $this-&gt;getTtlTime($ttl);\n        foreach ($values as $key =&gt; $value) {\n            $this-&gt;set($key, $value, $ttl);\n        }\n        return true;\n    }\n\n    /**\n     * 批量删除缓存\n     * @param iterable $keys\n     * @return bool\n     */\n    public function deleteMultiple($keys)\n    {\n        if (!is_array($keys)) {\n            $keys = [$keys];\n        }\n\n        foreach ($keys as $index =&gt; $key) {\n            $this-&gt;delete($key);\n        }\n\n        return true;\n    }\n\n    /**\n     * 缓存是否存在\n     * @param string $key\n     * @return bool\n     */\n    public function has($key)\n    {\n        $file = $this-&gt;getCacheKey($key);\n        return file_exists($file);\n    }\n}\n\nclass Cache implements \\Psr\\SimpleCache\\CacheInterface\n{\n    protected $driver;\n\n    public function __construct(CacheConfig $cacheConfig)\n    {\n        $driver = $cacheConfig-&gt;getDriver() ?: FileDriver::class;\n        $this-&gt;driver = new $driver($cacheConfig-&gt;getDir(), $cacheConfig-&gt;getPrefix());\n    }\n\n    public function __call($name, $arguments)\n    {\n        return $this-&gt;driver-&gt;{$name}(...$arguments);\n    }\n\n    public function set($key, $value, $ttl = null)\n    {\n        return $this-&gt;__call(__FUNCTION__, func_get_args());\n    }\n\n    public function setMultiple($values, $ttl = null)\n    {\n        return $this-&gt;__call(__FUNCTION__, func_get_args());\n    }\n\n    public function delete($key)\n    {\n        return $this-&gt;__call(__FUNCTION__, func_get_args());\n    }\n\n    public function has($key)\n    {\n        return $this-&gt;__call(__FUNCTION__, func_get_args());\n    }\n\n    public function get($key, $default = null)\n    {\n        return $this-&gt;__call(__FUNCTION__, func_get_args());\n    }\n\n    public function deleteMultiple($keys)\n    {\n        return $this-&gt;__call(__FUNCTION__, func_get_args());\n    }\n\n    public function clear()\n    {\n        return $this-&gt;__call(__FUNCTION__, func_get_args());\n    }\n\n    public function getMultiple($keys, $default = null)\n    {\n        return $this-&gt;__call(__FUNCTION__, func_get_args());\n    }\n}\n\ngo(function () {\n    $cacheConfig = new CacheConfig();\n    $cache = new Cache($cacheConfig); // Cache 需要实现 \\Psr\\SimpleCache\\CacheInterface 接口，示例仅实现了文件缓存\n\n    $clientId = '您的易联云应用ID';\n    $clientSecret = '您的易联云应用秘钥';\n    $driver = EasyPrinter::yiLinkCloud($clientId, $clientSecret, $cache);\n\n    // 新建一条命令\n    $PrintCommand = new PrintText();\n    $PrintCommand-&gt;setMachineCode('打印机编号');\n    $PrintCommand-&gt;setContent('欢迎使用EasyPrinter!');\n    $PrintCommand-&gt;setOriginId(md5(microtime()));\n\n    try {\n        $response = $driver-&gt;sendCommand($PrintCommand);\n        var_dump($response);\n    } catch (Throwable $throwable) {\n\n    }\n});\n\n上述 Cache 参考 Cache 实现仅仅实现了文件缓存，开发者若想使用其他缓存实现，可以自行实现 PSR-16 CacheInterface 接口 进行调用。\n\n目前已支持的指令\n\n\n\n服务商\n说明\nCommand\n\n\n\n\n易联云\n终端授权 (永久授权)\nAuthorizePrinter\n\n\n易联云\n获取请求令牌\nGetAccessToken\n\n\n易联云\n获取机型打印宽度\nGetPrinterInfo\n\n\n易联云\n获取终端状态\nGetPrinterStatus\n\n\n易联云\n添加应用菜单\nPrinterAddMenu\n\n\n易联云\n取消所有未打印订单\nPrinterCancelAll\n\n\n易联云\n取消单条未打印订单\nPrinterCancelOne\n\n\n易联云\n取消LOGO\nPrinterDeleteIcon\n\n\n易联云\n删除终端授权\nPrinterDeletePrinter\n\n\n易联云\n删除内置语音\nPrinterDeleteVoice\n\n\n易联云\n获取订单列表\nPrinterGetOrderPagingList\n\n\n易联云\n获取订单状态\nPrinterGetOrderStatus\n\n\n易联云\n获取机型软硬件版本\nPrinterGetVersion\n\n\n易联云\n设置打印方式\nPrinterSetBtnPrinter\n\n\n易联云\n设置LOGO\nPrinterSetIcon\n\n\n易联云\n接单拒单设置\nPrinterSetIfGetOrder\n\n\n易联云\n设置推送URL\nPrinterSetPushUrl\n\n\n易联云\n声音调节\nPrinterSetSound\n\n\n易联云\n设置内置语音\nPrinterSetVoice\n\n\n易联云\n关机重启\nPrinterShutdownRestart\n\n\n易联云\n打印图片\nPrintPicture\n\n\n易联云\n打印文字\nPrintText\n\n\n","link":"/Components/printer.html"},{"id":375,"title":"使用","content":"db-migrate\n参照Laravel开发的easyswoole数据库版本迁移工具。\n组件要求\n\nphp: &gt;=7.1.0\neasyswoole/command: ^1.1\neasyswoole/component: ^2.0\neasyswoole/ddl: ^1.0\neasyswoole/mysqli: ^2.2\neasyswoole/spl: ^1.0\neasyswoole/utility: ^1.0\n\n安装方法\n\ncomposer require easyswoole/db-migrate\n\n仓库地址\neasyswoole/db-migrate\n基本使用\n在全局 boostrap 事件中注册 MigrateCommand 并添加配置信息\n\nbootstrap.php\n\n\\EasySwoole\\Command\\CommandManager::getInstance()-&gt;addCommand(new \\EasySwoole\\DatabaseMigrate\\MigrateCommand());\n$config = new \\EasySwoole\\DatabaseMigrate\\Config\\Config();\n// 数据地址\n$config-&gt;setHost(\"127.0.0.1\");\n// 数据库端口\n$config-&gt;setPort(3306);\n// 数据库用户名\n$config-&gt;setUser(\"root\");\n// 数据库密码\n$config-&gt;setPassword(\"123456\");\n// 数据库库名\n$config-&gt;setDatabase(\"easyswoole\");\n// 数据库超时时长\n$config-&gt;setTimeout(5.0);\n// 数据库字符集\n$config-&gt;setCharset(\"utf8mb4\");\n//===========可选配置修改项，以下参数均有默认值===========\n// 迁移记录的数据库表名\n$config-&gt;setMigrateTable(\"migrations\");\n// 迁移文件目录的绝对路径\n$config-&gt;setMigratePath(EASYSWOOLE_ROOT . '/Database/Migrates/');\n// 迁移模板文件的绝对路径\n$config-&gt;setMigrateTemplate(EASYSWOOLE_ROOT . '/vendor/easyswoole/db-migrate/src/Resource/migrate._php');\n// 迁移模板类的类名\n$config-&gt;setMigrateTemplateClassName(\"MigratorClassName\");\n// 迁移模板类的表名\n$config-&gt;setMigrateTemplateTableName(\"MigratorTableName\");\n// 迁移模板创建表的模板文件的绝对路径\n$config-&gt;setMigrateCreateTemplate(EASYSWOOLE_ROOT . '/vendor/easyswoole/db-migrate/src/Resource/migrate_create._php');\n// 迁移模板修改表的模板文件的绝对路径\n$config-&gt;setMigrateAlterTemplate(EASYSWOOLE_ROOT . '/vendor/easyswoole/db-migrate/src/Resource/migrate_alter._php');\n// 迁移模板删除表的模板文件的绝对路径\n$config-&gt;setMigrateDropTemplate(EASYSWOOLE_ROOT . '/vendor/easyswoole/db-migrate/src/Resource/migrate_drop._php');\n// 数据填充目录绝对路径\n$config-&gt;setSeederPath(EASYSWOOLE_ROOT . '/Database/Seeds/');\n// 数据填充模板类的类名\n$config-&gt;setSeederTemplateClassName(\"SeederClassName\");\n// 数据填充模板文件的绝对路径\n$config-&gt;setSeederTemplate(EASYSWOOLE_ROOT . '/vendor/easyswoole/db-migrate/src/Resource/seeder._php');\n// 逆向生成迁移文件的模板文件绝对路径\n$config-&gt;setMigrateGenerateTemplate(EASYSWOOLE_ROOT . '/vendor/easyswoole/db-migrate/src/Resource/migrate_generate._php');\n// 逆向生成迁移模板SQL语句的DDL代码块\n$config-&gt;setMigrateTemplateDdlSyntax(\"DDLSyntax\");\n\\EasySwoole\\DatabaseMigrate\\MigrateManager::getInstance($config);\n如果不自定义setMigratePath、setSeederPath配置项，所有迁移命令必须在项目根目录(固定目录)下执行   \n执行 php easyswoole migrate -h\nphp easyswoole migrate -h\nDatabase migrate tool\n\nUsage:\n  easyswoole migrate ACTION [--opts ...]\n\nActions:\n  create    Create the migration repository\n  generate  Generate migration repository for existing tables\n  run       Run all migrations\n  rollback  Rollback the last database migration\n  reset     Rollback all database migrations\n  seed      Data filling tool\n  status    Show the status of each migration\n\nOptions:\n  -h, --help  Get help\ncreate\n\n创建一个迁移模板\n当需要新建表、修改表、删除表时，create命令可以创建一个简单的迁移模板文件\n\n可用操作选项：\n\n\n--alter：生成一个用于修改表的迁移模板\n\n示例：php easyswoole migrate create --alter=TableName\n\n\n\n\n--create：生成一个用于新建表的迁移模板\n\n示例：php easyswoole migrate create --create=TableName\n\n\n\n\n--drop：生成一个用于删除表的迁移模板\n\n示例：php easyswoole migrate create --drop=TableName\n\n\n\n\n--table：生成一个基础的迁移模板\n\n示例：php easyswoole migrate create --table=TableName  等同于 php easyswoole migrate create TableName\n\n\n\n\n操作会在迁移文件目录生成一个类似文件名为2021_04_08_082914_user.php的文件，代码类似如下，对应操作使用的是 easyswoole/ddl 组件方法\n&lt;?php\n\nuse EasySwoole\\DDL\\Blueprint\\Create\\Table as CreateTable;\nuse EasySwoole\\DDL\\Blueprint\\Alter\\Table as AlterTable;\nuse EasySwoole\\DDL\\Blueprint\\Drop\\Table as DropTable;\nuse EasySwoole\\DDL\\DDLBuilder;\nuse EasySwoole\\DDL\\Enum\\Character;\nuse EasySwoole\\DDL\\Enum\\Engine;\n\n/**\n * migrate create\n * Class User\n */\nclass User\n{\n    /**\n     * migrate run\n     * @return string\n     */\n    public function up()\n    {\n        return DDLBuilder::create('User',function (CreateTable $table){\n            $table-&gt;setIfNotExists(true);\n        });\n    }\n\n    /**\n     * migrate rollback\n     * @return string\n     */\n    public function down()\n    {\n        return DDLBuilder::dropIfExists('User');\n    }\n}\ngenerate\n\n对已存在的表生成适配当前迁移工具的迁移模板\n对于已经启动的项目没有做版本迁移，generate命令可以对已存在的表逆向生成迁移文件\n\n对已存在的表生成适配当前迁移工具的迁移模板\n可用操作选项：\n\n\n--tables：指定要生成迁移模板的表，多个表用 ',' 隔开\n\n示例：php easyswoole migrate generate --tables=table1,table2\n\n\n\n\n--ignore：指定要忽略生成迁移模板的表，多个表用 ',' 隔开\n\n示例：php easyswoole migrate generate --ignore=table1,table2\n\n\n\n\nrun\n\n对所有未迁移的文件执行迁移操作\n\nrollback\n\n回滚迁移记录，默认回滚上一次的迁移，指定操作相关参数可以从status命令中查看\n\n可用操作选项：\n\n\n--batch：指定要回滚的批次号\n\n示例：php easyswoole migrate rollback --batch=2\n\n\n\n\n--id：指定要回滚的迁移ID\n\n示例：php easyswoole migrate rollback --id=2\n\n\n\n\nreset\n\n根据迁移表的记录，一次性回滚所有迁移\n\nseed\n\n数据填充工具\n不加操作项即为执行填充数据操作，添加操作项即为创建填充模板\n生成模板文件之后，方法内的操作使用 easyswoole/mysqli 做数据填充，\n\n可用操作选项：\n\n\n--create：创建一个数据填充模板\n\n示例：php easyswoole migrate seed --create=UserTable\n\n\n\n直接填写文件名或者类名，即为执行指定填充文件(多个文件用 ',' 隔开)\n\n示例：php easyswoole migrate seed UserTable,UserInfoTable.php\n\n\n\n直接执行seed命令为执行数据填充目录下所有填充操作\n\n示例：php easyswoole migrate seed\n\n\n\n\nstatus\n\n迁移状态\n展示成功迁移的数据，即为迁移表内的数据\n","link":"/Components/databaseMigrate.html"},{"id":376,"title":"如何学习swoole","content":"学习Swoole之如何避免成为被坑哭的程序员\n很多刚从传统fpm模式转到swoole内存常驻模式的phper，总会觉得内心委屈，甚至想哭，原因swoole总会让你怀疑人生，这真的是我之前所认知的那个php语言吗？怎么那么坑啊。\nswoole下常见的&quot;坑&quot;\n\n\n为何全局变量无法共享呢\n例如，在以下代码中\n$http = new swoole_http_server(\"127.0.0.1\", 9501);\n$http-&gt;on(\"request\", function ($request, $response) {\n    static $i;\n    $response-&gt;end($i);\n    $i++;\n});\n\n$http-&gt;start();\n就会有人发现在swoole下static $i 和在fpm下所理解的输出不一致。这是在于出现了进程克隆，而每个进程之间的数据都是不一致的。\n\n\necho var_dump 无法输出到浏览器(http响应)\n我们在fpm模式下，echo $a 是可以把结果输出到浏览器中的，为何在swoole中就不行呢，原因在于模式的变更，swoole的运行模式不再是fpm，而是cli，如果你需要把数据响应给浏览器，你只能\n通过Http request回调中的response对象进行响应\n\n\nhttp请求参数获取\n在同swoole的http服务的时候，很多人会发现$_GET、$_POST等常见全局变量无法使用。这是因为$_GET、$_POST等变量都是全局的，在swoole当中会出现问题，如果想获取请求参数，可以用swoole回调时提供的Request对象来进行获取\n\n\nswoole不能使用die/exit\nphper都习惯用die/exit来调试代码，这是因为这个命令会直接退出当前进程，对于fpm来讲，每个请求都对应一个独立进程，退出了问题不大，但是在swoole当中，可能一个进程中会有多个请求同时在处理，如果你exit或者die来退出当前进程，会导致数据丢失。\n\n\nswoole下为何需要断线重连      \n很多程序员都习惯性的把数据库连接做单例化处理，这样很明显带来的好处就是节约了每次请求数据库需要连接多次的开销。那么为何在swoole下总是报错提示我数据库断线了呢？\n原因在于，传统fpm下，请求结束了，那么就会执行进程清理，数据库连接也被清理了，下次进来的时候，才会执行重新连接。这样就保证了连接都是可用的状态。但是在swoole常驻内存的情况下，\n请求结束后，该连接并不会被清理，依旧保留在内存空间内，而该连接若是长时间没有使用，或者是因为网络波动，那么就会断开。下次请求进来的时候，你没有判断连接状态，就直接去执行sql语句，那么就意味着你操作了一个断线的数据库连接，因此肯定会报错。\n\n\n内存泄露\n很多人用swoole写服务的时候，总是跑着跑着就莫名其妙的内存不足。这是因为swoole是一个常驻进程型的模型，在fpm下，请求结束之后会将进程内的变量进行清理，而swoole进程全局期的变量并不会因为请求的结束而被清理，会一直保存在内存中，一方面提高了效率，但是也让开发者必须注意到变量回收的必要性。\n\n\n协程上下文访问安全\n使用swoole协程的时候，会有人遇到变量的值不符合预期的情况，这里面可能是变量污染在作祟，在传统php 同步阻塞的编程模式下，所有的执行都是强制顺序执行的。但是在swoole中，多个协程之间是交替执行的，可能a协程让出执行权的时候b协程对某个跨协程变量进行了修改，那么当a协程恢复执行权的时候这个跨协程变量将不是让出时的值了(如果你对mysql有一定了解，就会发现这个情况并不难理解)。\n同时为了解决这个问题，我们通常在编程是要注意跨协程变量的使用，以及使用协程单例的方式来控制变量。\n使用swoole要学习的知识点\n\n\n以下内容中，必须 代表一定要先学习的部分，如果不懂会导致学习困难和跑偏，写的代码无法应用在生产环境； 应该 代表建议学习的知识点，但是也可以只是了解； 可以 代表推荐去学习，通常是开发者的弱点。\n\n\n基础编程知识\n\n\n应该了解阻塞和非阻塞的区别\n\n必须清楚PHP的GC机制 这个必须清楚，大多数php开发者都不清楚\n\n必须清楚php面向对象编程 这里一定要搞清楚对象引用机制和对象与内存之间的关系\n\n必须清楚资源及连接句柄的相关知识\n\n\n\n多进程编程\n\n\n必须清楚fpm和swoole的多进程模型及其区别\n\n必须了解 进程间通讯和进程隔离，应该了解进程信号量\n\n\n\n\n基础的TCP/UDP认知\n\n\n应该清楚TCP和UDP的区别\n\n\n应该清楚客户端和服务端的区别\n\n必须了解OSI七层模型中的上四层 了解常见应用层协议如http ftp smtp等\n\n\n\n协程\n\n\n必须清楚swoole协程工作模式\n\n必须清楚如何判断变量是否会跨协程使用\n\n\n\n总结\n总而言之，大多数php开发者学习swoole时候都会觉得坑的原因是来自于自身知识储备的不足。对于很多其他语言开发者必须掌握的知识，php开发时可能就无需掌握，但是这也是欠的技术债，会在进一步提升的时候遇到的瓶颈；导致在使用swoole的时候出了各种各样的问题。实际上，swoole是一个很强大的php拓展，他重新定义了php，让php有了更强的生命力。","link":"/Other/learnSwoole.html"},{"id":377,"title":"队列消费/自定义进程问题","content":"如何实现队列消费/自定义进程\n可能我们会经常遇见需要不断消费队列内内容的场景，我们以EasySwoole中自定义进程的方式，来实现这一功能。\n实现代码\n定义消费进程逻辑\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: Tioncico\n * Date: 2018/10/18 0018\n * Time: 9:43\n */\n\nnamespace App\\Process;\n\nuse EasySwoole\\Component\\Process\\AbstractProcess;\nuse Swoole\\Process;\n\nclass Consumer extends AbstractProcess\n{\n    private $isRun = false;\n    public function run($arg)\n    {\n        // TODO: Implement run() method.\n        /*\n         * 举例，消费redis中的队列数据\n         * 定时500ms检测有没有任务，有的话就while死循环执行\n         */\n        $this-&gt;addTick(500,function (){\n            if(!$this-&gt;isRun){\n                $this-&gt;isRun = true;\n                $redis = new \\redis();//此处为伪代码，请自己建立连接或者维护redis连接\n                while (true){\n                    try{\n                        $task = $redis-&gt;lPop('task_list');\n                        if($task){\n                            // do you task\n                        }else{\n                            break;\n                        }\n                    }catch (\\Throwable $throwable){\n                        break;\n                    }\n                }\n                $this-&gt;isRun = false;\n            }\n            var_dump($this-&gt;getProcessName().' task run check');\n        });\n    }\n\n    public function onShutDown()\n    {\n        // TODO: Implement onShutDown() method.\n    }\n\n    public function onReceive(string $str, ...$args)\n    {\n        // TODO: Implement onReceive() method.\n    }\n}\n注册消费进程\n在EasySwoole的全局事件中，注册消费进程。\n&lt;?php\nuse App\\Process\\TestProcess;\nuse EasySwoole\\Component\\Process\\Manager;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\n\npublic static function mainServerCreate(EventRegister $register)\n{\n\n    $allNum = 3;\n    for ($i = 0 ;$i &lt; $allNum;$i++){\n        $processConfig= new \\EasySwoole\\Component\\Process\\Config();\n        $processConfig-&gt;setProcessName('testProcess'.$i);//设置进程名称\n        Manager::getInstance()-&gt;addProcess(new TestProcess($processConfig));\n    }\n}\n爬虫例子：https://github.com/HeKunTong/easyswoole3_demo","link":"//Other/process.html"},{"id":378,"title":"redis/kafka订阅","content":"自定义进程实现redis订阅\n实现代码\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: Tioncico\n * Date: 2018/10/18 0018\n * Time: 10:28\n */\n\nnamespace App\\Process;\n\nuse EasySwoole\\Component\\Process\\AbstractProcess;\nuse Swoole\\Process;\n\nclass Subscribe extends AbstractProcess\n{\n    public function run($arg)\n    {\n        // TODO: Implement run() method.\n        $redis = new \\Redis();//此处为伪代码，请自己建立连接或者维护\n        $redis-&gt;connect('127.0.0.1');\n        $redis-&gt;subscribe(['ch1'],function (){\n            var_dump(func_get_args());\n        });\n    }\n\n    public function onShutDown()\n    {\n        // TODO: Implement onShutDown() method.\n    }\n\n    public function onReceive(string $str, ...$args)\n    {\n        // TODO: Implement onReceive() method.\n    }\n\n}\n接下来，需要做的事情，就是到EasySwooleEvent.php的主服务创建事件中，注册该进程即可。\nuse App\\Process;\nuse EasySwoole\\Core\\Swoole\\Process\\ProcessManager;\n\n\\EasySwoole\\Component\\Process\\Manager::getInstance()-&gt;addProcess(new Subscribe('sub'));","link":"/Other/redisSubscribe.html"},{"id":379,"title":"内核优化","content":"内核参数调整\nulimit设置\nulimit -n 要调整为100000甚至更大。 命令行下执行 ulimit -n 100000即可修改。如果不能修改，需要设置  /etc/security/limits.conf，加入\n* soft nofile 262140\n* hard nofile 262140\nroot soft nofile 262140\nroot hard nofile 262140\n* soft core unlimited\n* hard core unlimited\nroot soft core unlimited\nroot hard core unlimited\n注意，修改limits.conf文件后，需要重启系统生效\n内核设置\nLinux操作系统修改内核参数有3种方式：\n\n修改/etc/sysctl.conf文件，加入配置选项，格式为key = value，修改保存后调用sysctl -p加载新配置\n使用sysctl命令临时修改，如：sysctl -w net.ipv4.tcp_mem=\"379008       505344  758016\"\n\n直接修改/proc/sys/目录中的文件，如：echo \"379008       505344  758016\" &gt; /proc/sys/net/ipv4/tcp_mem\n\n\n第一种方式在操作系统重启后会自动生效，第二和第三种方法重启后失效\nnet.unix.max_dgram_qlen = 100\nswoole使用unix socket dgram来做进程间通信，如果请求量很大，需要调整此参数。系统默认为10，可以设置为100或者更大。\n或者增加worker进程的数量，减少单个worker进程分配的请求量。\nnet.core.wmem_max\n修改此参数增加socket缓存区的内存大小  \nnet.ipv4.tcp_mem  =   379008       505344  758016\nnet.ipv4.tcp_wmem = 4096        16384   4194304\nnet.ipv4.tcp_rmem = 4096          87380   4194304\nnet.core.wmem_default = 8388608\nnet.core.rmem_default = 8388608\nnet.core.rmem_max = 16777216\nnet.core.wmem_max = 16777216\nnet.ipv4.tcp_tw_reuse\n是否socket reuse，此函数的作用是Server重启时可以快速重新使用监听的端口。如果没有设置此参数，会导致server重启时发生端口未及时释放而启动失败\nnet.ipv4.tcp_tw_recycle\n使用socket快速回收，短连接Server需要开启此参数。此参数表示开启TCP连接中TIME-WAIT sockets的快速回收，Linux系统中默认为0，表示关闭。打开此参数可能会造成NAT用户连接不稳定，请谨慎测试后再开启。\n消息队列设置\n当使用消息队列作为进程间通信方式时，需要调整此内核参数\n\nkernel.msgmnb = 4203520，消息队列的最大字节数\nkernel.msgmni = 64，最多允许创建多少个消息队列\nkernel.msgmax = 8192，消息队列单条数据最大的长度\n\nFreeBSD/MacOS\n\nsysctl -w net.local.dgram.maxdgram=8192\nsysctl -w net.local.dgram.recvspace=200000\n修改Unix Socket的buffer区尺寸\n\n开启CoreDump\n设置内核参数\nkernel.core_pattern = /data/core_files/core-%e-%p-%t\n通过ulimit -c命令查看当前coredump文件的限制\nulimit -c\n如果为0，需要修改/etc/security/limits.conf，进行limit设置。\n开启core-dump后，一旦程序发生异常，会将进程导出到文件。对于调查程序问题有很大的帮助\n其他重要配置\n\nnet.ipv4.tcp_syncookies=1\nnet.ipv4.tcp_max_syn_backlog=81920\nnet.ipv4.tcp_synack_retries=3\nnet.ipv4.tcp_syn_retries=3\nnet.ipv4.tcp_fin_timeout = 30\nnet.ipv4.tcp_keepalive_time = 300\nnet.ipv4.tcp_tw_reuse = 1\nnet.ipv4.tcp_tw_recycle = 1\nnet.ipv4.ip_local_port_range = 20000    65000\nnet.ipv4.tcp_max_tw_buckets = 200000\nnet.ipv4.route.max_size = 5242880\n\n查看配置是否生效\n如：修改net.unix.max_dgram_qlen = 100后，通过\ncat /proc/sys/net/unix/max_dgram_qlen\n如果修改成功，这里是新设置的值。","link":"/Other/kernelOptimization.html"},{"id":380,"title":"随机生成问题","content":"随机生成问题\n由于Swoole本身的原因，在使用随机数时，需要额外注意，如果在父进程内调用了mt_rand，不同的子进程内再调用mt_rand返回的结果会是相同的。所以必须在每个子进程内调用mt_srand重新播种。\nshuffle和array_rand等依赖随机数的PHP函数同样会受到影响\n场景例子\n在异步任务，异步进程中，都需要注意随机数播种的问题，如下面的例子\nmt_rand(0, 1);    // 此处调用了 mt_rand 已经在父进程内自动播种\n$worker_num = 16;\n\n// fork 进程\nfor ($i = 0; $i &lt; $worker_num; $i++) {\n    $process = new swoole_process('child_async', false, 2);\n    $pid = $process-&gt;start();\n}\n\nfunction child_async(swoole_process $worker)\n{\n    mt_srand();  // 此处 必须要重新播种 否则会得到相同的结果\n    echo mt_rand(0, 100) . PHP_EOL;\n    $worker-&gt;exit();\n}","link":"/Other/random.html"},{"id":381,"title":"trait与单例","content":"Trait与单例\n\ntrait A{\n    private static $instance;\n    static function getInstance()\n    {\n        if(!isset(self::$instance)){\n            self::$instance = new static();\n        }\n        return self::$instance;\n    }\n}\n\nclass B{\n    use A;\n    function a()\n    {\n        var_dump('call at B');\n    }\n}\n\nclass C extends B{\n    function a()\n    {\n        var_dump('call at c');\n        parent::a(); // TODO: Change the autogenerated stub\n    }\n}\n\nclass D extends B{\n    use A;\n    function a()\n    {\n        var_dump('call at D');\n        parent::a(); // TODO: Change the autogenerated stub\n    }\n}\n$b = B::getInstance();\n$c = C::getInstance();\n$d = D::getInstance();\n\n$c-&gt;a();\n$d-&gt;a();\n\n以上输出:\nstring(9) \"call at B\"\nstring(9) \"call at D\"\nstring(9) \"call at B\"\n","link":"/Other/traitSingleTon.html"},{"id":382,"title":"mysql索引降维","content":"Mysql索引降维\n很多人都知道，mysql有索引这个概念，但是却很少去较真，如何利用索引去对数据降维，以提高查询速度。\n举个常见的场景，那就是用户日志（订单），例如，在中国移动的通话记录系统中，需要记录\n呼出手机号，被呼号码和呼出时间，而在该系统中，最常见或用的最多的需求，就是查询某个用户在某个时间段内的通话记录。我们做出以下数据特征模拟：\n\n一个月内，有一万个账户，每天打出三万通话记录。\n\n数据模拟生成代码：\n&lt;?php\n\nrequire 'vendor/autoload.php';\n\n\\EasySwoole\\EasySwoole\\Core::getInstance()-&gt;initialize();\n//::: warning \n//在3.3.7版本后,initialize事件调用改为:`EasySwoole\\EasySwoole\\Core::getInstance()-&gt;initialize()-&gt;globalInitialize();`\n//:::\n\nfunction generatePhoneList()\n{\n    $list = [];\n    for ($i=0;$i &lt;= 10000; $i++){\n        array_push($list,'155'.\\EasySwoole\\Utility\\Random::number(8));\n    }\n    return $list;\n}\n\nfunction generateTimeList(int $startTime,$max = 30000)\n{\n    $list = [];\n    for ($i=0;$i&lt;=$max;$i++){\n        //模拟从早上7点到凌晨\n        $t = mt_rand(\n            25200,86400\n        );\n        array_push($list,$startTime+$t);\n    }\n    sort($list);\n    return $list;\n}\n\n$config = \\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf('MYSQL');\n$db = new \\App\\Utility\\Pools\\MysqlPoolObject($config);\n$phoneList = generatePhoneList();\n//模拟一个月的时间数据\n$start = strtotime('20180101');\n//\nfor ($i = 0; $i&lt;=30; $i++){\n    $timeList = generateTimeList($start);\n    foreach ($timeList as $time){\n        $phone = $phoneList[mt_rand(0,10000)];\n        $target = $phoneList[mt_rand(0,10000)];\n        $db-&gt;insert('user_phone_record',[\n            'phone'=&gt;$phone,\n            'targetPhone'=&gt;$target,\n            'callTime'=&gt;$time\n        ]);\n\n    }\n    $start += 86400;\n}\n在本次讲解中，以数据量50万为例子，懒得等数据生成。phone，callTime为索引字段。\n需求\n查询某个时间段内某个账户的全部通话记录。\n那么此刻，很多人可能就直接写：\nSELECT * FROM test.user_phone_record where callTime &gt;=  1514768050 and  callTime &lt;= 1514871213 and  phone = 15587575857;\n以上语句在我的测试机中执行了0.26s，但是，若我调整一下where 的顺序：\nSELECT * FROM test.user_phone_record where phone = 15587575857 and callTime &gt;=  1514768050 and  callTime &lt;= 1514871213 ;\n那么久仅仅需要0.1s，节约了一半的时间。那么这两个看起来差不多的语句，为啥执行的时间不一样呢。\n直观解释\n首先，我们分别执行两个sql并查看结果(别说为啥不用explain和profiling解释，只想给你们最直观的解释)。\n\n SELECT count(*) FROM test.user_phone_record where phone = 15587575857 \n结果为15条记录。\nSELECT count(*) FROM test.user_phone_record where callTime >=  1514768050 and  callTime \n结果为76491条记录。\n\n那么最直观的解释来了：先where callTime再where phone，那么mysql做的事情就是：\n先找出76491条记录，再从76491条记录中找出account为15587575857的记录。同理，先where phone，再筛选时间，肯定是更加快的了。\n为什么会这样？\n这是和特定的数据结构与场景才可以这样去调优的，由前提条件：\n\n一个月内，有一万个账户，每天打出三万通话记录\n\n可知，单用户的通话频度不高，因此，先定位phone索引集再排除时间的搜索方式，肯定比先定时间再定账户的效率高。\n注意，这是特定场景！！！具体请以explain与profiling去分析，MYSQL的执行解释器，没有这么简单。","link":"/Other/mysqlIndexReduce.html"},{"id":383,"title":"tporm使用问题","content":"TP ORM使用问题\n由于swoole 是在常驻内存+协程环境下运行的,使用TP ORM 时,TP ORM自带了很多静态变量,将会出现问题,具体分析如下:  \n非协程常驻内存模式\n在同步,非协程模式下,一个worker在一个时间内只处理一个请求,到max_request时也将重启进程,可以勉强操作sql,但是以下静态变量会出现问题:\nthink\\Db 静态变量:\nprotected static $config = [];\n//数据库配置,几乎没有影响\n\nprotected static $query;\n//查询类名,没有影响\n\nprotected static $queryMap = [\n    'mongo' =&gt; '\\\\think\\\\db\\Mongo',\n];\n//查询类自动映射,没有影响\n\npublic static $queryTimes = 0;\n//数据库查询次数\n//常驻内存下是全局查询次数\n\npublic static $executeTimes = 0;\n//执行次数\n//常驻内存下其实是全局执行执行次数\n\nprotected static $cacheHandler;\n//缓存对象,没有影响\n\nthink\\Model 静态变量:\nprotected static $initialized = [];\n//初始化过的模型.\n//原本作用：确保一个模型类中的init方法在一次请求中只被执行一次\n//常驻内存下：一个模型只在第一次请求时执行该方法，后续请求不再执行，极有可能会造成bug\n\nprotected static $readMaster;\n//是否从主库读取数据\n//几乎没有影响\n\nthink\\db\\Connection 静态变量:\nprotected static $instance = [];\n//PDO操作实例\n//建立的连接管理实例\n//协程模式，高并发下可能会导致数据库操作bug\n\nprotected static $event = [];\n//监听回调\n//原本作用：给模型设置的事件回调\n//常驻内存下：随着运行时间不断增加将不断增加运行内存，一次请求增加的事件将影响到另外一次请求\n\nprotected static $info = [];\n// 数据表信息\n// 几乎没有影响\n\nprotected static $log = [];\n// 数据库日志\n// 原本作用: 记录一个请求的所有日志操作\n// 常驻内存: 随着数据库的不断操作,会使该变量不断增加,会造成内存溢出\n\nthink\\db\\Query 静态变量:\nprotected static $connections = [];\n// 数据库Connection对象\n// 暂时没发现使用的地方\n\nprivate static $event = [];\n//回调事件\n//原本作用:一次请求下,设置自身的回调事件\n//常驻内存下：一次请求增加的事件将影响到另外一次请求\n\nprivate static $extend = [];\n//扩展查询方法\n//几乎没有影响\n\nprivate static $readMaster = [];\n//需要读取主库的表\n//原本作用：设置某一个或者全部模型是否从主库读取数据\n//常驻内存下：如果在一个请求执行了Query::readMaster()方法，Query::$readMaster不会释放，将会影响到其他请求\n\nthink\\Db\\ModelEvent 静态变量:\nprivate static $event = [];\n// 回调事件\n//原本作用：给模型设置的事件回调\n//常驻内存下：随着运行时间不断增加将不断增加运行内存，一次请求增加的事件将影响到另外一次请求\n\nprotected static $observe = ['before_write', 'after_write', 'before_insert', 'after_insert', 'before_update', 'after_update', 'before_delete', 'after_delete', 'before_restore', 'after_restore'];\n//模型事件观察\n//没有影响\n\n协程常驻内存模式\n在协程模式下,多个客户端共用一个数据库连接,将会出现数据库操作异常问题,\n例如:\n\n用户A访问业务A,数据库开启事务-&gt;支付逻辑-&gt;完成事务\n用户B同时访问业务B,插入n条数据\n用户C同时访问业务A,数据库开启事务-&gt;支付逻辑-&gt;逻辑出错,回滚\n\n在这个逻辑中,由于都是共享一个数据库操作,并且受协程切换影响,数据库执行步骤可能会变为:\n用户A数据库开启事务-&gt;用户B插入n条数据-&gt;用户C开启事务-&gt;用户A支付逻辑-&gt;用户C支付逻辑-&gt;用户C逻辑错误,回滚事务-&gt;用户A完成事务\n当数据库这样执行时,用户A,B,C的所有数据库操作都将回滚,但是前端可能却会返回成功.  \n同样,由于静态变量共用,其他回调事件等问题同样存在","link":"/Other/tpORM.html"},{"id":384,"title":"curlssl错误","content":"CURL SSL错误\n在低版本的CURL中，若在服务启动前执行CURL一个ssl连接  那么此后在回调函数内再次执行该curl，会报错：\nA PKCS #11 module returned CKR_DEVICE_ERROR, indicating that a problem has occurred with the token or slot.\n若不在服务启动前执行CURL SSL连接，则不报错。\n相关代码\n$a = function (){\n    $ch = curl_init(\"https://www.baidu.com\");\n    $curlOPt = array(\n        CURLOPT_CONNECTTIMEOUT=&gt;3,\n        CURLOPT_TIMEOUT=&gt;10,\n        CURLOPT_AUTOREFERER=&gt;true,\n        CURLOPT_USERAGENT=&gt;\"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET4.0C; .NET4.0E)\",\n        CURLOPT_FOLLOWLOCATION=&gt;true,\n        CURLOPT_RETURNTRANSFER=&gt;true,\n        CURLOPT_SSL_VERIFYPEER=&gt;false,\n        CURLOPT_SSL_VERIFYHOST=&gt;false,\n        CURLOPT_HEADER=&gt;true,\n    );\n    curl_setopt_array($ch,$curlOPt);\n    $result = curl_exec($ch);\n    var_dump(curl_error($ch));\n    curl_close($ch);\n};\n\n$a();\n\nif(pcntl_fork()){\n    $a();\n}else{\n    $a();\n}\n\nswoole中同理。\n解决方案\n更新libcurl至最新的7.5.x,并重新编译php curl拓展。\n查看拓展版本：\nphp --ri curl","link":"/Other/curlSsl.html"},{"id":385,"title":"chromeheadless","content":"Chrome Headless\n什么是Chrome Headless\nHeadless Chrome 是 Chrome 浏览器的无界面形态，可以在不打开浏览器的前提下，使用所有 Chrome 支持的特性运行你的程序,简而言之，除了没有图形界面，headless chrome具有所有现代浏览器的特性，可以像在其他现代浏览器里一样渲染目标网页，并能进行网页截图，获取cookie，获取html等操作。\n而对于写爬虫的同学，很多都会面临都一个问题，那就是数据都是通过动态渲染，甚至是加密得到的，普通的分析接口模式早已无法满足需求，因此我们引入Chrome Headless 来解决数据渲染问题。\n部署 Chrome Headless\n因为环境部署不是本文的重点，因此我们直接推荐docker。\ndocker pull alpeware/chrome-headless-trunk\ndocker run -d -p 9222:9222 alpeware/chrome-headless-trunk\n访问debug 地址即可得到接口信息\ncurl http://{HOST}:9222/json\n以下例子中，{HOST}定义的IP主机响\n驱动Chrome Headless\nChrome Headless 可以通过websocket协议进行远程驱动debug。首先我们引入easyswoole的websocket客户端。\ncomposer require easyswoole/http-client\n我们以网站 https://datacenter.jin10.com/price 为例子，我们打开可以发现，里面的数据都是通过websocket实时刷新的，这个时候，通过传统手段抓接口的手段，是很难实现的。模拟实现如下：\nuse EasySwoole\\HttpClient\\HttpClient;\nuse EasySwoole\\Spl\\SplBean;\nuse Swoole\\WebSocket\\Frame;\n\nstatic $i = 0;\n\n//定义命令bean,具体协议格式可以看 Chrome Headless 文档\n\nclass Command extends SplBean{\n    protected $method;\n    protected $id;\n    protected $params;\n    protected function initialize(): void\n    {\n        if(empty($this-&gt;id)){\n            global $i;\n            $i++;\n            $this-&gt;id = $i;\n        }\n    }\n}\n//用websocket协议去驱动Chrome Headless\ngo(function (){\n    $targetUrl = 'https://datacenter.jin10.com/price';\n    $ch = curl_init('http://{HOST}:9222/json');\n    curl_setopt($ch,CURLOPT_RETURNTRANSFER,true);\n    $data = json_decode( curl_exec($ch) ,true);\n    $client = new HttpClient($data[0]['webSocketDebuggerUrl']);\n    if($client-&gt;upgrade()){\n        //打开URL\n        $command = new Command([\n            'method'=&gt;'Page.navigate',\n            'params'=&gt;[\n                'url'=&gt;$targetUrl\n            ]\n        ]);\n        $client-&gt;getClient()-&gt;push($command-&gt;__toString());\n        $client-&gt;recv(1);\n        //模拟等待渲染\n        \\co::sleep(2);\n        //实现 js 语句\n        $command = new Command([\n            'method'=&gt;'Runtime.evaluate',\n            'params'=&gt;[\n                'expression'=&gt;\"var p = document.querySelector('#J_pricewall &gt; div:nth-child(1) &gt; ul &gt; li:nth-child(1)').innerHTML;p;\"\n            ]\n        ]);\n        $client-&gt;getClient()-&gt;push($command-&gt;__toString());\n        //此处就可以得到渲染后的数据了\n        $data = json_decode($client-&gt;recv()-&gt;data,true)['result']['result']['value'];\n        var_dump($data);\n\n    }else{\n        var_dump('handshake fail');\n    }\n});\n\n以上教程仅供学习之用，请勿用于非法用途","link":"/Other/chromeHeadless.html"},{"id":386,"title":"graphql","content":"GraphQL\n本文档假定你熟悉GraphQL的概念。如果不是这样，请首先在官方网站上面了解 GraphQL。\n依赖类库\ncomposer require webonyx/graphql-php\nEasySwoole Http 中使用\n其实在EasySwoole Http服务器中使用，本质问题在于，如何得到RAW_POST过来的json数据。我们直接贴代码：\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\nuse GraphQL\\Type\\Definition\\ObjectType;\nuse GraphQL\\Type\\Definition\\Type;\nuse GraphQL\\GraphQL;\nuse GraphQL\\Type\\Schema;\n\nclass Index extends Controller\n{\n\n    function index()\n    {\n        $queryType = new ObjectType([\n            'name' =&gt; 'Query',\n            'fields' =&gt; [\n                'echo' =&gt; [\n                    'type' =&gt; Type::string(),\n                    'args' =&gt; [\n                        'message' =&gt; Type::nonNull(Type::string()),\n                    ],\n                    'resolve' =&gt; function ($root, $args) {\n                        return $root['prefix'] . $args['message'];\n                    }\n                ],\n            ],\n        ]);\n        $schema = new Schema([\n            'query' =&gt; $queryType\n        ]);\n\n        $input = $this-&gt;json();\n        $query = $input['query'];\n        $variableValues = isset($input['variables']) ? $input['variables'] : null;\n        try {\n            $rootValue = ['prefix' =&gt; 'You said: '];\n            $result = GraphQL::executeQuery($schema, $query, $rootValue, null, $variableValues);\n            $output = $result-&gt;toArray();\n        } catch (\\Exception $e) {\n            $output = [\n                'errors' =&gt; [\n                    [\n                        'message' =&gt; $e-&gt;getMessage()\n                    ]\n                ]\n            ];\n        }\n\n        $this-&gt;writeJson(200,$output);\n    }\n}","link":"/Other/graphQL.html"},{"id":387,"title":"延迟队列","content":"EasySwoole 基于Redis组件实现延迟队列\n介绍\n在用户要支付订单的时候，如果超过30分钟未支付，会把订单关掉。当然我们可以做一个定时任务，每个一段时间来扫描未支付的订单，如果该订单超过支付时间就关闭，但是在数据量小的时候并没有什么大的问题，但是数据量一大轮训数据库的方式就会变得特别耗资源。当面对千万级、上亿级数据量时，本身写入的IO就比较高，导致长时间查询或者根本就查不出来，更别说分库分表以后了。\n使用延迟队列解决的痛点无非是\n\n实现了数据延迟\n数据摊开(仔细去理解)\n\n知识点\n\nredis有序集合\nEasySwoole Redis协程客户端\n\n案例\n生成订单id ---&gt; 扔到延迟队列 ---&gt; 延迟队列消费进程不停获取30分钟前的订单满足条件的订单 ---&gt; 处理订单\n直接上代码\nEasySwooleEvent.php 注册redis连接池、注册延迟队列消费进程\n&lt;?php\nnamespace EasySwoole\\EasySwoole;\n\nuse App\\Process\\Consumer;\nuse EasySwoole\\EasySwoole\\Swoole\\EventRegister;\nuse EasySwoole\\EasySwoole\\AbstractInterface\\Event;\nuse EasySwoole\\Http\\Request;\nuse EasySwoole\\Http\\Response;\nuse EasySwoole\\Pool\\Manager;\nuse EasySwoole\\Redis\\Config\\RedisConfig;\nuse App\\RedisPool\\RedisPool;\nuse EasySwoole\\Pool\\Config;\nclass EasySwooleEvent implements Event\n{\n\n    public static function initialize()\n    {\n        // TODO: Implement initialize() method.\n        date_default_timezone_set('Asia/Shanghai');\n    }\n\n    public static function mainServerCreate(EventRegister $register)\n    {\n\n        //TODO:: 注册redis连接池\n        $config = new Config();\n        $redisConfig1 = new RedisConfig([\n            'host'      =&gt; '127.0.0.1',\n            'port'      =&gt; '6379'\n        ]);\n\n        // 这里的redis连接池看文档配吧\n        Manager::getInstance()-&gt;register(new RedisPool($config,$redisConfig1),'redis');\n\n        //TODO:: 延迟队列消费进程\n        $processConfig= new \\EasySwoole\\Component\\Process\\Config();\n        $processConfig-&gt;setProcessName('testProcess');\n\n        \\EasySwoole\\Component\\Process\\Manager::getInstance()-&gt;addProcess(new Consumer($processConfig));\n    }\n\n    public static function onRequest(Request $request, Response $response): bool\n    {\n        // TODO: Implement onRequest() method.\n\n        return true;\n    }\n\n    public static function afterRequest(Request $request, Response $response): void\n    {\n        // TODO: Implement afterAction() method.\n    }\n}\n\n扔到延迟队列\n&lt;?php\nnamespace App\\HttpController;\n\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\nuse EasySwoole\\Pool\\Manager;\n\nclass Index extends Controller\n{\n\n    function index()\n    {\n        /** @var $redis \\EasySwoole\\Redis\\Redis*/\n        $orderId = date('YmdHis', time());\n        $redis = Manager::getInstance()-&gt;get('redis')-&gt;getObj();\n        $res = $redis-&gt;zAdd('delay_queue_test1', time(), $orderId);\n        if ($res) {\n            $this-&gt;writeJson(200, '订单添加成功:'.$orderId);\n        }\n    }\n\n}\n延迟队列消费进程\n&lt;?php\nnamespace App\\Process;\n\nuse EasySwoole\\Component\\Process\\AbstractProcess;\nuse EasySwoole\\Pool\\Manager;\nuse Swoole\\Coroutine;\n\nclass Consumer extends AbstractProcess {\n    protected function run($arg)\n    {\n        go(function (){\n            while (true) {\n\n                //TODO:: 拿到redis\n                /** @var $redis \\EasySwoole\\Redis\\Redis*/\n                $redis = Manager::getInstance()-&gt;get('redis')-&gt;defer();\n\n                //TODO:: 从有序集合中拿到三秒(模拟30分钟)以前的订单\n                $orderIds = $redis-&gt;zRangeByScore('delay_queue_test1', 0, time()-3, ['withscores' =&gt; TRUE]);\n\n                if (empty($orderIds)) {\n                    Coroutine::sleep(1);\n                    continue;\n                }\n\n                //TODO::拿出后立马删除\n                $redis-&gt;zRem('delay_queue_test1', ...$orderIds);\n\n                foreach ($orderIds as $orderId)\n                {\n                    var_dump($orderId);\n\n                    //TODO::判断此订单30分钟后，是否仍未完成，做相应处理\n                }\n            }\n        });\n    }\n\n}\n测试\n请求index/index 投递订单到延迟队列\n➜  ~ curl 127.0.0.1:9501/index/index\n{\"code\":200,\"result\":\"订单添加成功:20200422004046\",\"msg\":null}%\n等3s看终端是否输出\n➜  easyswoole php easyswoole start\n  ______                          _____                              _\n |  ____|                        / ____|                            | |\n | |__      __ _   ___   _   _  | (___   __      __   ___     ___   | |   ___\n |  __|    / _` | / __| | | | |  \\___ \\  \\ \\ /\\ / /  / _ \\   / _ \\  | |  / _ \\\n | |____  | (_| | \\__ \\ | |_| |  ____) |  \\ V  V /  | (_) | | (_) | | | |  __/\n |______|  \\__,_| |___/  \\__, | |_____/    \\_/\\_/    \\___/   \\___/  |_|  \\___|\n                          __/ |\n                         |___/\nmain server                   SWOOLE_WEB\nlisten address                0.0.0.0\nlisten port                   9501\nip@en0                        192.168.43.57\nworker_num                    8\nreload_async                  true\nmax_wait_time                 3\npid_file                      /Users/xx/sites/easyswoole/Temp/pid.pid\nlog_file                      /Users/xx/sites/easyswoole/Log/swoole.log\nuser                          xx\ndaemonize                     false\nswoole version                4.4.15\nphp version                   7.2.18\neasy swoole                   3.3.7\ndevelop/produce               develop\ntemp dir                      /Users/xx/sites/easyswoole/Temp\nlog dir                       /Users/xx/sites/easyswoole/Log\n\nstring(14) \"20200422004046\"\n总结\n这只是一个思路，大家可以根据实际业务做不同调整","link":"/Other/delayQueue.html"},{"id":388,"title":"栏目说明","content":"栏目介绍\n本栏目——开源项目推荐，旨在共同推动开源的氛围，欢迎基于easyswoole的开源项目、或适用于easyswoole环境的开源项目提交。","link":"/OpenSource/explanation.html"},{"id":389,"title":"xlswriter-excel解析项目","content":"xlsWriter-excel解析项目\n  \n为什么使用xlswriter\n请参考下方对比图；由于内存原因，PHPExcel数据量相对较大的情况下无法正常工作，虽然可以通过修改memory_limit配置来解决内存问题，但完成工作的时间可能会更长;\n\nxlswriter是一个 PHP C 扩展，可用于在 Excel 2007+ XLSX 文件中读取数据，插入多个工作表，写入文本、数字、公式、日期、图表、图片和超链接。\n它具备以下特性：\n一、写入\n\n100％兼容的Excel XLSX文件\n完整的Excel格式\n合并单元格\n定义工作表名称\n过滤器\n图表\n数据验证和下拉列表\n工作表PNG/JPEG图像\n用于写入大文件的内存优化模式\n适用于Linux，FreeBSD，OpenBSD，OS X，Windows\n编译为32位和64位\nFreeBSD许可证\n唯一的依赖是zlib\n\n二、读取\n\n完整读取数据\n光标读取数据\n按数据类型读取\n\n从这里开始\n文档|Documents\nPECL 仓库\n\nIDE Helper\ncomposer require viest/php-ext-xlswriter-ide-helper:dev-master\n基准测试\n测试环境: Macbook Pro 13 inch, Intel Core i5, 16GB 2133MHz LPDDR3 Memory, 128GB SSD Storage.\n导出\n\n两种内存模式导出100万行数据（单行27列，数据类型均为字符串，单个字符串长度为19）\n\n\n普通模式：耗时 29S，内存只需 2083MB；\n固定内存模式：仅需 52S，内存仅需 &lt;1MB；\n\n导入\n\n100万行数据（单行1列，数据类型为INT）\n\n\n全量模式：耗时 3S，内存仅 558MB；\n游标模式：耗时 2.8S，内存仅 &lt;1MB；\n","link":"/OpenSource/xlsWriter.html"},{"id":390,"title":"ritaswcipaddress ip地址归属地","content":"IP地址归属地，支持IPv6地址(离线数据库，定期更新)\n为什么建立这个库\n政府在大力推进IPv6建设，作者响应国家号召，整合网络免费数据库，制作成离线版供大家使用\n国家公文链接：关于开展2019年IPv6网络就绪专项行动的通知\n链接\nGithub\nPackagist\nBlog\n使用方法\ncomposer require ritaswc/zx-ip-address\n$result = \\Ritaswc\\ZxIPAddress\\IPv4Tool::query('114.114.114.114');\n/*\n$result = [\n    \"start\" =&gt; \"114.114.114.114\"\n    \"end\" =&gt; \"114.114.114.114\"\n    \"addr\" =&gt; array:2 [\n        0 =&gt; \"江苏省南京市\"\n        1 =&gt; \"南京信风网络科技有限公司GreatbitDNS服务器\"\n    ]\n    \"disp\" =&gt; \"江苏省南京市 南京信风网络科技有限公司GreatbitDNS服务器\"\n]\n */\n$result = \\Ritaswc\\ZxIPAddress\\IPv6Tool::query('240e:e9:8819:0:3::3f9');\n/*\n$result = [\n    \"start\" =&gt; \"240e:e9:8800::\"\n    \"end\" =&gt; \"240e:e9:8fff:ffff::\"\n    \"addr\" =&gt; array:2 [\n        0 =&gt; \"中国江苏省苏州市\"\n        1 =&gt; \"中国电信IDC\"\n    ]\n    \"disp\" =&gt; \"中国江苏省苏州市 中国电信IDC\"\n]\n */","link":"/OpenSource/ritaswcIpAddress.html"},{"id":391,"title":"demo","content":"Demo\nEasySwoole-Chat\n基于 EasySwoole V3 实现的聊天室 \n聊天室 Demo 地址\nEasySwoole-Admin\n基于 EasySwoole 框架实现的后台系统，内部使用 Policy 组件、FastCache 组件、mysqli 连接池组件等。用于：API 开发过程学习、组件使用学习、项目后台。 \nadmin 后台模板地址\nEasySwoole-Http-Monitor\n使用 EasySwoole 实现的开发工具，可以记录最近的 http 请求，并且可以分析 http 请求参数、复发请求，可用于微信异步回调调试，支付一单，可以反复模拟推送回调，直到程序走通。 \nhttp 监控工具地址\ncurdAutomaticGeneration\n能够快速根据数据库生成 CURD 代码，包括全套 bean、model、controller，实现代码分层，包括快速开发增删改查功能模块。\n自动写代码工具地址\njin-Chat\n是基于 EasySwoole V3 并整合 EasySwoole 文档中的 mysql/redis 协程连接池、Task 异步任务、Fast-Cache 缓存、chat 聊天等功能的完整 IM 应用（demo）\nim Demo 地址(原作者暂时没维护,因此fork)\nim Demo 地址(原作者仓库地址)\nsocialite (第三方登录集成组件)\n基于 overtrue/socialite 改造的，适用于 EasySwoole 的第三方登录组件，现已支持 wechat、qq、weibo、github、facebook\n第三方登录集成组件地址\n缓存驱动 (基于 EasySwoole Redis 客户端实现)\n基于 EasySwoole Redis 客户端实现的遵循 PSR-16 CacheInterface 的缓存驱动\n缓存驱动地址","link":"/demo.html"}]